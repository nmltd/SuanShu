<?xml version="1.0"?>
<doc>
	<assembly>
		<name>IKVMDocOut</name>
	</assembly>
	<members>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.TriDiagonalization">
			<summary>A tri-diagonal matrix <i>A</i> is a matrix such that
 it has non-zero elements only in the main diagonal, the first diagonal below, and the first
 diagonal above.
 Successive Householder reflections on columns and then rows gradually transform a
 <em>symmetric</em> matrix
 <i>A</i> to the tri-diagonal form.
 The procedure is essentially the same as in Hessenberg decomposition, c.f.,
 <para></para>HessenbergDecomposition,
 except that here we apply the procedure only to symmetric matrix.
 The trailing elements in rows are also zeroed out, due to symmetry.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/tridiagonal_matrix">
 Wikipedia: Tridiagonal matrix</a></item>
 <item><a href="http://en.wikipedia.org/wiki/householder_transformation#tridiagonalization">
 Wikipedia: TriDiagonalization</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.TriDiagonalization.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Runs the tri-diagonalization process for a symmetric matrix.</summary>
			<param name="A">a symmetric matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not symmetric</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.TriDiagonalization.T">
			<summary>Gets <i>T</i>, such that <i>T = Q * A * Q</i>.
 <i>T</i> is triangular.
 <i>Q</i> is orthogonal.</summary>
			<returns>the <i>T</i> matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.TriDiagonalization.Q">
			<summary>Gets <i>Q</i>, such that <i>Q * A * Q = T</i>.
 <i>Q</i> is orthogonal.
 <i>T</i> is triangular.</summary>
			<returns>the <i>Q</i> matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.SymmetricTridiagonalDecomposition">
			<summary>Given a <em>square, symmetric</em> matrix <i>A</i>, we find <i>Q</i>
 such that <i>Q&apos; * A * Q = T</i> , where <i>T</i> is a tridiagonal matrix. This implementation
 uses Householder reflection to repeatedly zero out the elements below and above the sub-diagonal.
 For example, the first step is to left multiply <i>A</i> by a Householder matrix
 <i>Q<sub>1</sub></i> so that matrix <i>Q<sub>1</sub> * A</i> has zeros in the left column (except
 for the first two rows). That is (<i>Q&apos;s</i> are symmetric.),
 \[
 Q_1 \times A = Q_1&apos; \times A =
 \begin{bmatrix}
 a_{11} &amp; * &amp; ... &amp; * \\
 a_{21} &amp; &amp; &amp; \\
 0 &amp; &amp; &amp; \\
 \vdots &amp; &amp; A &apos; &amp; \\
 0 &amp; &amp; &amp;
 \end{bmatrix}
 \]
 Then, we right multiply <i>A</i> by <i>Q<sub>1</sub></i> so that matrix
 <i>Q<sub>1</sub> A*Q<sub>1</sub> </i> has zeros in the first row except first two columns. We
 have
 \[
 Q_1&apos; \times A \times Q_1 =
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp;0 &amp; \cdots &amp; 0 \\
 a_{21} &amp; &amp; &amp; &amp;\\
 0 &amp; &amp; &amp; &amp;\\
 \vdots &amp; &amp; A&apos;&apos; &amp;&amp; \\
 0 &amp; &amp; &amp; &amp;
 \end{bmatrix}
 \]
 At the end, we have a tridiagonal matrix
 <i>T</i> such that
 \[
 (Q_n&apos; \times ... \times Q_1&apos;) \times A \times (Q_1 \times ... \times Q_n) = T
 \]
 Denote
 \[
 Q = (Q_1 \times ... \times Q_n)
 \]
 we have
 \[
 Q&apos;\times A \times Q = T
 \]
 This transformation always succeeds.<para> See also: </para>&quot;Golub, G. H., van Loan, C. F., &quot;Algorithm 8.3.1 (Householder Tridiagonalization),&quot; Matrix
 Computations, 3rd edition.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.SymmetricTridiagonalDecomposition.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Runs the tridiagonal decomposition for a <em>square, symmetric</em>
 matrix. This decomposition does not require a precision parameter, though checking the result
 will need an epsilon.
 <para/>
 The algorithm implemented here has two differences than Algorithm 8.3.1 in the reference.
 First the generation of a Householder matrix does not follow Algorithm 5.1.1 in the
 reference.
 The Householder matrix defining vector <i>v</i> of generator vector <i>x</i>is calculated as
 \[
 v = (x-\rho||x||e_1 )/||x-\rho||x||e_1 ||
 \],
 where\(\rho = sign(x_1)\) and \(e_1=(1,0,\cdots,0)^T\).
 <para/>
 Secondly the sub-matrices <i>A(k+2:dim,k)</i> and <i>A(k,k+2:dim)</i> are updated to zero
 after the calculation in the <i>k-th</i> iteration. This update is not documented in
 Algorithm 8.3.1 in the reference.<para> See also: </para>&quot;Golub, G. H., van Loan, C. F., &quot;Algorithm 8.3.1,&quot; Matrix Computations, 3rd edition.&quot;</summary>
			<param name="A">a square and symmetric matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not square nor symmetric</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.SymmetricTridiagonalDecomposition.Q">
			<summary>Returns the rotation matrix.
 \[
 Q = P_1\times P_2\times\cdots\times P_{n-2}
 \].
 <i>Q&apos;AQ</i> is a tridiagonal matrix.</summary>
			<returns>the rotation matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.SymmetricTridiagonalDecomposition.T">
			<summary>Gets the symmetric tridiagonal <i>T</i> matrix.</summary>
			<returns><i>T</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalizationByHouseholder">
			<summary>Given a tall (<i>m x n</i>) matrix <i>A</i>, where <i>m &#8805; n</i>,
 we find orthogonal matrices <i>U</i> and <i>V</i> such that <i>U&apos; * A * V = B</i>.
 <i>B</i> is an upper bi-diagonal matrix.
 That is,
 \[
 U&apos;AV = \begin{bmatrix}
 d_1 &amp; f_1 &amp; ... &amp; &amp; &amp; \\
 0 &amp; d_2 &amp; f_2 &amp; ... &amp; &amp; \\
 0 &amp; ... &amp; &amp; &amp; &amp; \\
 ... &amp; &amp; &amp; &amp; d_{n-1} &amp; f_{n-1} \\
 ... &amp; &amp; &amp; &amp; &amp; d_n \\
 0 &amp; ... &amp; &amp; &amp; &amp; 0 \\
 &amp; ... &amp; &amp; &amp; &amp; ... \\
 0 &amp; ... &amp; &amp; &amp; &amp; 0
 \end{bmatrix}
 \]
 This implementation uses the Householder reflection process to repeatedly zero out the columns
 and the rows (partially).
 For example, the first step is to left multiply <i>A</i> with the Householder matrix
 <i>U<sub>1</sub>&apos;</i> so that
 matrix <i>U1 * A</i> has zeros in the left column (except for the first row). That is,
 \[
 \begin{bmatrix}
 a_{1,1} &amp; * &amp; ... &amp; * \\
 0 &amp; &amp; &amp; \\
 0 &amp; &amp; &amp; \\
 ... &amp; &amp; A_1 &amp; \\
 ... &amp; &amp; &amp; \\
 0 &amp; &amp; &amp;
 \end{bmatrix}
 \]
 Then, we right multiply <i>A</i> with <i>V<sub>1</sub></i>. (Note that the <i>V&apos;s</i> are
 Hermitian.) We have
 \[
 U_1&apos;AV_1 = \begin{bmatrix}
 a_{1,1} &amp; a_{1,2} &amp; 0 &amp; ... &amp; 0\\
 0 &amp; &amp; &amp; &amp; \\
 0 &amp; &amp; &amp; &amp; \\
 ... &amp; &amp; A_2 &amp; &amp; \\
 ... &amp; &amp; &amp; &amp; \\
 0 &amp; &amp; &amp; &amp;
 \end{bmatrix}
 \]
 In the end,
 <i>(U<sub>1</sub> * ... * U<sub>n</sub>)&apos; * A * (V<sub>1</sub> * ... * V<sub>n</sub>) = B</i>
 where <i>B</i> is upper bi-diagonal.
 The upper part of <i>B</i>, an <i>n x n</i> matrix, is a square, bi-diagonal matrix.
 <para/>
 This transformation always succeeds.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalizationByHouseholder.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Runs the Householder bi-diagonalization for a tall matrix.<para> See also: </para>&quot;G. H. Golub, C. F. van Loan, &quot;Algorithm 5.4.2,&quot; Matrix Computations, 3rd edition.&quot;</summary>
			<param name="A">a tall matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not tall</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalizationByHouseholder.B">
			<summary>Gets <i>B</i>, which is the square upper part of <c>U.t().multiply(A).multiply(V)</c>.
 The dimension of <i>B</i> is <i>n x n</i>.</summary>
			<returns><i>B</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalizationByHouseholder.U">
			<summary>Gets <i>U</i>, where
 <i>U<sup>&apos;</sup> = U<sub>k</sub> * ... * U<sub>1</sub></i>, <c>k = A.nCols()</c> (or
 <c>k = A.nCols() - 1</c> for square A).
 The dimension of <i>U</i> is <i>m x m</i>.
 <para/>
 To compute <i>U</i>,
 instead of explicitly doing this multiplication, this implementation improves the performance
 by applying <i>U<sub>i</sub></i>&apos;s repeatedly on an identity matrix.
 We take the transpose afterward.</summary>
			<returns>the <i>U</i> matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalizationByHouseholder.V">
			<summary>Gets <i>V</i>, where
 <i>V<sup>&apos;</sup> = V<sub>k</sub> * ... * V<sub>1</sub></i>, <c>k = A.nCols() - 2</c>.
 The dimension of <i>V</i> is <i>n x n</i>.
 <para/>
 To compute <i>V</i>,
 instead of explicitly doing this multiplication, this implementation improves the performance
 by applying <i>V<sub>i</sub></i>&apos;s repeatedly on an identity matrix.
 We take the transpose afterward.</summary>
			<returns>the <i>V</i> matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalizationByGolubKahanLanczos">
			<summary>This implementation uses Golub-Kahan-Lanczos algorithm with reorthogonalization. A tiny value
 <c>epsilon</c> is given for checking whether <i>&#945;</i> or <i>&#946;</i> equals to zero.<para> See also: </para>&quot;G. H. Golub, C. F. van Loan, &quot;Chapter 9.3.3, Bidiagonalization and the SVD,&quot; Matrix
 Computations, 3rd edition.&quot;<para> See also: </para><a href="http://web.eecs.utk.edu/~dongarra/etemplates/node198.html">Golub-Kahan-Lanczos
 Bidiagonalization Procedure.</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalizationByGolubKahanLanczos.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Runs the Golub-Kahan-Lanczos bi-diagonalization for a tall matrix.</summary>
			<param name="A">the tall matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalizationByGolubKahanLanczos.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Runs the Golub-Kahan-Lanczos bi-diagonalization for a tall matrix.</summary>
			<param name="A">the tall matrix</param>
			<param name="rng">the random number generator for generation of the first column vector in <i>V</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalizationByGolubKahanLanczos.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Runs the Golub-Kahan-Lanczos bi-diagonalization for a tall matrix.</summary>
			<param name="A">the tall matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="rng">the random number generator for picking the first column vector in <i>V</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalizationByGolubKahanLanczos.B">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalizationByGolubKahanLanczos.U">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalizationByGolubKahanLanczos.V">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalization">
			<summary>Given a tall (<i>m x n</i>) matrix <i>A</i>, where <i>m &#8805; n</i>,
 find orthogonal matrices <i>U</i> and <i>V</i> such that <i>U&apos; * A * V = B</i>.
 <i>B</i> is an upper bi-diagonal matrix.
 That is,
 \[
 U&apos;AV = \begin{bmatrix}
 d_1 &amp; f_1 &amp; ... &amp; &amp; &amp; \\
 0 &amp; d_2 &amp; f_2 &amp; ... &amp; &amp; \\
 0 &amp; ... &amp; &amp; &amp; &amp; \\
 ... &amp; &amp; &amp; &amp; d_{n-1} &amp; f_{n-1} \\
 ... &amp; &amp; &amp; &amp; &amp; d_n \\
 0 &amp; ... &amp; &amp; &amp; &amp; 0 \\
 &amp; ... &amp; &amp; &amp; &amp; ... \\
 0 &amp; ... &amp; &amp; &amp; &amp; 0
 \end{bmatrix}
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalization.B">
			<summary>Gets <i>B</i>, which is the square upper part of <c>U.t().multiply(A).multiply(V)</c>.
 The dimension of <i>B</i> is <i>n x n</i>.</summary>
			<returns><i>B</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalization.U">
			<summary>Gets <i>U</i>, where
 <i>U<sup>&apos;</sup> = U<sub>k</sub> * ... * U<sub>1</sub></i>, <c>k = A.nCols()</c>.
 The dimension of <i>U</i> is <i>m x m</i>.</summary>
			<returns><i>U</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.diagonalization.BiDiagonalization.V">
			<summary>Gets <i>V</i>, where
 <i>V<sup>&apos;</sup> = V<sub>k</sub> * ... * V<sub>1</sub></i>, <c>k = A.nCols() - 2</c>.
 The dimension of <i>V</i> is <i>n x n</i>.</summary>
			<returns><i>V</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Spectrum">
			<summary>A spectrum is the set of eigenvalues of a matrix.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/eigenvalue,_eigenvector_and_eigenspace">
 Wikipedia: Eigenvalues and eigenvectors</a></item>
 <item><a
 href="http://en.wikipedia.org/wiki/eigenvalue,_eigenvector_and_eigenspace#eigenspace_and_spectrum">
 Wikipedia: Eigenvalues and eigenvectors - Eigenspace and spectrum</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Spectrum.getEigenvalues">
			<summary>Get all the eigenvalues.</summary>
			<returns>the eigenvalues</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.InverseIteration">
			<summary>Inverse iteration is an iterative eigenvalue algorithm.
 It finds an approximate eigenvector when an approximation to an eigenvalue is already known.
 Inverse iteration does not apply when &#955; is the <em>exact</em> eigenvalue because (A - &#955;I) is singular.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/inverse_iteration">Wikipedia: Inverse iteration</a></item>
 <item>&quot;G. H. Golub, C. F. van Loan, &quot;Section 2.4.1,&quot; Matrix Computations, 3rd edition.&quot;</item>
 <item>COMPUTING AN EIGENVECTOR WITH INVERSE ITERATION, ILSE C. F. IPSEN.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.InverseIteration.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.InverseIteration.StoppingCriterion)">
			<summary>Construct an instance of <tt>InverseIteration</tt> to find the corresponding eigenvector.</summary>
			<param name="A">a matrix</param>
			<param name="lambda">an eigenvalue</param>
			<param name="criterion">a convergence criterion</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.InverseIteration.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Construct an instance of <tt>InverseIteration</tt> to find the corresponding eigenvector.</summary>
			<param name="A">a matrix</param>
			<param name="lambda">an eigenvalue</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.InverseIteration.getEigenVector(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary>Get an eigenvector from an initial guess.</summary>
			<param name="v0">an initial guess of eigenvector</param>
			<param name="maxIterations">the maximum number of iterations, e.g., 10</param>
			<returns>an approximate eigenvector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.InverseIteration.getEigenVector">
			<summary>Get an eigenvector.</summary>
			<returns>an approximate eigenvector</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.InverseIteration.StoppingCriterion">
			<summary>This interface defines the convergence criterion.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.InverseIteration.StoppingCriterion.toStop(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Check whether we stop with the current eigenvector.</summary>
			<param name="v">an eigenvector</param>
			<returns><c>true</c> if we are satisfied with the eigenvector</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.EigenProperty">
			<summary><c>EigenProperty</c> is a read-only structure that contains the information
 about a particular eigenvalue,
 such as its multiplicity and eigenvectors.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.EigenProperty.eigenvalue">
			<summary>Get the eigenvalue.</summary>
			<returns>the eigenvalue</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.EigenProperty.algebraicMultiplicity">
			<summary>Get the multiplicity of the eigenvalue (a root) of the characteristic
 polynomial.</summary>
			<returns>the algebraic multiplicity</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.EigenProperty.geometricMultiplicity">
			<summary>Get the dimension of the vector space spanned by the eigenvectors.</summary>
			<returns>the geometric multiplicity</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.EigenProperty.eigenbasis">
			<summary>Get the eigenvectors.</summary>
			<returns>the eigenvectors</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.EigenProperty.eigenVector">
			<summary>Get an eigenvector.
 Note that eigenvector is not unique.
 This implementation always returns the first vector in the basis.
 To get a complete set of the basis of the eigenvector space, use <para></para>#eigenbasis().</summary>
			<returns>an eigenvector</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.EigenDecomposition">
			<summary>Let <i>A</i> be a square, <em>diagonalizable</em> <i>N &#215; N</i> matrix with <i>N</i> linearly independent eigenvectors.
 Then <i>A</i> can be factorized as <i>Q * D * Q&apos; = A</i>.
 <i>Q</i> is the square <i>N &#215; N</i> matrix whose <i>i</i>-th column is the eigenvector of <i>A</i>,
 and <i>D</i> is the diagonal matrix whose diagonal elements are the corresponding eigenvalues.<para> See also: </para><a href="http://en.wikipedia.org/wiki/eigendecomposition_of_a_matrix#eigendecomposition_of_a_matrix">Wikipedia: Eigendecomposition of a matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.EigenDecomposition.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Run the eigen decomposition on a <em>square</em> matrix.</summary>
			<param name="A">a square, <em>diagonalizable</em> matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.EigenDecomposition.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Run the eigen decomposition on a <em>square</em> matrix.</summary>
			<param name="A">a square, <em>diagonalizable</em> matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.EigenDecomposition.D">
			<summary>Get the diagonal matrix <i>D</i> as in <i>Q * D * Q&apos; = A</i>.
 <para/>
 Note that for the moment we support only real eigenvalues.</summary>
			<returns><i>D</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.EigenDecomposition.Q">
			<summary>Get <i>Q</i> as in <i>Q * D * Q&apos; = A</i>.
 <para/>
 Note that for the moment we support only real eigenvalues.</summary>
			<returns><i>Q</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.EigenDecomposition.Qt">
			<summary>Get <i>Q&apos;</i> as in <i>Q * D * Q&apos; = A</i>.
 <para/>
 Note that for the moment we support only real eigenvalues.</summary>
			<returns><c>Q.t()</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen">
			<summary>Given a <em>square</em> matrix <i>A</i>, an eigenvalue <i>&#955;</i> and its associated
 eigenvector <i>v</i> are defined by <i>Av = &#955;v</i>.
 We first find the eigenvalues and then the eigenvector space by solving a system of homogeneous
 linear equations.
 That is, <i>(A - &#955;)v = 0</i>.
 <para/>
 <em>
 TODO: For the moment, we compute both real and complex eigenvalues,
 but we do not compute the eigenvectors for complex eigenvalues.
 </em>
 <para/>
 The R equivalent function is <c>eigen</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/eigenvalue_algorithm">Wikipedia: Eigenvalue
 algorithm</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Compute the eigenvalues and eigenvectors for a <em>square</em> matrix.<para> See also: </para><a href="http://en.wikipedia.org/wiki/qr_algorithm">Wikipedia: QR algorithm</a></summary>
			<param name="A">a <em>square</em> matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.Method)">
			<summary>Compute the eigenvalues and eigenvectors for a <em>square</em> matrix.</summary>
			<param name="A">a <em>square</em> matrix</param>
			<param name="method">the eigen decomposition algorithm, c.f., <para></para>Method</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Use <para></para>Method#QR method by default.<para> See also: </para>#Eigen(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix, double)</summary>
			<param name="A">a <em>square</em> matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.Method,System.Double)">
			<summary>Compute the eigenvalues and eigenvectors for a <em>square</em> matrix.
 For each eigenvalue, there are infinitely many associated eigenvectors, which forms a vector
 space.
 This implementation computes a set of linearly independent basis, any linear combination of
 them qualifies as an eigenvector.
 <para/>
 <em>
 TODO: For the moment, we compute both real and complex eigenvalues,
 but we do not compute the eigenvectors for complex eigenvalues.
 </em></summary>
			<param name="A">a <em>square</em> matrix</param>
			<param name="method">the eigen decomposition algorithm, c.f., <para></para>Method</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not square</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.size">
			<summary>Get the number of distinct eigenvalues.</summary>
			<returns>the number of distinct eigenvalues</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.getEigenvalues">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.getRealEigenvalues">
			<summary>Get all real eigenvalues.
 The eigenvalues are sorted in descending order.</summary>
			<returns>all real eigenvalues</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.getEigenvalue(System.Int32)">
			<summary>Get the <i>i</i>-th eigenvalue.
 The eigenvalues are sorted in descending order. The index counts from 0 to agree with the
 <c>List&lt;Number&gt;</c> convention.</summary>
			<param name="i">an index, counting from 0</param>
			<returns>return the <i>i</i>-th eigenvalue</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.getProperty(java.lang.Number)">
			<summary>Get the <para></para>EigenProperty by eigenvalue.
 Note that the number passed in must be exactly the same as the eigenvalue in binary
 representation.
 Passing in an approximate number (up to precision) will likely result in an unmatched error,
 i.e., <c>null</c> returned.</summary>
			<param name="eigenvalue">an eigenvalue</param>
			<returns>the <c>EigenProperty</c> of the eigenvalue</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.getProperty(System.Int32)">
			<summary>Get the <i>i</i>-th <para></para>EigenProperty.
 The eigenvalues are sorted in descending order. The index counts from 0 to agree with the
 <c>List&lt;Number&gt;</c> convention.</summary>
			<param name="i">the index, counting from 0</param>
			<returns>the <i>i</i>-th <c>EigenProperty</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.Method">
			<summary>the available methods to compute eigenvalues and eigenvectors</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.Method.CHARACTERISTIC_POLYNOMIAL">
			<summary>For a matrix of dimension 4 or smaller.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.Method.SYMMETRY">
			<summary>For a symmetric matrix.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.Method.QR">
			<summary>For any matrix.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.Method.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.Eigen.Method.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.CharacteristicPolynomial">
			<summary>The characteristic polynomial of a <em>square</em> matrix is the function
 <code><i>
 p(&#955;) = det(A - &#955;I)
 </i></code>
 The zeros of this polynomial are the eigenvalues of <i>A</i>. That is,
 <i>&#955;</i> being an eigenvalue of <i>A</i> is equivalent to stating that the system of linear equations
 <code><i>
 (A - &#955;I) v = 0
 </i></code>
 where <i>I</i> is an identity matrix, has a non-zero solution <i>v</i> (namely an eigenvector).
 <para/>
 The Cayley-Hamilton theorem states that
 every <em>square</em> matrix satisfies its own characteristic polynomial, that is, <i>p(A) = 0 </i>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/eigenvalue_algorithm">Wikipedia: Eigenvalue algorithm</a></item>
 <item><a href="http://en.wikipedia.org/wiki/cayley-hamilton_theorem">Wikipedia: Cayley-Hamilton theorem</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.CharacteristicPolynomial.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct the characteristic polynomial for a <em>square</em> matrix.</summary>
			<param name="A">a square matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not square</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.CharacteristicPolynomial.getCharacteristicPolynomial">
			<summary>Get the characteristic polynomial.</summary>
			<returns>the characteristic polynomial</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.CharacteristicPolynomial.getEigenvalues">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.CharacteristicPolynomial.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.TridiagonalDeflationSearch">
			<summary>This class locates deflation in a tridiagonal matrix.<para> See also: </para>&quot;Golub, G. H., Van Loan, C. F., &quot;Algorithm 8.3.3 (Symmetric QR Algorithm&quot;, Matrix
 Computations, 3rd edition.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.TridiagonalDeflationSearch.#ctor(System.Boolean,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.TridiagonalDeflationSearch.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DeflationCriterion,System.Boolean,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.TridiagonalDeflationSearch.backSearch(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.TridiagonalDeflationSearch.backSearch(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.SymmetricQRAlgorithm">
			<summary>The symmetric QR algorithm is an eigenvalue algorithm by computing the real Schur canonical form
 of a <em>square, symmetric</em> matrix.
 That is, <i>Q&apos;AQ = D</i> where <i>Q</i> is orthogonal, and <i>D</i> is diagonal. The eigenvalues
 of <i>A</i> are the same as those of the diagonal entries of <i>D</i>. And the columns of
 <i>Q</i> are the eigenvectors of <i>A</i>. The basic idea of the algorithm is first reducing the
 symmetric matrix to a tridiagonal matrix, and then using Givens rotations to eliminate the off
 diagonal elements.
 <para/>
 This implementation is the implicit double-shift version. It makes the use of multiple shifts
 easier to introduce. The matrix is first brought to the tridiagonal form: <i>A<sub>0</sub> =
 Q<sub>0</sub>&apos;AQ<sub>0</sub></i> as in the explicit version; then, at each step, the element at
 1st column, 2nd row of
 \(A_k-\mu I\) is zeroed out via a small-size Givens rotation. where
 \(\mu\) is the shift. Then successive Givens rotations are performed in order
 to return the working matrix <i>A<sub>k</sub></i> to the tridiagonal form. This operation is
 known as bulge chasing, due to the peculiar shape of the non-zero entries of the matrix along the
 steps of the algorithm. Deflation is performed as soon as one of the off-diagonal entries of
 <i>A<sub>k</sub></i> is sufficiently small. No QR decomposition is explicitly performed. Instead,
 we use the Implicit Symmetric QR Step with Wilkinson Shift, as described in Golub and Van Loan.<para> See also: </para>&quot;Golub, G. H., van Loan, C. F., &quot;Algorithm 8.3.2, Algorithm 8.3.3&quot; Matrix Computations, 3rd
 edition.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.SymmetricQRAlgorithm.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Runs the QR algorithm on a <em>symmetric</em> matrix. The algorithm stops when <i>D</i>
 becomes diagonal.</summary>
			<param name="A">a <em>symmetric</em> matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not symmetric</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.SymmetricQRAlgorithm.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Runs the QR algorithm on a <em>symmetric</em> matrix. The algorithm stops when <i>D</i>
 becomes diagonal.</summary>
			<param name="A">a <em>symmetric</em> matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.SymmetricQRAlgorithm.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double,System.Int32)">
			<summary>Runs the QR algorithm on a <em>symmetric</em> matrix. The algorithm stops when <i>D</i>
 becomes diagonal.</summary>
			<param name="A">a <em>symmetric</em> matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not symmetric</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.SymmetricQRAlgorithm.getEigenvalues">
			<summary>
 <para/>
 Given a tridiagonal matrix, <i>T</i>,
 \[
 \begin{bmatrix}
 a_{1} &amp; b_{2} &amp; 0 &amp; 0\\
 b_{2} &amp; a_{2} &amp; b_{3}&amp; 0\\
 0 &amp; b_{3} &amp; a_{3}&amp; b_{4}\\
 0 &amp; 0 &amp; b_{4}&amp; a_{4}
 \end{bmatrix}
 \]
 the real Schur canonical form is <i>Q&apos;TQ = D</i>, where
 <i>Q</i> is orthogonal, and <i>D</i> is diagonal.
 <para/>
 This implementation is a modified version of the algorithm in the reference.<para> See also: </para>&quot;Golub, G. H., Van Loan, C. F., &quot;Algorithm 8.3.2 and Algorithm 8.3.3&quot;, Matrix
 Computations, 3rd edition.&quot;</summary>
			<returns>the list of eigenvalues</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.SymmetricQRAlgorithm.Gs">
			<summary>Gets the list of <i>G<sub>k</sub></i>&apos;s produced in the process of diagonalizing the
 tridiagonal matrix.</summary>
			<returns>the list of <i>G<sub>k</sub></i>&apos;s</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.SymmetricQRAlgorithm.Q">
			<summary>Gets the <i>Q</i> matrix as in <i>Q&apos;AQ = D</i>, where <i>D</i> is diagonal and <i>Q</i> is
 orthogonal. The columns of Q are the eigenvectors of <i>A</i>.
 <para/>
 This implementation stores all the Givens matrix <i>G<sub>k</sub></i>&apos;s produced in the
 process of diagonalizing the tridiagonal matrix.
 <i>Q</i> is a product of them and the rotation matrix,<i>Q<sub>0</sub></i> which
 tridiagonalizes A. That is,
 \[
 Q = (Q_0\timesG_1 \times ... \times G_n)
 \]</summary>
			<returns><i>Q</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.SymmetricQRAlgorithm.D">
			<summary>Gets the <i>D</i> matrix as in the real Schur canonical form <i>Q&apos;AQ = D</i>.
 <i>D</i> is diagonal. The eigenvectors of <i>A</i> are columns of <i>Q</i>.<para> See also: </para>&quot;James W. Demmel, Applied Numerical Linear Algebra, SIAM; 1 edition (August 1, 1997).&quot;</summary>
			<returns><i>D</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.SymmetricQRAlgorithm.getEigenvectors">
			<summary>Gets the eigenvectors of <i>A</i>, which are the columns of <i>Q</i>. The order of the
 eigenvectors matches the order of corresponding eigenvalues returned by the method
 <para></para>#getEigenvalues().</summary>
			<returns>the eigenvectors of <i>A</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.QRAlgorithm">
			<summary>The QR algorithm is an eigenvalue algorithm by computing the real Schur canonical form of a
 matrix.
 That is, <i>Q&apos;AQ = T</i> where <i>Q</i> is orthogonal, and <i>T</i> is quasi-triangular.
 The eigenvalues of <i>A</i> are the same as those of the diagonal blocks in <i>T</i>.
 The basic idea of the procedure is to perform the QR decomposition,
 writing the matrix as a product of an orthogonal matrix and an upper triangular matrix,
 multiply the factors in the opposite order, and iterate.
 <para/>
 This implementation is the implicit double-shift version.
 It makes the use of multiple shifts easier to introduce.
 The matrix is first brought to the upper Hessenberg form: <i>A<sub>0</sub> = QAQ&apos;</i> as in the
 explicit version;
 then, at each step, the first column of
 <i>A<sub>k</sub></i> is transformed via a small-size Householder similarity transformation to the
 first column of <i>p(A<sub>k</sub>)e<sub>1</sub></i>,
 where <i>p(A<sub>k</sub>)</i>, of degree <i>r</i>, is the polynomial that defines the shifting
 strategy.
 Then successive Householder transformation of size <i>r+1</i> are performed in order to return
 the working matrix <i>A<sub>k</sub></i> to the upper Hessenberg form.
 This operation is known as bulge chasing, due to the peculiar shape of the non-zero entries of
 the matrix along the steps of the algorithm.
 Deflation is performed as soon as one of the sub-diagonal entries of <i>A<sub>k</sub></i> is
 sufficiently small.
 No QR decomposition is explicitly performed. Instead, we use the Francis algorithm
 (<para></para>FrancisQRStep), as described in Golub and Van Loan.<para> See also: </para><a href="http://en.wikipedia.org/wiki/qr algorithm">Wikipedia: QR algorithm</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.QRAlgorithm.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Runs the QR algorithm on a <em>square</em> matrix.
 The algorithm loops until <i>H</i> becomes quasi-triangular.</summary>
			<param name="A">a matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not square</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.QRAlgorithm.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Runs the QR algorithm on a <em>square</em> matrix.
 The algorithm loops until <i>H</i> becomes quasi-triangular.</summary>
			<param name="A">a <em>square</em> matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.QRAlgorithm.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double,System.Int32)">
			<summary>Runs the QR algorithm on a <em>square</em> matrix.
 The algorithm is a convergence algorithm. It stops when either
 <list type="number">
 <item><i>H</i> becomes quasi-triangular, or</item>
 <item>the maximum number of iterations is reached.</item>
 </list>
 By default, intermediate <i>Q<sub>i</sub></i>&apos;s are not kept.</summary>
			<param name="A">a <em>square</em> matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not square</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.QRAlgorithm.getEigenvalues">
			<summary>
 Given a Hessenberg matrix,
 \[
 \begin{bmatrix}
 H_{11} &amp; H_{12} &amp; H_{13}\\
 0 &amp; H_{22} &amp; H_{23}\\
 0 &amp; 0 &amp; H_{33}
 \end{bmatrix}
 \]
 the real Schur canonical form is <i>Q&apos;HQ = T</i>, where
 <i>Q</i> is orthogonal, and <i>T</i> is quasi-triangular.

 <para/>
 This implementation is a modified version of the algorithm in the reference.<para> See also: </para>&quot;G. H. Golub, C. F. van Loan, &quot;Algorithm 7.5.2,&quot; Matrix Computations, 3rd edition.&quot;</summary>
			<returns>the list of eigenvalues</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.QRAlgorithm.Qs">
			<summary>Gets the list of <i>Q<sub>i</sub></i>&apos;s produced in the process of the QR
 algorithm (if <c>keepQs</c> is set to <c>true</c>).</summary>
			<returns>the list of <i>Q<sub>i</sub></i>&apos;s</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.QRAlgorithm.Q">
			<summary>Gets the <i>Q</i> matrix as in the real Schur canonical form <i>Q&apos;AQ = T</i>.
 The columns of <i>Q</i> are called Schur vectors.
 If <i>T</i> is diagonal, then the Schur vectors are the eigenvectors.
 <para/>
 This implementation stores all the <i>Q<sub>i</sub></i>&apos;s produced in the process of the QR
 algorithm.
 <i>Q</i> is a product of them. That is,
 \[
 Q = (Q_1 \times ... \times Q_n)
 \]</summary>
			<returns><i>Q</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.QRAlgorithm.T">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.QRAlgorithm.getEigenVectors">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.HessenbergDeflationSearch">
			<summary>Given a Hessenberg matrix, this class searches the largest unreduced Hessenberg sub-matrix.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.HessenbergDeflationSearch.#ctor(System.Boolean,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.HessenbergDeflationSearch.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DeflationCriterion,System.Boolean,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.HessenbergDeflationSearch.backSearch(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Finds <i>H<sub>22</sub></i> such that <i>H<sub>22</sub></i> is the largest unreduced
 Hessenberg sub-matrix, and <i>H<sub>33</sub></i> is upper quasi-triangular.
 For performance reason, this implementation has a side effect: the method modifies the input
 <i>H</i> by rounding the negligible sub-diagonal elements to 0.
 <c>H<sub>22</sub></c> an unreduced Hessenberg in Algorithm 7.5.2 has the dimension
 \((l_r-u_l+1) \times (l_r-u_l+1)\).
 We try to minimize \(u_l\) (hence maximize the <i>H<sub>22</sub></i> dimension).
 <c>H<sub>33</sub></c> an upper quasi-triangular in Algorithm 7.5.2 has dimension
 \((n-l_r) \times (n-l_r)\).
 We try to minimize \(l_r\) (hence maximize the <i>H<sub>33</sub></i> dimension).<para> See also: </para>&quot;G. W. Steward, &quot;Algorithm 3.3,&quot; Matrix Algorithms, Volume II&quot;</summary>
			<param name="H">a Hessenberg matrix</param>
			<returns>deflation information; <c>null</c> if no deflation is found, hence the input matrix
         is already quasi-triangular</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.HessenbergDecomposition">
			<summary>Given a <em>square</em> matrix <i>A</i>, we find <i>Q</i> such that <i>Q&apos; * A * Q = H</i> where
 <i>H</i> is a Hessenberg matrix.
 This implementation uses Householder reflection to repeatedly zero out the elements below the
 sub-diagonal.
 For example, the first step is to left multiply <i>A</i> by a Householder matrix
 <i>Q<sub>1</sub></i> so that
 matrix <i>Q<sub>1</sub> * A</i> has zeros in the left column (except for the first two rows).
 That is (<i>Q&apos;s</i> are Hermitian.),
 \[
 Q_1 \times A = Q_1&apos; \times A = \begin{bmatrix}
 a_{11} &amp; * &amp; ... &amp; * \\
 a_{21} &amp; &amp; &amp; \\
 0 &amp; &amp; &amp; \\
 ... &amp; &amp;A &apos; &amp; \\
 ... &amp; &amp; &amp; \\
 0 &amp; &amp; &amp;
 \end{bmatrix}
 \]
 Then, we right multiply <i>A</i> by <i>Q<sub>1</sub></i>.
 We have
 \[
 Q_1&apos; \times A \times Q_1 = \begin{bmatrix}
 a_{11} &amp; ? &amp; ... &amp; ? \\
 a_{21} &amp; &amp; &amp; \\
 0 &amp; &amp; &amp; \\
 ... &amp; &amp; A&apos;&apos; &amp; \\
 ... &amp; &amp; &amp; \\
 0 &amp; &amp; &amp;
 \end{bmatrix}
 \]
 At the end, we have a Hessenberg <i>H</i> such that
 \[
 (Q_n&apos; \times ... \times Q_1&apos;) \times A \times (Q_1 \times ... \times Q_n) = H
 \]
 We have
 \[
 Q = (Q_1 \times ... \times Q_n)
 \]
 This transformation always succeeds.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.HessenbergDecomposition.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Runs the Hessenberg decomposition for a <em>square</em> matrix.
 This decomposition does not require a precision parameter, though checking the result will
 need an epsilon.<para> See also: </para>Hessenberg#isHessenberg(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,
 double)<para> See also: </para>&quot;G. H. Golub, C. F. van Loan, &quot;Algorithm 7.4.2,&quot; Matrix Computations, 3rd edition.&quot;</summary>
			<param name="A">a square matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not square</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.HessenbergDecomposition.Q">
			<summary>Gets the <i>Q</i> matrix, where
 \[
 Q = (Q_1 \times ... \times Q_n)
 \]
 <i>n = dim - 2</i>.
 <para/>
 To compute <i>Q</i>, instead of explicitly doing this multiplication,
 we can improve the performance by applying the <i>Q<sub>i</sub></i>&apos;s repeatedly on an
 identity matrix.</summary>
			<returns>the <i>Q</i> matrix in the QR decomposition</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.HessenbergDecomposition.H">
			<summary>Gets the <i>H</i> matrix.</summary>
			<returns><i>H</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.Hessenberg">
			<summary>An <em>upper</em> Hessenberg matrix is a square matrix which has zero entries below the first
 sub-diagonal.
 For example,
 \[
 \begin{bmatrix}
 1 &amp; 2 &amp; 3 &amp; 4 &amp; \\
 5 &amp; 6 &amp; 7 &amp; 8 &amp; \\
 0 &amp; 9 &amp; 10 &amp; 11 &amp; \\
 0 &amp; 0 &amp; 12 &amp; 13 &amp;
 \end{bmatrix}
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/hessenberg_matrix">Wikipedia: Hessenberg matrix</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.Hessenberg.deflationCriterion">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.Hessenberg.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DeflationCriterion)">
			<summary>Construct a Hessenberg utility class.</summary>
			<param name="dc">a deflation criterion</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.Hessenberg.#ctor">
			<summary>Construct a Hessenberg utility class with the default deflation criterion.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.Hessenberg.isHessenberg(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Check if <i>H</i> is <em>upper</em> Hessenberg.
 An upper Hessenberg matrix has zero entries below the first sub-diagonal.</summary>
			<param name="H">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <i>H</i> is upper Hessenberg</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.Hessenberg.isReducible(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Check if <i>H</i> is <em>upper</em> Hessenberg and is reducible.
 Note that matrix <i>|0|</i> is unreducible.</summary>
			<param name="H">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <i>H</i> is upper Hessenberg and is reducible</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.Hessenberg.reduce(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
This looks for 0s in the sub-diagonal of a Hessenberg matrix, <i>H</i>,
 and reduces (splits) it into a number of non-reducible Hessenberg matrices.
 For example, we reduce
 \[
 \begin{matrix}
 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6\\
 7 &amp; 8 &amp; 9 &amp; 10 &amp; 11 &amp; 12\\
 0 &amp; 14 &amp; 15 &amp; 16 &amp; 17 &amp; 18 \\
 0 &amp; 0 &amp; 0 &amp; 22 &amp; 23 &amp; 24 \\
 0 &amp; 0 &amp; 0 &amp; 28 &amp; 29 &amp; 30 \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 35 &amp; 36
 \end{matrix}
 \]
 into
 \[
 \begin{matrix}
 1 &amp; 2 &amp; 3 \\
 7 &amp; 8 &amp; 9 \\
 0 &amp; 14 &amp; 15 \\
 \end{matrix}
 \]
 and
 \[
 \begin{matrix}
 22 &amp; 23 &amp; 24 \\
 28 &amp; 29 &amp; 30 \\
 0 &amp; 35 &amp; 36 \\
 \end{matrix}
 \]
 <em>Not yet implemented.</em></summary>
			<param name="H">a matrix</param>
			<returns>a list of non-reducible Hessenberg matrices</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DeflationCriterion">
			<summary>Determines whether a sub-diagonal entry is sufficiently small to be neglected.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DeflationCriterion.isNegligible(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,System.Int32,System.Double)">
			<summary>Checks whether a sub-diagonal element is sufficiently small.</summary>
			<param name="H">a matrix</param>
			<param name="i">a row index</param>
			<param name="j">a column index</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered
                0</param>
			<returns><c>true</c> is <i>H[i,j]</i> is deemed small enough</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.Deflation">
			<summary>A deflation found in a Hessenberg (or tridiagonal in symmetric case) matrix.
 Given a Hessenberg matrix,
 \[
 \begin{bmatrix}
 H_{11} &amp; H_{12} &amp; H_{13}\\
 0 &amp; H_{22} &amp; H_{23}\\
 0 &amp; 0 &amp; H_{33}
 \end{bmatrix}
 \]
 <list type="bullet">
 <item>\(u_l\) is the upper left hand corner index of <i>H<sub>22</sub></i>;</item>
 <item>\(l_r\) is the lower right hand corner index of <i>H<sub>22</sub></i></item>
 </list>
 <para/>
 Deflation of an upper Hessenberg matrix splits it into multiple smaller upper Hessenberg
 matrices
 when the sub-diagonal entries are sufficiently small. For example, suppose
 \[
 H = \begin{bmatrix}
 1 &amp; 2 &amp; 3 &amp; 4 &amp; \\
 5 &amp; 6 &amp; 7 &amp; 8 &amp; \\
 0 &amp; 9 &amp; 10 &amp; 11 &amp; \\
 0 &amp; 0 &amp; 12 &amp; 13 &amp;
 \end{bmatrix}
 \]
 We can split <i>H</i> into <i>H<sub>1</sub></i> and <i>H<sub>2</sub></i>, so that
 \[
 H_1 = \begin{bmatrix}
 1 &amp; 2 \\
 5 &amp; 6 \\
 \end{bmatrix}
 \]
 \[
 H_2 = \begin{bmatrix}
 10 &amp; 11 \\
 12 &amp; 13 \\
 \end{bmatrix}
 \]<para> See also: </para>&quot;Golub and van Loan, Section 7.5.1.&quot;<para> See also: </para>&quot;G. H. Golub, C. F. van Loan, &quot;7.5.2 Deflation,&quot; Matrix Computations, 3rd edition.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.Deflation.getUpperLeft">
			<summary>Gets the upper left corner of the deflation.</summary>
			<returns>the index of the upper left corner</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.Deflation.getLowerRight">
			<summary>Gets the lower right corner of the deflation.</summary>
			<returns>the index of the lower right corner</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DefaultDeflationCriterion">
			<summary>The default deflation criterion is to use eq. 7.5.2 in Golub and van Loan: <i>H[i,j]</i> is
 negligible when
 <code><i>| H[i,j] | &lt; tol * (| H[i-1,j] | + | H[i,j+1] |)</i></code>
 or, when
 <code><i>| H[i-1,j] | + | H[i,j+1] | == 0</i></code>
 and to use eq. 2.2 in Matrix Algorithms, Volume II by Steward G. W.
 <code><i>| H[i,j] | &lt; tol * ||A||<sub>F</sub></i></code></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DefaultDeflationCriterion.DEFAULT_THRESHOLD">
			<summary>The default tolerance parameter <i>tol</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DefaultDeflationCriterion.#ctor">
			<summary>Constructs the default deflation criterion.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DefaultDeflationCriterion.#ctor(System.Double)">
			<summary>Constructs the default deflation criterion.</summary>
			<param name="threshold">the tolerance in Steward&apos;s deflation criterion</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DefaultDeflationCriterion.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DefaultDeflationCriterion.MatrixNorm)">
			<summary>Constructs the default deflation criterion, with the algorithm for computing matrix norm for
 the matrix argument in
 <para></para>#isNegligible(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix, int, int, double) isNegligible().
 <para/>
 Note: for special types of matrices, a fast implementation of matrix norm can speed up the
 whole process.</summary>
			<param name="matrixNorm">the matrix norm algorithm</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DefaultDeflationCriterion.#ctor(System.Double,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DefaultDeflationCriterion.MatrixNorm)">
			<summary>Constructs the default deflation criterion, with the algorithm for computing matrix norm for
 the matrix argument in
 <para></para>#isNegligible(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix, int, int, double) isNegligible().
 <para/>
 Note: for special types of matrices, a fast implementation of matrix norm can speed up the
 whole process.</summary>
			<param name="threshold">the tolerance in Steward&apos;s deflation criterion</param>
			<param name="matrixNorm">the matrix norm algorithm</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DefaultDeflationCriterion.isNegligible(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,System.Int32,System.Double)">
			<summary>Checks if
 <c>H[i,j]</c> is negligible by Steward&apos;s deflation criterion.</summary>
			<param name="H">a matrix</param>
			<param name="i">a row index</param>
			<param name="j">a column index</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered
                0</param>
			<returns><c>true</c> if
 <blockquote><c>| H[i,j] | &lt; tol * (| H[i-1,j] | + | H[i,j+1] |)</c></blockquote></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DefaultDeflationCriterion.MatrixNorm">
			<summary>Computes the norm of a given matrix.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.eigen.qr.DefaultDeflationCriterion.MatrixNorm.compute(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussJordanElimination">
			<summary>Gauss-Jordan elimination performs elementary row operations to reduce a matrix to the reduced row echelon form.
 The three elementary row operations are:
 scaling rows, swapping rows, and adding multiples of a row to another row.
 That is,
 <i>T * A == U</i>
 where <i>T</i> is the transformation matrix, <i>U</i> is in the reduced row echelon form.
 <para/>
 This implementation makes sure that the leading 1s are numerically 1 for comparison purpose.
 Suppose there is a leading 1 at [i,j], <c>U.get(i, j) == 1</c> always returns <c>true</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/gauss%e2%80%93jordan_elimination">Wikipedia: Gauss-Jordan elimination</a></item>
 <item><a href="http://en.wikipedia.org/wiki/reduced_row_echelon_form#reduced_row_echelon_form">Wikipedia: Row echelon form</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussJordanElimination.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,System.Double)">
			<summary>Run the Gauss-Jordan elimination algorithm.</summary>
			<param name="A">a matrix</param>
			<param name="usePivoting"><c>true</c> if partial pivoting is wanted, e.g., for numerical stability</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussJordanElimination.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Run the Gauss-Jordan elimination algorithm.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussJordanElimination.T">
			<summary>Get the transformation matrix, <i>T</i>, such that <i>T * A = U</i>.</summary>
			<returns>the transformation matrix <i>T</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussJordanElimination.U">
			<summary>Get the reduced row echelon form matrix, <i>U</i>, such that <i>T * A = U</i>.</summary>
			<returns>the reduced row echelon form matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination4SquareMatrix">
			<summary>This is a wrapper for <para></para>GaussianElimination but applies only to <em>square</em> matrices.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination4SquareMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Run the Gaussian elimination algorithm on a square matrix.</summary>
			<param name="A">a square matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not square</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination4SquareMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Run the Gaussian elimination algorithm on a square matrix.</summary>
			<param name="A">a square matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not square</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination4SquareMatrix.L">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination4SquareMatrix.U">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination4SquareMatrix.P">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination">
			<summary>The Gaussian elimination performs elementary row operations to reduce a matrix to the row echelon form.
 The two elementary row operations are:
 swapping rows, and adding multiples of a row to another row.
 This is equivalent to multiplying the original matrix with invertible matrices from the left.
 For a square matrix, this algorithm essentially computes an LU decomposition.
 We have,
 <code><i>
 T * A == U
 </i></code>
 where <i>T</i> is the transformation matrix, <i>U</i> is in the row echelon form.
 And,
 <code><i>
 P * A == L * U
 </i></code>
 where <i>P</i> is the permutation matrix, <i>U</i> is lower triangular, <i>U</i> is in the row echelon form.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/gaussian_elimination">Wikipedia: Gaussian elimination</a></item>
 <item><a href="http://en.wikipedia.org/wiki/reduced_row_echelon_form#reduced_row_echelon_form">Wikipedia: Row echelon form</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,System.Double)">
			<summary>Run the Gaussian elimination algorithm.</summary>
			<param name="A">a matrix</param>
			<param name="usePivoting"><c>true</c> if to use partial pivoting, e.g., for numerical stability.
 In general, no pivoting means no row interchanges.
 It can be done only if Gaussian elimination never runs into zeros on the diagonal.
 Since division by zero is a fatal error we usually avoid no pivoting.</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Run the Gaussian elimination algorithm with partial pivoting.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination.T">
			<summary>Get the transformation matrix, <i>T</i>, such that <i>T * A = U</i>.</summary>
			<returns><i>T</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination.U">
			<summary>Get the upper triangular matrix, <i>U</i>, such that
 <i>T * A = U</i> and <i>P * A = L * U</i>.</summary>
			<returns><i>U</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination.L">
			<summary>Get the lower triangular matrix <i>L</i>, such that <i>P * A = L * U</i>.</summary>
			<returns><i>L</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.gaussianelimination.GaussianElimination.P">
			<summary>Get the permutation matrix, <i>P</i>, such that <i>P * A = L * U</i>.</summary>
			<returns><i>P</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QRDecomposition">
			<summary>QR decomposition of a matrix decomposes an <i>m x n</i> matrix <i>A</i> so that <i>A = Q * R</i>.
 <list type="bullet">
 <item><i>Q</i> is an <i>m x n</i> orthogonal matrix;</item>
 <item><i>R</i> is a <i>n x n</i> upper triangular matrix.</item>
 </list>
 Alternatively, we can have <i>A = sqQ * tallR</i>, where
 <list type="bullet">
 <item><i>sqQ</i> is a square <i>m x m</i> orthogonal matrix;</item>
 <item><i>tallR</i> is a <i>m x n</i> matrix.</item>
 </list><para> See also: </para><a href="http://en.wikipedia.org/wiki/qr_decomposition">Wikipedia: QR decomposition</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QRDecomposition.P">
			<summary>Get <i>P</i>, the pivoting matrix in the QR decomposition.</summary>
			<returns><i>P</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QRDecomposition.Q">
			<summary>Get the orthogonal <i>Q</i> matrix in the QR decomposition, <i>A = QR</i>.
 The dimension of <i>Q</i> is <i>m x n</i>, the same as <i>A</i>, the matrix to be orthogonalized.</summary>
			<returns><i>Q</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QRDecomposition.R">
			<summary>Get the upper triangular matrix <i>R</i> in the QR decomposition, <i>A = QR</i>.
 The dimension of <i>R</i> is <i>n x n</i>, a square matrix.</summary>
			<returns><i>R</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QRDecomposition.rank">
			<summary>Get the numerical rank of <i>A</i> as computed by the QR decomposition.
 Numerical determination of rank requires a criterion to decide when a value should be treated as zero, hence a precision parameter.
 This is a practical choice which depends on both the matrix and the application.
 For instance, for a matrix with a big first eigenvector, we should accordingly decrease the precision to compute the rank.</summary>
			<returns>the rank of <i>A</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QRDecomposition.squareQ">
			<summary>Get the square <i>Q</i> matrix. This is an arbitrary orthogonal completion of the <i>Q</i> matrix in the QR decomposition.
 The dimension is <i>m x m</i> (square). We have <i>A = sqQ * tallR</i>.</summary>
			<returns>the square <i>Q</i> matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QRDecomposition.tallR">
			<summary>Get the tall <i>R</i> matrix. This is completed by binding zero rows beneath the square upper triangular matrix <i>R</i> in the QR decomposition.
 The dimension is <i>m x n</i>. It may not be square. We have <i>A = sqQ * tallR</i>.</summary>
			<returns>the tall <i>R</i> matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QR">
			<summary>QR decomposition of a matrix decomposes an <i>m x n</i> matrix <i>A</i> so that <i>A = Q * R</i>.
 <list type="bullet">
 <item><i>Q</i> is an <i>m x n</i> orthogonal matrix;</item>
 <item><i>R</i> is a <i>n x n</i> upper triangular matrix.</item>
 </list>
 Alternatively, we can have <i>A = sqQ * tallR</i>, where
 <list type="bullet">
 <item><i>sqQ</i> is a square <i>m x m</i> orthogonal matrix;</item>
 <item><i>tallR</i> is a <i>m x n</i> matrix.</item>
 </list><para> See also: </para><a href="http://en.wikipedia.org/wiki/qr_decomposition">Wikipedia: QR decomposition</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QR.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Run the QR decomposition on a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QR.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Run the QR decomposition on a matrix.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QR.P">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QR.Q">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QR.R">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QR.rank">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QR.squareQ">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.QR.tallR">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.HouseholderQR">
			<summary>Successive Householder reflections gradually transform a matrix <i>A</i> to the upper triangular
 form.
 For example, the first step is to multiply <i>A</i> with a Householder matrix
 <i>Q<sub>1</sub></i> so that
 matrix <i>Q<sub>1</sub> * A</i> has zeros in the left column (except for the first row).
 That is,
 \[
 Q_1 \times A = \begin{bmatrix}
 a_1 &amp; * &amp; ... &amp; * \\
 0 &amp; &amp; &amp; \\
 ... &amp; &amp; &amp; \\
 ... &amp; &amp; A&apos; &amp; \\
 ... &amp; &amp; &amp; \\
 0 &amp; &amp; &amp;
 \end{bmatrix}
 \]
 At the end,\(Q_n \times ... \times Q_1 \times A = R\) where <i>R</i> is upper triangular.
 <para/>
 Householder reflection has a better numerical stability than the Gram-Schmidt process.<para> See also: </para><a href="http://en.wikipedia.org/wiki/qr_decomposition#using_householder_reflections">
 Wikipedia: Using Householder reflections</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.HouseholderQR.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Runs the Householder reflection process to orthogonalize a matrix.</summary>
			<param name="A">a matrix, where the number of rows &#8805; the number of columns</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<exception cref="T:java.lang.IllegalArgumentException">if the number of rows &lt; the number of columns</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.HouseholderQR.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Runs the Householder reflection process to orthogonalize a matrix.</summary>
			<param name="A">a matrix, where the number of rows &#8805; the number of columns</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.HouseholderQR.Q">
			<summary>Gets the <i>Q</i> matrix in the QR decomposition. The dimension of <i>Q</i> is <i>nRows x
 nCols</i>.
 \[
 \begin{array}{lcl}
 Q_n \times ... \times Q_3 \times Q_2 \times Q_1 \times A = R \\
 A = [Q_n \times ... \times Q_3 \times Q_2 \times Q_1]^{-1} \times R \\
 = [Q_1^{-1} \times Q_2^{-1} \times ... \times Q_n^{-1}] \times R \\
 = [Q_1 \times Q_2 \times ... \times Q_n] \times R \\
 Q = Q_1 \times Q_2 \times ... \times Q_n
 \end{array}
 \]
 \(Q_1^{-1} = Q_1\) , by the unitary property of Householder matrix
 <para/>
 This implementation does not compute <i>Q</i> by explicitly doing this multiplication.
 Instead, we improve the performance by applying <i>Q<sub>i</sub></i>&apos;s repeatedly on an
 identity matrix.</summary>
			<returns><i>Q</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.HouseholderQR.R">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.HouseholderQR.P">
			<summary>Gets <i>P</i>, the pivoting matrix in the QR decomposition.
 Householder process does not need pivoting.
 Hence, <i>P</i> is always an identity matrix.</summary>
			<returns>an identity matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.HouseholderQR.rank">
			<summary>Computes the rank by counting the number of non-zero rows in <i>R</i>.
 <para/>
 <em>Note that <i>Q</i> may have more columns than the rank.
 The user should interpret the result with caution.</em></summary>
			<returns>the rank</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.HouseholderQR.squareQ">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.HouseholderQR.tallR">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.HouseholderQR.getHouseholderMatrices">
			<summary>Gets the householder reflections used in the reflection.</summary>
			<returns>the householder reflections used in the reflection</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.GramSchmidt">
			<summary>The Gram-Schmidt process is a method for orthogonalizing a set of vectors in an inner product space.
 It does so by iteratively computing the vector orthogonal to the subspace spanned by the previously found orthogonal vectors.
 An orthogonal vector is the difference between a column vector and its projection on the subspace.
 <para/>
 There is the problem of &quot;loss of orthogonality&quot; during the process.
 In general, the bigger the matrix is, e.g., dimension = 3500x3500, the less precise the result is.
 The vectors in <i>Q</i> may not be as orthogonal.
 This implementation uses a numerically stable Gram-Schmidt process with twice re-orthogonalization
 to alleviate the problem of rounding errors.
 <para/>
 Numerical determination of rank requires a criterion to decide how small a value should be treated as zero.
 This is a practical choice which depends on both the matrix and the application.
 For instance, for a matrix with a big first eigenvector,
 we should accordingly decrease the precision to compute the rank.
 <para/>
 While the result for the orthogonal basis may match those of the <para></para>HouseholderReflection Householder reflection,
 the result for the orthogonal complement may differ because the kernel basis is not unique.<para> See also: </para><list type="bullet">
 <item>&quot;Luc Giraud, Julien Langou, Miroslav Rozloznik, &quot;On the loss of orthogonality in the Gram-Schmidt orthogonalization process,&quot; Computers &amp; Mathematics with Applications, Volume 50, Issue 7, October 2005, p. 1069-1075. Numerical Methods and Computational Mechanics.&quot;</item>
 <item>&quot;Gene H. Golub, Charles F. Van Loan, Matrix Computations (Johns Hopkins Studies in Mathematical Sciences)(3rd Edition)(Paperback).&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/gram-schmidt">Wikipedia: Gram-Schmidt process</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.GramSchmidt.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,System.Double)">
			<summary>Run the Gram-Schmidt process to orthogonalize a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="pad0Cols">when a column is linearly dependent on the previous columns, there is no orthogonal vector. We pad the basis with a 0-vector.</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.GramSchmidt.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Run the Gram-Schmidt process to orthogonalize a matrix.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.GramSchmidt.Q">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.GramSchmidt.R">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.GramSchmidt.P">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.GramSchmidt.rank">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.GramSchmidt.squareQ">
			<summary>

 This implementation extends <i>Q</i> by appending <i>A</i>&apos;s orthogonal complement.
 Suppose <i>Q</i> has the orthogonal basis for a subspace <i>A</i>.
 To compute the orthogonal complement of <i>A</i>, we apply the Gram-Schmidt procedure to either
 <list type="number">
 <item>the columns of <i>I - P = I - Q * Q&apos;</i>, or</item>
 <item>the spanning set \(\left \{ u_1, u_2, ..., u_k, e_1, e_2, ..., e_n \right \}\)
 and keeping only the first <i>n</i> elements of the resulting basis of <i>R<sub>n</sub></i>.
 The last <i>n-k</i> elements are the basis for the orthogonal complement. <i>k</i> is the rank.</item>
 </list>
 We implemented the second option.</summary>
			<returns>the spanning set of both the orthogonal basis of <i>A</i> and the orthogonal complement</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.qr.GramSchmidt.tallR">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SymmetricSVD">
			<summary>This algorithm calculates the Singular Value Decomposition (SVD) of a <em>square, symmetric</em>
 matrix <i>A</i> using QR algorithm.
 <i>A=UDV&apos;</i>, where <i>U</i> and <i>V</i> are orthogonal matrices. <i>D</i> is a diagonal
 matrix. We use QR algorithm to compute the eigenvalues of <i>A</i>, and the orthogonal matrix
 <i>Q</i>, so that <i>Q&apos;AQ</i> is a diagonal matrix.
 <para/>
 The orthogonal matrix <i>U</i> equals <i>Q</i>. To make the entries in <i>D</i>
 non-negative, we flip the sign of the columns of <i>V</i> that correspond to negative entries of
 <i>D</i>.
 The remaining columns in <i>V</i> are the same as those in <i>Q</i>.<para> See also: </para>&quot;Pradhan, T., Routray, A., and Kabi, B., &quot;Chapter 13 Comparative Evaluation of Symmetric SVD
 Algorithms for Real-Time Face and Eye Tracking,&quot; in Matrix Information Geometry, Nielsen, F, and
 Bhatia, R, ED. Springer, 2013, pp. 323.&quot;<para> See also: </para>SymmetricQRAlgorithm</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SymmetricSVD.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Calculates the SVD of <i>A</i>.</summary>
			<param name="A">a symmetric matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not square or if <i>A</i> is not symmetric</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SymmetricSVD.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Calculates the SVD of A.</summary>
			<param name="A">a symmetric matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not square or if <i>A</i> is not symmetric</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SymmetricSVD.Ut">
			<summary>Returns the matrix <i>U&apos;</i> as in <i>A=UDV&apos;</i>.</summary>
			<returns><i>U&apos;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SymmetricSVD.U">
			<summary>Returns the matrix <i>U</i> as in <i>A=UDV&apos;</i>.</summary>
			<returns><i>U</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SymmetricSVD.getSingularValues">
			<summary>Returns the singular values (same as the eigenvalues) of <i>A</i>.</summary>
			<returns>the singular values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SymmetricSVD.V">
			<summary>Returns the matrix <i>V</i> as in <i>A=UDV&apos;</i>.</summary>
			<returns><i>V</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SymmetricSVD.D">
			<summary>Returns the matrix <i>D</i> as in <i>A=UDV&apos;</i>.</summary>
			<returns><i>D</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVDDecomposition">
			<summary>SVD decomposition decomposes a matrix <i>A</i> of dimension <i>m x n</i>, where <i>m &gt;= n</i>, such that
 <i>U&apos; * A * V = D</i>, or <i>U * D * V&apos; = A</i>.
 <list type="bullet">
 <item><i>U</i> is orthogonal and has the dimension <i>m x n</i>.</item>
 <item><i>D</i> is diagonal and has the dimension <i>n x n</i>.</item>
 <item><i>V</i> is orthogonal and has the dimension <i>n x n</i>.</item>
 </list><para> See also: </para><a href="http://en.wikipedia.org/wiki/singular_value_decomposition">Wikipedia: Singular value decomposition</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVDDecomposition.getSingularValues">
			<summary>Get the normalized, hence positive, singular values.
 They may differ from the values in <i>D</i> if this computation turns off normalization.</summary>
			<returns>the singular values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVDDecomposition.D">
			<summary>Get the <i>D</i> matrix as in SVD decomposition.</summary>
			<returns><i>D</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVDDecomposition.U">
			<summary>Get the <i>U</i> matrix as in SVD decomposition.</summary>
			<returns><i>U</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVDDecomposition.Ut">
			<summary>Get the transpose of <i>U</i>, i.e., <c>U().t()</c>.</summary>
			<returns><c>U().t()</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVDDecomposition.V">
			<summary>Get the <i>V</i> matrix as in SVD decomposition.</summary>
			<returns><i>V</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVD">
			<summary>SVD decomposition decomposes a matrix <i>A</i> of dimension <i>m x n</i>, where <i>m &gt;= n</i>, such that
 <i>U&apos; * A * V = D</i>, or <i>U * D * V&apos; = A</i>.
 <list type="bullet">
 <item><i>U</i> is orthogonal and has the dimension <i>m x n</i>.</item>
 <item><i>D</i> is diagonal and has the dimension <i>n x n</i>.</item>
 <item><i>V</i> is orthogonal and has the dimension <i>n x n</i>.</item>
 </list><para> See also: </para><a href="http://en.wikipedia.org/wiki/singular_value_decomposition">Wikipedia: Singular value decomposition</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVD.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,System.Double)">
			<summary>Run the SVD decomposition on a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="doUV"><c>false</c> if to compute only the singular values but not <i>U</i> and <i>V</i></param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVD.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean)">
			<summary>Run the SVD decomposition on a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="doUV"><c>false</c> if to compute only the singular values but not <i>U</i> and <i>V</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVD.getSingularValues">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVD.D">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVD.U">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVD.Ut">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.SVD.V">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.GolubKahanSVD">
			<summary>Golub-Kahan algorithm does the SVD decomposition of a <em>tall</em> matrix in two stages.
 <list type="number">
 <item>First, it reduces the matrix to a bidiagonal matrix using a sequence of Householder
 transformations.</item>
 <item>Second, it reduces the super-diagonal of the bidiagonal matrix to 0s, using a sequence of
 Givens transformations.</item>
 </list><para> See also: </para>&quot;G. H. Golub, C. F. van Loan, &quot;Algorithm 8.6.2,&quot; Matrix Computations, 3rd edition.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.GolubKahanSVD.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,System.Boolean,System.Double)">
			<summary>Run the Golub-Kahan SVD decomposition on a <em>tall</em> matrix.</summary>
			<param name="A">a <em>tall</em> matrix</param>
			<param name="doUV"><c>false</c> if to compute only the singular values but not <i>U</i> and
 <i>V</i></param>
			<param name="normalize"><c>true</c> if to sort the singular values in descending order and make
                  them positive</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not tall</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.GolubKahanSVD.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,System.Boolean,System.Double,System.Int32)">
			<summary>Runs the Golub-Kahan SVD decomposition on a <em>tall</em> matrix.</summary>
			<param name="A">a <em>tall</em> matrix</param>
			<param name="doUV"><c>false</c> if to compute only the singular values but not <i>U</i>
 and <i>V</i></param>
			<param name="normalize"><c>true</c> if to sort the singular values in descending order and make
                      them positive</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not tall</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.GolubKahanSVD.getSingularValues">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.GolubKahanSVD.D">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.GolubKahanSVD.U">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.GolubKahanSVD.Ut">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.svd.GolubKahanSVD.V">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskyWang2006">
			<summary>Cholesky decomposition works only for a positive definite matrix. If a matrix is not positive
 definite, Wang (2006) suggests to first do an eigen decomposition. Second, force the non-negative
 diagonal elements in the diagonal matrix to be a small non-negative number, e.g., 0. Third,
 re-construct a positive definite matrix from the new diagonal elements. Finally, Cholesky
 decomposition can proceed as usual to the &quot;modified&quot; matrix.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskyWang2006.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Constructs the Cholesky decomposition of a matrix.</summary>
			<param name="Sigma">a matrix, e.g., a covariance matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskyWang2006.L">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskySparse">
			<summary>Cholesky decomposition decomposes a real, symmetric (hence square), and positive definite matrix
 <i>A</i> into <i>A = L * L<sup>t</sup></i>, where <i>L</i> is a lower triangular matrix. For any
 real, symmetric, positive definite matrix, there is a unique Cholesky decomposition, such that
 <i>L</i>&apos;s diagonal entries are all positive. This implementation uses the Cholesky-Banachiewicz
 algorithm, which starts from the upper left corner of the matrix <i>L</i> and proceeds to
 calculate the matrix row by row.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/cholesky_decomposition"> Wikipedia: Cholesky
 decomposition</a></item>
 <item><a
 href="http://en.wikipedia.org/wiki/cholesky_decomposition#the_cholesky-banachiewicz_and_cholesky-crout_algorithms">
 Wikipedia: The Cholesky-Banachiewicz and Cholesky-Crout algorithms</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskySparse.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Runs the Cholesky decomposition on a real, symmetric (hence square), and positive definite
 matrix.</summary>
			<param name="A">a real, symmetric (hence square), and positive definite matrix</param>
			<exception cref="T:java.lang.RuntimeException">if <i>A</i> is not positive definite matrix</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskySparse.L">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskyBanachiewiczParallelized">
			<summary>This is a parallelized version of <para></para>CholeskyBanachiewicz. This implementation is much
 faster for computing large matrices (dimension &gt; 500) on multi-core platform.<para> See also: </para>CholeskyBanachiewicz</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskyBanachiewiczParallelized.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskyBanachiewiczParallelized.shouldUseParallel(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskyBanachiewiczParallelized.L">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskyBanachiewicz">
			<summary>Cholesky decomposition decomposes a real, symmetric (hence square), and positive definite matrix
 <i>A</i> into <i>A = L * L<sup>t</sup></i>, where <i>L</i> is a lower triangular matrix. For any
 real, symmetric, positive definite matrix, there is a unique Cholesky decomposition, such that
 <i>L</i>&apos;s diagonal entries are all positive. This implementation uses the Cholesky-Banachiewicz
 algorithm, which starts from the upper left corner of the matrix <i>L</i> and proceeds to
 calculate the matrix row by row.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/cholesky_decomposition"> Wikipedia: Cholesky
 decomposition</a></item>
 <item><a
 href="http://en.wikipedia.org/wiki/cholesky_decomposition#the_cholesky-banachiewicz_and_cholesky-crout_algorithms">
 Wikipedia: The Cholesky-Banachiewicz and Cholesky-Crout algorithms</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskyBanachiewicz.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Runs the Cholesky decomposition on a real, symmetric (hence square), and positive definite
 matrix.</summary>
			<param name="A">a real, symmetric (hence square), and positive definite matrix</param>
			<exception cref="T:java.lang.RuntimeException">if <i>A</i> is not positive definite matrix</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.CholeskyBanachiewicz.L">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.Cholesky">
			<summary>Cholesky decomposition decomposes a real, symmetric (hence square), and positive definite matrix
 <i>A</i> into <i>A = L * L<sup>t</sup></i>, where <i>L</i> is a lower triangular matrix. For any
 real, symmetric, positive definite matrix, there is a unique Cholesky decomposition, such that
 <i>L</i>&apos;s diagonal entries are all positive.<para> See also: </para><a href="http://en.wikipedia.org/wiki/cholesky_decomposition"> Wikipedia: Cholesky
 decomposition</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.Cholesky.L">
			<summary>Get the lower triangular matrix <i>L</i>.</summary>
			<returns><i>L</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.Chol">
			<summary>Cholesky decomposition decomposes a real, symmetric (hence square), and positive definite matrix
 <i>A</i> into <i>A = L * L<sup>t</sup></i>, where <i>L</i> is a lower triangular matrix. For any
 real, symmetric, positive definite matrix, there is a unique Cholesky decomposition, such that
 <i>L</i>&apos;s diagonal entries are all positive. This implementation uses the Cholesky-Banachiewicz
 algorithm, which starts from the upper left corner of the matrix <i>L</i> and proceeds to
 calculate the matrix row by row.
 <para/>
 The R equivalent function is <c>chol, cholmod</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/cholesky_decomposition"> Wikipedia: Cholesky
 decomposition</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.Chol.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Run the Cholesky decomposition on a real, symmetric (hence square), and positive definite
 matrix.</summary>
			<param name="A">a real, symmetric (hence square), and positive definite matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not symmetric</exception>
			<exception cref="T:java.lang.RuntimeException">if <i>A</i> is not positive definite matrix</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.Chol.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean)">
			<summary>Run the Cholesky decomposition on a real, symmetric (hence square), and positive definite
 matrix.</summary>
			<param name="A">a real, symmetric (hence square), and positive definite matrix</param>
			<param name="isSymmetric"><c>true</c> if <c>A</c> is symmetric to avoid the symmetry check</param>
			<exception cref="T:java.lang.RuntimeException">if <i>A</i> is not positive definite matrix</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.Chol.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Run the Cholesky decomposition on a real, symmetric (hence square), and positive definite
 matrix.</summary>
			<param name="A">a real, symmetric (hence square), and positive definite matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not symmetric</exception>
			<exception cref="T:java.lang.RuntimeException">if <i>A</i> is not positive definite matrix</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.Chol.L">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.cholesky.Chol.Lt">
			<summary>Gets the transpose of the lower triangular matrix, <i>L&apos;</i>. The transpose is upper
 triangular.</summary>
			<returns><i>L&apos;</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LUDecomposition">
			<summary>LU decomposition decomposes an <i>n x n</i> matrix <i>A</i> so that <i>P * A = L * U</i>.
 <i>P</i> is an <i>n x n</i> permutation matrix.
 <i>L</i> is an <i>n x n</i> lower triangular matrix.
 <i>U</i> is an <i>n x n</i> upper triangular matrix.
 That is,
 <blockquote><code><i>
 P.multiply(A) == L.multiply(U)
 </i></code></blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/lu_decomposition">Wikipedia: LU decomposition</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LUDecomposition.L">
			<summary>Get the lower triangular matrix <i>L</i> as in the LU decomposition.</summary>
			<returns><i>L</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LUDecomposition.U">
			<summary>Get the upper triangular matrix <i>U</i> as in the LU decomposition.</summary>
			<returns><i>U</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LUDecomposition.P">
			<summary>Get the permutation matrix <i>P</i> as in <i>P * A = L * U</i>.</summary>
			<returns><i>P</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LU">
			<summary>LU decomposition decomposes an <i>n x n</i> matrix <i>A</i> so that <i>P * A = L * U</i>.
 <i>P</i> is an <i>n x n</i> permutation matrix.
 <i>L</i> is an <i>n x n</i> lower triangular matrix.
 <i>U</i> is an <i>n x n</i> upper triangular matrix.
 That is,
 <blockquote><code><c>
 P.multiply(A) == L.multiply(U)
 </c></code></blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/lu_decomposition">Wikipedia: LU decomposition</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LU.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Run the LU decomposition on a square matrix.</summary>
			<param name="A">a square matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LU.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Run the LU decomposition on a square matrix.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LU.L">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LU.U">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LU.P">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LDL">
			<summary>The LDL decomposition decomposes a real and symmetric (hence square) matrix <i>A</i> into <i>A = L * D * L<sup>t</sup></i>.
 <i>L</i> is a lower triangular matrix.
 <i>D</i> is a diagonal matrix.
 Unlike Cholesky decomposition, this decomposition applies to all real and symmetric matrices,
 whether positive definite or not.
 Moreover, when <i>A</i> is positive definite the elements of the diagonal matrix <i>D</i> are all positive.
 In other words, if <i>A</i> is semi/positive/negative definite, so is <i>D</i>.
 This algorithm eliminates the need to take square roots.<para> See also: </para><a href="http://en.wikipedia.org/wiki/ldl_decomposition#avoiding_taking_square_roots">Wikipedia: Avoiding taking square roots</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LDL.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Run the LDL decomposition on a real and symmetric (hence square) matrix.</summary>
			<param name="A">a real and symmetric (hence square) matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not symmetric</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LDL.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Run the LDL decomposition on a real and symmetric (hence square) matrix.</summary>
			<param name="A">a real and symmetric (hence square) matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not symmetric</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LDL.L">
			<summary>Get <i>L</i> as in the LDL decomposition.</summary>
			<returns><i>L</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LDL.Lt">
			<summary>Get the transpose of <i>L</i> as in the LDL decomposition.
 The transpose is upper triangular.</summary>
			<returns><i>L&apos;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.LDL.D">
			<summary>Get <i>D</i> the the diagonal matrix in the LDL decomposition.</summary>
			<returns><i>D</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.Doolittle">
			<summary>Doolittle algorithm is a LU decomposition algorithm which decomposes a <em>square</em> matrix
 <i>A</i> into:
 <list type="bullet">
 <item><i>P</i> is an <i>n x n</i> permutation matrix;</item>
 <item><i>L</i> is an <i>n x n</i> (unit) lower triangular matrix;</item>
 <item><i>U</i> is an <i>n x n</i> upper triangular matrix,</item>
 </list>
 such that <i>PA = LU</i>.
 That is,
 <code><c>P.multiply(A) == L.multiply(U) </c></code>
 Not every non-singular matrix can be LU decomposed but some singular matrix can have valid LU
 decomposition.
 For example, the following singular matrix has LU decomposition.
 \[
 \begin{bmatrix}
 1 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 2\\
 0 &amp; 1 &amp; -1
 \end{bmatrix}
 \]
 On the other hand, the LU decomposition with pivoting always exists, even if the matrix is
 singular.
 <para/>
 With (partial) pivoting, rows may be swapped during the decomposition process to avoid division
 by zero, and hence make the process more numerically stable.<para> See also: </para><a href="http://en.wikipedia.org/wiki/doolittle_decomposition">
 Wikipedia: LU decomposition</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.Doolittle.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Runs Doolittle algorithm on a square matrix for LU decomposition.</summary>
			<param name="A">the square matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.Doolittle.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Runs Doolittle algorithm on a square matrix for LU decomposition.</summary>
			<param name="A">the square matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.Doolittle.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean)">
			<summary>Runs Doolittle algorithm on a square matrix for LU decomposition.</summary>
			<param name="A">the square matrix</param>
			<param name="usePivoting"><c>true</c> if (partial) pivoting is used</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.Doolittle.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,System.Double)">
			<summary>Runs Doolittle algorithm on a square matrix for LU decomposition.</summary>
			<param name="A">the square matrix</param>
			<param name="usePivoting"><c>true</c> if (partial) pivoting is used</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered
                    0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.Doolittle.L">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.Doolittle.U">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.factorization.triangle.Doolittle.P">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable">
			<summary>A matrix is represented by a rectangular table structure with accessors.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixRing">
			<summary>A matrix ring is the set of all <i>n &#215; n</i> matrices over an arbitrary <para></para>Ring <i>R</i>.
 This matrix set becomes a ring under matrix addition and multiplication.
 Moreover, it has a structure of a *-algebra over <i>R</i>, where the involution * on the matrix ring is the matrix transposition.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixRing.t">
			<summary>Get the transpose of this matrix.
 This is the involution on the matrix ring.</summary>
			<returns>the transpose of this matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixRing.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary><i>this + that</i></summary>
			<param name="that">a matrix</param>
			<returns>the sum of <c>this</c> and <c>that</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixRing.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary><i>this - that</i></summary>
			<param name="that">a matrix</param>
			<returns>the difference between <c>this</c> and <c>that</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixRing.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary><i>this * that</i></summary>
			<param name="that">a matrix</param>
			<returns>the product of<c>this</c> and <c>that</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixRing.opposite">
			<summary>Get the opposite of this matrix.</summary>
			<returns><i>-this</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixRing.ZERO">
			<summary>Get a zero matrix that has the same dimension as this matrix.</summary>
			<returns>the 0 matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixRing.ONE">
			<summary>Get an identity matrix that has the same dimension as this matrix.
 For a non-square matrix, it zeros out the rows (columns) with index &gt; nCols (nRows).</summary>
			<returns>an identity matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils">
			<summary>These are the boolean operators that take matrices or vectors and check if they satisfy a
 certain property.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isSymmetric(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is symmetric.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <blockquote><c>A.t() == A</c></blockquote></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isSkewSymmetric(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is skew symmetric.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <blockquote><c>A.t() == -A</c></blockquote></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isIdempotent(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is idempotent.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <blockquote><c>A = A*A or A = A<sup>2</sup></c></blockquote></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isOrthogonal(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is orthogonal, up to a precision.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <blockquote><c>AA&apos; = 1</c></blockquote></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isMagicSquare(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
Checks if a matrix is a magic square.
 <em>Not yet implemented.</em></summary>
			<param name="A">a matrix</param>
			<returns><c>true</c> if <i>A</i> is a square matrix having distinct positive integers,
         arranged such that the sums of the numbers in any rows, columns, or diagonals are equal</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isSingular(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a <em>square</em> matrix is singular, i.e, having no inverse, up to a precision.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <i>A<sup>-1</sup></i> does not exist</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isDiagonal(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a <em>square</em> matrix is a diagonal matrix, up to a precision.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <i>A</i> is square and <i>A<sub>i</sub><sub>j</sub>=0</i>, for all
 <i>i != j</i>.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isIdentity(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is an identity matrix, up to a precision.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <i>A</i> is square, and <i>A<sub>i</sub><sub>j</sub>=0</i> for all
 <i>i != j</i>, and
 <i>A<sub>i</sub><sub>j</sub>=1</i>, for all <i>i == j</i>.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isUpperTriangular(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is upper triangular, up to a precision.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if the matrix is upper triangular</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isLowerTriangular(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is lower triangular, up to a precision.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if the matrix is lower triangular</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isQuasiTriangular(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is quasi (upper) triangular, up to a precision.

 <para/>
 A quasi triangular matrix is upper Hessenberg with no two consecutive
 non-zero elements on the first subdiagonal.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if the matrix is quasi (upper) triangular</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isUpperBidiagonal(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is upper bidiagonal, up to a precision.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if the matrix is upper bidiagonal</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isLowerBidiagonal(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is lower bidiagonal, up to a precision.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if the matrix is lower bidiagonal</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isTridiagonal(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is tridiagonal, up to a precision.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if the matrix is tridiagonal</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isRowEchelonForm(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is in the row echelon form, up to a precision.<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/reduced_row_echelon_form#reduced_row_echelon_form">Wikipedia:
 Row echelon form</a></summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if the matrix is in row echelon form</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isReducedRowEchelonForm(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a matrix is in the reduced row echelon form, up to a precision.<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/reduced_row_echelon_form#reduced_row_echelon_form">Wikipedia:
 Row echelon form</a></summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if the matrix is in reduced row echelon form</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isScalar(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
Checks if a <em>square</em> matrix is a scalar matrix, up to a precision.</summary>
			<param name="A">a matrix</param>
			<returns><c>true</c> if <i>A</i> is diagonal and, <i>a<sub>i</sub><sub>j</sub>=c</i>, for all
 <i>i == j</i>, <i>c</i> is a constant.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isSymmetricPositiveDefinite(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a <em>square</em> matrix is symmetric and positive definite.<para> See also: </para><a href="http://en.wikipedia.org/wiki/positive-definite_matrix">Wikipedia:
 Positive-definite matrix</a></summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if A is symmetric, and <i>z&apos;Mz &gt; 0</i>, for all non-zero real vectors
 <i>z</i>.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isPositiveDefinite(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a <em>square</em> matrix is positive definite; the matrix needs not be symmetric.
 A real matrix <i>A</i> is positive definite if
 the symmetric part <i>A<sub>symmetric</sub> = 1/2 * (A + A&apos;)</i> is symmetric positive
 definite.<para> See also: </para><a href="http://en.wikipedia.org/wiki/positive-definite_matrix">Wikipedia:
 Positive-definite matrix</a></summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <i>A</i> satisfies <i>z&apos;Mz &gt; 0</i>, for all non-zero real vectors
 <i>z</i>.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isPositiveSemiDefinite(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks if a <em>square</em> matrix is positive definite, up to a precision.<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/positive-definite_matrix#negative-definite.2c_semidefinite_and_indefinite_matrices">Wikipedia:
 Negative-definite, semidefinite and indefinite matrices</a></summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <i>A</i> satisfies <i>z&apos;Mz &gt; 0</i>, for all non-zero real vectors
 <i>z</i>.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isZero(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Checks if a vector is a zero vector, i.e., all its entries are 0, up to a precision.</summary>
			<param name="v">a vector</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <i>v</i> is a zero vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.areEqual(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Checks the equality of two matrices up to a precision.
 Two matrices are equal if
 <list type="number">
 <item>the dimensions are the same;</item>
 <item>all entries are equal</item>
 </list></summary>
			<param name="A1">a matrix</param>
			<param name="A2">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if all entries are equal, entry by entry</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.areEqual(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Checks if two vectors are equal, i.e., <i>v1 - v2</i> is a zero vector, up to a precision.</summary>
			<param name="v1">a vector</param>
			<param name="v2">a vector</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if all entries are equal, entry by entry</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.areOrthogonal(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Checks if two vectors are orthogonal, i.e., <i>v1 ∙ v2 == 0</i>.</summary>
			<param name="v1">a vector</param>
			<param name="v2">a vector</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> the two vectors are orthogonal</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.areOrthogonal(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[],System.Double)">
			<summary>Checks if a set of vectors are orthogonal, i.e., for any <i>v1</i>, <i>v2</i> in <i>v</i>,
 <i>v1 ∙ v2 == 0</i>.</summary>
			<param name="v">a set of vectors</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if any two vectors are orthogonal</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.areOrthogonormal(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Checks if two vectors are orthogonormal.
 Two vectors are orthogonormal if
 <list type="number">
 <item><i>{v1, v2}</i> are orthogonal;</item>
 <item><i>|v1| = |v2| = 1</i>.</item>
 </list></summary>
			<param name="v1">a vector</param>
			<param name="v2">a vector</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if the two vectors are orthogonormal</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.areOrthogonormal(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[],System.Double)">
			<summary>Checks if a set of vectors are orthogonormal.</summary>
			<param name="v">a set of vectors</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if any two vectors are orthogonormal</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.areAllSparse(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[])">
			<summary>Checks if all matrices are <para></para>SparseMatrix.</summary>
			<param name="matrices"></param>
			<returns><c>true</c> if and only if all matrices are <para></para>SparseMatrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.areAllSparse(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Checks if all vectors are <para></para>SparseVector.</summary>
			<param name="vectors"></param>
			<returns><c>true</c> if and only if all matrices are <para></para>SparseVector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.throwIfNotEqualSize(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Checks if the input vectors have the same size.</summary>
			<param name="v1">a vector</param>
			<param name="v2">a vector</param>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.vector.VectorSizeMismatch">if sizes do not match</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.throwIfInvalidIndex(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary>Checks if an index is a valid index.</summary>
			<param name="v">a vector</param>
			<param name="index">a vector index</param>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.vector.VectorAccessException">if the index is invalid</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixPropertyUtils.isNaN(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Checks if a vector contains any <c>NaN</c> entry.</summary>
			<param name="v">a vector</param>
			<returns><c>true</c> if there is at least one <c>NaN</c> entry.</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess">
			<summary>This interface defines the methods for accessing entries in a matrix.
 Indices count from 1, e.g., <c>get(1,1)</c>.
 This is what mathematicians (not programmers) are accustomed to.
 Invalid access such as using out-of-range indices or altering immutable matrix
 will lead to <para></para>MatrixAccessException.
 The <em>only</em> way to change a matrix is by calling <para></para>#set(int, int, double).
 Other operations that &quot;change&quot; the matrix actually creates a new and independent copy.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess.set(System.Int32,System.Int32,System.Double)">
			<summary>Set the matrix entry at <i>[i,j]</i> to a value.
 This is the only method that may change a matrix.</summary>
			<param name="i">the row index</param>
			<param name="j">the column index</param>
			<param name="value">the value to set <i>A[i,j]</i> to</param>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">if <i>i</i> or <i>j</i> is out of range</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess.get(System.Int32,System.Int32)">
			<summary>Get the matrix entry at <i>[i,j]</i>.</summary>
			<param name="i">the row index</param>
			<param name="j">the column index</param>
			<returns><i>A[i,j]</i></returns>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">if <i>i</i> or <i>j</i> is out of range</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix">
			<summary>This interface defines a <c>Matrix</c> as a <para></para>Ring, a <para></para>Table, and a few more methods not already defined in its mathematical definition.
 The interface is made minimal to avoid listing all possible matrix operations.
 Instead, matrix operations are grouped into packages and classes by their properties.
 This is to avoid interface &quot;pollution&quot;, lengthy and cumbersome design.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Right multiply this matrix, <i>A</i>, by a vector.</summary>
			<param name="v">a vector</param>
			<returns><i>Av</i>, a vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix.scaled(System.Double)">
			<summary>Scale this matrix, <i>A</i>, by a constant.</summary>
			<param name="c">a double</param>
			<returns><i>cA</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix.getRow(System.Int32)">
			<summary>Get the specified row in the matrix as a vector.</summary>
			<param name="i">the row index</param>
			<returns>the vector <i>A[i, ]</i></returns>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">when <i>i</i> &lt; 1, or when <i>i</i> &gt; the number of rows</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix.getColumn(System.Int32)">
			<summary>Get the specified column in the matrix as a vector.</summary>
			<param name="j">the column index</param>
			<returns>a vector <i>A[, j]</i></returns>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">when <i>j</i> &lt; 1, or when <i>j</i> &gt; the number of columns</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix.deepCopy">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix">
			<summary>This is a read-only view of a <para></para>Matrix instance.
 It keeps a reference to the matrix instance,
 delegates all operations to the instance except for <para></para>#set(int, int, double) which
 will always result in an <para></para>MatrixAccessException.
 Note that the returned values of all operations (e.g., <c>add()</c>) have the same types as the
 original matrix.
 Popular usages of this class include, e.g., the <c>final</c> member of a class, the return value
 of a method.
 <para/>
 Note that the &apos;immutability&apos; can be broken if the original matrix is modified.
 To avoid this, make a copy of the original matrix before passing it to the constructor. For
 example,
 <code><c>ImmutableMatrix immutable = new ImmutableMatrix(m.deepCopy());
 </c></code></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a read-only version of a matrix.
 <em>Note that changing the original matrix changes the &quot;immutable&quot; version as well</em>.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.t">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.deepCopy">
			<summary>Make a deep copy of the underlying matrix.
 <em>The copy is no longer an <c>ImmutableMatrix</c> and may be mutable.</em></summary>
			<returns>a deep copy of the underlying matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.ImmutableMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.ThomasAlgorithm">
			<summary>Thomas algorithm is an efficient algorithm to solve a linear tridiagonal matrix equation. The
 complexity of the Thomas algorithm is \(O(N)\), where <i>N</i> is the number of unknowns.
 <para/>
 A tridiagonal system for <i>N</i> unknowns can be written as
 \[
 a_i x_{i-1} + b_i x_i + c_i x_{i+1} = d_i,
 \]
 where <i>a<sub>1</sub></i> = 0 and <i>c<sub>n</sub></i> = 0.
 \[
 \begin{bmatrix}
 {b_1} &amp; {c_1} &amp; { } &amp; { } &amp; { 0 } \\
 {a_2} &amp; {b_2} &amp; {c_2} &amp; { } &amp; { } \\
 { } &amp; {a_3} &amp; {b_3} &amp; \ddots &amp; { } \\
 { } &amp; { } &amp; \ddots &amp; \ddots &amp; {c_{n-1}} \\
 { 0 } &amp; { } &amp; { } &amp; {a_n} &amp; {b_n} \\
 \end{bmatrix}
 \begin{bmatrix}
 {x_1} \\ {x_2} \\ {x_3} \\ \vdots \\ {x_n} \\
 \end{bmatrix}
 =
 \begin{bmatrix}
 {d_1} \\ {d_2} \\ {d_3} \\ \vdots \\ {d_n} \\
 \end{bmatrix}
 .
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/thomas_algorithm">Wikipedia: Thomas algorithm</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.ThomasAlgorithm.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.ThomasAlgorithm.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Solves a tridiagonal matrix equation.</summary>
			<param name="A">the left hand side coefficient matrix</param>
			<param name="d">the right hand side vector</param>
			<returns>the solution vector</returns>
			<exception cref="T:java.lang.ArithmeticException">when the diagonal contains zeros</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.OLSSolverBySVD">
			<summary>This class solves an over-determined system of linear equations in the
 ordinary least square sense.
 An over-determined system, represented by
 <blockquote><i>Ax = y</i></blockquote>
 has more rows than columns. That is, there are more equations than unknowns.
 One important application is linear regression, where <i>A</i> is the
 independent factors, <i>y</i> the dependent observations.
 The solution <i>x^</i> minimizes:
 <blockquote><i>|Ax - y|<sub>2</sub></i></blockquote>
 That is, <i>x^</i> is the best approximation that
 minimizes the sum of squared differences between the data values and their
 corresponding modeled values.
 The approach is called &quot;linear&quot; least squares since the solution depends
 linearly on the data.
 <blockquote><i>
 <i>x^</i> = (A<sup>t</sup>A)<sup>-1</sup>A<sup>t</sup>y,
 </i></blockquote>
 This implementation does not use the above formula to solve for <i>x^</i>
 because of the numerical stability problem in computing
 <i>A<sup>t</sup>A</i>.
 Instead, we use SVD decomposition, an orthogonal decomposition method that is
 numerically stable.
 SVD allows approximation by truncating small singular values.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/linear_least_squares">Wikipedia:
 Linear least squares</a></item>
 <item><a href="http://en.wikipedia.org/wiki/least_squares">Wikipedia: Least
 squares</a></item>
 <item><a
 href="http://en.wikipedia.org/wiki/linear_least_squares#orthogonal_decomposition_methods">Wikipedia:
 Orthogonal decomposition methods</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.OLSSolverBySVD.#ctor(System.Double)">
			<summary>Construct an OLS solver for an over-determined system of linear
 equations.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
 considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.OLSSolverBySVD.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary>In the ordinary least square sense, solve
 <blockquote><i>Ax = y</i></blockquote></summary>
			<param name="problem">a system of linear equations</param>
			<returns>a solution <i>x^</i> that minimizes
 <blockquote><i>|Ax - y|<sub>2</sub></i></blockquote></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.OLSSolverByQR">
			<summary>This class solves an over-determined system of linear equations in the
 ordinary least square sense.
 An over-determined system, represented by
 <blockquote><i>Ax = y</i></blockquote>
 has more rows than columns. That is, there are more equations than unknowns.
 One important application is linear regression, where <i>A</i> is the
 independent factors, <i>y</i> the dependent observations.
 The solution <i>x^</i> minimizes:
 <blockquote><i>|Ax - y|<sub>2</sub></i></blockquote>
 That is, <i>x^</i> is the best approximation that
 minimizes the sum of squared differences between the data values and their
 corresponding modeled values.
 The approach is called &quot;linear&quot; least squares since the solution depends
 linearly on the data.
 <blockquote><i>
 <i>x^</i> = (A<sup>t</sup>A)<sup>-1</sup>A<sup>t</sup>y,
 </i></blockquote>
 This implementation does not use the above formula to solve for <i>x^</i>
 because of the numerical stability problem in computing
 <i>A<sup>t</sup>A</i>.
 Instead, we use QR decomposition, an orthogonal decomposition method that is
 numerically stable.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/linear_least_squares">Wikipedia: Linear least
 squares</a></item>
 <item><a href="http://en.wikipedia.org/wiki/least_squares">Wikipedia: Least squares</a></item>
 <item><a
 href="http://en.wikipedia.org/wiki/linear_least_squares#orthogonal_decomposition_methods">Wikipedia:
 Orthogonal decomposition methods</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.OLSSolverByQR.#ctor(System.Double)">
			<summary>Construct an OLS solver for an over-determined system of linear
 equations.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.OLSSolverByQR.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary>In the ordinary least square sense, solve
 <blockquote><i>Ax = y</i></blockquote></summary>
			<param name="problem">a system of linear equations</param>
			<returns>a solution <i>x^</i> that minimizes
 <blockquote><i>|Ax - y|<sub>2</sub></i></blockquote></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.OLSSolver">
			<summary>This class solves an over-determined system of linear equations in the
 ordinary least square sense.
 An over-determined system, represented by
 <blockquote><i>Ax = y</i></blockquote>
 has more rows than columns. That is, there are more equations than unknowns.
 One important application is linear regression, where <i>A</i> is the
 independent factors, <i>y</i> the dependent observations.
 The solution <i>x^</i> minimizes:
 <blockquote><i>|Ax - y|<sub>2</sub></i></blockquote>
 That is, <i>x^</i> is the best approximation that
 minimizes the sum of squared differences between the data values and their
 corresponding modeled values.
 The approach is called &quot;linear&quot; least squares since the solution depends
 linearly on the data.
 <blockquote><i>
 <i>x^</i> = (A<sup>t</sup>A)<sup>-1</sup>A<sup>t</sup>y,
 </i></blockquote>
 This implementation does not use the above formula to solve for <i>x^</i>
 because of the numerical stability problem in computing
 <i>A<sup>t</sup>A</i>.
 Instead, we use an orthogonal decomposition method.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/linear_least_squares">Wikipedia:
 Linear least squares</a></item>
 <item><a href="http://en.wikipedia.org/wiki/least_squares">Wikipedia: Least
 squares</a></item>
 <item><a
 href="http://en.wikipedia.org/wiki/linear_least_squares#orthogonal_decomposition_methods">Wikipedia:
 Orthogonal decomposition methods</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.OLSSolver.#ctor(System.Double)">
			<summary>Construct an OLS solver for an over-determined system of linear
 equations.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
 considered 0</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LUSolver">
			<summary>Use LU decomposition to solve <i>Ax = b</i> where <i>A</i> is square and
 <i>det(A) != 0</i>.
 The dimensions of <i>A</i> and <i>b</i> must match. The algorithm goes as follows.
 <blockquote><code><i>
 Ax = b;
 LUx = PAx = Pb
 </i></code></blockquote>
 We first solve
 <i>Ly = b</i> by forward substitution and then <i>Ux = y</i> by backward
 substitution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/lu_decomposition#solving_linear_equations">
 Wikipedia: Solving linear equations</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LUSolver.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LUSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary>Solve <i>Ax = b</i>.</summary>
			<param name="problem">a system of linear equations</param>
			<returns>x a solution such that <i>Ax = b</i></returns>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LinearSystemSolver.NoSolution">if there is no solution to the system</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LUSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Solves <i>AX = B</i>.</summary>
			<param name="A">the left-hand side coefficient matrix</param>
			<param name="B">the right-hand side of the equation</param>
			<returns>the solution, <i>X</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem">
			<summary>This is the problem of solving a system of linear equations.
 <blockquote><i>
 Ax = b
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Constructs a system of linear equations <i>Ax = b</i>.</summary>
			<param name="A">the the homogeneous part, the coefficient matrix, of the linear system</param>
			<param name="b">the non-homogeneous part, the right-hand side vector, of the linear system</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.A">
			<summary>Gets the homogeneous part, the coefficient matrix, of the linear system.</summary>
			<returns>the coefficient matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.b">
			<summary>Gets the non-homogeneous part, the right-hand side vector, of the linear system.</summary>
			<returns>the vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.size">
			<summary>Gets the number of variables in the linear system.</summary>
			<returns>the number of variables</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.withMaxIteration(System.Int32)">
			<summary>Overrides the maximum count of iterations.</summary>
			<param name="maxIteration">the maximum count of iterations</param>
			<returns>the new problem with the overriden maximum count of iterations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.getMaxIteration">
			<summary>Gets the specified maximum number of iterations.</summary>
			<returns>the maximum number of iterations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.withTolerance(com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Overrides the tolerance instance.</summary>
			<param name="tolerance">the criteria which determines when the solution converges and the iteration
                  stops</param>
			<returns>the new problem with the overriden tolerance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.getTolerance">
			<summary>Gets the specified <para></para>Tolerance instance.</summary>
			<returns>the <para></para>Tolerance instance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.withInitialGuess(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Overrides the initial guess of the solution.</summary>
			<param name="initialGuess">the initial guess of the solution</param>
			<returns>the new problem with the overriden initial guess</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.getInitialGuess">
			<summary>Gets the initial guess of the solution for the problem.</summary>
			<returns>the initial guess</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.withLeftPreconditioner(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.Preconditioner)">
			<summary>Overrides the left preconditioner. If right-preconditioning is used, leave this as its
 default value - <para></para>IdentityPreconditioner.</summary>
			<param name="preconditioner">the preconditioner</param>
			<returns>the new problem with the overriden left preconditioner</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.getLeftPreconditioner">
			<summary>Gets the left preconditioner.</summary>
			<returns>the left preconditioner</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.withRightPreconditioner(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.Preconditioner)">
			<summary>Overrides the right preconditioner. If left-preconditioning is used, leave this as its
 default value - <para></para>IdentityPreconditioner.</summary>
			<param name="preconditioner">the preconditioner</param>
			<returns>the new problem with the overriden right preconditioner</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem.getRightPreconditioner">
			<summary>Gets the right preconditioner.</summary>
			<returns>the right preconditioner</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LinearSystemSolver">
			<summary>Solve a system of linear equations in the form:
 <blockquote><i>
 Ax = b,
 </i></blockquote>
 We assume that, after row reduction, <i>A</i> has no more rows than columns.
 That is, the system must not be over-determined.
 For example, the following system is <em>not</em> over-determined. One of the
 rows is linearly dependent.
 \[
 \begin{bmatrix}
 1 &amp; -1 &amp; 0\\
 0 &amp; -2 &amp; 0\\
 0 &amp; 0 &amp; -1\\
 0 &amp; 0 &amp; -2
 \end{bmatrix} x =
 \begin{bmatrix}
 -0.8\\
 -1.6\\
 0.8\\
 1.6
 \end{bmatrix}
 \]
 This linear system of equations is solved in two steps.
 <list type="number">
 <item>First, solve <i>Ax = 0</i>, the homogeneous system, for non trivial
 solutions.</item>
 <item>Then, solve <i>Ax = b</i> for a particular solution.</item>
 </list>
 If <i>A</i> has full rank, this implementation solves the system by LU
 decomposition.
 Otherwise, a particular solution is found by <i>x = T * b</i>.
 The final solution is:
 <blockquote><i>x_particular + {x_null_space_of_A}</i></blockquote>
 hence, the translation of the null space of <i>A</i> by the vector
 <i>x_particular</i>.<para> See also: </para><list type="bullet">
 <item><a
 href="http://en.wikipedia.org/wiki/system_of_linear_equations">Wikipedia:
 System of linear equations</a></item>
 <item><a
 href="http://en.wikipedia.org/wiki/kernel_(matrix)#nonhomogeneous_equations">Wikipedia:
 Nonhomogeneous equations</a></item>
 <item><a
 href="http://en.wikipedia.org/wiki/system_of_linear_equations#homogeneous_systems">Wikipedia:
 Homogeneous systems</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LinearSystemSolver.#ctor(System.Double)">
			<summary>Construct a solver for a linear system of equations.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LinearSystemSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Get a particular solution for the linear system, <i>Ax = b</i>.</summary>
			<param name="A0">a matrix representing a linear system of equations (the
           homogeneous part)</param>
			<returns>a particular solution</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LinearSystemSolver.NoSolution">
			<summary>This is the runtime exception thrown when it fails to solve a system of linear
 equations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LinearSystemSolver.NoSolution.#ctor(System.String)">
			<summary>Construct an <c>LinearSystemSolver.NoSolution</c> exception.</summary>
			<param name="msg">the error message</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LinearSystemSolver.Solution">
			<summary>This is the solution to a linear system of equations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LinearSystemSolver.Solution.getParticularSolution(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Get a particular solution for the linear system.</summary>
			<param name="b">a vector</param>
			<returns>a particular solution</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LinearSystemSolver.Solution.getHomogeneousSoln">
			<summary>Get the basis of the homogeneous solution for the linear system,
 <i>Ax = b</i>.
 That is, the solutions for <i>Ax = 0</i>.</summary>
			<returns>the homogeneous solution</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel">
			<summary>The kernel or null space (also nullspace) of a matrix <i>A</i> is the set of all vectors <i>x</i> for which <i>Ax = 0</i>.
 The kernel of a matrix with <i>n</i> columns is a linear subspace of n-dimensional Euclidean space.
 Also, the kernel of a matrix <i>A</i> is exactly the same as the kernel of the linear mapping defined by the matrix-vector multiplication, <i>x &#8594; Ax</i>.
 That is, the set of vectors that map to the zero vector.
 The rank-nullity theorem says that the rank of <i>A</i> + the dimension of the kernel of <i>A</i> = the number of columns in <i>A</i>.
 <para/>
 The kernel is the solution of a system of homogeneous linear equations.
 With the transformation matrix <i>T</i>, which turns <i>A</i> into the reduced row echelon form,
 it can solve also a system of non-homogeneous linear equations.
 Specifically, to find a particular solution for a non-homogeneous system of linear equations with a matrix <i>A</i>, i.e.,
 <blockquote><i>Ax = b</i></blockquote>
 we solve
 <blockquote><i>T * A = U</i></blockquote>
 and then
 <blockquote><i>x = T * b</i></blockquote>
 where
 <i>x</i> is a particular solution.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/kernel_(matrix)#nonhomogeneous_equations">Wikipedia: Kernel (matrix)</a></item>
 <item><a href="http://en.wikipedia.org/wiki/rank-nullity_theorem">Wikipedia: Rank-nullity theorem</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.Method,System.Double)">
			<summary>Construct the kernel of a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="method">the kernel computation method</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0;
 the &#949; is used to determine the numerical rank of the linear space</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct the kernel of a matrix.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.nullity">
			<summary>Get the nullity of <i>A</i>.
 That is, the dimension of the kernel.</summary>
			<returns>the nullity</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.rank">
			<summary>Get the rank of <i>A</i>.
 That is, the number of linearly independent columns or rows in <i>A</i>.</summary>
			<returns>the rank</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.basisAndFreeVars">
			<summary>Get the kernel basis and the associated free variables for each basis/column.
 This method is only meaningful when the kernel is computed using <para></para>Method#GAUSSIAN_JORDAN_ELIMINATION.
 Using this process, a free variable corresponds to an entry &apos;1&apos; in a column.
 For the example in Wikipedia,
 <i>x<sub>3</sub></i> (the 3rd variable) is a free variable, and it corresponds to <i>[3,-5,1,0,0,0]<sup>t</sup></i>.
 <para/>
 If the kernel basis is computed using a different method, call <para></para>#basis() instead.<para> See also: </para><a href="http://en.wikipedia.org/wiki/kernel_(matrix)#basis">Wikipedia: Basis</a></summary>
			<returns>a map of indices and kernel basis vectors</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.basis">
			<summary>Get the kernel basis.</summary>
			<returns>the kernel basis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.isZero">
			<summary>Check if the kernel has zero dimension, that is, if <i>A</i> has full rank.</summary>
			<returns><c>true</c> if the kernel is null</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.T">
			<summary>Get the transformation matrix, <i>T</i>, such that <i>T * A = U</i>.
 To find a particular solution for a non-homogeneous system of linear equations <i>Ax = b</i>, we do
 <blockquote><i>x = T * b</i></blockquote>
 where <i>x</i> is a particular solution.</summary>
			<returns>the transformation matrix <i>T</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.U">
			<summary>Get the upper triangular matrix <i>U</i>, such that <i>T * A = U</i>.</summary>
			<returns>the <i>U</i> matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.Method">
			<summary>These are the available methods to compute kernel basis.
 Note that the matrices <i>T</i> and <i>U</i> are always computed using Gauss-Jordan elimination.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.Method.QR">
			<summary>use QR decomposition; moderately expensive (recommended)</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.Method.GAUSSIAN_JORDAN_ELIMINATION">
			<summary>use Gauss-Jordan elimination; cheap but subject to numerical stability (rounding errors)</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.Method.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.Kernel.Method.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.ForwardSubstitution">
			<summary>Forward substitution solves a matrix equation in the form <i>Lx = b</i>
 by an iterative process for a lower triangular matrix <i>L</i>.
 The process is so called because for a lower triangular matrix, one first computes
 <i>x<sub>1</sub></i>,
 then substitutes that forward into the next equation to solve for <i>x<sub>2</sub></i>,
 and repeats until <i>x<sub>n</sub></i>.
 Note that some diagonal entries in <i>L</i> can be 0s, provided that the system of equations is
 consistent.
 For example,
 \[
 \begin{bmatrix}
 0 &amp; 0 &amp; 0\\
 2 &amp; 0 &amp; 0\\
 4 &amp; 5 &amp; 6
 \end{bmatrix} \times
 \begin{bmatrix}
 0\\
 0\\
 30
 \end{bmatrix} =
 \begin{bmatrix}
 0\\
 0\\
 30
 \end{bmatrix}
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/triangular_matrix#forward_substitution">
 Wikipedia: Forward substitution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.ForwardSubstitution.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.ForwardSubstitution.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Solve <i>Lx = b</i>.</summary>
			<param name="L">a lower triangular matrix, representing the system of linear equations (the
          homogeneous part)</param>
			<param name="b">a vector</param>
			<returns>a solution <i>x</i> such that <i>Lx = b</i></returns>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LinearSystemSolver.NoSolution">if there is no solution to the system</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.ForwardSubstitution.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.ForwardSubstitution.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.ForwardSubstitution.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.BackwardSubstitution">
			<summary>Backward substitution solves a matrix equation in the form <i>Ux = b</i>
 by an iterative process for an upper triangular matrix <i>U</i>.
 The process is so called because for an upper triangular matrix, one first computes
 <i>x<sub>n</sub></i>,
 then substitutes that backward into the next equation to solve for <i>x<sub>n-1</sub></i>,
 and repeats until <i>x<sub>1</sub></i>.
 Note that some diagonal entries in <i>U</i> can be 0s, provided that the system of equations is
 consistent.
 For example,
 \[
 \begin{bmatrix}
 1 &amp; 2 &amp; 3\\
 0 &amp; 0 &amp; 5\\
 0 &amp; 0 &amp; 0
 \end{bmatrix} \times
 \begin{bmatrix}
 10\\
 0\\
 0
 \end{bmatrix} =
 \begin{bmatrix}
 10\\
 0\\
 0
 \end{bmatrix}
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/triangular_matrix#forward_and_back_substitution">
 Wikipedia: Forward and Back Substitution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.BackwardSubstitution.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.BackwardSubstitution.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Solve <i>Ux = b</i>.</summary>
			<param name="U">an upper triangular matrix, representing the system of linear equations (the
          homogeneous part)</param>
			<param name="b">a vector</param>
			<returns>a solution <i>x</i> such that <i>Ux = b</i></returns>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LinearSystemSolver.NoSolution">if there is no solution to the system</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.BackwardSubstitution.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.BackwardSubstitution.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.BackwardSubstitution.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix">
			<summary>A permutation matrix is a square matrix that has exactly one entry &apos;1&apos; in each row and each
 column and 0&apos;s elsewhere. Suppose <i>P</i> is a permutation matrix, <i>A</i> any matrix, then
 <list type="number">
 <item><i>P * A</i> swaps the rows of <i>A</i>;</item>
 <item><i>A * P</i> swaps the columns of <i>A</i>;</item>
 </list>
 To ensure that the matrix represents a consistent permutation, there is no method &apos;set&apos; in this
 class. The matrix entries can only be modified by the swap functions.<para> See also: </para><a href="http://en.wikipedia.org/wiki/permutation_matrix">Wikipedia: Permutation matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.#ctor(System.Int32)">
			<summary>Construct an identity permutation matrix.</summary>
			<param name="dim">the matrix dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.#ctor(System.Int32[])">
			<summary>Construct a permutation matrix from an 1D <c>double[]</c>.</summary>
			<param name="data">the 1D <c>double[]</c> indicating the column position of the 1 in each row</param>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>data</c> is not a permutation matrix</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix)">
			<summary>Copy constructor.</summary>
			<param name="P">a permutation matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.sign">
			<summary>Gets the sign of the permutation matrix which is also the determinant. It is +1 for an even
 (or 0) number of swaps and -1 for an odd number of swaps.</summary>
			<returns>the sign</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.swapRow(System.Int32,System.Int32)">
			<summary>Swaps two rows of a permutation matrix.</summary>
			<param name="i1">row 1</param>
			<param name="i2">row 2</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.swapColumn(System.Int32,System.Int32)">
			<summary>Swaps two columns of a permutation matrix.</summary>
			<param name="j1">column 1</param>
			<param name="j2">column 2</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.moveRow2End(System.Int32)">
			<summary>Swaps a row of the permutation matrix with the last row.</summary>
			<param name="i">the row to be swapped with the last row</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.moveColumn2End(System.Int32)">
			<summary>Swaps a column of a permutation matrix with the last column.</summary>
			<param name="j">the column to be swapped with the last column</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.rightMultiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Right multiplication by <i>P</i>. <i>A * P</i> is the same as swapping columns in <i>A</i>
 according to <i>P</i>.</summary>
			<param name="A">a matrix</param>
			<returns>the matrix with the columns swapped</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Left multiplication by <i>P</i>. <i>P * v</i> is the same as swapping the vector entries/rows
 according to <i>P</i>.</summary>
			<param name="v">a column vector</param>
			<returns>the vector with the rows swapped</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Left multiplication by <i>P</i>. <i>P * A</i> is the same as swapping rows in <i>A</i>
 according to <i>P</i>.</summary>
			<param name="A">a matrix</param>
			<returns>the matrix with the rows swapped</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.t">
			<summary>The transpose of a permutation matric is the same as its inverse. That is,
 <blockquote><c>P.multiply(P.t()) == P.t().multiply(P) == P.toDense().ONE()</c></blockquote></summary>
			<returns>a copy of itself</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.PermutationMatrix.set(System.Int32,System.Int32,System.Double)">
			<summary><para><c>DEPRECATED:</c> use the swap functions instead</para>
Don&apos;t use this function to change entries in a Permutation matrix. Use the swap functions
 instead.
 <para/>
 <para></para>#swapRow(int, int),
 <para></para>#swapColumn(int, int),
 <para></para>#moveRow2End(int),
 <para></para>#moveColumn2End(int),</summary>
			<exception cref="T:java.lang.UnsupportedOperationException">when called</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.HilbertMatrix">
			<summary>A Hilbert matrix, <i>H</i>, is a symmetric matrix with entries being the unit fractions
 <blockquote><i>H[i][j] = 1 / (i + j -1)</i></blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/hilbert_matrix"> Wikipedia: Hilbert matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.HilbertMatrix.#ctor(System.Int32)">
			<summary>Constructs a Hilbert matrix.</summary>
			<param name="n">the Hilbert matrix dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.HilbertMatrix.invdet">
			<summary>One over the determinant of <i>H</i>: <i>1/|H|</i>, which is an integer.</summary>
			<returns>one over the determinant of <i>H</i>, which is an integer</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.HilbertMatrix.det">
			<summary>The determinant of a Hilbert matrix is the reciprocal of an integer.<para> See also: </para><a href="http://www.research.att.com/~njas/sequences/a005249"> OEIS: sequence
 A005249</a></summary>
			<returns>the determinant</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix">
			<summary>Givens rotation is a rotation in the plane spanned by two coordinates axes. That is, left
 multiplying a vector <i>x</i> by <i>G(i, j, &#952;)</i>, i.e., <i>G(i, j, &#952;)x</i>, amounts
 to rotating <i>x</i> counter-clockwise by radians in the <i>(i ,j)</i> coordinate plane. Its main
 use is to zero out entries in matrices and vectors. Compared to Householder transformation,
 Givens rotation can zero out entries more selectively. For example, given a matrix <i>A</i>, we
 can construct a Givens matrix, <i>G</i>, such that <i>GA</i> has a 0 at an entry <i>GA[i,j]</i>
 of our choice. Givens matrices are orthogonal.
 <para/>
 This implementation of a Givens matrix is <em>immutable</em>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/givens_rotation">Wikipedia: Givens rotation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.#ctor(System.Int32,System.Int32,System.Int32,System.Double,System.Double)">
			<summary>Constructs a Givens matrix in the form
 \[
 G(i,j,c,s) = \begin{bmatrix}
 1 &amp; ... &amp; 0 &amp; ... &amp; 0 &amp; ... &amp; 0\\
 ... &amp; &amp; &amp; &amp; &amp; &amp; \\
 0 &amp; ... &amp; c &amp; ... &amp; s &amp; ... &amp; 0\\
 ... &amp; &amp; &amp; &amp; &amp; &amp; \\
 0 &amp; ... &amp; -s &amp; ... &amp; c &amp; ... &amp; 0\\
 ... &amp; &amp; &amp; &amp; &amp; &amp; \\
 0 &amp; ... &amp; 0 &amp; ... &amp; 0 &amp; ... &amp; 1
 \end{bmatrix}
 \]
 We have,
 <blockquote><code>
 <i>G[i,i] = c</i> (diagonal entry)
 <i>G[j,j] = c</i> (diagonal entry)
 <i>G[i,j] = s</i>
 <i>G[j,i] = -s</i>
 </code></blockquote></summary>
			<param name="dim">the dimension of <i>G</i></param>
			<param name="i"><i>i</i></param>
			<param name="j"><i>j</i></param>
			<param name="c"><i>c</i></param>
			<param name="s"><i>s</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix)">
			<summary>Copy constructor.</summary>
			<param name="that">a Givens matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.CtorFromRho(System.Int32,System.Int32,System.Int32,System.Double)">
			<summary>Constructs a Givens matrix from &#961;.
 This construction is discussed in the reference.<para> See also: </para>&quot;G. H. Golub, C. F. van Loan, &quot;Section 5.1.11,&quot; Matrix Computations, 3rd edition.&quot;</summary>
			<param name="dim">the dimension of <i>G</i></param>
			<param name="i"><i>i</i></param>
			<param name="j"><i>j</i></param>
			<param name="rho"><i>&#961;</i></param>
			<returns>a Givens matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.Ctor2x2(System.Double,System.Double)">
			<summary>Same as <c>new GivensMatrix(2, 1, 2, c, s)</c>.</summary>
			<param name="c"><i>c</i></param>
			<param name="s"><i>s</i></param>
			<returns>a 2x2 Givens matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.CtorToRotateRows(System.Int32,System.Int32,System.Int32,System.Double,System.Double)">
			<summary>Constructs a Givens matrix such that <i>G * [a b]<sup>t</sup> = [* 0]<sup>t</sup></i>.
 This operation rotates rows <i>i<sub>1</sub></i> and <i>i<sub>2</sub></i> to make the entry
 in row <i>i<sub>1</sub></i> 0.
 This implementation is a variant of the numerically stable version in the reference.<para> See also: </para>&quot;G. W. Stewart, &quot;Algorithm 1.6,&quot; Matrix Algorithms Vol. 1&quot;</summary>
			<param name="dim">the dimension of <i>G</i></param>
			<param name="i1"><i>i<sub>1</sub></i> as in <i>A[i<sub>1</sub>,i<sub>1</sub>] = c</i></param>
			<param name="i2"><i>i<sub>2</sub></i> as in <i>A[i<sub>1</sub>,i<sub>2</sub>] = s</i></param>
			<param name="a"><i>a</i> as in <i>[a b]<sup>t</sup></i></param>
			<param name="b"><i>b</i> as in <i>[a b]<sup>t</sup></i></param>
			<returns><i>G</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.CtorToZeroOutEntry(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,System.Int32)">
			<summary>Constructs a Givens matrix such that <i>G * A</i> has 0 in the <i>[i,j]</i> entry.</summary>
			<param name="A">a matrix</param>
			<param name="i"><i>i</i> as in <i>A[i,j]</i></param>
			<param name="j"><i>j</i> as in <i>A[i,j]</i></param>
			<returns>a Givens matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.CtorToRotateColumns(System.Int32,System.Int32,System.Int32,System.Double,System.Double)">
			<summary>Constructs a Givens matrix such that <i>[a b] * G = [* 0]</i>.
 This operation rotates columns <i>j<sub>1</sub></i> and <i>j<sub>2</sub></i> to make the
 entry in column <i>j<sub>2</sub></i> 0.</summary>
			<param name="dim">the dimension of <i>G</i></param>
			<param name="j1"><i>j<sub>1</sub></i> as in <i>A[j<sub>1</sub>,j<sub>1</sub>] = c</i></param>
			<param name="j2"><i>j<sub>2</sub></i> as in <i>A[j<sub>1</sub>,j<sub>2</sub>] = s</i></param>
			<param name="a"><i>a</i> as in <i>[a b]<sup>t</sup></i></param>
			<param name="b"><i>b</i> as in <i>[a b]<sup>t</sup></i></param>
			<returns>a Givens matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.CtorToZeroOutEntryByTranspose(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,System.Int32)">
			<summary>Constructs a Givens matrix such that <i>G<sup>t</sup> * A</i> has 0 in the <i>[i,j]</i>
 entry.</summary>
			<param name="A">a matrix</param>
			<param name="i"><i>i</i> as in <i>A[i,j]</i></param>
			<param name="j"><i>j</i> as in <i>A[i,j]</i></param>
			<returns><i>G</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.i">
			<summary>Gets the value of <i>i</i>.</summary>
			<returns>the value of <i>i</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.j">
			<summary>Gets the value of <i>j</i>.</summary>
			<returns>the value of <i>j</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.c">
			<summary>Gets the value of <i>c</i>.</summary>
			<returns>the value of <i>c</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.s">
			<summary>Gets the value of <i>s</i>.</summary>
			<returns>the value of <i>s</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.rho">
			<summary>Gets &#961; as discussed in the reference.<para> See also: </para>&quot;G. H. Golub, C. F. van Loan, &quot;Section 5.1.11,&quot; Matrix Computations, 3rd edition.&quot;</summary>
			<returns>&#961;</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.rotate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
Rotates <i>x</i> in the <i>[i,j]</i> coordinate plane.</summary>
			<param name="x">a vector</param>
			<returns><i>G(i, j, &#952;)x</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.t">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Left multiplication by <i>G</i>, namely, <i>G * A</i>.
 This operation affects only the <i>i</i>-th and the <i>j</i>-th rows.
 This implementation uses this fact for performance.</summary>
			<param name="A">a left multiply matrix</param>
			<returns><i>G * A</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.multiplyInPlace(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Left multiplication by <i>G</i>, namely, <i>G * A</i>.
 This operation changes the input matrix <i>A</i> for performance reason (skipping copying).</summary>
			<param name="A">a left multiply matrix; <em>it is changed after the operation</em></param>
			<returns><i>G * A</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.multiplyInPlace(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Right multiplies this matrix, <i>A</i>, by a vector.
 This operation changes the input vector <i>v</i> for performance reason (skipping copying).</summary>
			<param name="v">a vector; <em>it is changed after the operation</em></param>
			<returns><i>Av</i>, a vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.rightMultiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Right multiplication by <i>G</i>, namely, <i>A * G</i>.
 This operation affects only the <i>i</i>-th and the <i>j</i>-th columns.
 This implementation uses this fact for performance.</summary>
			<param name="A">a right multiply matrix</param>
			<returns><i>A * G</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.rightMultiplyInPlace(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Right multiplication by <i>G</i>, namely, <i>A * G</i>.
 This operation changes the input matrix <i>A</i> for performance reason (skipping copying).</summary>
			<param name="A">a left multiply matrix; <em>it is changed after the operation</em></param>
			<returns><i>A * G</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.product(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix[])">
			<summary>Given an array of Givens matrices <i>{G<sub>i</sub>}</i>,
 computes <i>G</i>, where
 <blockquote><i>
 G = G<sub>1</sub> * G<sub>2</sub> * ... * G<sub>n</sub>
 </i></blockquote></summary>
			<param name="Gs">an array of Givens matrices</param>
			<returns><i>G</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.product(java.util.List)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.set(System.Int32,System.Int32,System.Double)">
			<summary><para><c>DEPRECATED:</c> GivensMatrix is immutable</para>
</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.ZERO">
			<summary><para><c>DEPRECATED:</c> no zero matrix for GivensMatrix</para>
</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.GivensMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage">
			<summary>There are multiple ways to implement the storage data structure depending on the matrix type for
 optimization purpose. This class provides a default way to access the storage structure.
 A particular matrix implementation may override these methods for performance, if implementation
 details of <c>storage</c> are known.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary>Construct a <c>DefaultMatrixStorage</c> to wrap a storage for access.</summary>
			<param name="storage">the matrix data storage/representation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.setRow(System.Int32,System.Double[])">
			<summary>Set the values for a row in the matrix, i.e., <i>[i, *]</i>.</summary>
			<param name="i">the row index, counting from 1</param>
			<param name="values">the values to change the row entries to</param>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">if the number of <c>values</c> does not match the column size</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.setRow(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Set the values for a row in the matrix, i.e., <i>[i, *]</i>.</summary>
			<param name="i">the row index, counting from 1</param>
			<param name="v">the vector to change the row entries to</param>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">if the number of <c>values</c> does not match the column size</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.getRow(System.Int32)">
			<summary>Get a row.</summary>
			<param name="i">the row index, counting from 1</param>
			<returns>row <i>i</i></returns>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">if the row index is invalid</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.setColumn(System.Int32,System.Double[])">
			<summary>Set the values for a column in the matrix, i.e., <i>[*, j]</i>.</summary>
			<param name="j">the column index, counting from 1</param>
			<param name="values">the values to change the column entries to</param>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">if the number of <c>values</c> does not match the row size</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.setColumn(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Set the values for a column in the matrix, i.e., <i>[*, j]</i>.</summary>
			<param name="j">the column index, counting from 1</param>
			<param name="v">the vector to change the column entries to</param>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">if the number of <c>values</c> does not match the row size</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.getColumn(System.Int32)">
			<summary>Get a column.</summary>
			<param name="j">the column index, counting from 1</param>
			<returns>row <i>j</i></returns>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">if the column index is invalid</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.DefaultMatrixStorage.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.Densifiable">
			<summary>This interface specifies whether a matrix implementation can be efficiently converted to the standard dense matrix representation.
 A particular matrix implementation may optimize the conversion by taking advantage of having access to the class&apos; private members.
 Thus, <c>toDense()</c> is in general more efficient than explicit copy construction.<para> See also: </para>DenseMatrix</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.Densifiable.toDense">
			<summary>Densify a matrix, i.e., convert a matrix implementation to the standard dense matrix, <para></para>DenseMatrix.</summary>
			<returns>a matrix representation in <para></para>DenseMatrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix">
			<summary>This class implements the standard, dense, <c>double</c> based matrix representation. There are
 two additional methods to change the matrix content:
 <list type="bullet">
 <item><para></para>#setRow(int, com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)</item>
 <item><para></para>#setColumn(int, com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.#ctor(System.Int32,System.Int32)">
			<summary>Constructs a 0 matrix of dimension <i>nRows * nCols</i>.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.#ctor(System.Double[][])">
			<summary>Constructs a matrix from a 2D <c>double[][]</c> array.</summary>
			<param name="data">a 2D array input</param>
			<exception cref="T:java.lang.IllegalArgumentException">when <c>data</c> is a jagged array</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.#ctor(System.Double[],System.Int32,System.Int32)">
			<summary>Constructs a matrix from a 1D <c>double[]</c>. The array is a concatenation of the matrix
 rows. A sample usage is to convert a vector to a matrix. For example, to construct a column
 vector, we do
 <code><c>DenseMatrix V = new DenseMatrix(v.toArray(), v.length, 1);
 </c></code>
 To construct a row vector, we do
 <code><c>DenseMatrix V = new DenseMatrix(v.toArray(), 1, v.length);
 </c></code></summary>
			<param name="data">the 1D array input</param>
			<param name="nRows">the number or rows</param>
			<param name="nCols">the number of columns</param>
			<exception cref="T:java.lang.IllegalArgumentException">when the length of <c>data</c> does not equal to <i>nRows *
                                  nCols</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Constructs a column matrix from a vector.</summary>
			<param name="v">a vector</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Converts any matrix to the standard matrix representation. This method is the same as
 <para></para>#toDense if <c>A</c> is <para></para>Densifiable.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix)">
			<summary>Copy constructor performing a deep copy.</summary>
			<param name="A">a <c>DenseMatrix</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix,System.Boolean)">
			<summary>This constructor is useful for subclass to pass in computed value.</summary>
			<param name="A">a <c>DenseMatrix</c></param>
			<param name="copy"><c>true</c> if a deep copy of <c>A</c> is needed</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.toDense">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.setRow(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Changes the matrix row values to a vector value.</summary>
			<param name="i">the <i>i</i>-th row to change</param>
			<param name="v">the values to change the row to</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.setColumn(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Changes the matrix column values to a vector value.</summary>
			<param name="j">the <i>j</i>-th column to change</param>
			<param name="v">the values to change the column to</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.getRow(System.Int32,System.Int32,System.Int32)">
			<summary>Gets a sub-row of the <i>i</i>-th row, from <c>beginCol</c> column to <c>endCol</c> column,
 inclusively.</summary>
			<param name="i">the row to extract</param>
			<param name="beginCol">the beginning column of the sub-row</param>
			<param name="endCol">the ending column of the sub-row</param>
			<returns>a sub-row</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.getColumn(System.Int32,System.Int32,System.Int32)">
			<summary>Gets a sub-column of the <i>j</i>-th column, from <c>beginRow</c> row to <c>endRow</c> row,
 inclusively.</summary>
			<param name="j">the column to extract</param>
			<param name="beginRow">the beginning row of the sub-column</param>
			<param name="endRow">the ending row of the sub-column</param>
			<returns>a sub-column</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.t">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData">
			<summary>This implementation of the storage of a dense matrix stores the data of a 2D matrix as an 1D
 array.
 In general, computing index for a <c>double[]</c> is faster than that for a <c>double[][]</c>.
 Hence for most operations, e.g., element-by-element add, minus, this implementation has a better
 performance.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.ZERO_ENTRY">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.#ctor(System.Double[],System.Int32,System.Int32,com.numericalmethod.suanshu.number.doublearray.DoubleArrayOperation)">
			<summary>Construct a storage, and specify the implementations of the element-wise operations.</summary>
			<param name="data">the data</param>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="operation">the implementations of the element-wise operations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.#ctor(System.Double[],System.Int32,System.Int32)">
			<summary>Construct a storage.</summary>
			<param name="data">the data</param>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.position(System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.newInstance(System.Double[],System.Int32,System.Int32,com.numericalmethod.suanshu.number.doublearray.DoubleArrayOperation)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.asArray">
			<summary>Cast this data structure as a <c>double[]</c>.
 Modifying the returned value modifies the internal data.</summary>
			<returns>itself as a <c>double[]</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData)">
			<summary>Add up the elements in <c>this</c> and <c>that</c>, element-by-element.</summary>
			<param name="that">an array of data</param>
			<returns>the sums of elements</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData)">
			<summary>Subtract the elements in <c>this</c> by <c>that</c>, element-by-element.</summary>
			<param name="that">an array of data</param>
			<returns>the differences of elements</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.scaled(System.Double)">
			<summary>Multiply the elements in <c>this</c> by a scalar, element-by-element.</summary>
			<param name="c">the scaling constant</param>
			<returns>the scaled elements</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.DenseData.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix">
			<summary>A tri-diagonal matrix has non-zero entries only on the super, main and sub diagonals.<para> See also: </para><a href="http://en.wikipedia.org/wiki/tridiagonal_matrix">Wikipedia: Tridiagonal matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix.#ctor(System.Int32)">
			<summary>Constructs a 0 tri-diagonal matrix of dimension <i>dim * dim</i>.</summary>
			<param name="dim">the dimension of the matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix.#ctor(System.Double[][])">
			<summary>Constructs a tri-diagonal matrix from a 3-row 2D <c>double[][]</c> array such that:
 <list type="number">
 <item>the first row is the super diagonal with <i>(dim - 1)</i> entries;</item>
 <item>the second row is the main diagonal with <i>dim</i> entries;</item>
 <item>the third row is the sub diagonal with <i>(dim - 1)</i> entries.</item>
 </list>
 For example,
 <blockquote><code><c>
         new double[][]{
              {2, 5, 8, 11},
              {1, 4, 7, 10, 13},
              {3, 6, 9, 12}
          }
 </c></code></blockquote>
 gives
 \[
 \begin{bmatrix}
 1 &amp; 2 &amp; 0 &amp; 0 &amp; 0\\
 3 &amp; 4 &amp; 5 &amp; 0 &amp; 0\\
 0 &amp; 6 &amp; 7 &amp; 8 &amp; 0\\
 0 &amp; 0 &amp; 9 &amp; 10 &amp; 11\\
 0 &amp; 0 &amp; 0 &amp; 12 &amp; 13
 \end{bmatrix}
 \]
 We allow <c>null</c> input when a diagonal is 0s.
 For example,
 <blockquote><code><c>
         new double[][]{
              {2, 5, 8, 11},
              {1, 4, 7, 10, 13},
              null
          }
 </c></code></blockquote>
 gives
 \[
 \begin{bmatrix}
 1 &amp; 2 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 4 &amp; 5 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 7 &amp; 8 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 10 &amp; 11\\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 13
 \end{bmatrix}
 \]
 The following is not allowed because the dimension cannot be determined.
 <blockquote><code><c>
         new double[][]{
              null,
              null,
              null
          }
 </c></code></blockquote></summary>
			<param name="data">the 2D array input</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Casts a matrix to tridiagonal by copying the 3 diagonals (ignoring all other entries).</summary>
			<param name="A">the matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix)">
			<summary>Copy constructor performing a deep copy.</summary>
			<param name="that">a tri-diagonal matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix.t">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.TridiagonalMatrix.ONE">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix">
			<summary>A diagonal matrix has non-zero entries only on the main diagonal.<para> See also: </para><a href="http://en.wikipedia.org/wiki/diagonal_matrix">Wikipedia: Diagonal matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.#ctor(System.Double[])">
			<summary>Constructs a diagonal matrix from a <c>double[]</c>. For example,
 <blockquote><code><c>
         new double[][]{
              {1, 2, 3, 4, 5},
          }
 </c></code></blockquote>
 gives
 \[
 \begin{bmatrix}
 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 2 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 3 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 4 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 5
 \end{bmatrix}
 \]</summary>
			<param name="data">the 1D array input</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.#ctor(System.Double[],System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.#ctor(System.Int32)">
			<summary>Constructs a 0 diagonal matrix of dimension <i>dim * dim</i>.</summary>
			<param name="dim">the matrix dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.#ctor(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix)">
			<summary>Copy constructor.</summary>
			<param name="that">a diagonal matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Computes the sum of two diagonal matrices.</summary>
			<param name="that">a diagonal matrix</param>
			<returns><c>this</c> + <c>that</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Computes the difference between two diagonal matrices.
 <para/></summary>
			<param name="that">a diagonal matrix</param>
			<returns><c>this</c> - <c>that</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Computes the product of two diagonal matrices.</summary>
			<param name="that">a diagonal matrix</param>
			<returns><c>this</c> * <c>that</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.t">
			<summary>The transpose of a diagonal matrix is the same as itself.</summary>
			<returns>a copy</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.DiagonalMatrix.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix">
			<summary>A bi-diagonal matrix is either upper or lower diagonal. It has non-zero entries only on the main,
 and either the super-diagonal (upper) or sub-diagonal (lower).<para> See also: </para><a href="http://en.wikipedia.org/wiki/bidiagonal_matrix">Wikipedia: Bidiagonal matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.#ctor(System.Double[][])">
			<summary>Constructs a bi-diagonal matrix from a 2D <c>double[][]</c> array. There are always two
 rows.
 The longer row is the main diagonal and has one more element.
 If the first row is shorter, it is an upper bi-diagonal matrix.
 If the second row is shorter, it is a lower bi-diagonal matrix.
 For example,
 <blockquote><code><c>
         new double[][]{
              {2, 5, 8, 11},
              {1, 4, 7, 10, 13}
          }
 </c></code></blockquote>
 gives
 \[
 \begin{bmatrix}
 1 &amp; 2 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 4 &amp; 5 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 7 &amp; 8 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 10 &amp; 11\\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 13
 \end{bmatrix}
 \]
 We allow <c>null</c> input when a diagonal is 0s, except for the main diagonal.
 For example,
 <blockquote><code><c>
         new double[][]{
              {1, 4, 7, 10, 13},
              null
          }
 </c></code></blockquote>
 gives
 \[
 \begin{bmatrix}
 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 4 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 7 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 10 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 13
 \end{bmatrix}
 \]
 The following is not allowed because the dimension cannot be determined.
 <blockquote><code><c>
         new double[][]{
              null,
              null
          }
 </c></code></blockquote>
 This implementation treats a diagonal matrix as an upper bi-diagonal matrix.</summary>
			<param name="data">the 2D array input</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.#ctor(System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.BidiagonalMatrixType)">
			<summary>Constructs a 0 bi-diagonal matrix of dimension <i>dim * dim</i>.</summary>
			<param name="dim">the dimension of the matrix</param>
			<param name="type">the type of bi-diagonal matrix to create</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix)">
			<summary>Copy constructor.</summary>
			<param name="that">a bi-diagonal matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.getType">
			<summary>Gets the bi-diagonal matrix type.</summary>
			<returns>the bi-diagonal matrix type</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.isUnreduced(System.Double)">
			<summary>A bi-diagonal matrix is unreduced if it has no 0 on <em>both</em> the super and main
 diagonals.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <c>this</c> is unreduced</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>
 <para/>
 When the two matrices have opposite types, i.e., one is <para></para>BidiagonalMatrixType#UPPER
 and one is <para></para>BidiagonalMatrixType#LOWER, the product of the two bi-diagonal matrices is
 a tridiagonal matrix.</summary>
			<param name="that">a matrix</param>
			<returns><c>this</c> * <c>that</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.t">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.ONE">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.BidiagonalMatrixType">
			<summary>the available types of bi-diagonal matrices</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.BidiagonalMatrixType.UPPER">
			<summary>an upper bi-diagonal matrix, where there are only non-zero entries on the main and super
 diagonal</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.BidiagonalMatrixType.LOWER">
			<summary>a lower bi-diagonal matrix, where there are only non-zero entries on the main and sub
 diagonal</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.BidiagonalMatrixType.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.diagonal.BidiagonalMatrix.BidiagonalMatrixType.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix">
			<summary>An upper triangular matrix has 0 entries where row index is greater than column index. An upper
 triangular matrix is always square.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.#ctor(System.Int32)">
			<summary>Constructs an upper triangular matrix of dimension <i>dim * dim</i>.</summary>
			<param name="dim">the matrix dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.#ctor(System.Double[][])">
			<summary>Constructs an upper triangular matrix from a 2D <c>double[][]</c> array.</summary>
			<param name="data">the 2D array input</param>
			<exception cref="T:java.lang.IllegalArgumentException">when the input <c>data</c> is not a upper triangular</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs an upper triangular matrix from a matrix.</summary>
			<param name="A">a matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">when <c>A</c> is not square</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix)">
			<summary>Copy constructor.</summary>
			<param name="U">an upper triangular matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.toDense">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.t">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.UpperTriangularMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix">
			<summary>A symmetric matrix is a square matrix such that its transpose equals to itself, i.e.,
 <blockquote><c>A[i][j] = A[j][i]</c></blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/symmetric_matrix"> Wikipedia: Symmetric matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.#ctor(System.Int32)">
			<summary>Construct a symmetric matrix of dimension <i>dim * dim</i>.</summary>
			<param name="dim">the matrix dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.#ctor(System.Double[][])">
			<summary>Construct a symmetric matrix from a 2D <c>double[][]</c> array.
 The array specifies only the lower triangular part (main diagonal inclusive) of the whole
 matrix.
 For example,
 <blockquote><c><code>
         new double[][]{
                  {1},
                  {2, 3},
                  {4, 5, 6},
                  {7, 8, 9, 10},
                  {11, 12, 13, 14, 15}});
 </code></c></blockquote>
 gives
 \[
 \begin{bmatrix}
 1 &amp; 2 &amp; 4 &amp; 7 &amp; 11\\
 2 &amp; 3 &amp; 5 &amp; 8 &amp; 12\\
 4 &amp; 5 &amp; 6 &amp; 9 &amp; 13\\
 7 &amp; 8 &amp; 9 &amp; 10 &amp; 14\\
 11 &amp; 12 &amp; 13 &amp; 14 &amp; 15
 \end{bmatrix}
 \]
 This constructor uses lower instead of upper triangular representation for visual reason.</summary>
			<param name="data">the lower triangular specification</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Cast an (almost) symmetric matrix into <tt>SymmetricMatrix</tt> by averaging A(i,j) and
 A(j,i).</summary>
			<param name="A">an (almost) symmetric matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean)">
			<summary>Cast an (almost) symmetric matrix into <tt>SymmetricMatrix</tt>.</summary>
			<param name="A">an (almost) symmetric matrix</param>
			<param name="copyLower"><c>true</c> if the lower triangular portion of A is used; otherwise, the
                  average values of A(i,j) and A(j,i) are used</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix)">
			<summary>Copy constructor.</summary>
			<param name="S">a symmetric matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.toDense">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.t">
			<summary>The transpose of a symmetric matrix is the same as itself.</summary>
			<returns>a copy of itself</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix">
			<summary>A lower triangular matrix has 0 entries where column index &gt; row index. A lower triangular matrix
 is always square.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.#ctor(System.Int32)">
			<summary>Constructs a lower triangular matrix of dimension <i>dim * dim</i>.</summary>
			<param name="dim">the matrix dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.#ctor(System.Double[][])">
			<summary>Constructs a lower triangular matrix from a 2D <c>double[][]</c> array.</summary>
			<param name="data">the 2D array input</param>
			<exception cref="T:java.lang.IllegalArgumentException">when the input <c>data</c> is not a lower triangular</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs a lower triangular matrix from a matrix.</summary>
			<param name="A">a matrix</param>
			<exception cref="T:java.lang.IllegalArgumentException">when <c>A</c> is not square</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix)">
			<summary>Copy constructor.</summary>
			<param name="L">a lower triangular matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.toDense">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.t">
			<summary><c>t(A)</c></summary>
			<returns>an upper triangular matrix which is the transpose of
         <c>this</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.LowerTriangularMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.SimpleMatrixMathOperation">
			<summary>This is a generic, single-threaded implementation of matrix math operations.
 It assumes no knowledge of how a matrix is implemented.
 Consequently, they are bound to have suboptimal performance.
 A particular implementation of <para></para>Matrix can improve performance by taking advantage of
 having access to the internal members.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.SimpleMatrixMathOperation.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.SimpleMatrixMathOperation.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.SimpleMatrixMathOperation.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.SimpleMatrixMathOperation.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.SimpleMatrixMathOperation.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.SimpleMatrixMathOperation.scaled(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.SimpleMatrixMathOperation.transpose(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.MatrixMathOperation">
			<summary>This interface defines some standard operations for generic matrices.
 An implementation of such provides a default implementation of certain matrix definitions.
 Moreover, it allows these definitions to change to another implementation easily.
 Note that the return type of the operations is the general <para></para>Matrix interface.
 An implementation can override these return types.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.MatrixMathOperation.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary><i>A<sub>1</sub> + A<sub>2</sub></i></summary>
			<param name="A1">a matrix</param>
			<param name="A2">a matrix</param>
			<returns>the sum of <i>A<sub>1</sub> and A<sub>2</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.MatrixMathOperation.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary><i>A<sub>1</sub> - A<sub>2</sub></i></summary>
			<param name="A1">a matrix</param>
			<param name="A2">a matrix</param>
			<returns>the difference between <i>A<sub>1</sub> and A<sub>2</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.MatrixMathOperation.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary><i>A<sub>1</sub> * A<sub>2</sub></i></summary>
			<param name="A1">a matrix</param>
			<param name="A2">a matrix</param>
			<returns>the product of <i>A<sub>1</sub> and A<sub>2</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.MatrixMathOperation.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary><i>A * v</i></summary>
			<param name="A">a matrix</param>
			<param name="v">a vector</param>
			<returns>the product of <i>A</i> and <i>v</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.MatrixMathOperation.scaled(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,System.Double)">
			<summary><i>c * A</i></summary>
			<param name="A">a matrix</param>
			<param name="c">a scalar</param>
			<returns><i>A</i> scaled by <i>c</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.MatrixMathOperation.transpose(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary>Get the transpose of <i>A</i>.</summary>
			<param name="A">a matrix</param>
			<returns>the transpose of <i>A</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.AutoParallelMatrixMathOperation">
			<summary>This class uses <para></para>ParallelMatrixMathOperation when the first input matrix argument&apos;s size
 is greater than the defined threshold; otherwise, it uses <para></para>SimpleMatrixMathOperation.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.AutoParallelMatrixMathOperation.DEFAULT_MATRIX_SIZE_THRESHOLD">
			<summary>The default matrix size threshold.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.AutoParallelMatrixMathOperation.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.AutoParallelMatrixMathOperation.#ctor(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.AutoParallelMatrixMathOperation.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.AutoParallelMatrixMathOperation.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.AutoParallelMatrixMathOperation.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.AutoParallelMatrixMathOperation.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.AutoParallelMatrixMathOperation.scaled(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.mathoperation.AutoParallelMatrixMathOperation.transpose(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixAccess)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector">
			<summary>A sparse vector stores only non-zero values.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.#ctor(System.Int32)">
			<summary>Constructs a sparse vector.</summary>
			<param name="size">the size of the vector</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.#ctor(System.Int32,System.Int32[],System.Double[])">
			<summary>Constructs a sparse vector.</summary>
			<param name="size">the size of the vector</param>
			<param name="indices">the indices of the non-zero values</param>
			<param name="values">the non-zero values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.#ctor(System.Int32,java.util.List)">
			<summary>Constructs a sparse vector.</summary>
			<param name="size">the size of the vector</param>
			<param name="entries">a list of sparse vector entries</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.#ctor(System.Double[])">
			<summary>Constructs a sparse vector from a <c>double[]</c>.</summary>
			<param name="v">a vector</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Constructs a sparse vector from a vector.</summary>
			<param name="v">a vector</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector)">
			<summary>Copy constructor.</summary>
			<param name="that">the vector to be copied</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.get(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.set(System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.iterator">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.add(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.minus(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.divide(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.add(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.minus(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.innerProduct(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.innerProduct(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.pow(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.scaled(com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.norm">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.norm(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.angle(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.toArray">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.nNonZeros">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.hashCode">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry">
			<summary>This is an entry in a <para></para>SparseVector.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry.#ctor(System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry.index">
			<summary>Gets the index of this entry in the sparse vector, counting from 1.</summary>
			<returns>the index</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry.value">
			<summary>Gets the value of this entry.</summary>
			<returns>the value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry.hashCode">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry.Comparator">
			<summary>This <c>Comparator</c> sorts the matrix coordinates first from top to
 bottom (rows), and then from left to right (columns).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry.Comparator.INSTANCE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry.Comparator.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry.Comparator.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry.Comparator.compare(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Entry)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Iterator">
			<summary>This wrapper class overrides the <para></para>java.util.Iterator#remove()
 method to throw an exception when called.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Iterator.hasNext">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Iterator.next">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector.Iterator.remove">
			<summary>Overridden to avoid the vector being altered.</summary>
			<exception cref="T:java.lang.UnsupportedOperationException">always; set the element to zero
                                       instead</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseStructure">
			<summary>This interface defines common operations on sparse structures such as sparse
 vector or sparse matrix.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseStructure.nNonZeros">
			<summary>Get the number of non-zero entries in the structure.</summary>
			<returns>the number of non-zero entries in the structure</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrixUtils">
			<summary>These are the utility functions for <para></para>SparseMatrix.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrixUtils.sortInRowColumnOrder(java.util.List,System.Int32,System.Int32,System.Boolean,System.Boolean)">
			<summary>Sorts a list of sparse matrix entries in row-column order in linear time. The returned array
 contains the start indices of all rows in the sorted entries. For example, <c>result[0]</c>
 contains the start index of the first row, <c>result[1]</c> contains the start index of the
 second row, etc. That means, the entries from <c>entries[result[k-1]]</c> to
 <c>entries[result[k] - 1]</c> are entries in row k.</summary>
			<param name="entries">the sparse matrix entries to be sorted</param>
			<param name="nRows">the number of rows in the matrix (or the maximum possible row index)</param>
			<param name="nCols">the number of columns in the matrix (or the maximum possible column
                       index)</param>
			<param name="checkRange"><c>true</c> if entry coordinates should be checked against range</param>
			<param name="checkDuplicate"><c>true</c> if duplicates are NOT allowed</param>
			<returns>the start indices of rows in the sorted entries</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrixUtils.sortInRowColumnOrder(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
			<summary>Sorts an array of sparse matrix entries in row-column order in linear time. The returned
 array contains the start indices of all rows in the sorted entries. For example,
 <c>result[0]</c> contains the start index of the first row, <c>result[1]</c> contains the
 start index of the second row, etc. That means, the entries from <c>entries[result[k-1]]</c>
 to <c>entries[result[k] - 1]</c> are entries in row k.</summary>
			<param name="entries">the sparse matrix entries to be sorted</param>
			<param name="nRows">the number of rows of the matrix (or the maximum possible row index)</param>
			<param name="nCols">the number of columns of the matrix (or the maximum possible column
                       index)</param>
			<param name="checkRange"><c>true</c> if entry coordinates should be checked against range</param>
			<param name="checkDuplicate"><c>true</c> if duplicates are NOT allowed</param>
			<returns>the start indices of rows in the sorted entries</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrixUtils.sortInRowOrder(java.util.List,System.Int32)">
			<summary>Sorts a list of sparse matrix entries in row order (column indices in the same row can be in
 arbitrary order) in linear time. The returned array contains the start indices of all rows
 in the sorted entries. For example, <c>result[0]</c> contains the start index of the first
 row, <c>result[1]</c> contains the start index of the second row, etc. That means, the
 entries from <c>entries[result[k-1]]</c> to <c>entries[result[k] - 1]</c> are entries in
 row k.</summary>
			<param name="entries">the sparse matrix entries to be sorted</param>
			<param name="nRows">the number of rows of the matrix (or the maximum row index)</param>
			<returns>the start indices of rows in the sorted entries</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrixUtils.sortInRowOrder(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry[],System.Int32)">
			<summary>Sorts an array of sparse matrix entries in row order (column indices in the same row can be
 in arbitrary order) in linear time. The returned array contains the start indices of all rows
 in the sorted entries. For example, <c>result[0]</c> contains the start index of the first
 row, <c>result[1]</c> contains the start index of the second row, etc. That means, the
 entries from <c>entries[result[k-1]]</c> to <c>entries[result[k] - 1]</c> are entries in
 row k.</summary>
			<param name="entries">the sparse matrix entries to be sorted</param>
			<param name="nRows">the number of rows of the matrix (or the maximum row index)</param>
			<returns>the start indices of rows in the sorted entries</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrixUtils.sortInColumnOrder(java.util.List,System.Int32)">
			<summary>Sorts a list of sparse matrix entries in column order (row indices in the same row can be in
 arbitrary order) in linear time. The returned array contains the start indices of all columns
 in the sorted entries. For example, <c>result[0]</c> contains the start index of the first
 column, <c>result[1]</c> contains the start index of the second column, etc. That means, the
 entries from <c>entries[result[k-1]]</c> to <c>entries[result[k] - 1]</c> are entries in
 column k.</summary>
			<param name="entries">the sparse matrix entries to be sorted</param>
			<param name="nCols">the number of columns of the matrix (or the maximum column index)</param>
			<returns>the start indices of columns in the sorted entries</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrixUtils.sortInColumnOrder(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry[],System.Int32)">
			<summary>Sorts an array of sparse matrix entries in column order (row indices in the same row can be
 in arbitrary order) in linear time. The returned array contains the start indices of all
 columns in the sorted entries. For example, <c>result[0]</c> contains the start index of the
 first column, <c>result[1]</c> contains the start index of the second column, etc. That
 means, the entries from <c>entries[result[k-1]]</c> to <c>entries[result[k] - 1]</c> are
 entries in column k.</summary>
			<param name="entries">the sparse matrix entries to be sorted</param>
			<param name="nCols">the number of columns of the matrix (or the maximum column index)</param>
			<returns>the start indices of columns in the sorted entries</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrixUtils.countEntriesInEachRow(java.util.List,System.Int32)">
			<summary>Counts the number of entries in each row.
 Note: Row index starts from 1, therefore the zeroth element in the returned array is always
 0.</summary>
			<param name="entries">the sparse matrix entries</param>
			<param name="nRows">the number of rows of the matrix (or the maximum row index)</param>
			<returns>the counts (i.e., <c>counts[1]</c> stores the number of entries in the first row)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrixUtils.countEntriesInEachColumn(java.util.List,System.Int32)">
			<summary>Counts the number of entries in each column.
 Note: Column index starts from 1, therefore the zeroth element in the returned array is
 always 0.</summary>
			<param name="entries">the sparse matrix entries</param>
			<param name="nCols">the number of columns of the matrix (or the maximum column index)</param>
			<returns>the counts (i.e., <c>counts[1]</c> stores the number of entries in the first column)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrixUtils.toString(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix)">
			<summary>Returns a string representation of a <para></para>SparseMatrix.</summary>
			<param name="A">the sparse matrix</param>
			<returns>the <para></para>String representation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrixUtils.equals(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix)">
			<summary>Checks if two <para></para>SparseMatrixs are equal.</summary>
			<param name="A">one sparse matrix</param>
			<param name="B">another sparse matrix</param>
			<returns><c>true</c> if <c>A</c> and <c>B</c> are equal</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix">
			<summary>A sparse matrix stores only non-zero values. When there are only a few non-zeros in a matrix,
 sparse matrix saves memory space for storing the matrix. In addition, the matrix operations based
 on sparse matrix are usually more efficient. The time complexities are proportional to the number
 of non-zero values instead of the dimension-squared of dense matrix.<para> See also: </para><a href="http://en.wikipedia.org/wiki/sparse_matrix"> Wikipedia: Sparse
 matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.getEntrytList">
			<summary>Exports the non-zero values in the matrix as a list of <para></para>Entrys. This is useful
 for converting between the different formats of <para></para>Entry. For example,
 <blockquote><code><c>
 // construct matrix using DOK
 DOKSparseMatrix dok = new DOKSparseMatrix(5, 5);
 // ... insert some values to DOK matrix
 // convert to CSR matrix for efficient matrix operations
 CSRSparseMatrix csr = new CSRSparseMatrix(5, 5, dok.getEntrytList());
 </c></code></blockquote></summary>
			<returns>the sparse entries</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry">
			<summary>This is a (non-zero) entry in a sparse matrix.
 <para/>
 This class is immutable.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry.coordinates">
			<summary>the coordinates of this entry</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry.value">
			<summary>the entry value</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.MatrixCoordinate,System.Double)">
			<summary>Construct a sparse entry in a sparse matrix.</summary>
			<param name="coordinates">the entry coordinates</param>
			<param name="value">the entry value</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry.hashCode">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry.TopLeftFirstComparator">
			<summary>This <c>Comparator</c> sorts the matrix coordinates first from top to
 bottom (rows), and then from left to right (columns).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry.TopLeftFirstComparator.INSTANCE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry.TopLeftFirstComparator.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry.TopLeftFirstComparator.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry.TopLeftFirstComparator.compare(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix.Entry)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.MatrixCoordinate">
			<summary>The location of a matrix entry is specified by a 2D coordinates <i>(i, j)</i>, where <i>i</i> and
 <i>j</i> are the row-index and column-index of the entry respectively.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.MatrixCoordinate.i">
			<summary>the row index</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.MatrixCoordinate.j">
			<summary>the column index</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.MatrixCoordinate.#ctor(System.Int32,System.Int32)">
			<summary>Construct a matrix coordinate specifying an entry location.</summary>
			<param name="i">the row index</param>
			<param name="j">the column index</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.MatrixCoordinate.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.MatrixCoordinate.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.MatrixCoordinate.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix">
			<summary>The list of lists (LIL) format for sparse matrix stores one list per row,
 where each entry stores a column index and value. Typically, these entries
 are kept sorted by column index for faster lookup. This is another format
 which is good for incremental matrix construction.<para> See also: </para><a href="http://en.wikipedia.org/wiki/sparse_matrix#list_of_lists_.28lil.29">
 Wikipedia: List of lists (LIL)</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.#ctor(System.Int32,System.Int32)">
			<summary>Construct a sparse matrix in LIL format.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[])">
			<summary>Construct a sparse matrix in LIL format.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="rowIndices">the row indices of the non-zeros values</param>
			<param name="columnIndices">the column indices of the non-zeros values</param>
			<param name="value">the non-zero values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.#ctor(System.Int32,System.Int32,java.util.List)">
			<summary>Construct a sparse matrix in LIL format by a list of non-zero entries.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="entries">the list of entries</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix)">
			<summary>Copy constructor.</summary>
			<param name="that">the matrix to be copied</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.getEntrytList">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.t">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.toDense">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.nNonZeros">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.LILSparseMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix">
			<summary>The Dictionary Of Key (DOK) format for sparse matrix uses the coordinates of
 non-zero entries in the matrix as keys. The non-zero values are hashed such
 that adding, removing, retrieving values can be done in constant time. This
 data structure is efficient for incremental construction but poor for
 iterating non-zero elements in a matrix.<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/sparse_matrix#dictionary_of_keys_.28dok.29">
 Wikipedia: Dictionary of keys (DOK)</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.#ctor(System.Int32,System.Int32)">
			<summary>Construct a sparse matrix in DOK format.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[])">
			<summary>Construct a sparse matrix in DOK format.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="rowIndices">the row indices of the non-zeros values</param>
			<param name="columnIndices">the column indices of the non-zeros values</param>
			<param name="value">the non-zero values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.#ctor(System.Int32,System.Int32,java.util.List)">
			<summary>Construct a sparse matrix in DOK format by a list of non-zero entries.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="entries">the entry list</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix)">
			<summary>Copy constructor.</summary>
			<param name="that">the matrix to be copied</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.getEntrytList">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.t">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.toDense">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.nNonZeros">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.DOKSparseMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix">
			<summary>The Compressed Sparse Row (CSR) format for sparse matrix has this representation:
 <c>(value, col_ind, row_ptr)</c>. Three arrays are used to represent a sparse matrix:
 <c>value</c> stores all the non-zero entries of the matrix from left to right, top to bottom.
 <c>col_ind</c> is the column indices corresponding to the <c>values</c>. <c>row_ptr</c> is the
 list of <c>values</c> indices where each row starts. For example:
 \[
 \begin{bmatrix}
 1 &amp; 2 &amp; 0 &amp; 0\\
 0 &amp; 3 &amp; 9 &amp; 0\\
 0 &amp; 1 &amp; 4 &amp; 0
 \end{bmatrix}
 \]
 <blockquote><code><c>
 value   = [ 1 2 3 9 1 4 ]
 col_ind = [ 0 1 1 2 1 2 ]
 row_ptr = [ 0 2 4 6 ]
 </c></code></blockquote>
 Note: <c>(row_ptr[i] - row_ptr[i - 1])</c> is the number of non-zero entries in row <i>i</i>.
 <para/>
 This format is very inefficient for incremental construction or changes using
 <para></para>#set(int, int, double), but efficient for matrix computation.<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/sparse_matrix#compressed_sparse_row_.28csr_or_crs.29">
 Wikipedia: Compressed sparse row (CSR or CRS)</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.#ctor(System.Int32,System.Int32)">
			<summary>Constructs a sparse matrix in CSR format.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[])">
			<summary>Constructs a sparse matrix in CSR format.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="rowIndices">the row indices of the non-zeros values</param>
			<param name="columnIndices">the column indices of the non-zeros values</param>
			<param name="values">the non-zero values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.#ctor(System.Int32,System.Int32,java.util.List)">
			<summary>Constructs a sparse matrix in CSR format by a list of non-zero entries.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="entries">the list of entries</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.#ctor(System.Int32,System.Int32,java.util.List,System.Boolean)">
			<summary>Constructs a sparse matrix in CSR format by a list of non-zero entries.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="entries">the list of entries</param>
			<param name="areEntriesSorted"><c>true</c> if the list of entries are sorted in row-major order</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs a sparse matrix from a matrix.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix)">
			<summary>Copy constructor.</summary>
			<param name="that">the matrix to be copied</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.getEntrytList">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.t">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.toDense">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.nNonZeros">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.CSRSparseMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.IterativeLinearSystemSolver">
			<summary>An iterative method for solving an N-by-N (or non-square) linear system
 <i>Ax = b</i> involves a sequence of matrix-vector multiplications.
 Starting with an initial guess of the solution, each iteration returns a new
 estimate of the solution. It is hoped that the estimates converge
 to a satisfactory solution (within a tolerance) after <i>k</i> iterations.
 For a dense matrix <i>A</i>, each iteration takes <i>O(N<sup>2</sup>)</i>
 operations. An iterative method takes <i>O(kN<sup>2</sup>)</i> operations to
 converge. For a sparse system, matrix-vector multiplication takes only
 <i>O(nNonZeros)</i> where <i>nNonZeros</i> is the number of non-zeros in the
 sparse matrix. Therefore, an iterative method can be much faster than a
 traditional direct method of solving a linear system such as taking inverse.
 An iterative method using sparse matrices is much faster than one using dense
 matrices.
 <para/>
 Here are some guidelines for choosing an iterative solver of a sparse system.

 For Hermitian problems, if the system is positive definite,
 use <para></para>ConjugateGradientSolver CG or
 <para></para>MinimalResidualSolver MINRES, otherwise use only MINRES.
 To avoid doing inner products in CG or MINRES, we may choose the stationary
 methods such as <para></para>JacobiSolver Jacobi,
 <para></para>GaussSeidelSolver Gauss-Seidel,
 <para></para>SuccessiveOverrelaxationSolver SOR, or
 <para></para>SymmetricSuccessiveOverrelaxationSolver SSOR.
 These methods saves computation costs in each iteration but the number of
 iterations may increase unless there is a good preconditioner.

 For non-Hermitian problems, the choice is not so easy.
 If matrix-vector multiplication is very expensive,
 <para></para>GeneralizedMinimalResidualSolver GMRES is probably the best
 choice because it performs the fewest multiplications.
 The second best alternatives are <para></para>QuasiMinimalResidualSolver QMR
 or <para></para>BiconjugateGradientSolver BiCG.
 QMR is numerically more stable than BiCG.

 When the transpose of a matrix is not available, there are transpose-free
 methods such as
 <para></para>ConjugateGradientSquaredSolver CGS or
 <para></para>BiconjugateGradientStabilizedSolver BiCGSTAB.

 For non-square systems, there are CG methods for solving over-determined
 systems such as
 <para></para>ConjugateGradientNormalResidualSolver CGNR, and
 under-determined systems such as <para></para>ConjugateGradientNormalErrorSolver CGNE.
 <para/>
 The use of <para></para>Preconditioner can improve the rate of convergence of an
 iterative method. A preconditioner transforms a linear system into one that
 is equivalent in the sense that it has the same solution. The transformed
 system has more favorable spectral properties which affect convergence rate.

 In particular, a preconditioner <i>M</i> approximates the coefficient
 matrix <i>A</i>, and the transformed system is easier to solve. For example,
 <blockquote><i>
 M<sup>-1</sup>Ax = M<sup>-1</sup>b
 </i></blockquote>
 has the same solution as the original system <i>Ax = b</i>. The spectral
 properties of its coefficient matrix <i>M<sup>-1</sup>A</i> may be more
 favorable.
 Another way of preconditioning a system is
 <blockquote><i>
 M<sub>1</sub><sup>-1</sup>AM<sub>2</sub><sup>-1</sup>(M<sub>2</sub>x) =
 M<sub>1</sub><sup>-1</sup>b
 </i></blockquote>
 The matrices <i>M<sub>1</sub></i> and <i>M<sub>2</sub></i> are called left-
 and right preconditioners respectively.
 There are 3 kinds of preconditioning: left, right, or split.
 Left-preconditioning leaves <i>M<sub>2</sub></i> as
 <para></para>IdentityPreconditioner. Similarly, right-preconditioning leaves
 <i>M<sub>1</sub></i> as
 <para></para>IdentityPreconditioner.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.IterativeLinearSystemSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary>Solves iteratively
 <blockquote>
 <i>Ax = b</i>
 </blockquote>
 until the solution converges, i.e., the norm of residual
 (<i>b - Ax</i>) is less than or equal to the threshold.</summary>
			<param name="problem">a system of linear equations</param>
			<param name="monitor">an iteration monitor</param>
			<returns>an (approximate) solution to the linear problem</returns>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.ConvergenceFailure">if the algorithm fails to converge</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.IterativeLinearSystemSolver.Solution">
			<summary>This is the solution to a system of linear equations using an iterative
 solver.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.IterativeLinearSystemSolver.Solution.step">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.IterativeLinearSystemSolver.Solution.search(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.ConvergenceFailure">
			<summary>This exception is thrown by
 <para></para>IterativeLinearSystemSolver#solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem, com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)
 when the iterative algorithm detects a breakdown or fails to converge.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.ConvergenceFailure.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.ConvergenceFailure.Reason)">
			<summary>Construct an exception with reason.</summary>
			<param name="reason">the reason for the failure</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.ConvergenceFailure.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.ConvergenceFailure.Reason,System.String)">
			<summary>Construct an exception with reason and error message.</summary>
			<param name="reason">the reason for the failure</param>
			<param name="message">the error message</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.ConvergenceFailure.getReason">
			<summary>Get the reason for the convergence failure.</summary>
			<returns>the failure reason</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.ConvergenceFailure.Reason">
			<summary>the reasons for the convergence failure</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.ConvergenceFailure.Reason.BREAKDOWN">
			<summary>Thrown when the iterative algorithm fails to proceed during its
 iterations, due to, for example, division-by-zero.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.ConvergenceFailure.Reason.MAX_ITERATIONS_EXCEEDED">
			<summary>Thrown if the iterative algorithm fails to converge to a solution
 within a specified tolerance after the specified maximum number
 of iterations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.ConvergenceFailure.Reason.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.ConvergenceFailure.Reason.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.SteepestDescentSolver">
			<summary>The Steepest Descent method (SDM) solves a symmetric n-by-n linear system.
 The convergence is guaranteed if <i>A</i> is symmetric positive definite.

 <para/>
 Only left preconditioning is supported in this implementation.
 The preconditioner must be symmetric and positive definite.<para> See also: </para><a href="http://en.wikipedia.org/wiki/gradient_descent">Wikipedia: Gradient descent</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.SteepestDescentSolver.DEFAULT_RESIDUAL_REFRESH_RATE">
			<summary>The algorithm recomputes the residual as <i>b - Ax<sub>i</sub></i> once per this number of iterations</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.SteepestDescentSolver.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Steepest Descent method (SDM) solver.</summary>
			<param name="leftPreconditionerFactory">constructs a new left preconditioner</param>
			<param name="residualRefreshRate">the number of iterations before the next refresh</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.SteepestDescentSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Steepest Descent method (SDM) solver.</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.SteepestDescentSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.SteepestDescentSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.QuasiMinimalResidualSolver">
			<summary>The Quasi-Minimal Residual method (QMR) is useful for solving a non-symmetric n-by-n linear
 system. It applies a least-squares solve and update to the
 <para></para>BiconjugateGradientSolver BiCG residuals, thereby smoothing out the irregular
 convergence behavior of BiCG. Also, QMR largely avoids the breakdown that can occur in BiCG. On
 the other hand, it does not effect a true minimization of either the error or the residual. While
 it converges smoothly, it does not essentially improve on the BiCG in terms of the number of
 iteration steps.
 <para/>
 This implementation does not have a look ahead mechanism.
 This implementation uses the split preconditioning (<i>M = M<sub>1</sub>M<sub>2</sub></i>).<para> See also: </para>&quot;Yousef Saad, &quot;Quasi-Minimal Residual Algorithm,&quot; in <i>Iterative Methods for Sparse Linear
 Systems</i>, 2nd ed. 2000, ch. 7, sec. 7.3.2, p. 211-212.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.QuasiMinimalResidualSolver.DEFAULT_RESIDUAL_REFRESH_RATE">
			<summary>The algorithm recomputes the residual as <i>b - Ax<sub>i</sub></i> once per this number of
 iterations</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.QuasiMinimalResidualSolver.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Quasi-Minimal Residual (QMR) solver.</summary>
			<param name="leftPreconditionerFactory">constructs a new left preconditioner</param>
			<param name="rightPreconditionerFactory">constructs a new right preconditioner</param>
			<param name="residualRefreshRate">the number of iterations before the next refresh</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.QuasiMinimalResidualSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Quasi-Minimal Residual (QMR) solver.</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.QuasiMinimalResidualSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.QuasiMinimalResidualSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.MinimalResidualSolver">
			<summary>The Minimal Residual method (MINRES) is useful for solving a symmetric n-by-n linear system
 (possibly indefinite or singular). When the coefficient matrix <i>A</i> is Hermitian, the Arnoldi
 algorithm used in <para></para>GeneralizedMinimalResidualSolver GMRES can be simplified to a
 3-term recurrence known as Lanczos algorithm. Thus, an approximate solution can be computed
 without saving all the orthonormal basis vectors generated. When <i>A</i> is singular, MINRES
 returns a least-squares solution with small <i>|Ar|</i> (where <i>r = b - Ax</i>).
 <para/>
 Only left preconditioning is supported in this implementation.<para> See also: </para>&quot;Anne Greenbaum, &quot;Algorithm 4P,&quot; Iterative methods for solving linear systems, ch.8,
 pp.122.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.MinimalResidualSolver.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a MINRES solver.</summary>
			<param name="leftPreconditionerFactory">constructs a new left preconditioner</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.MinimalResidualSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a MINRES solver.</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.MinimalResidualSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.MinimalResidualSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.GeneralizedMinimalResidualSolver">
			<summary>The Generalized Minimal Residual method (GMRES) is useful for solving a non-symmetric n-by-n
 linear system. It computes a sequence of orthogonal vectors (like
 <para></para>MinimalResidualSolver MINRES), and combines these through a least-squares solve and
 update. However, unlike MINRES (and <para></para>ConjugateGradientSolver CG) it requires storing
 the whole sequence, so that a large amount of storage is needed. For this reason, a restarted
 version of this method is often used. In a restarted version, computation and storage costs are
 limited by specifying a fixed number of vectors to be generated.
 <para/>
 This implementation is a restarted version. In addition, it uses a Givens rotation to transform
 the intermediate Hessenberg matrix into an upper triangular matrix, such that convergence can be
 determined as soon as the residual norm at each sub-step is small enough. Only left
 preconditioning is supported.<para> See also: </para>&quot;Yousef Saad, &quot;GMRES,&quot; in <i>Iterative Methods for Sparse Linear Systems</i>, 2nd ed. 2000,
 ch. 6, sec. 6.5, p. 157-172.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.GeneralizedMinimalResidualSolver.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a GMRES solver with restarts.</summary>
			<param name="leftPreconditionerFactory">constructs a new left preconditioner</param>
			<param name="m">the solver restarts every <c>m</c> iterations;
                                  Practically, as <c>m</c> increases, the computational
                                  cost increases at least by <i>O(m<sup>2</sup>)n</i> because of the
                                  Gram-Schmidt orthogonalization. The memory cost increases by <i>O(mn)</i>.</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.GeneralizedMinimalResidualSolver.#ctor(System.Int32,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a GMRES solver with restarts.</summary>
			<param name="m">the solver restarts every <c>m</c> iterations;
                     Practically, as <c>m</c> increases, the computational
                     cost increases at least by <i>O(m<sup>2</sup>)n</i> because of the
                     Gram-Schmidt orthogonalization. The memory cost increases by <i>O(mn)</i>.</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.GeneralizedMinimalResidualSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a full GMRES solver.</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.GeneralizedMinimalResidualSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.GeneralizedMinimalResidualSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.GeneralizedConjugateResidualSolver">
			<summary>The Generalized Conjugate Residual method (GCR) is useful for solving
 a non-symmetric n-by-n linear system. GCR computes the next
 Krylov basis vector as a linear combination of the current residual and all
 previous basis vectors.
 <para/>
 This implementation is a restarted version of GCR.
 Only left preconditioning is supported.<para> See also: </para>&quot;Yousef Saad, &quot;GCR, ORTHOMIN, and ORTHODIR,&quot; in <i>Iterative Methods for Sparse Linear Systems</i>, 2nd ed. 2000, ch. 6, sec. 6.9, p. 182-184.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.GeneralizedConjugateResidualSolver.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a GCR solver with restarts.</summary>
			<param name="leftPreconditionerFactory">constructs a new left preconditioner</param>
			<param name="m">the solver restarts every <c>m</c> iterations</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.GeneralizedConjugateResidualSolver.#ctor(System.Int32,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a GCR solver with restarts.</summary>
			<param name="m">the solver restarts every <c>m</c> iterations</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.GeneralizedConjugateResidualSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a full GCR solver.</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.GeneralizedConjugateResidualSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.GeneralizedConjugateResidualSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientSquaredSolver">
			<summary>The Conjugate Gradient Squared method (CGS) is useful for solving
 a non-symmetric n-by-n linear system. This method is a variant of
 <para></para>BiconjugateGradientSolver BiCG that applies the updating
 operations for the <i>A</i>-sequence and the <i>A<sup>t</sup></i>-sequence
 both to the same vectors. Ideally, this would double the convergence rate,
 but in practice convergence may be much more irregular than for BiCG.
 This may sometimes lead to unreliable results.

 A practical advantage is that the CGS method does not need the multiplications
 with the transpose of the coefficient matrix. In some applications of CG
 methods, <i>A</i> is available only through some approximations but not
 explicitly. In such situations, the transpose of <i>A</i>, i.e.,
 <i>A<sup>t</sup></i>, is usually not available.

 In addition, the rounding errors in the CGS method tend to be more damaging than in the
 standard BiCG algorithm.

 <para/>
 Only left preconditioning is supported in this implementation.<para> See also: </para>&quot;Yousef Saad, “Conjugate Gradient Squared,” in <i>Iterative Methods for Sparse Linear Systems</i>, 2nd ed. 2000, ch. 7, sec. 7.4.1, p. 215-216.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientSquaredSolver.DEFAULT_RESIDUAL_REFRESH_RATE">
			<summary>The algorithm recomputes the residual as <i>b - Ax<sub>i</sub></i> once per this number of iterations</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientSquaredSolver.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Conjugate Gradient Squared (CGS) solver.</summary>
			<param name="leftPreconditionerFactory">constructs a new left preconditioner</param>
			<param name="residualRefreshRate">the number of iterations before the next refresh</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientSquaredSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Conjugate Gradient Squared (CGS) solver.</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientSquaredSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientSquaredSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientSolver">
			<summary>The Conjugate Gradient method (CG) is useful for solving a symmetric n-by-n
 linear system. The method derives its name from the fact that it
 generates a sequence of conjugate (or orthogonal) vectors. These vectors are
 the residuals of the iterates. They are also the gradients of a quadratic
 function, the minimization of which is equivalent to solving the linear
 system. CG is an extremely effective method when the coefficient matrix is
 symmetric positive definite as storage for only a limited number of
 vectors is required. For a coefficient matrix that is not
 symmetric, not positive-definite, and even not square, there are solvers using the CG method.
 For example, <para></para>ConjugateGradientNormalResidualSolver CGNR solves an over-determined system;
 <para></para>ConjugateGradientNormalErrorSolver CGNE solves an under-determined system.
 <para/>
 If <i>A</i> is symmetric, positive-definite and square, the CG method solves
 <blockquote><i>
 Ax = b
 </i></blockquote>
 Note that if the coefficient matrix <i>A</i> passed into the algorithm is not
 symmetric positive-definite, the algorithm behaves unexpectedly.
 <para/>
 Only left preconditioning is supported in this implementation.
 The preconditioner must be symmetric and positive definite.<para> See also: </para>&quot;Yousef Saad, &quot;The Conjugate Gradient Algorithm,&quot; in <i>Iterative Methods for Sparse Linear Systems</i>, 2nd ed. 2000, ch. 6, sec. 6.7, p. 174-181.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientSolver.DEFAULT_RESIDUAL_REFRESH_RATE">
			<summary>The algorithm recomputes the residual as <i>b - Ax<sub>i</sub></i> once per this number of iterations</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientSolver.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Conjugate Gradient (CG) solver.</summary>
			<param name="leftPreconditionerFactory">constructs a new left preconditioner</param>
			<param name="residualRefreshRate">the number of iterations before the next refresh</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Conjugate Gradient (CG) solver.</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientNormalResidualSolver">
			<summary>For an under-determined system of linear equations, <i>Ax = b</i>, or
 when the coefficient matrix <i>A</i> is non-symmetric and nonsingular,
 the normal equation matrix <i>AA<sup>t</sup></i> is symmetric and
 positive definite, and hence CG is applicable.
 Thus, the Conjugate Gradient Normal Residual method (CGNR) applies
 the <para></para>ConjugateGradientSolver Conjugate Gradient method (CG)
 to the normal equation
 <blockquote><i>
 (A<sup>t</sup>A)x = A<sup>t</sup>b
 </i></blockquote>
 The equivalent symmetric system has the form:
 \[
 \begin{bmatrix}
 0 &amp; A\\
 A&apos; &amp; 0
 \end{bmatrix} \times
 \begin{bmatrix}
 Ax\\
 x
 \end{bmatrix} =
 \begin{bmatrix}
 b\\
 A&apos;b
 \end{bmatrix}
 \]
 The convergence may be slow
 as the spectrum of <i>AA<sup>t</sup></i> will be less favorable than the
 spectrum of <i>A</i>.
 <para/>
 Only left preconditioning is supported in this implementation.<para> See also: </para>&quot;Yousef Saad, &quot;Preconditioned CG for the Normal Equations,&quot; in <i>Iterative Methods for Sparse Linear Systems</i>, 2nd ed. 2000, ch. 9, sec. 9.5, p. 259-260.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientNormalResidualSolver.DEFAULT_RESIDUAL_REFRESH_RATE">
			<summary>The algorithm recomputes the residual as <i>b - Ax<sub>i</sub></i> once per this number of iterations</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientNormalResidualSolver.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Conjugate Gradient Normal Residual method (CGNR) solver.</summary>
			<param name="leftPreconditionerFactory">constructs a new left preconditioner</param>
			<param name="residualRefreshRate">the number of iterations before the next refresh</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientNormalResidualSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Conjugate Gradient Normal Residual method (CGNR) solver.</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientNormalResidualSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientNormalResidualSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientNormalErrorSolver">
			<summary>For an under-determined system of linear equations, <i>Ax = b</i>, or
 when the coefficient matrix <i>A</i> is non-symmetric and nonsingular,
 the normal equation matrix <i>AA<sup>t</sup></i> is symmetric and
 positive definite, and hence CG is applicable.
 Thus, the Conjugate Gradient Normal Error method (CGNE) applies
 the <para></para>ConjugateGradientSolver Conjugate Gradient method (CG)
 to the normal equation
 <blockquote><i>
 (AA<sup>t</sup>)y = b
 </i></blockquote>
 for <i>y</i>, and then computes the solution
 <blockquote><i>
 x = A<sup>t</sup>y
 </i></blockquote>
 The equivalent symmetric system has the form:
 \[
 \begin{bmatrix}
 I &amp; A\\
 A&apos; &amp; 0
 \end{bmatrix} \times
 \begin{bmatrix}
 r\\
 x
 \end{bmatrix} =
 \begin{bmatrix}
 b\\
 0
 \end{bmatrix}
 \]
 with <i>r = b - Ax</i> arising from the standard necessary conditions
 satisfied by the solution of the constrained optimization problem,
 \[
 \min \left \| r - b \right \|^2 \textup{ s.t., } A&apos;r = 0
 \]
 The convergence may be slow
 as the spectrum of <i>AA<sup>t</sup></i> will be less favorable than the
 spectrum of <i>A</i>.
 <para/>
 Only left preconditioning is supported in this implementation.<para> See also: </para>&quot;Yousef Saad, &quot;Preconditioned CG for the Normal Equations,&quot; in <i>Iterative Methods for Sparse Linear Systems</i>, 2nd ed. 2000, ch. 9, sec. 9.5, p. 259-260.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientNormalErrorSolver.DEFAULT_RESIDUAL_REFRESH_RATE">
			<summary>The algorithm recomputes the residual as <i>b - Ax<sub>i</sub></i> once per this number of iterations</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientNormalErrorSolver.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Conjugate Gradient Normal Error (CGNE) solver.</summary>
			<param name="leftPreconditionerFactory">constructs a new left preconditioner</param>
			<param name="residualRefreshRate">the number of iterations before the next refresh</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientNormalErrorSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Conjugate Gradient Normal Error (CGNE) solver.</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientNormalErrorSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.ConjugateGradientNormalErrorSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.BiconjugateGradientStabilizedSolver">
			<summary>The Biconjugate Gradient Stabilized (BiCGSTAB) method is useful for solving
 non-symmetric n-by-n linear systems.
 Like <para></para>ConjugateGradientSquaredSolver CGS, this algorithm is a
 transpose-free variant of
 <para></para>BiconjugateGradientSolver BiCG, but uses a different
 update for the <i>A<sup>t</sup></i>-sequence to obtain a smoother
 convergence than CGS does.
 <para/>
 Only left preconditioning is supported in this implementation.<para> See also: </para>&quot;Yousef Saad, &quot;BICGSTAB,&quot; in <i>Iterative Methods for Sparse Linear Systems</i>, 2nd ed. 2000, ch. 7, sec. 7.4.2, p. 216-219.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.BiconjugateGradientStabilizedSolver.DEFAULT_RESIDUAL_REFRESH_RATE">
			<summary>The algorithm recomputes the residual as <i>b - Ax<sub>i</sub></i> once per this number of iterations</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.BiconjugateGradientStabilizedSolver.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Biconjugate Gradient Stabilized solver (BiCGSTAB) .</summary>
			<param name="leftPreconditionerFactory">constructs a new left preconditioner</param>
			<param name="residualRefreshRate">the number of iterations before the next refresh</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.BiconjugateGradientStabilizedSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Biconjugate Gradient Stabilized solver (BiCGSTAB) .</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.BiconjugateGradientStabilizedSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.BiconjugateGradientStabilizedSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.BiconjugateGradientSolver">
			<summary>The Biconjugate Gradient method (BiCG) is useful for solving non-symmetric
 n-by-n linear systems. It generates two CG-like sequences of vectors, one
 based on a system with the original coefficient matrix <i>A</i>, and one on
 <i>A<sup>t</sup></i>. They are made
 mutually orthogonal, or &quot;bi-orthogonal&quot;. This method is useful when the matrix is non-symmetric and nonsingular.
 However, convergence may be irregular, and there is a possibility that the
 method will break down. BiCG , like
 <para></para>ConjugateGradientSolver CG, uses limited
 storage. It requires a multiplication with the coefficient
 matrix and with its transpose at each iteration.
 <para/>
 Only left preconditioning is supported in this implementation.<para> See also: </para>&quot;Yousef Saad, &quot;The Biconjugate Gradient Algorithm,&quot; in <i>Iterative Methods for Sparse Linear Systems</i>, 2nd ed. 2000, ch. 7, sec. 7.3.1, p. 210-211.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.BiconjugateGradientSolver.DEFAULT_RESIDUAL_REFRESH_RATE">
			<summary>The algorithm recomputes the residual as <i>b - Ax<sub>i</sub></i> once
 per this number of iterations</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.BiconjugateGradientSolver.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Biconjugate Gradient (BiCG) solver.</summary>
			<param name="leftPreconditionerFactory">constructs a new left preconditioner</param>
			<param name="residualRefreshRate">the number of iterations before the next refresh</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.BiconjugateGradientSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Biconjugate Gradient (BiCG) solver.</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.BiconjugateGradientSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.nonstationary.BiconjugateGradientSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.SSORPreconditioner">
			<summary>SSOR preconditioner is derived from a symmetric coefficient matrix <i>A</i>
 which is decomposed as
 <blockquote><i>
 A = D + L + L<sup>t</sup>
 </i></blockquote>
 The SSOR preconditioning matrix is defined as
 <blockquote><i>
 M = (D + L)D<sup>-1</sup>(D + L)<sup>t</sup>
 </i></blockquote>
 or, parameterized by <i>&#969;</i>
 <blockquote><i>
 M(&#969;) = (1/(2 - &#969;))(D / &#969; + L)(D / &#969;)<sup>-1</sup>(D / &#969; + L)<sup>t</sup>
 </i></blockquote>

 <para/>
 The optimal <i>&#969;</i> reduces the number of iterations to
 a lower order. In practice, however, the spectral information for computing
 the optimal <i>&#969;</i> is expensive to obtain.<para> See also: </para>SymmetricSuccessiveOverrelaxationSolver</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.SSORPreconditioner.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Construct an SSOR preconditioner with a symmetric coefficient matrix.</summary>
			<param name="A">a symmetric coefficient matrix</param>
			<param name="omega">an extrapolation factor</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.SSORPreconditioner.solve(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Solve <i>Mz = x</i> using this SSOR preconditioner.</summary>
			<param name="x">a vector</param>
			<returns><i>M<sup>-1</sup>x</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.SSORPreconditioner.transposeSolve(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary><i>M<sup>t</sup>x = M<sup>-1</sup>x</i> as <i>M</i> is symmetric.</summary>
			<param name="x">a vector</param>
			<returns><c>solve(x)</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory">
			<summary>This constructs a new instance of <para></para>Preconditioner for a coefficient matrix.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.PreconditionerFactory.newInstance(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a new instance of <para></para>Preconditioner for a coefficient matrix.</summary>
			<param name="A">a coefficient matrix</param>
			<returns>a new instance of <para></para>Preconditioner</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.Preconditioner">
			<summary>Preconditioning reduces the condition number of the
 coefficient matrix of a linear system to accelerate the convergence
 when the system is solved by an iterative method.<para> See also: </para><a href="http://en.wikipedia.org/wiki/preconditioner">Wikipedia: Preconditioner</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.Preconditioner.solve(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Solve <i>Mv = x</i>, where <i>M</i> is the preconditioner matrix.
 In effect, this method returns <i>v</i> as the product
 <i>M<sup>-1</sup>x</i>.</summary>
			<param name="x">a vector</param>
			<returns><i>M<sup>-1</sup>x</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.Preconditioner.transposeSolve(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Solve <i>M<sup>t</sup>v = x</i>, where <i>M</i> is the preconditioner
 matrix.
 In effect, this method returns <i>v</i> as the product
 <i>M<sup>-t</sup>x</i>.
 This method is usually called by a solver
 which solves
 a dual system <i>A<sup>t</sup>x<sup>*</sup> = b<sup>*</sup></i>.
 <para></para>BiconjugateGradientSolver is an example of such a solver.</summary>
			<param name="x">a vector</param>
			<returns><i>M<sup>-t</sup>x</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.JacobiPreconditioner">
			<summary>The Jacobi (or diagonal) preconditioner is one of the simplest forms of
 preconditioning, such that the preconditioner is the diagonal of
 the coefficient matrix, i.e., <i>P = diag(A)</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.JacobiPreconditioner.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a Jacobi preconditioner.</summary>
			<param name="A">a coefficient matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.JacobiPreconditioner.solve(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Return <i>P<sup>-1</sup>x</i>, where <i>P</i> is the diagonal matrix
 of <i>A</i>. The output vector <i>v</i>
 has entries:
 <blockquote><i>
 v<sub>i</sub> = x<sub>i</sub> / A<sub>i,i</sub>
 </i></blockquote></summary>
			<param name="x">a vector</param>
			<returns><i>P<sup>-1</sup>x</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.JacobiPreconditioner.transposeSolve(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary><i>P<sup>t</sup> = P<sup>-1</sup></i> for Jacobi preconditioner.</summary>
			<param name="x">a vector</param>
			<returns><i>P<sup>-1</sup>x</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.IdentityPreconditioner">
			<summary>This identity preconditioner is used when no preconditioning is applied. This
 is used as the default preconditioner for an unpreconditioned linear system
 solver.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.IdentityPreconditioner.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.IdentityPreconditioner.solve(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Return the input vector <i>x</i>.</summary>
			<param name="x">a vector</param>
			<returns>x the input vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.preconditioner.IdentityPreconditioner.transposeSolve(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Return the input vector <i>x</i>.</summary>
			<param name="x">a vector</param>
			<returns>x the input vector</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.SymmetricSuccessiveOverrelaxationSolver">
			<summary>The Symmetric Successive Overrelaxation method (SSOR) is like
 <para></para>SuccessiveOverrelaxationSolver SOR, but it performs in each
 iteration one forward sweep followed by one backward sweep.
 With an optimal value of <i>&#969;</i>, the convergence rate of SSOR is
 usually slower than that of SOR with an optimal <i>&#969;</i>.
 <para/>
 This implementation does not support preconditioning.<para> See also: </para><a href="http://en.wikipedia.org/wiki/successive_over-relaxation_method">Wikipedia:
 Successive over-relaxation method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.SymmetricSuccessiveOverrelaxationSolver.#ctor(System.Double,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a SSOR solver with the extrapolation factor <i>&#969;</i>.<para> See also: </para>SuccessiveOverrelaxationSolver#SuccessiveOverrelaxationSolver(double, int,
 com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)</summary>
			<param name="omega">the extrapolation factor</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.SymmetricSuccessiveOverrelaxationSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.SymmetricSuccessiveOverrelaxationSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.SuccessiveOverrelaxationSolver">
			<summary>The Successive Overrelaxation method (SOR), is devised by applying
 extrapolation to the <para></para>GaussSeidelSolver Gauss-Seidel method.
 This extrapolation takes the form of a weighted average between the previous
 iterate and the computed Gauss-Seidel iterate successively for each component.
 If the weight <i>&#969;</i> is chosen optimally, SOR may converge faster than
 the Gauss-Seidel method by an order of magnitude.
 If the coefficient matrix <i>A</i> is symmetric positive definite, SOR is
 guaranteed to converge for any value of <i>&#969;</i> between 0 and 2,
 though the choice of <i>&#969;</i> can significantly affect the rate of
 convergence.
 In principle, given the spectral radius <i>&#961;</i> of the Jacobi iteration
 matrix, one can determine a priori the theoretically optimal value of
 <i>&#969;</i> for SOR:
 <blockquote><i>
 &#969;<sub>opt</sub> = 2 / (1 + sqrt(1 - &#961;<sup>2</sup>))
 </i></blockquote>
 This is seldom done, since calculating the spectral radius of the Jacobi
 matrix requires an impractical amount of computation. However, relatively
 inexpensive rough estimates of <i>&#961;</i> can yield reasonable estimates for
 the optimal value of <i>&#969;</i>.
 <para/>
 This implementation does not support preconditioning.<para> See also: </para><a href="http://en.wikipedia.org/wiki/successive_over-relaxation_method">Wikipedia: Successive over-relaxation method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.SuccessiveOverrelaxationSolver.#ctor(System.Double,System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a SOR solver with the extrapolation factor <i>&#969;</i>.

 Usually, <i>&#969;</i> is chosen inside the interval (0, 2).
 It is shown that SOR fails to converge if
 <i>&#969;</i> is outside the interval (0, 2).
 Technically, if <i>&#969;</i> is within (0, 1), the method becomes
 under-relaxation.
 If <i>&#969;</i> equals to 1, SOR simplifies to the
 <para></para>GaussSeidelSolver Gauss-Seidel method.</summary>
			<param name="omega">the extrapolation factor</param>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.SuccessiveOverrelaxationSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.SuccessiveOverrelaxationSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.SORSweep">
			<summary>This is a building block for
 <para></para>SuccessiveOverrelaxationSolver SOR and
 <para></para>SymmetricSuccessiveOverrelaxationSolver SSOR
 to perform the forward or backward sweep. That is, solving the <i>n</i> equations in
 <i>Ax = b</i> sequentially (forward or backward), while using the updated
 components of <i>x</i> as soon as they are available.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.SORSweep.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Construct an instance to perform forward or backward sweep for a linear
 system <i>Ax = b</i>.</summary>
			<param name="A">the coefficient matrix</param>
			<param name="b">a vector</param>
			<param name="omega">the extrapolation factor</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.SORSweep.forward(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Perform a forward sweep.</summary>
			<param name="x">the original iterate</param>
			<returns>the next iterate</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.SORSweep.backward(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Perform a backward sweep.</summary>
			<param name="x">the original iterate</param>
			<returns>the next iterate</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.JacobiSolver">
			<summary>The Jacobi method solves sequentially <i>n</i> equations in a linear
 system <i>Ax = b</i> in isolation in each iteration.
 For the <i>i</i>-th equation,
 it solves for the value <i>x<sub>i</sub></i> while assuming the other
 <i>x</i>&apos;s remain fixed. The convergence is slow.
 <para/>
 This implementation does not support preconditioning.<para> See also: </para><a href="http://en.wikipedia.org/wiki/jacobi_method">Wikipedia: Jacobi method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.JacobiSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Jacobi solver.</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.JacobiSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.JacobiSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.GaussSeidelSolver">
			<summary>Similar to the <para></para>JacobiSolver Jacobi method, the Gauss-Seidel method (GS)
 solves each equation in sequential order. However, in each iteration, GS uses
 the previously computed <i>x</i> components as soon as they are available.
 In general, GS converges faster than the Jacobi method does (if there is a convergence), though still slowly.
 <para/>
 This implementation does not support preconditioning.<para> See also: </para><a href="http://en.wikipedia.org/wiki/gauss%e2%80%93seidel_method">Wikipedia: Gauss-Seidel method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.GaussSeidelSolver.#ctor(System.Int32,com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance)">
			<summary>Construct a Gauss-Seidel (GS) solver.</summary>
			<param name="maxIteration">the maximum number of iterations</param>
			<param name="tolerance">the convergence threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.GaussSeidelSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.solver.iterative.stationary.GaussSeidelSolver.solve(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.linearsystem.LSProblem,com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.VariancebtX">
			<summary>Computes \(b&apos;Xb\).<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/covariance_matrix#which_matrices_are_covariance_matrices.3f">Wikipedia:
 Which matrices are covariance matrices?</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.VariancebtX.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Computes \(b&apos;Xb\).</summary>
			<param name="b">a vector</param>
			<param name="X">a matrix</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SymmetricKronecker">
			<summary>Compute the symmetric Kronecker product of two matrices.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Chapter 14.4.2, Symmetric Kronecker product,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SymmetricKronecker.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Compute the symmetric Kronecker product of two matrices.</summary>
			<param name="M">a matrix</param>
			<param name="N">a matrix</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SVEC">
			<summary><c>SVEC</c> converts a symmetric matrix <i>K = {K<sub>ij</sub>}</i> into a vector of dimension <i>n(n+1)/2</i>.
 That is,
 \[
 \rm{svec}(K) = [k_{1,1}, \sqrt2k_{1,2}, ..., \sqrt2k_{1,n}, k_{2,2}, \sqrt2k_{2,3}, ..., \sqrt2k_{2,n}, ... k_{n,n},]
 \]
 <c>SVEC</c> is the inverse operator of <para></para>MAT.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;eq. 14.37,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SVEC.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct the SVEC of a matrix.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef">
			<summary>This is a &apos;reference&apos; to a sub-matrix of a larger matrix without copying it. For performance
 reason, we often want to work with a sub-matrix without copying it.
 <para/>
 The reference sub-matrix is <em>immutable</em>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32[],System.Int32[])">
			<summary>Constructs a sub-matrix reference.</summary>
			<param name="A">a matrix</param>
			<param name="rows">the row indices</param>
			<param name="cols">the column indices</param>
			<exception cref="T:java.lang.IndexOutOfBoundsException">if <i>rowFrom</i>, <i>rowTo</i>, <i>colFrom</i>, or
 <i>colTo</i> is invalid</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary>Constructs a sub-matrix reference.</summary>
			<param name="A">a matrix</param>
			<param name="rowFrom">the beginning row index</param>
			<param name="rowTo">the ending row index</param>
			<param name="colFrom">the beginning column index</param>
			<param name="colTo">the ending column index</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs a reference to the whole matrix.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.t">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.deepCopy">
			<summary>Returns <c>this</c> as the reference is immutable.</summary>
			<returns><c>this</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SubMatrixRef.set(System.Int32,System.Int32,System.Double)">
			<summary><para><c>DEPRECATED:</c> SubMatrixRef is immutable</para>
</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SimilarMatrix">
			<summary>Given a matrix <i>A</i> and an invertible matrix <i>P</i>, we construct the similar matrix
 <i>B</i> s.t.,
 <blockquote><i>
 B = P<sup>-1</sup>AP
 </i></blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/similar_matrix">Wikipedia: Similar matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.SimilarMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs the similar matrix <i>B = P<sup>-1</sup>AP</i>.</summary>
			<param name="P">an invertible matrix</param>
			<param name="A">a matrix</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.PseudoInverse">
			<summary>The Moore-Penrose pseudo-inverse of an <i>m x n</i> matrix <i>A</i> is <i>A<sup>+</sup></i>.
 It is a generalization of the inverse matrix.
 This implementation uses the Singular Value decomposition to compute the pseudo-inverse. Specifically,
 <blockquote><code><i>
 A = U * D * V&apos;
 A<sup>+</sup> = V * D<sup>+</sup> * U&apos;
 </i></code></blockquote>
 The properties are
 <list type="bullet">
 <item><i>A<sup>+</sup></i> has the dimension of <i>n x m</i>.</item>
 <item><i>A * A<sup>+</sup> * A = A</i></item>
 <item><i>A<sup>+</sup> * A * A<sup>+</sup> = A<sup>+</sup></i></item>
 <item><i>(A * A<sup>+</sup>)&apos; = A * A<sup>+</sup></i></item>
 <item><i>(A<sup>+</sup> * A)&apos; = A<sup>+</sup> * A</i></item>
 </list>
 When <i>A</i> is invertible, its pseudo-inverse coincides with its inverse.<para> See also: </para>SVD<para> See also: </para><a href="http://en.wikipedia.org/wiki/moore-penrose_pseudo-inverse">Wikipedia: Moore-Penrose pseudo-inverse</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.PseudoInverse.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Construct the Moore-Penrose pseudo-inverse matrix of a matrix.<para> See also: </para><a href="http://en.wikipedia.org/wiki/moore-penrose_pseudo-inverse#the_general_case_and_the_svd_method">Wikipedia: The general case and the SVD method</a></summary>
			<param name="A">an <i>m x n</i> matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0.
 This threshold truncates negligible singular values less than the smaller of &#949; and (t = machine &#949; * max(m,n) * max(D)).</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.PseudoInverse.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct the Moore-Penrose pseudo-inverse matrix of <i>A</i>.</summary>
			<param name="A">an <i>m x n</i> matrix</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Pow">
			<summary>This is a square matrix <i>A</i> to the power of an integer <i>n</i>, <i>A<sup>n</sup></i>.
 To avoid overflow of <c>double</c> precision, we represent the result as a product of
 <blockquote><i>
 A<sup>n</sup> = base<sup>scale</sup> * B;
 </i></blockquote>
 E.g.,
 <blockquote><i>
 A<sup>n</sup> = 1e100<sup>scale</sup> * B = 10<sup>100 * scale</sup> * B
 </i></blockquote>
 All entries in <i>B</i> can be represented in <c>double</c> precision.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Pow.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,System.Double)">
			<summary>Construct the power matrix <i>A<sup>n</sup></i> so that
 <blockquote><i>
 A<sup>n</sup> = base<sup>scale</sup> * B
 </i></blockquote></summary>
			<param name="A">a matrix</param>
			<param name="n">a positive integer exponent</param>
			<param name="base">the base to scale down the product to avoid overflow</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Pow.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32)">
			<summary>Construct the power matrix <i>A<sup>n</sup></i> so that
 <blockquote><i>
 A<sup>n</sup> = (1e100)<sup>scale</sup> * B
 </i></blockquote></summary>
			<param name="A">a matrix</param>
			<param name="n">a positive integer exponent</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Pow.base">
			<summary>Get the radix or base of the coefficient.<para> See also: </para><a href="http://en.wikipedia.org/wiki/radix">Wikipedia: Radix</a></summary>
			<returns>the base</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Pow.scale">
			<summary>Get the exponential of the coefficient.</summary>
			<returns>the exponential of the coefficient</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Pow.B">
			<summary>Get the double precision matrix.</summary>
			<returns>the double precision matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.OuterProduct">
			<summary>The outer product of two vectors <i>a</i> and <i>b</i>, is a row vector multiplied on the left by
 a column vector. That is,
 <blockquote>
 a &#8855; b = a b<sup>T</sup>
 </blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.OuterProduct.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils">
			<summary>These are the utility functions to apply to matrices.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.rowSums(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary>Get the row sums. That is, the first element in the output array equals to the sum of the
 entries in the first row of the input matrix, so on and so forth. So, the number of entries
 in the output equals to the number of rows in the input matrix.</summary>
			<param name="A">a matrix</param>
			<returns>the row sums</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.rowSumVector(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary>Get the row sum vector of a given matrix.</summary>
			<param name="A">the matrix</param>
			<returns>the row sum vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.colSums(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary>Get the column sums. That is, the first element in the output array equals to the sum of the
 entries in the first column of the input matrix, so on and so forth. So, the number of
 entries in the output equals to the number of columns in the input matrix.</summary>
			<param name="A">a matrix</param>
			<returns>the column sums</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.colSumVector(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary>Get the column sum vector of a given matrix.</summary>
			<param name="A">the matrix</param>
			<returns>the column sum vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.rowMeans(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary>Get the row means. That is, the first element in the output array equals to the mean of the
 entries in the first row of the input matrix, so on and so forth. So, the number of
 entries in the output equals to the number of rows in the input matrix.</summary>
			<param name="A">a matrix</param>
			<returns>the row means</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.rowMeanVector(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary>Get the row mean vector of a given matrix.</summary>
			<param name="A">the matrix</param>
			<returns>the row mean vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.colMeans(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary>Get the column means. That is, the first element in the output array equals to the mean of
 the entries in the first column of the input matrix, so on and so forth. So, the number of
 entries in the output equals to the number of columns in the input matrix.</summary>
			<param name="A">a matrix</param>
			<returns>the column means</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.colMeanVector(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary>Get the column mean vector of a given matrix.</summary>
			<param name="A">the matrix</param>
			<returns>the column mean vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.deRowMean(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Get the de-mean (row means) matrix of a given matrix.</summary>
			<param name="A">the matrix</param>
			<returns>the de-mean matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.deColumnMean(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Get the de-mean (column means) matrix of a given matrix.</summary>
			<param name="A">the matrix</param>
			<returns>the de-mean matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.sum(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary>Get the sum of all elements in the given matrix.</summary>
			<param name="A">the matrix</param>
			<returns>the sum of all elements</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.to1DArray(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary>Get all matrix entries in the form of an 1D <c>double[]</c>.</summary>
			<param name="A">a matrix</param>
			<returns>all matrix entries in <c>double[]</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.to2DArray(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary>Get all matrix entries in the form of a 2D <c>double[][]</c> array.</summary>
			<param name="A">a matrix</param>
			<returns>all matrix entries in <c>double[][]</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.toRows(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Get an array of all row vectors from a matrix.</summary>
			<param name="A">a matrix</param>
			<returns>row vectors (indexed from top to bottom)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.toColumns(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Get an array of all column vectors from a matrix.</summary>
			<param name="A">a matrix</param>
			<returns>column vectors (indexed from left to right)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixUtils.toString(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary>Get the <c>String</c> representation of a matrix.</summary>
			<param name="A">a matrix</param>
			<returns>the <c>String</c> representation of a matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixRootByDiagonalization">
			<summary>The square root of a matrix extends the notion of square root from numbers to matrices. <i>A</i>
 matrix <i>B</i> is said to be a square root of <i>A</i> if the matrix product <i>BB</i> is equal
 to <i>A</i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/square_root_of_a_matrix#by_diagonalization">Wikipedia:
 By diagonalization</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixRootByDiagonalization.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs the square root of a Matrix by diagonalization.</summary>
			<param name="S">a diagonalizable matrix</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixMeasure">
			<summary>A measure, &#956;, of a matrix, <i>A</i>, is a map from the Matrix space to the Real line.
 That is,
 <blockquote><i>
 &#956;: A -&gt; R
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixMeasure.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixMeasure.rank(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Compute the <em>numerical</em> rank of a matrix.
 Ignore all singular values smaller than a threshold.<para> See also: </para><a href="http://en.wikipedia.org/wiki/rank_(linear_algebra)">Wikipedia: Rank (linear
 algebra)</a></summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns>the numerical rank of <i>A</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixMeasure.rank(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Compute the <em>numerical</em> rank of a matrix.
 Ignore all singular values less than a threshold.</summary>
			<param name="A">a matrix</param>
			<returns>the numerical rank of <i>A</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixMeasure.nullity(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
Compute the nullity of a matrix.<para> See also: </para><a href="http://en.wikipedia.org/wiki/rank-nullity_theorem">Wikipedia: Rank-nullity
 theorem</a></summary>
			<param name="A">a matrix</param>
			<returns>the nullity of <i>A</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixMeasure.det(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Compute the determinant of a matrix.<para> See also: </para><a href="http://en.wikipedia.org/wiki/determinant">Wikipedia: Determinant</a></summary>
			<param name="A">a matrix</param>
			<returns>the determinant of <i>A</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixMeasure.tr(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Compute the sum of the diagonal elements, i.e., the trace of a matrix.<para> See also: </para><a href="http://en.wikipedia.org/wiki/trace_(linear_algebra)">Wikipedia: Trace (linear
 algebra)</a></summary>
			<param name="A">a matrix</param>
			<returns>the trace of <i>A</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixMeasure.Frobenius(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Compute the Frobenius norm, i.e., the sqrt of the sum of squares of all elements of a matrix.<para> See also: </para><a href="http://en.wikipedia.org/wiki/matrix_norm#frobenius_norm">Wikipedia: Frobenius
 norm</a></summary>
			<param name="A">a matrix</param>
			<returns>the sqrt of sum of squares of all elements in <i>A</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixMeasure.max(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Compute the maximal entry in a matrix.</summary>
			<param name="A">a matrix</param>
			<returns>the maximal entry</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixMeasure.min(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Compute the minimal entry in a matrix.</summary>
			<param name="A">a matrix</param>
			<returns>the minimal entry</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory">
			<summary>These are the utility functions to create a new matrix/vector from existing ones.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.identity(System.Int32,System.Int32)">
			<summary>Constructs a new identity matrix.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<returns>the new identity matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.foreach(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Constructs a new matrix in which each entry is the result of applying a function to the
 corresponding entry of a matrix. The type of the output matrix is always the same as the type
 of the input matrix. However, sparsity <em>may</em> not preserved under this
 operation.</summary>
			<param name="A">a matrix</param>
			<param name="f">the function to be applied to each entry of a matrix</param>
			<returns>\([f(A[i,j])], \forall i, j\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.foreachRow(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction)">
			<summary>Constructs a new matrix in which each row is the result of applying a real vector function on
 each row vector of an input matrix.</summary>
			<param name="A">the input matrix</param>
			<param name="f">the real vector function</param>
			<returns>\([f(A[i,])], \forall i\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.foreachColumn(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction)">
			<summary>Constructs a new matrix in which each column is the result of applying a real vector function
 on each column vector of an input matrix.</summary>
			<param name="matrix">the input matrix</param>
			<param name="f">the real vector function</param>
			<returns>\([f(A[,j])], \forall j\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.cbind(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Combines an array of vectors by columns. The vectors must have the same length.</summary>
			<param name="vectors">an array of vectors, e.g., <i>v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>,
 ...</i></param>
			<returns><i>[v<sub>1</sub> v<sub>2</sub> v<sub>3</sub> ...]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.cbind(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector[])">
			<summary>Combines an array of sparse vectors by columns and returns a CSR sparse matrix. The vectors
 must have the same length.</summary>
			<param name="vectors">an array of vectors, e.g., <i>v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>,
 ...</i></param>
			<returns><i>[v<sub>1</sub> v<sub>2</sub> v<sub>3</sub> ...]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.cbind(java.util.List)">
			<summary>Combines a list of vectors by columns. The vectors must have the same length.</summary>
			<param name="vectors">a list of vectors, e.g., <i>v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>,
 ...</i></param>
			<returns><i>[v<sub>1</sub> v<sub>2</sub> v<sub>3</sub> ...]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.cbind(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[])">
			<summary>Combines an array of matrices by columns. The matrices must have the same number of rows.</summary>
			<param name="matrices">an array of matrices, e.g., <i>A<sub>1</sub>, A<sub>2</sub>, A<sub>3</sub>,
 ...</i></param>
			<returns><i>[A<sub>1</sub> A<sub>2</sub> A<sub>3</sub> ...]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.cbind(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix[])">
			<summary>Combines an array of sparse matrices by columns. The matrices must have the same number of
 rows. If all the matrices have the same type, then returns the combined matrix of that type;
 otherwise, returns a CSR sparse matrix.</summary>
			<param name="matrices">an array of matrices, e.g., <i>A<sub>1</sub>, A<sub>2</sub>, A<sub>3</sub>,
 ...</i></param>
			<returns><i>[A<sub>1</sub> A<sub>2</sub> A<sub>3</sub> ...]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.rbind(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Combines an array of vectors by rows. The vectors must have the same length. If the vectors
 are all sparse, it will returns a sparse matrix.</summary>
			<param name="vectors">an array of vector, e.g., <i>v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>,
 ...</i></param>
			<returns>\[
         \begin{bmatrix}
         v_1\\
         v_2\\
         v_3\\
         ...
         \end{bmatrix}
         \]</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if the vectors form a jagged array</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.rbind(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector[])">
			<summary>Combines an array of sparse vectors by rows and returns a sparse matrix. The vectors must
 have the same length.</summary>
			<param name="vectors">an array of vector, e.g., <i>v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>,
 ...</i></param>
			<returns>\[
         \begin{bmatrix}
         v_1\\
         v_2\\
         v_3\\
         ...
         \end{bmatrix}
         \]</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if the vectors form a jagged array</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.rbind(java.util.List)">
			<summary>Combines a list of array of vectors by rows. The vectors must have the same length.</summary>
			<param name="vectors">a list of vector, e.g., <i>v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>,
 ...</i></param>
			<returns>\[
         \begin{bmatrix}
         v_1\\
         v_2\\
         v_3\\
         ...
         \end{bmatrix}
         \]</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if the vectors form a jagged array</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.rbind(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[])">
			<summary>Combines an array of matrices by rows. The matrices must have the same number of columns.</summary>
			<param name="matrices">an array of matrices, e.g., <i>A<sub>1</sub>, A<sub>2</sub>, A<sub>3</sub>,
 ...</i></param>
			<returns>\[
         \begin{bmatrix}
         A_1\\
         A_2\\
         A_3\\
         ...
         \end{bmatrix}
         \]</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.rbind(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix[])">
			<summary>Combines an array of sparse matrices by rows. The matrices must have the same number of
 columns. If all the matrices have the same type, then returns a sparse matrix of that type;
 otherwise, returns CSR sparse matrix.</summary>
			<param name="matrices">an array of matrices, e.g., <i>A<sub>1</sub>, A<sub>2</sub>, A<sub>3</sub>,
 ...</i></param>
			<returns>\[
         \begin{bmatrix}
         A_1\\
         A_2\\
         A_3\\
         ...
         \end{bmatrix}
         \]</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.subMatrix(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary>Constructs a sub-matrix from the four corners of a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="rowFrom">the beginning row index</param>
			<param name="rowTo">the ending row index</param>
			<param name="colFrom">the beginning column index</param>
			<param name="colTo">the ending column index</param>
			<returns><i>A[rowFrom:rowTo, colFrom:colTo]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.subMatrix(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix,System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary>Constructs a sub-matrix from the four corners of a sparse matrix.</summary>
			<param name="A">a sparse matrix</param>
			<param name="rowFrom">the beginning row index</param>
			<param name="rowTo">the ending row index</param>
			<param name="colFrom">the beginning column index</param>
			<param name="colTo">the ending column index</param>
			<returns><i>A[rowFrom:rowTo, colFrom:colTo]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.subMatrix(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32[],System.Int32[])">
			<summary>Constructs a sub-matrix from the intersections of rows and columns of a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="rows">the rows to be extracted</param>
			<param name="cols">the columns to be extracted</param>
			<returns><i>A[rows, cols]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.subMatrix(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix,System.Int32[],System.Int32[])">
			<summary>Constructs a sub-matrix from the intersections of rows and columns of a sparse matrix.</summary>
			<param name="A">a sparse matrix</param>
			<param name="rows">the rows to be extracted</param>
			<param name="cols">the columns to be extracted</param>
			<returns><i>A[rows, cols]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.rows(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32[])">
			<summary>Construct a sub-matrix from the rows of a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="rows">the rows to be extracted</param>
			<returns><i>A[rows, *]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.rows(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,System.Int32)">
			<summary>Constructs a sub-matrix from the rows of a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="begin">the beginning row index (counting from 1)</param>
			<param name="end">the ending row index (counting from 1)</param>
			<returns><i>A[begin:end, *]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.columns(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32[])">
			<summary>Constructs a sub-matrix from the columns of a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="cols">the columns to be extracted</param>
			<returns><i>A[*, cols]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.columns(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,System.Int32)">
			<summary>Constructs a sub-matrix from the columns of a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="begin">the beginning column index (counting from 1)</param>
			<param name="end">the ending column index (counting from 1)</param>
			<returns><i>A[*, begin:end]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.replaceInPlace(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,System.Int32,System.Int32,System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Replaces a sub-matrix of a matrix with a smaller matrix. This method is best NOT to apply to
 <para></para>SymmetricMatrix because this method does not ensure the symmetry property after
 replacement.

 <para/>
 <em>Note that The original matrix is modified afterward (for performance reason in case of a
 big matrix).
 No new <c>Matrix</c> instance is constructed.</em></summary>
			<param name="original">the matrix whose entries are to be replaced</param>
			<param name="rowFrom">the beginning row index</param>
			<param name="rowTo">the ending row index</param>
			<param name="colFrom">the beginning column index</param>
			<param name="colTo">the ending column index</param>
			<param name="replacement">the matrix to be inserted into the original matrix</param>
			<returns>the modified matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.copyAndReplace(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,System.Int32,System.Int32,System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
Makes a copy of a matrix and then replace a sub-matrix of the copy. The two input matrices
 are not modified. This method is best NOT to apply to <para></para>SymmetricMatrix because this
 method does not ensure the symmetry property after replacement.</summary>
			<param name="original">the matrix whose entries are to be replaced</param>
			<param name="rowFrom">the beginning row index</param>
			<param name="rowTo">the ending row index</param>
			<param name="colFrom">the beginning column index</param>
			<param name="colTo">the ending column index</param>
			<param name="replacement">the matrix to be inserted into the original matrix</param>
			<returns>the modified matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.diagonalMatrix(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Gets the diagonal of a matrix.</summary>
			<param name="A">a matrix</param>
			<returns>a diagonal matrix whose diagonal entries are <i>A<sub>i,i</sub></i>, zeros elsewhere</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <i>A</i> is not square</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.minorMatrix(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,System.Int32)">
			<summary>Gets the minor matrix of a given matrix, by removing a specified row and a specified column.<para> See also: </para><a href="http://en.wikipedia.org/wiki/minor_(linear_algebra)">
 Wikipedia: Minor (linear algebra)</a></summary>
			<param name="X">the matrix</param>
			<param name="row">the index of the row to be removed</param>
			<param name="col">the index of the column to be removed</param>
			<returns>the minor matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.randomDenseMatrix(System.Int32,System.Int32,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Constructs a random <para></para>DenseMatrix.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="rng">a random number generator</param>
			<returns>a random <para></para>DenseMatrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.randomSymmetricMatrix(System.Int32,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Constructs a random <para></para>SymmetricMatrix.</summary>
			<param name="dim">the matrix dimension</param>
			<param name="rng">a random number generator</param>
			<returns>a random <para></para>SymmetricMatrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.randomLowerTriangularMatrix(System.Int32,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Constructs a random <para></para>LowerTriangularMatrix.</summary>
			<param name="dim">the matrix dimension</param>
			<param name="rng">a random number generator</param>
			<returns>a random <para></para>SymmetricMatrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.randomUpperTriangularMatrix(System.Int32,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Constructs a random <para></para>UpperTriangularMatrix.</summary>
			<param name="dim">the matrix dimension</param>
			<param name="rng">a random number generator</param>
			<returns>a random <para></para>UpperTriangularMatrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.randomDOKSparseMatrix(System.Int32,System.Int32,System.Int32,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Constructs a random <para></para>DOKSparseMatrix.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="nNonZero">the number of non-zero elements</param>
			<param name="rlg">a random long generator</param>
			<returns>a random <para></para>DOKSparseMatrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.randomLILSparseMatrix(System.Int32,System.Int32,System.Int32,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Constructs a random <para></para>LILSparseMatrix.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="nNonZero">the number of non-zero elements</param>
			<param name="rlg">a random long generator</param>
			<returns>a random <para></para>LILSparseMatrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.randomCSRSparseMatrix(System.Int32,System.Int32,System.Int32,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Constructs a random <para></para>CSRSparseMatrix.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="nNonZero">the number of non-zero elements</param>
			<param name="rlg">a random long generator</param>
			<returns>a random <para></para>CSRSparseMatrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MatrixFactory.randomPositiveDefiniteMatrix(System.Int32,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Constructs a random symmetric, positive definite matrix.</summary>
			<param name="dim">the matrix dimension</param>
			<param name="rng">a random number generator</param>
			<returns>a random symmetric, positive definite matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MAT">
			<summary><c>MAT</c> is the inverse operator of <para></para>SVEC. That is,
 <blockquote><i>
 mat(svec(A)) = A
 </i></blockquote><para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;eq. 14.41f,&quot; Practical Optimization: Algorithms and
 Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.MAT.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Constructs the MAT of a vector.</summary>
			<param name="v">a vector</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.KroneckerProduct">
			<summary>Given an <i>m-by-n</i> matrix <i>A</i> and a <i>p-by-q</i> matrix <i>B</i>,
 their Kronecker product <i>C</i>, also called their matrix direct product, is
 an <i>(mp)-by-(nq)</i> matrix with entries defined by
 <blockquote><i>
 c<sub>st</sub> = a<sub>ij</sub> b<sub>kl</sub>
 </i></blockquote>
 where
 <blockquote><code><i>
 s = p(i - 1) + k
 t = q(j - 1) + l
 </i></code></blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/kronecker_product">Wikipedia: Kronecker product</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.KroneckerProduct.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct the Kronecker product of two matrices.</summary>
			<param name="A">a matrix</param>
			<param name="B">a matrix</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Inverse">
			<summary>For a <em>square</em> matrix <i>A</i>, the inverse, A<sup>-1</sup>, if exists, satisfies
 <blockquote><c>A.multiply(A.inverse()) == A.ONE()</c></blockquote>
 There are multiple ways to compute the inverse of a matrix. They are,
 <list type="bullet">
 <item>an analytic solution for small matrices, e.g., 2x2,</item>
 <item>LU Decomposition,</item>
 <item>the Moore-Penrose pseudoinverse.</item>
 </list><para> See also: </para><a href="http://en.wikipedia.org/wiki/matrix_inverse">Wikipedia: Invertible matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Inverse.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs the inverse of a matrix.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Inverse.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Constructs the inverse of a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.InnerProduct">
			<summary>The Frobenius inner product is the component-wise inner product of two matrices as though they are vectors.
 In other words, it is the sum of the entries of the Hadamard product, that is,
 <blockquote><code><i>
 A : B = trace(A&apos;B) = trace(AB&apos;);
 </i></code></blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/matrix_multiplication#frobenius_inner_product">Wikipedia: Frobenius inner product</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.InnerProduct.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Compute the inner product of two matrices.</summary>
			<param name="A">a matrix</param>
			<param name="B">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.InnerProduct.value">
			<summary>Get the value of the inner product.</summary>
			<returns>the value of the inner product</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection">
			<summary>A Householder transformation in the 3-dimensional space is the reflection of a vector in the
 plane.
 The plane, containing the origin, is uniquely defined by a unit vector,
 called the defining vector, orthogonal to the plane.
 The reflection <i>Hx</i> can be computed without explicitly expanding <i>H</i>.
 <blockquote><code><i>
 H = I - 2vv&apos;
 Hx = (I - 2vv&apos;)x = Ix - 2vv&apos;x = x - 2v&lt;v,x&gt;, where x is a column vector
 yH = (H&apos;y&apos;)&apos; = (Hy&apos;)&apos;, where y is a row vector
 </i></code></blockquote>
 When <i>H</i> is applied to a set of column vectors, it transforms each vector individually, as
 in block matrix multiplication.
 <blockquote><code><i>
 H * A = H * [A<sub>1</sub> A<sub>2</sub> ... A<sub>n</sub>] = [H * A<sub>1</sub> H *
 A<sub>2</sub> ... H * A<sub>n</sub>]
 </i></code></blockquote>
 When <i>H</i> is applied to a set of row vectors, it transforms each vector individually, as in
 block matrix multiplication.
 \[
 AH = \begin{bmatrix}
 A_1H\\
 A_2H\\
 A_3H\\
 A_4H\\
 A_5H
 \end{bmatrix}
 \]<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/householder_reflection">Wikipedia:
 Householder transformation</a></item>
 <item><a href="http://en.wikipedia.org/wiki/householder_operator">Wikipedia:
 Householder operator</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a Householder matrix from the vector that defines the
 hyperplane orthogonal to the vector. If the defining vector is a 0-vector, the
 Householder matrix is the identity matrix.</summary>
			<param name="v">the hyperplane defining vector</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderContext)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.definingVector">
			<summary>Get the Householder defining vector which is orthogonal to the Householder hyperplane.</summary>
			<returns>the Householder defining vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.reflect(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Apply the Householder matrix, <i>H</i>, to a column vector, <i>x</i>.
 <blockquote><code><i>
 Hx = x - 2 * &lt;v,x&gt; * v
 </i></code></blockquote></summary>
			<param name="x">a vector</param>
			<returns><i>Hx</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.reflectVectors(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[],System.Int32,System.Int32)">
			<summary>Apply the Householder matrix, <i>H</i>, to an array of vectors.</summary>
			<param name="vectors">an array of vectors</param>
			<param name="startIndex">the start index of the array to apply</param>
			<param name="endIndex">the end index of the array to apply, inclusive</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.reflect(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Apply the Householder matrix, <i>H</i>, to a matrix (a set of column
 vectors), <i>A</i>.
 <blockquote><code><i>
 H * A = [H * A<sub>1</sub> H * A<sub>2</sub> ... H * A<sub>n</sub>]
 </i></code></blockquote></summary>
			<param name="A">a matrix</param>
			<returns><i>H * A</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.reflectColumns(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.rightReflect(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Apply the Householder matrix, <i>H</i>, to a matrix (a set of row
 vectors), <i>A</i>.
 \[
 AH =
 \begin{bmatrix}
 A_1H\\
 A_2H\\
 A_3H\\
 A_4H\\
 A_5H
 \end{bmatrix}
 \]</summary>
			<param name="A">a matrix</param>
			<returns><i>A * H</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.reflectRows(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.H">
			<summary>Get the Householder matrix <i>H = I - 2 * v * v&apos;</i>. To compute <i>H
 *v</i>, do not use this method. Instead use <para></para>#reflect(Vector).</summary>
			<returns>the Householder matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.product(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection[],System.Int32,System.Int32)">
			<summary>Compute <i>Q</i> from Householder matrices <i>{Q<sub>i</sub>}</i>.
 <blockquote><code><i>
 Q = Q<sub>1</sub> * Q<sub>2</sub> * ... * Q<sub>n</sub> * I
 </i></code></blockquote>
 This implementation use an efficient way to compute <i>Q</i>, i.e., by
 applying <i>Q<sub>i</sub></i>&apos;s repeatedly on an identity matrix.</summary>
			<param name="Hs">an array of Householders</param>
			<param name="from">the beginning index of <i>H</i>&apos;s; <i>Q<sub>1</sub></i> is
 <i>Q<sub>from</sub></i></param>
			<param name="to">the ending index of <i>H</i>&apos;s; <i>Q<sub>n</sub></i> is
 <i>Q<sub>to</sub></i></param>
			<returns>the product of an array of Householder matrices, from
         <c>Hs[from]</c> to <c>Hs[to]</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection.product(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderReflection[],System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary>Compute <i>Q</i> from Householder matrices <i>{Q<sub>i</sub>}</i>.
 <blockquote><code><i>
 Q = Q<sub>1</sub> * Q<sub>2</sub> * ... * Q<sub>n</sub> * I
 </i></code></blockquote>
 The identity matrix, <i>I</i>, may have more rows than columns. The
 bottom rows are padded with zeros.
 <para/>
 This implementation use an efficient way to compute <i>Q</i>, i.e., by
 applying <i>Q<sub>i</sub></i>&apos;s repeatedly on an identity matrix.</summary>
			<param name="Hs">an array of Householders</param>
			<param name="from">the beginning index of <i>H</i>&apos;s; <i>Q<sub>1</sub></i> is
 <i>Q<sub>from</sub></i></param>
			<param name="to">the ending index of <i>H</i>&apos;s; <i>Q<sub>n</sub></i> is
 <i>Q<sub>to</sub></i></param>
			<param name="nRows">the number of rows of <i>I</i></param>
			<param name="nCols">the number of columns of <i>I</i></param>
			<returns>the product of an array of Householder matrices, from
         <c>Hs[from]</c> to <c>Hs[to]</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace">
			<summary>Maintains the matrix to be transformed by a sequence of Householder reflections. After all
 transformation are done, the final transformed matrix and the accumulated transformation matrices
 can be obtained via <para></para>#getTransformedMatrix(), <para></para>#U(), and
 <para></para>#Vt() respectively.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Creates an instance that transforms the given matrix <i>A</i>.</summary>
			<param name="A">the matrix to be transformed</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Creates an instance that transforms the given matrix <i>A</i>.</summary>
			<param name="A">the matrix to be transformed</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.generateAndReflectColumns(System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary>Reflects a range of sub-columns with a Householder generated by the first column in the
 range.</summary>
			<param name="firstColumnIndex">the column index of the first sub-column</param>
			<param name="lastColumnIndex">the column index of the last sub-column</param>
			<param name="firstEntryIndex">the row index of the first entry of the sub-columns</param>
			<param name="lastEntryIndex">the row index of the last entry of the sub-columns</param>
			<returns>the information of the generated Householder transformation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.generateLeftHouseholder(System.Int32,System.Int32,System.Int32)">
			<summary>Generates a left Householder from a sub-column of the underlying matrix, in order to zero out
 entries (except the first entry) of the sub-column.</summary>
			<param name="columnIndex">the column index of the sub-column</param>
			<param name="firstEntryIndex">the row index of the first entry of the sub-column</param>
			<param name="lastEntryIndex">the row index of the last entry of the sub-column</param>
			<returns>the information of the generated Householder transformation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.reflect(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.Householder,System.Int32,System.Int32)">
			<summary>Reflects (or left transform) a range of columns in the underlying matrix with a given
 Householder.</summary>
			<param name="H">the Householder</param>
			<param name="fromColumn">the column index of the first column</param>
			<param name="toColumn">the column index of the last column</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.generateAndReflectRows(System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary>Reflects a range of sub-rows with a Householder generated by the first row in the range.</summary>
			<param name="firstRowIndex">the row index of the first sub-row</param>
			<param name="lastRowIndex">the row index of the last sub-row</param>
			<param name="firstEntryIndex">the column index of the first entry of the sub-rows</param>
			<param name="lastEntryIndex">the column index of the last entry of the sub-rows</param>
			<returns>the information of the generated Householder transformation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.generateRightHouseholder(System.Int32,System.Int32,System.Int32)">
			<summary>Generates a right Householder from a sub-row of the underlying matrix, in order to zero out
 entries (except the first entry) of the sub-row.</summary>
			<param name="rowIndex">the row index of the sub-row</param>
			<param name="firstEntryIndex">the column index of the first entry of the sub-row</param>
			<param name="lastEntryIndex">the column index of the last entry of the sub-row</param>
			<returns>the information of the generated Householder transformation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.rightReflect(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.Householder,System.Int32,System.Int32)">
			<summary>Reflects (or right transform) a range of rows in the underlying matrix with a given
 Householder.</summary>
			<param name="H">the Householder</param>
			<param name="fromRow">the row index of the first row</param>
			<param name="toRow">the row index of the last row</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.getTransformedMatrix">
			<summary>Gets the final matrix transformed by all the Householder transformations.</summary>
			<returns>the transformed matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.get(System.Int32,System.Int32)">
			<summary>Gets the value of an entry at (i,j) in the transformed matrix.</summary>
			<param name="i">the row index</param>
			<param name="j">the column index</param>
			<returns>the value at (i,j)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.U">
			<summary>Gets the accumulated Householder reflections applied to A. That is, the <i>m x m</i> matrix
 <i>U</i>,
 \[
 U_k * ... * U_2 * U_1 * A = B
 U * A = B
 U = (U_k * ... * U_2 * U_1)
 U&apos; = (U_1 * U_2 * ... * U_k)
 \]</summary>
			<returns>the accumulated Householder reflection</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.Vt">
			<summary>Gets the inverse (or transpose) of accumulated Householder right-reflections applied to A.
 That is, the <i>n x n</i> matrix <i>V&apos;</i>,
 \[
 A * V_1 * V_2 * ... * V_k = B
 A * V = B
 A = B * V&apos;
 V = (V_1 * V_2 * ... * V_k)
 V&apos; = (V_k * ... * V_2 * V_1)
 \]</summary>
			<returns>the transpose of the accumulated Householder right-reflections</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.getLeftHouseholders">
			<summary>Gets all the accumulated left Householders.</summary>
			<returns>a list of the left Householders</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.getRightHouseholders">
			<summary>Gets all the accumulated right Householders.</summary>
			<returns>a list of the right Householders</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.Householder">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.Householder.fromContext(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderContext,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.Householder.toContext(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderInPlace.Householder)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderContext">
			<summary>This is the context information about a Householder transformation. It tells
 <list type="number">
 <item><i>v</i>, the defining vector which is perpendicular to the Householder hyperplane;</item>
 <item>generator, the vector used to generate the Householder defining vector;</item>
 <item>&#955;, the norm of the generator with the sign chosen to be the opposite of the
 first coordinate of generator.</item>
 </list></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderContext.v">
			<summary>The defining vector which is perpendicular to the Householder hyperplane.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderContext.beta">
			<summary>&#946; = 2 / v&apos;v.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderContext.generator">
			<summary>The vector which is used to generate the Householder vector.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderContext.lambda">
			<summary>The norm of the generator with the sign chosen to be the opposite of the first coordinate
 of the generator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderContext.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Constructs a Householder context information.</summary>
			<param name="v">the defining vector which is perpendicular to the Householder hyperplane</param>
			<param name="beta">&#946;</param>
			<param name="generator">the vector that generates the Householder reflection</param>
			<param name="lambda">&#955;, the negative norm of the generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderContext.getContext(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Generates the context information from a generating vector <i>x</i>. Given a vector <i>x</i>,
 return a vector <i>v</i>, such that
 <blockquote><code><i>
 Hx = ±||x|| * e<sub>1</sub>
 </i></code></blockquote>
 That is,
 <blockquote><code><c>
 H.reflect(x) == new DenseVector(new double[]{±x.norm(), 0, ...})
 </c></code></blockquote><para> See also: </para>&quot;G. W. Steward, &quot;Algorithm 1.1,&quot; Matrix Algorithms, Volume 1&quot;</summary>
			<param name="x">a vector</param>
			<returns>the context information for a Householder transformation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderContext.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Householder4ZeroGenerator">
			<summary>Faster implementation of Householder reflection for zero generator vector.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Householder4ZeroGenerator.#ctor(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Householder4ZeroGenerator.reflect(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Householder4SubVector">
			<summary>Faster implementation of Householder reflection for sub-vectors at a given index.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Householder4SubVector.#ctor(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Householder4SubVector.#ctor(System.Int32,System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Householder4SubVector.#ctor(System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.HouseholderContext)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Householder4SubVector.#ctor(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Householder4SubVector.definingVector">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.Householder4SubVector.reflect(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct">
			<summary>This is a fast and memory-saving implementation of computing the Kronecker product.
 It computes the matrix entry values only on demand by calling the <para></para>#get(int, int) method.
 If, however, the Kronecker product is used for matrix operations frequently,
 the class <para></para>KroneckerProduct, which computes all entries at
 construction, should be used instead.
 <para/>
 This class is immutable.<para> See also: </para>KroneckerProduct</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a Kronecker product for read-only.</summary>
			<param name="A">a matrix</param>
			<param name="B">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.add(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.minus(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.t">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.FastKroneckerProduct.deepCopy">
			<summary>Return <c>this</c> as this <para></para>Matrix is immutable.</summary>
			<returns><c>this</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation">
			<summary>There are three elementary row operations which are equivalent to left multiplying an elementary
 matrix.
 They are row switching, row multiplication, and row addition.
 By applying these operations to an identity matrix, <i>I</i>,
 the resultant matrix, <i>T</i>, is a transformation matrix, such that
 left multiplying <i>T</i> with a matrix <i>A</i>, i.e., <i>T * A</i>,
 is equivalent to applying the same sequence of operations to <i>A</i>.
 Similarly, the three elementary column operations are:
 column switching, column multiplication, and column addition.
 Column operations correspond to right multiplying a transformation matrix.<para> See also: </para><a href="http://en.wikipedia.org/wiki/elementary_row_operations">Wikipedia: Elementary
 matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.#ctor(System.Int32)">
			<summary>Construct a transformation matrix of elementary operations.
 The initial transformation matrix <i>T</i> is an identity matrix.</summary>
			<param name="dim">the dimension of <i>T</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.#ctor(System.Int32,System.Int32)">
			<summary>Construct a transformation matrix of elementary operations.
 The initial transformation matrix <i>T</i> is an identity matrix, if it is square.
 Otherwise, the rightmost columns are padded with zeros.</summary>
			<param name="nRows">the number of rows of <i>T</i></param>
			<param name="nCols">the number of columns of <i>T</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Transform A by elementary operations.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.T">
			<summary>Get the transformed matrix <i>T</i>.</summary>
			<returns><i>T</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.swapRow(System.Int32,System.Int32)">
			<summary>Swap rows:
 <blockquote><code><i>
 A[i<sub>1</sub>, ] = A[i<sub>2</sub>, ]
 A[i<sub>2</sub>, ] = A[i<sub>1</sub>, ]
 </i></code></blockquote></summary>
			<param name="i1">becoming row <i>i<sub>2</sub></i></param>
			<param name="i2">becoming row <i>i<sub>1</sub></i></param>
			<returns>the modified self</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.scaleRow(System.Int32,System.Double)">
			<summary>Scale a row:
 <blockquote><i>
 A[i, ] = c * A[i, ]
 </i></blockquote></summary>
			<param name="i">the row to be scaled</param>
			<param name="c">the scaling factor</param>
			<returns>the modified self</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.addRow(System.Int32,System.Int32,System.Double)">
			<summary>Row addition:
 <blockquote><i>
 A[i<sub>1</sub>, ] = A[i<sub>1</sub>, ] + c * A[i<sub>2</sub>, ]
 </i></blockquote></summary>
			<param name="i1">addend; the row to add to; the row is modified afterward</param>
			<param name="i2">the row to add with</param>
			<param name="c">the scaling factor for row <i>i<sub>2</sub></i></param>
			<returns>the modified self</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.swapColumn(System.Int32,System.Int32)">
			<summary>Swap columns:
 <blockquote><code><i>
 A[, j<sub>1</sub>] = A[, j<sub>2</sub>]
 A[, j<sub>2</sub>] = A[, j<sub>1</sub>]
 </i></code></blockquote></summary>
			<param name="j1">becoming column <i>j<sub>2</sub></i></param>
			<param name="j2">becoming column <i>j<sub>1</sub></i></param>
			<returns>the modified self</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.scaleColumn(System.Int32,System.Double)">
			<summary>Scale a column:
 <blockquote><i>
 A[, j] = c * A[, j]
 </i></blockquote></summary>
			<param name="j">the column to be scaled</param>
			<param name="c">the scaling factor</param>
			<returns>the modified self</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.addColumn(System.Int32,System.Int32,System.Double)">
			<summary>Column addition:
 <blockquote><i>
 A[, j<sub>1</sub>] = A[, j<sub>1</sub>] + c * A[, j<sub>2</sub>]
 </i></blockquote></summary>
			<param name="j1">addend; the column to add to; the column is modified afterward</param>
			<param name="j2">the column to add with</param>
			<param name="c">the scaling factor for
           <c>col2</c></param>
			<returns>the modified self</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.ElementaryOperation.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.CongruentMatrix">
			<summary>Given a matrix <i>A</i> and an invertible matrix <i>P</i>, we create the congruent matrix
 <i>B</i> s.t.,
 <blockquote><i>
 B = P&apos;AP
 </i></blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/matrix_congruence">Wikipedia: Matrix congruence</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.CongruentMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs the congruent matrix <i>B = P&apos;AP</i>.</summary>
			<param name="P">an invertible matrix</param>
			<param name="A">a matrix</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.positivedefinite.PositiveSemiDefiniteMatrixNonNegativeDiagonal">
			<summary>This class &quot;converts&quot; a matrix into a symmetric, positive semi-definite matrix, if it is not
 already so, by forcing the negative diagonal entries in the eigen decomposition to 0.<para> See also: </para>&quot;Jin Wang, Chunlei Liu. &quot;Generating Multivariate Mixture of Normal Distributions using a
 Modified Cholesky Decomposition,&quot; Simulation Conference, 2006. WSC 06. Proceedings of the Winter.
 p. 342 - 347. 3-6 Dec. 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.positivedefinite.PositiveSemiDefiniteMatrixNonNegativeDiagonal.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Constructs a positive semi-definite matrix by forcing the negative diagonal entries in the
 eigen decomposition to 0.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0;
                used in the eigen decomposition (don&apos;t make it 0)</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.positivedefinite.PositiveDefiniteMatrixByPositiveDiagonal">
			<summary>This class &quot;converts&quot; a matrix into a symmetric, positive definite matrix, if it is not already
 so, by forcing the diagonal entries in the eigen decomposition to a small non-negative number,
 e.g., 0.<para> See also: </para>&quot;Jin Wang, Chunlei Liu. &quot;Generating Multivariate Mixture of Normal Distributions using a
 Modified Cholesky Decomposition,&quot; Simulation Conference, 2006. WSC 06. Proceedings of the Winter.
 p. 342 - 347. 3-6 Dec. 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.positivedefinite.PositiveDefiniteMatrixByPositiveDiagonal.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double,System.Double)">
			<summary>Constructs a positive definite matrix by forcing the diagonal entries in the eigen
 decomposition to a small non-negative number, e.g., 0.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0;
                used in the eigen decomposition (don&apos;t make it 0)</param>
			<param name="small">the minimum value of the new diagonal entries</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.positivedefinite.MatthewsDavies">
			<summary>Matthews and Davies propose the following way to coerce a non-positive definite Hessian matrix to
 become symmetric, positive definite. An LDL decomposition is performed on the non-positive
 definite matrix. The zero and negative entries are then replaced by the smallest positive entry
 in the diagonal matrix.<para> See also: </para>&quot;Andreas Antoniou and Wu-Sheng Lu, &quot;Algorithm 5.4,&quot; Practical Optimization: Algorithms and
 Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.positivedefinite.MatthewsDavies.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs a symmetric, positive definite matrix using the Matthews-Davies algorithm. This
 implementation replaces all zero or negative entries on the diagonal by the smallest positive
 entry on the diagonal. If all entries in the diagonal are negative, <i>D</i> becomes an
 identity matrix.</summary>
			<param name="H">a non-positive definite matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.positivedefinite.MatthewsDavies.L">
			<summary>Gets the lower triangular matrix <i>L</i> in the LDL decomposition.</summary>
			<returns><i>L</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.positivedefinite.MatthewsDavies.Lt">
			<summary>Gets the transpose of the lower triangular matrix <i>L</i> in the LDL decomposition. The
 transpose is upper triangular.</summary>
			<returns><i>L<sup>t</sup></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.positivedefinite.MatthewsDavies.D">
			<summary>Gets the diagonal matrix <i>D</i> in the LDL decomposition.</summary>
			<returns><i>D</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.positivedefinite.MatthewsDavies.Dhat">
			<summary>Gets the modified diagonal matrix which is positive definite.</summary>
			<returns><i>D^</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.positivedefinite.GoldfeldQuandtTrotter">
			<summary>Goldfeld, Quandt and Trotter propose the following way to coerce a non-positive definite Hessian
 matrix to become symmetric, positive definite. For a non-positive definite Hessian matrix
 <i>H</i>, we compute
 \[
 \widehat{H} = \frac{H + \beta I}{1 + \beta}
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.doubles.operation.positivedefinite.GoldfeldQuandtTrotter.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Constructs a symmetric, positive definite matrix using the Goldfeld-Quandt-Trotter algorithm.</summary>
			<param name="H">a non-positive definite matrix</param>
			<param name="beta">a positive number.
             The bigger beta is, the closer <i>H^</i> is to <i>I</i>.
             If <c>beta == Double.POSITIVE_INFINITY</c>, then <i>H^ = I</i>.</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.generic.GenericMatrixAccess">
			<summary>This interface defines the methods for accessing entries in a matrix over a field.
 Indices count from 1, e.g., <c>get(1,1)</c>.
 This is what mathematicians (not programmers) are accustomed to.
 Invalid access such as using out-of-range indices or altering immutable matrix
 will lead to <para></para>MatrixAccessException.
 The <em>only</em> way to change a matrix is by calling
 <para></para>#set(int, int, com.numericalmethod.suanshu.algebra.structure.Field).
 Other operations that &quot;change&quot; the matrix actually creates a new and independent copy.<para> See also: </para>com.numericalmethod.suanshu.algebra.structure.Field</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.GenericMatrixAccess.set(System.Int32,System.Int32,com.numericalmethod.suanshu.algebra.structure.Field)">
			<summary>Set the matrix entry at <i>[i,j]</i> to a value.
 This is the only method that may change a matrix.</summary>
			<param name="i">the row index</param>
			<param name="j">the column index</param>
			<param name="value">the value to set <i>A[i,j]</i> to</param>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">if <i>i</i> or <i>j</i> is out of range</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.GenericMatrixAccess.get(System.Int32,System.Int32)">
			<summary>Get the matrix entry at <i>[i,j]</i>.</summary>
			<param name="i">the row index</param>
			<param name="j">the column index</param>
			<returns><i>A[i,j]</i></returns>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">if <i>i</i> or <i>j</i> is out of range</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.generic.GenericMatrix">
			<summary>This class defines a matrix over a field.
 This interface is made minimal so that we do not list all possible matrix operations.
 Instead, matrix operations are grouped into packages and classes by their properties.
 This is to avoid interface &quot;pollution&quot;, lengthy and cumbersome design.<para> See also: </para>Field<para> See also: </para>Table</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix">
			<summary>This is a <para></para>Real matrix.
 Comparing to the <c>double</c>-based <para></para>DenseMatrix,
 this class allows arbitrary precision arithmetic at the cost of (much) slower performance.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.#ctor(System.Int32,System.Int32)">
			<summary>Construct a <para></para>Real matrix.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.#ctor(com.numericalmethod.suanshu.number.Real[][])">
			<summary>Construct a <para></para>Real matrix.</summary>
			<param name="data">a matrix data of <para></para>Real numbers in a 2D array</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.#ctor(System.Double[][])">
			<summary>Construct a <para></para>Real matrix.</summary>
			<param name="data">a matrix data of <c>double</c>s in a 2D array</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.set(System.Int32,System.Int32,com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.scaled(com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.doubleValue">
			<summary>Construct a <para></para>DenseMatrix equivalent of this Real matrix (rounded if necessary).</summary>
			<returns>a <para></para>DenseMatrix equivalent</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.RealMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix">
			<summary>This is a generic matrix over a <para></para>Field.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.#ctor(System.Int32,System.Int32,com.numericalmethod.suanshu.algebra.structure.Field)">
			<summary>Construct a matrix over a field.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
			<param name="init">an initial value for the entries, e.g., 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.#ctor(com.numericalmethod.suanshu.algebra.structure.Field[][])">
			<summary>Construct a matrix over a field.</summary>
			<param name="data">the matrix entries</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.set(System.Int32,System.Int32,com.numericalmethod.suanshu.algebra.structure.Field)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.scaled(com.numericalmethod.suanshu.algebra.structure.Field)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.GenericFieldMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix">
			<summary>This is a <para></para>Complex matrix.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.#ctor(System.Int32,System.Int32)">
			<summary>Construct a <para></para>Complex matrix.</summary>
			<param name="nRows">the number of rows</param>
			<param name="nCols">the number of columns</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.#ctor(com.numericalmethod.suanshu.number.complex.Complex[][])">
			<summary>Construct a <para></para>Complex matrix.</summary>
			<param name="data">a matrix data of <para></para>Complex numbers in a 2D array</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.#ctor(System.Double[][])">
			<summary>Construct a <para></para>Complex matrix.</summary>
			<param name="data">a matrix data of <c>double</c>s in a 2D array</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.set(System.Int32,System.Int32,com.numericalmethod.suanshu.number.complex.Complex)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.add(com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.minus(com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.multiply(com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.scaled(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.doubleValue">
			<summary>Construct a <para></para>DenseMatrix equivalent of this Complex matrix (rounded if necessary).</summary>
			<returns>a <para></para>DenseMatrix equivalent</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.generic.matrixtype.ComplexMatrix.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixSingularityException">
			<summary>This is the runtime exception thrown when an operation acts on a singular matrix, e.g., applying LU decomposition to a singular matrix.
 A singular matrix is a matrix that is not invertible; equivalently, its determinant is 0.<para> See also: </para><a href="http://en.wikipedia.org/wiki/singular_matrix"> Wikipedia: Singular matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixSingularityException.#ctor">
			<summary>Construct an instance of <c>MatrixSingularityException</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixSingularityException.#ctor(System.String)">
			<summary>Construct an instance of <c>MatrixSingularityException</c> with a message.</summary>
			<param name="msg">an error message</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixMismatchException">
			<summary>This is the runtime exception thrown when an operation acts on matrices that have incompatible dimensions.
 E.g.,
 <list type="bullet">
 <item><i>A + B</i> fails when <i>A</i> and <i>B</i> have different numbers of rows and columns.</item>
 <item><i>A x B</i> fails when <i>A</i> has a number of columns different from the number of rows <i>B</i> has.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixMismatchException.#ctor">
			<summary>Construct an instance of <c>MatrixMismatchException</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixMismatchException.#ctor(System.String)">
			<summary>Construct an instance of <c>MatrixMismatchException</c> with a message.</summary>
			<param name="msg">an error message</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException">
			<summary>This is the runtime exception thrown when trying to access an invalid entry in a matrix, e.g., <i>A[0, 0]</i>.
 Matrix indices count from 1. The first entry (upper left hand corner) is <i>A[1, 1]</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException.#ctor">
			<summary>Construct an instance of <c>MatrixAccessException</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.matrix.MatrixAccessException.#ctor(System.String)">
			<summary>Construct an instance of <c>MatrixAccessException</c> with a message.</summary>
			<param name="msg">an error message</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector">
			<summary>An Euclidean vector is a geometric object that has both a magnitude/length and a direction.
 The mathematical structure of a collection of vectors is a <para></para>HilbertSpace Hilbert space.
 This interface is made minimal to avoid listing all possible vector operations.
 Instead, vector operations are grouped into packages and classes by their properties.
 This is to avoid interface &quot;pollution&quot;, lengthy and cumbersome design.
 <para/>
 The <em>only</em> way to change a vector is by <para></para>#set(int, double).
 Other operations that &quot;change&quot; the vector actually creates a new and independent copy.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/euclidean_vector">Wikipedia: Euclidean vector</a></item>
 <item><a href="http://en.wikipedia.org/wiki/vector_space">Wikipedia: Vector space</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.size">
			<summary>Get the length of this vector.</summary>
			<returns>the vector length</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.get(System.Int32)">
			<summary>Get the value at position <i>i</i>.</summary>
			<param name="i">the position of a vector entry</param>
			<returns><i>v[i]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.set(System.Int32,System.Double)">
			<summary>Change the value of an entry in this vector.
 This is the only method that may change the entries of a vector.</summary>
			<param name="i">the index of the entry to change. The indices are counting from 1, NOT 0.</param>
			<param name="value">the value to change to</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.add(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>\(this + that\)</summary>
			<param name="that">a vector</param>
			<returns>\(this + that\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.minus(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>\(this - that\)</summary>
			<param name="that">a vector</param>
			<returns>\(this - that\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Multiply <c>this</c> by <c>that</c>, entry-by-entry.</summary>
			<param name="that">a vector</param>
			<returns>\(this \cdot that\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.divide(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Divide <c>this</c> by <c>that</c>, entry-by-entry.</summary>
			<param name="that">a vector</param>
			<returns>\(this / that\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.add(System.Double)">
			<summary>Add a constant to all entries in this vector.</summary>
			<param name="c">a constant</param>
			<returns>\(v + c\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.minus(System.Double)">
			<summary>Subtract a constant from all entries in this vector.</summary>
			<param name="c">a constant</param>
			<returns>\(v - c\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.innerProduct(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Inner product in the Euclidean space is the dot product.<para> See also: </para><a href="http://en.wikipedia.org/wiki/dot_product"> Wikipedia: Dot product</a></summary>
			<param name="that">a vector</param>
			<returns>\(this \cdot that\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.pow(System.Double)">
			<summary>Take the exponentiation of all entries in this vector, entry-by-entry.</summary>
			<param name="c">a constant</param>
			<returns>\(v ^ s\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.scaled(System.Double)">
			<summary>Scale this vector by a constant, entry-by-entry.
 Here is a way to get a unit version of the vector:
 <blockquote><c>
 vector.scaled(1. / vector.norm())
 </c></blockquote></summary>
			<param name="c">a constant</param>
			<returns>\(c \times this\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.scaled(com.numericalmethod.suanshu.number.Real)">
			<summary>Scale this vector by a constant, entry-by-entry.
 Here is a way to get a unit version of the vector:
 <blockquote><c>
 vector.scaled(1. / vector.norm())
 </c></blockquote></summary>
			<param name="c">a constant</param>
			<returns>\(c \times this\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.norm">
			<summary>Compute the length or magnitude or Euclidean norm of a vector, namely, \(\|v\|\).</summary>
			<returns>the Euclidean norm</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.norm(System.Double)">
			<summary>Gets the \(L^p\)-norm \(\|v\|_p\) of this vector.
 <list type="bullet">
 <item>When <i>p</i> is finite, \(\|v\|_p = \sum_{i}|v_i^p|^\frac{1}{p}\).</item>
 <item>When <i>p</i> is \(+\infty\) (<para></para>Double#POSITIVE_INFINITY), \(\|v\|_p =
 \max|v_i|\).</item>
 <item>When <i>p</i> is \(-\infty\) (<para></para>Double#NEGATIVE_INFINITY), \(\|v\|_p =
 \min|v_i|\).</item>
 </list><para> See also: </para><a href="http://en.wikipedia.org/wiki/norm_(mathematics)">Wikipedia: Norm
 (mathematics)</a></summary>
			<param name="p"><i>p &#8805; 1</i>, or <para></para>Double#POSITIVE_INFINITY or
          <para></para>Double#NEGATIVE_INFINITY</param>
			<returns>\(\|v\|_p\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.angle(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Measure the angle, \(\theta\), between <c>this</c> and <c>that</c>.
 That is,
 \[
 this \cdot that = \|this\| \times \|that\| \times \cos \theta
 \]</summary>
			<param name="that">a vector</param>
			<returns>the angle, \(\theta\), between <c>this</c> and <c>that</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.opposite">
			<summary>Get the opposite of this vector.</summary>
			<returns><i>-v</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.ZERO">
			<summary>Get a 0-vector that has the same length as this vector.</summary>
			<returns>the 0-vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.toArray">
			<summary>Cast this vector into a 1D <c>double[]</c>.</summary>
			<returns>a copy of all vector entries as a <c>double[]</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector.deepCopy">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef">
			<summary>Represents a sub-vector backed by the referenced vector, without data
 copying. Note that changes to the referenced vector will also be reflected in
 the sub-vector instance.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.get(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.set(System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.add(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.minus(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.innerProduct(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.pow(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.scaled(com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.norm">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.toArray">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.SubVectorRef.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector">
			<summary>This is a read-only view of a <para></para>Vector instance. It keeps the reference to the
 instance and delegates all operations to the instance except for
 <para></para>#set(int, double) which will always result in an <para></para>VectorAccessException.
 It may, however, still be modified indirectly via the reference of the
 original vector. To ensure complete immutability, an independent copy is needed.
 That is,
 <blockquote><c>
 ImmutableVector immutable = new ImmutableVector(v.deepCopy());
 </c></blockquote>
 Note that the returned values of all operations (e.g., <c>add</c>) has
 the same types as the original ones.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a read-only version of a vector.
 <em>Note that, however, changing the original vector changes the &quot;immutable&quot; version as
 well.</em></summary>
			<param name="v">a vector</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.set(System.Int32,System.Double)">
			<summary>This method is overridden to always throw <c>VectorAccessException</c>.</summary>
			<exception cref="T:com.numericalmethod.suanshu.algebra.linear.vector.VectorAccessException">always</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.get(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.add(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.minus(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.divide(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.add(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.minus(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.innerProduct(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.pow(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.scaled(com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.norm">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.norm(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.angle(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.toArray">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.ImmutableVector.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.vector.doubles.CombinedVectorByRef">
			<summary>For efficiency, this wrapper concatenates two or more vectors by references
 (without data copying). Note that changes to the referenced vectors will also
 be reflected in the combined instance.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.CombinedVectorByRef.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.CombinedVectorByRef.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.CombinedVectorByRef.get(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.CombinedVectorByRef.set(System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.CombinedVectorByRef.toArray">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.CombinedVectorByRef.deepCopy">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation">
			<summary>This is a generic implementation of the math operations of <c>double</c> based <para></para>Vector.
 It assumes no knowledge of how a vector is implemented.
 A particular implementation of <para></para>Vector can improve performance by taking advantage of
 having access to the internal members.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.add(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.minus(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.divide(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.innerProduct(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.pow(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.scaled(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.add(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.minus(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.scaled(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.opposite(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.angle(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.norm(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.VectorMathOperation.norm(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector">
			<summary>This class implements the standard, dense, <c>double</c> based vector representation.<para> See also: </para><a href="http://en.wikipedia.org/wiki/euclidean_vector">Wikipedia:
 Euclidean vector</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.#ctor(System.Int32)">
			<summary>Constructs a vector.</summary>
			<param name="length">the length of this vector</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.#ctor(System.Int32,System.Double)">
			<summary>Constructs a vector, initialized by repeating a value.</summary>
			<param name="length">the length of this vector</param>
			<param name="value">the initial value</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.#ctor(System.Double[])">
			<summary>Constructs a vector, initialized by a <c>double[]</c>.</summary>
			<param name="data">an 1D array</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.#ctor(java.util.Collection)">
			<summary>Constructs a vector, initialized by a collection, with order defined by
 its iterator.</summary>
			<param name="data">a collection of <c>Double</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.#ctor(System.Int32[])">
			<summary>Constructs a vector, initialized by a <c>int[]</c>.</summary>
			<param name="data">an 1D array</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs a vector from a column or row matrix.</summary>
			<param name="A">a column or row matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Casts any vector to a <c>DenseVector</c>.</summary>
			<param name="v">a vector</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector)">
			<summary>Copy constructor.</summary>
			<param name="vector">a vector</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.set(System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.set(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector)">
			<summary>Replaces a sub-vector <c>v[from : replacement.length]</c> by a
 replacement starting at position <c>from</c>.</summary>
			<param name="from">the starting position of the replacement</param>
			<param name="replacement">a vector for substitution</param>
			<exception cref="T:java.lang.IllegalArgumentException">if the replacement length exceeds the
                                  end of this vector</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.get(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.add(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.add(com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.minus(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.minus(com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.scaled(com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.multiply(com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.divide(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.divide(com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.add(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.minus(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.pow(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.norm(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.norm">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.angle(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.innerProduct(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.innerProduct(com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.toArray">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.dense.DenseVector.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory">
			<summary>These are the utility functions that create new instances of vectors from existing ones.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.concat(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Concatenates an array of vectors into one vector.</summary>
			<param name="vectors">an array of vectors, e.g., \((v_1, v_2, v_3, ...)\).</param>
			<returns>\(c(v_1, v_2, v_3, ...)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.concat(java.util.Collection)">
			<summary>Concatenates an array of vectors into one vector.</summary>
			<param name="vectors">an array of vectors, e.g., \((v_1, v_2, v_3, ...)\).</param>
			<returns>\(c(v_1, v_2, v_3, ...)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.concat(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector[])">
			<summary>Concatenates an array of sparse vectors into one sparse vector.</summary>
			<param name="vectors">an array of sparse vectors, e.g., \((v_1, v_2, v_3, ...)\).</param>
			<returns>\(c(v_1, v_2, v_3, ...)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.foreach(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Constructs a new vector in which each entry is the result of applying a
 function to the corresponding entry of a vector.</summary>
			<param name="f">the function to be applied to each entry of a vector</param>
			<param name="vector">a vector</param>
			<returns><i>[f(v<sub>i</sub>)]</i> for all <i>i</i>s</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.foreach(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Constructs a new vector in which each entry is the result of applying a
 function to the corresponding entry of a sparse vector. Note that this
 operation may not preserve sparsity.</summary>
			<param name="f">the function to be applied to each entry of a vector</param>
			<param name="vector">a sparse vector</param>
			<returns><i>[f(v<sub>i</sub>)]</i> for all <i>i</i>s</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.subVector(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32,System.Int32)">
			<summary>Gets a sub-vector from a vector.</summary>
			<param name="vector">a vector</param>
			<param name="from">the beginning index</param>
			<param name="to">the ending index</param>
			<returns><c>v[from : to]</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.subVector(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseVector,System.Int32,System.Int32)">
			<summary>Gets a sub-vector from a sparse vector.</summary>
			<param name="vector">a sparse vector</param>
			<param name="from">the beginning index</param>
			<param name="to">the ending index</param>
			<returns><c>v[from : to]</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.subVector(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32[])">
			<summary>Gets a sub-vector from a vector according to a given array
 of ordered indices (repetition allowed).</summary>
			<param name="vector">a vector</param>
			<param name="indices">the array of ordered indices (repetition allowed)</param>
			<returns>a sub-vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.diagonal(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Gets the diagonal of a matrix as a vector.</summary>
			<param name="A">a matrix</param>
			<returns>a vector whose entries are <i>A<sub>i</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.diagonal(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix)">
			<summary>Gets the diagonal of a sparse matrix as a sparse vector.</summary>
			<param name="A">a sparse matrix</param>
			<returns>a sparse vector whose entries are <i>A<sub>i</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.superDiagonal(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Gets the super-diagonal of a matrix as a vector.</summary>
			<param name="A">a matrix</param>
			<returns>a vector whose entries are <i>A<sub>i,i+1</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.superDiagonal(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix)">
			<summary>Gets the super-diagonal of a sparse matrix as a sparse vector.</summary>
			<param name="A">a sparse matrix</param>
			<returns>a sparse vector whose entries are <i>A<sub>i,i+1</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.subDiagonal(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Gets the sub-diagonal of a matrix as a vector.</summary>
			<param name="A">a matrix</param>
			<returns>a vector whose entries are <i>A<sub>i+1,i</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.subDiagonal(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.sparse.SparseMatrix)">
			<summary>Gets the sub-diagonal of a sparse matrix as a sparse vector.</summary>
			<param name="A">a sparse matrix</param>
			<returns>a sparse vector whose entries are <i>A<sub>i+1,i</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.foreachRow(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary>Constructs a vector in which each entry is the result of applying a
 <para></para>RealScalarFunction to each row of an input matrix.</summary>
			<param name="matrix">the input matrix</param>
			<param name="f">the real scalar function</param>
			<returns>the vector containing the results</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.foreachColumn(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary>Constructs a vector in which each entry is the result of applying a
 <para></para>RealScalarFunction to each column of an input matrix.</summary>
			<param name="matrix">the input matrix</param>
			<param name="f">the real scalar function</param>
			<returns>the vector containing the results</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.foreachVector(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[],com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary>Applies a <para></para>RealScalarFunction on each input vector.</summary>
			<param name="vectors">the input vectors</param>
			<param name="f">the real scalar function</param>
			<returns>the values after applying <c>f</c> on the vectors</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.foreachVector(java.util.Collection,com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary>Applies a <para></para>RealScalarFunction on each input vector.</summary>
			<param name="vectors">the input vectors</param>
			<param name="f">the real scalar function</param>
			<returns>the values after applying <c>f</c> on the vectors</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.foreachVector(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[],com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction)">
			<summary>Applies a real vector function on each input vector.</summary>
			<param name="vectors">the input vectors</param>
			<param name="f">the real vector function</param>
			<returns>the output vectors after applying the function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.foreachVector(java.util.Collection,com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction)">
			<summary>Applies a real vector function on each input vector.</summary>
			<param name="vectors">the input vectors</param>
			<param name="f">the real vector function</param>
			<returns>the output vectors after applying the function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.getCoordinate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[],System.Int32)">
			<summary>Gets the vector entries from a particular coordinate. If all input vectors
 are sparse, then returns a sparse vector.</summary>
			<param name="vectors">the input vectors</param>
			<param name="i">the index to a vector entry; the coordinate index</param>
			<returns>a vector composed of the entries from a particular coordinate</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.getCoordinate(java.util.Collection,System.Int32)">
			<summary>Gets the vector entries from a particular coordinate.</summary>
			<param name="vectors">the input vectors</param>
			<param name="i">the index to a vector entry; the coordinate index</param>
			<returns>a vector composed of the entries from a particular coordinate</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.getOffsetVectors(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32,System.Int32)">
			<summary>Given the reference vector <c>v0</c>, the delta <c>dv</c>, and
 the range <c>[a, b]</c>, the offset vectors are:
 <blockquote><i>
 v0 + a * dv, v0 + (a + 1) * dv, ..., v0 + b * dv.
 </i></blockquote></summary>
			<param name="v0">the reference vector <c>v0</c></param>
			<param name="dv">the change (base offset) made to the vector at each step <c>dv</c></param>
			<param name="a">the minimum multiple of <c>dv</c> that is added to <c>v0</c></param>
			<param name="b">the maximum multiple of <c>dv</c> that is added to <c>v0</c></param>
			<returns>a list containing the vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.cumsum(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Gets the cumulative sums.</summary>
			<param name="arr">an array of vectors</param>
			<returns>the cumulative sum, element-by-element</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.VectorFactory.get0s(System.Int32,System.Int32)">
			<summary>Gets <c>n</c> 0 vectors.</summary>
			<param name="dimension">the dimension of the vectors</param>
			<param name="n">the number of 0 vectors</param>
			<returns><c>n</c> 0 vectors</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace">
			<summary>A vector space is a set of vectors that are closed under some operations. The basis of a vector
 space is a set of vectors that, in a linear combination, can represent every vector in the space,
 and that no element of the set can be represented as a linear combination of the others. In other
 words, a basis is a linearly independent spanning set. The orthogonal complement
 <i>A<sup>&#8869;</sup></i> of a subspace <i>A</i> of an inner product space <i>V</i> is the set of
 all vectors in <i>V</i> that are orthogonal to every vector in <i>A</i>. Informally, it is called
 the perp, short for perpendicular complement. For an <i>m x n</i> matrix <i>A</i>, where <i>m
 &#8805; n</i>, the orthogonal basis are the orthogonalization of the columns. The orthogonal
 complement is <i>A<sup>&#8869;</sup> = Null(A.t())</i>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/basis_(linear_algebra)">Wikipedia: Basis (linear
 algebra)</a></item>
 <item><a href="http://en.wikipedia.org/wiki/orthogonal_complement">Wikipedia: Orthogonal
 complement</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Construct a vector space from a matrix (a set of column vectors).
 This implementation computes the orthogonal basis and the orthogonal complement.</summary>
			<param name="A">a matrix, i.e., (a set of column vectors)</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0.
                The &#949; is used to determine the numerical rank of the linear space.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a vector space from a matrix (a set of column vectors).
 This implementation computes the orthogonal basis and the orthogonal complement.</summary>
			<param name="A">a matrix, i.e., (a set of column vectors)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.#ctor(java.util.List,System.Double)">
			<summary>Construct a vector space from a list of vectors.
 This implementation computes the orthogonal basis and the orthogonal complement.</summary>
			<param name="elements">a list of vectors</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0.
                 The &#949; is used to determine the numerical rank of the linear space.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.#ctor(java.util.List)">
			<summary>Construct a vector space from a list of vectors.
 This implementation computes the orthogonal basis and the orthogonal complement.</summary>
			<param name="elements">a list of vectors</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.#ctor(System.Double,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Construct a vector space from an array of vectors.
 This implementation computes the orthogonal basis and the orthogonal complement.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0.
                 The &#949; is used to determine the numerical rank of the linear space.</param>
			<param name="elements">a list of vectors</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Construct a vector space from an array of vectors.
 This implementation computes the orthogonal basis and the orthogonal complement.</summary>
			<param name="elements">a list of vectors</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.rank">
			<summary>Get the rank of this vector space.</summary>
			<returns>the rank</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.getBasis">
			<summary>Get the orthogonal basis.</summary>
			<returns>the orthogonal basis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.getComplement">
			<summary>Get the basis of the orthogonal complement.</summary>
			<returns>the orthogonal basis of the nullspace</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.getLinearSpan(System.Double[])">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
Get the linear span of the orthogonal basis from a set of coefficients.</summary>
			<param name="d">coefficients</param>
			<returns>a span of the basis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.getSpanningCoefficients(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Find a linear combination of the basis that best approximates a vector in the least square
 sense.
 This implementation solves an OLS problem.<para> See also: </para>OLSSolver</summary>
			<param name="b">a vector</param>
			<returns>the coefficients for a linear combination of basis; <c>null</c> if <c>b</c> is not
         in the vector space</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.isSpanned(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Check whether a vector is in the span of the basis.
 That is, whether there exists a linear combination of the basis that equals the vector.</summary>
			<param name="b">a vector</param>
			<returns><c>true</c> if <c>b</c> is in this vector space</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.RealVectorSpace.isInKernel(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
Check whether a vector is in the span of the the kernel/nullspace.
 That is, whether there exists a linear combination of the basis of the kernel that equals the
 vector.</summary>
			<param name="b">a vector</param>
			<returns><c>true</c> if <c>b</c> is in the kernel/nullspace of this vector space</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.Projection">
			<summary>Project a vector <i>v</i> on another vector <i>w</i> or a set of vectors (basis) <i>{w<sub>i</sub>}</i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/vector_projection">Wikipedia: Vector projection</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.Projection.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,java.util.List)">
			<summary>Project a vector <i>v</i> onto a set of basis <i>{w<sub>i</sub>}</i>.</summary>
			<param name="v">a vector</param>
			<param name="basis"><i>{w<sub>i</sub>}</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.Projection.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Project a vector <i>v</i> onto a set of basis <i>{w<sub>i</sub>}</i>.</summary>
			<param name="v">a vector</param>
			<param name="basis"><i>{w<sub>i</sub>}</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.Projection.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Project a vector <i>v</i> onto another vector.</summary>
			<param name="v">a vector</param>
			<param name="w">another vector</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.Projection.getOrthogonalVector">
			<summary>Get the orthogonal vector which is equal to <i>v</i> minus the projection of <i>v</i> on <i>{w<sub>i</sub>}</i>.</summary>
			<returns>the orthogonal vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.Projection.getProjectionLength(System.Int32)">
			<summary>Get the length of <i>v</i> projected on each dimension <i>{w<sub>i</sub>}</i>.</summary>
			<param name="i">an index, counting from 0</param>
			<returns>the <i>i</i>-th projection length</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.Projection.getProjectionVector(System.Int32)">
			<summary>Get the <i>i</i>-th projected vector of <i>v</i> on <i>{w<sub>i</sub>}</i>.
 It lies on the hyperplane of <i>{w<sub>i</sub>}</i>.</summary>
			<param name="i">an index, counting from 0</param>
			<returns>the <i>i</i>-th projection vector</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.Basis">
			<summary>A basis is a set of linearly independent vectors spanning a vector space.
 Every element in this space can be uniquely represented by a linear combination of elements in the basis.
 This implementation is the standard basis of the Euclidean R<sup>n</sup> space.<para> See also: </para><a href="http://en.wikipedia.org/wiki/basis_(linear_algebra)">Wikipedia: Basis (linear algebra)</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.Basis.#ctor(System.Int32,System.Int32)">
			<summary>Construct a vector that corresponds to the <i>i</i>-th dimension in R<sup>n</sup>.
 That is (a 1 in the <i>i</i>-th entry),
 \[
 \begin{bmatrix}
 0\\
 ...\\
 1\\
 ...\\
 0
 \end{bmatrix}
 \]</summary>
			<param name="dim">the dimension</param>
			<param name="i">the <i>i</i>-th dimension in R<sup>n</sup></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.Basis.getBasis(System.Int32)">
			<summary>Get the full set of the standard basis vectors.</summary>
			<param name="dim">the dimension</param>
			<returns>the basis vectors</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.doubles.operation.Basis.getBasis(System.Int32,System.Int32)">
			<summary>Get a subset of the standard basis vectors.</summary>
			<param name="dim">the dimension</param>
			<param name="nCols">the number of basis vectors requested; it must be smaller than <c>dim</c></param>
			<returns>the basis vectors</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if there are more columns requested than the dimension</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.vector.VectorSizeMismatch">
			<summary>This is the exception thrown when an operation is performed on two vectors with different
 sizes.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.VectorSizeMismatch.#ctor(System.Int32,System.Int32)">
			<summary>Constructs an instance of <c>SizeMismatch</c>.</summary>
			<param name="size1">size 1</param>
			<param name="size2">size 2</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.linear.vector.VectorAccessException">
			<summary>This is the exception thrown when any invalid access to a <para></para>Vector instance is
 detected, e.g., out-of-range index.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.VectorAccessException.#ctor(System.Int32,System.Int32)">
			<summary>Constructs an instance of <c>VectorAccessException</c> for out-of-range access.</summary>
			<param name="size">the vector size</param>
			<param name="index">the out-of-range index</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.linear.vector.VectorAccessException.#ctor(System.String)">
			<summary>Constructs an instance of <c>VectorAccessException</c>.</summary>
			<param name="msg">the error message</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.structure.VectorSpace">
			<summary>A vector space is a set <i>V</i> together with two binary operations that combine two entities to yield a third,
 called vector addition and scalar multiplication.<para> See also: </para><a href="http://en.wikipedia.org/wiki/vector_space">Wikipedia: Vector space</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.VectorSpace.scaled(com.numericalmethod.suanshu.algebra.structure.Field)">
			<summary><i>&#215; : F &#215; V &#8594; V</i>
 <para/>
 The result of applying this function to a scalar, <i>c</i>, in <i>F</i> and <i>v</i> in <i>V</i> is denoted <i>cv</i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/scalar_multiplication">Wikipedia: Scalar multiplication</a></summary>
			<param name="c">a multiplier</param>
			<returns><i>c * this</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.structure.Ring">
			<summary>A ring is a set <i>R</i> equipped with two binary operations called addition and multiplication:
 <blockquote><c>+ : R &#215; R &#8594; R</c></blockquote> and
 <blockquote><c>&#8901; : R &#215; R &#8594; R</c></blockquote>
 To qualify as a ring, the set and two operations, <i>(R, +, &#8901;)</i>, must satisfy the requirements known as the ring axioms.<para> See also: </para><a href="http://en.wikipedia.org/wiki/ring_(mathematics)">Wikipedia: Ring (mathematics)</a></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.structure.Monoid">
			<summary>A monoid is a group with a binary operation (<i>&#215;</i>), satisfying the group axioms:
 <list type="number">
 <item>closure</item>
 <item>associativity</item>
 <item>existence of multiplicative identity</item>
 </list><para> See also: </para><a href="http://en.wikipedia.org/wiki/monoid">Wikipedia: Monoid</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.Monoid.multiply(System.Object)">
			<summary><i>&#215; : G &#215; G &#8594; G</i></summary>
			<param name="that">the multiplicand</param>
			<returns><i>this &#215; that</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.Monoid.ONE">
			<summary>The multiplicative element 1 in the group such that for any elements <i>a</i> in the group,
 the equation <i>1 &#215; a = a &#215; 1 = a</i> holds.</summary>
			<returns>1</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.structure.HilbertSpace">
			<summary>A Hilbert space is an inner product space, an abstract vector space in which distances and angles can be measured.
 It is also &quot;complete&quot;, meaning that if a sequence of vectors is Cauchy, then it converges to some limit in the space.<para> See also: </para><a href="http://en.wikipedia.org/wiki/hilbert_space">Wikipedia: Hilbert space</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.HilbertSpace.innerProduct(System.Object)">
			<summary><i>&lt;&#8901;,&#8901;&gt; : H &#215; H &#8594; F</i>
 <para/>
 Inner product formalizes the geometrical notions such as the length of a vector and the angle between two vectors.
 It defines orthogonality between two vectors, where their inner product is 0.</summary>
			<param name="that">the object to form an angle with <c>this</c></param>
			<returns><i>&lt;this,that&gt;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.HilbertSpace.angle(System.Object)">
			<summary><i>&#8736; : H &#215; H &#8594; F</i>
 <para/>
 Inner product formalizes the geometrical notions such as the length of a vector and the angle between two vectors.
 It defines orthogonality between two vectors, where their inner product is 0.</summary>
			<param name="that">the object to form an angle with this</param>
			<returns>the angle between <c>this</c> and <c>that</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.structure.Field">
			<summary>As an algebraic structure, every field is a ring, but not every ring is a field.
 That is, it has the notion of addition, subtraction, multiplication, satisfying certain axioms.
 The most important difference is that a field allows for division (though not division by zero),
 while a ring may not possess a multiplicative inverse.
 In addition, the multiplication operation in a field is required to be commutative.<para> See also: </para><a href="http://en.wikipedia.org/wiki/field_mathematics">Wikipedia: Field (mathematics)</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.Field.inverse">
			<summary>For each <i>a</i> in <i>F</i>, there exists an element <i>b</i> in <i>F</i> such that
 <i>a &#215; b = b &#215; a = 1</i>.
 That is, it is the object such as
 <blockquote><c>this.multiply(this.inverse()) == this.ONE</c></blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/multiplicative_inverse">
 Wikipedia: Multiplicative inverse</a></summary>
			<returns><i>1 / this</i> if it exists</returns>
			<exception cref="T:com.numericalmethod.suanshu.algebra.structure.Field.InverseNonExistent">if the inverse does not exist</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.Field.divide(System.Object)">
			<summary><i>/ : F &#215; F &#8594; F</i>
 <para/>
 That is the same as
 <blockquote><c>this.multiply(that.inverse())</c></blockquote></summary>
			<param name="that">the denominator</param>
			<returns><i>this / that</i></returns>
			<exception cref="T:com.numericalmethod.suanshu.algebra.structure.Field.InverseNonExistent">if the inverse does not exist</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.structure.Field.InverseNonExistent">
			<summary>This is the exception thrown when the inverse of a field element does not exist.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.Field.InverseNonExistent.#ctor">
			<summary>Construct an instance of <c>InverseNonExistent</c></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.structure.BanachSpace">
			<summary>A Banach space, <i>B</i>, is a complete normed vector space such that
 every Cauchy sequence (with respect to the metric <i>d(x, y) = |x - y|</i>) in <i>B</i> has a limit in <i>B</i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/banach_space">Wikipedia: Banach space</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.BanachSpace.norm">
			<summary><i>|&#8901;| : B &#8594; F</i>
 <para/>
 <c>norm</c> assigns a strictly positive length or size to all vectors in the vector space,
 other than the zero vector.<para> See also: </para><a href="http://en.wikipedia.org/wiki/norm_(mathematics)">Wikipedia: Norm (mathematics)</a></summary>
			<returns><i>|this|</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.algebra.structure.AbelianGroup">
			<summary>An Abelian group is a group with a binary additive operation (<i>+</i>), satisfying the group axioms:
 <list type="number">
 <item>closure</item>
 <item>associativity</item>
 <item>existence of additive identity</item>
 <item>existence of additive opposite</item>
 <item>commutativity of addition</item>
 </list><para> See also: </para><a href="http://en.wikipedia.org/wiki/abelian_group">Wikipedia: Abelian group</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.AbelianGroup.add(System.Object)">
			<summary><i>+ : G &#215; G &#8594; G</i></summary>
			<param name="that">the object to be added</param>
			<returns><i>this + that</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.AbelianGroup.minus(System.Object)">
			<summary><i>- : G &#215; G &#8594; G</i>
 <para/>
 The operation &quot;<i>-</i>&quot; is not in the definition of of an additive group but can be deduced.
 This function is provided for convenience purpose. It is equivalent to
 <blockquote><c>this.add(that.opposite())</c></blockquote>.</summary>
			<param name="that">the object to be subtracted (subtrahend)</param>
			<returns><i>this - that</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.AbelianGroup.opposite">
			<summary>For each <i>a</i> in <i>G</i>, there exists an element <i>b</i> in <i>G</i> such that
 <i>a + b = b + a = 0</i>.
 That is, it is the object such as
 <blockquote><c>this.add(this.opposite()) == this.ZERO</c></blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/additive_inverse"> Wikipedia: Additive inverse</a></summary>
			<returns><i>-this</i>, the additive opposite</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.algebra.structure.AbelianGroup.ZERO">
			<summary>The additive element 0 in the group, such that for all elements <i>a</i> in the group,
 the equation <i>0 + a = a + 0 = a</i> holds.</summary>
			<returns><i>0</i>, the additive identity</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.LeastSquares">
			<summary>This method obtains a least squares estimate of a polynomial to fit the input data, by a weighted
 sum of orthogonal polynomials up to a specified order. That is,
 \[
 f(x) \approx f_n(x) = a_1 \phi_1(x) + a_2 \phi_2(x) + \cdots + a_n \phi_n (x)
 \]
 where \(\left\{\phi_i(x)\right\}\) are a set of orthogonal polynomials. The idea behind this is
 to avoid ill-conditioned linear algebra that arises when fitting coefficients of the target
 polynomial.
 <para/>
 Unlike interpolation, this method does not guarantee that the fitted curve will pass through each
 point (unless the order of the polynomial is equal to the number of data points) and it is hence
 appropriate to use with observations that include noise.<para> See also: </para><a href="http://en.wikipedia.org/wiki/least_squares_(function_approximation)">Wikipedia:
 Least squares (function approximation)</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.curvefit.LeastSquares.UNIFORM_WEIGHTING">
			<summary>A uniform weighting.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.LeastSquares.#ctor(System.Int32,com.numericalmethod.suanshu.analysis.curvefit.LeastSquares.Weighting)">
			<summary>Construct a new instance of this algorithm, which will use a weighted sum of orthogonal
 polynomials up to order <i>n</i> (the number of points).</summary>
			<param name="m">the maximum degree of the orthogonal polynomials (<i>m &#8804; n</i>)</param>
			<param name="weighting">the function used to determine the weight for each observation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.LeastSquares.#ctor(System.Int32)">
			<summary>Construct a new instance of this algorithm, which uses uniform weighting for the
 observations.</summary>
			<param name="m">the maximum order of the orthogonal polynomials</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.LeastSquares.fit(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.LeastSquares.Weighting">
			<summary>This interface defines a weighting for observations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.LeastSquares.Weighting.getWeightForObservation(System.Double,System.Double)">
			<summary>Specify the weight given to a particular observation. Most commonly uniform weighting is
 used.</summary>
			<param name="x">the independent variable in the observation</param>
			<param name="y">the dependent variable in the observation</param>
			<returns>the weight assigned to this particular observation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.CurveFitting">
			<summary>Curve fitting is the process of constructing a curve, or mathematical function, that has the best
 fit to a series of data points, possibly subject to constraints. Curve fitting can involve either
 interpolation, where an exact fit to the data is required, or smoothing, in which a &quot;smooth&quot;
 function is constructed that approximately fits the data.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.CurveFitting.fit(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary>Fit a real valued function from a discrete set of data points.</summary>
			<param name="f">a discrete set of data points</param>
			<returns>the fitted function</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.PartialDerivativesByCenteredDifferencing">
			<summary>This implementation computes the partial derivatives by centered differencing. That is,
 \[
 \frac{\partial z}{\partial x} = \frac{z_{i+1, j} - z_{i-1, j}}{x_{i+1} - x_{i-1}} \\
 \frac{\partial z}{\partial y} = \frac{z_{i, j+1} - z_{i, j-1}}{y_{j+1} - y_{j-1}} \\
 \frac{\partial^2 z}{\partial x \partial y} =
 \frac{z_{i+1,j+1}-z_{i+1,j-1}-z_{i-1,j+1}+z_{i-1,j-1}}{(x_{i+1}-x_{i-1})(y_{j+1}-y_{j-1})}
 \]
 At the points on the boundaries, one-sided differences are used.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.PartialDerivativesByCenteredDifferencing.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.PartialDerivativesByCenteredDifferencing.dx(com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid,System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.PartialDerivativesByCenteredDifferencing.dy(com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid,System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.PartialDerivativesByCenteredDifferencing.dxdy(com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid,System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid">
			<summary>A regular grid is a tessellation of n-dimensional Euclidean space by congruent parallelotopes
 (e.g. bricks), meaning that grid points are <em>equally-spaced</em>. This is a special case of
 rectilinear grid. This implementation is backed by a two-dimensional array.<para> See also: </para><a href="http://en.wikipedia.org/wiki/regular_grid">Wikipedia: Regular grid</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid.#ctor(System.Double[][],System.Double,System.Double,System.Double,System.Double)">
			<summary>Create a new grid where the dependent variable values are taken from the given
 two-dimensional array and the values of the dependent variables are specified by their first
 values and the difference between successive values.
 <para/>
 The first index for the input array will be corresponding to <i>x</i> and the second index to
 <i>y</i> and the size will be inferred from the size of the array.</summary>
			<param name="z">the two-dimensional array containing the values of the dependent variable</param>
			<param name="x0">the first value of the independent variable <i>x</i></param>
			<param name="y0">the first value of the independent variable <i>y</i></param>
			<param name="deltaX">the distance between adjacent points along the x-axis</param>
			<param name="deltaY">the distance between adjacent points along the y-axis</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid.z(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid.x">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid.y">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid.x(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid.y(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid.sizeX">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid.sizeY">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid.x0">
			<summary>Get the value of <i>x<sub>0</sub></i>, the first value of the independent variable <i>x</i>.</summary>
			<returns><i>x<sub>0</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid.y0">
			<summary>Get the value of <i>y<sub>0</sub></i>, the first value of the independent variable <i>y</i>.</summary>
			<returns><i>y<sub>0</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid.deltaX">
			<summary>Return the distance between two adjacent points along the x-axis.</summary>
			<returns>\(\delta_x\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateRegularGrid.deltaY">
			<summary>Return the distance between two adjacent points along the y-axis.</summary>
			<returns>\(\delta_y\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGridInterpolation">
			<summary>A bivariate interpolation, which requires the input to form a <em>rectilinear</em> grid. This
 requirement is imposed by most higher-order methods. Other methods exist but their performance is
 generally inferior.<para> See also: </para><a href="http://http://en.wikipedia.org/wiki/interpolation">Wikipedia: Interpolation</a><para> See also: </para>BivariateGrid</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGridInterpolation.interpolate(com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid)">
			<summary>Construct a real valued function from a grid of observations.</summary>
			<param name="grid">the grid of observations</param>
			<returns>the interpolated function</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid">
			<summary>A <em>rectilinear</em> (meaning that grid lines are not necessarily equally-spaced) bivariate
 grid of <c>double</c> values. The independent variables are labeled <i>x</i> and <i>y</i>, and
 the dependent variable is labeled <i>z</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid.z(System.Int32,System.Int32)">
			<summary>Get the value of the dependent variable <i>z</i> at the given indices in the grid.</summary>
			<param name="i">the index along the x-axis</param>
			<param name="j">the index along the y-axis</param>
			<returns><i>z(x<sub>i</sub>, <i>y<sub>j</sub></i>)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid.x(System.Int32)">
			<summary>Get the value of <i>x<sub>i</sub></i>, the i-th value of the independent variable <i>x</i>.</summary>
			<param name="i">the index</param>
			<returns><i>x<sub>i</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid.x">
			<summary>Get the values of the independent variable <i>x<sub>i</sub></i>.</summary>
			<returns><i>x<sub>i</sub></i>&apos;s</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid.y(System.Int32)">
			<summary>Get the value of <i>y<sub>j</sub></i>, the j-th value of the independent variable <i>y</i>.</summary>
			<param name="j">the index</param>
			<returns><i>y<sub>j</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid.y">
			<summary>Get the values of the independent variable <i>y<sub>j</sub></i>.</summary>
			<returns><i>y<sub>j</sub></i>&apos;s</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid.sizeX">
			<summary>Define the size of the grid along the x-axis. That is, the number of points along the x-axis.</summary>
			<returns>the size along the x-axis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid.sizeY">
			<summary>Define the size of the grid along the y-axis. That is, the number of points along the y-axis.</summary>
			<returns>the size along the y-axis</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateArrayGrid">
			<summary>Implementation of <para></para>BivariateGrid, backed by arrays.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateArrayGrid.#ctor(System.Double[][],System.Double[],System.Double[])">
			<summary>Create a new grid with a given two-dimensional array of grid values, and values for grid line
 positions along the x-axis and the y-axis.</summary>
			<param name="z">the grid values</param>
			<param name="x">the grid line positions along the x-axis</param>
			<param name="y">the grid line positions along the y-axis</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateArrayGrid.z(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateArrayGrid.x">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateArrayGrid.y">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateArrayGrid.x(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateArrayGrid.y(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateArrayGrid.sizeX">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateArrayGrid.sizeY">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BilinearInterpolation">
			<summary>Bilinear interpolation is the 2-dimensional equivalent of linear interpolation. The algorithm
 first does linear interpolation in the x-direction at the desired <i>x</i> position on the two
 enclosing horizontal grid lines (say, <i>y<sub>1</sub></i> and <i>y<sub>2</sub></i>), then does
 another linear interpolation using these two interpolated points to interpolate the value at
 <i>(x, y)</i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/bilinear_interpolation">Wikipedia: Bilinear
 interpolation</a><para> See also: </para>LinearInterpolation</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BilinearInterpolation.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BilinearInterpolation.interpolate(com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BicubicSpline">
			<summary>Bicubic splines are the two-dimensional equivalent of cubic splines. In this two-dimensional
 case, for each of the <i>N</i> columns of grid values, an one-dimensional spline
 <i>z(x<sub>i</sub>, y)</i> is constructed. To interpolate the value of a point <i>(a, b)</i>,
 <i>N</i> values at <i>b</i> (i.e., <i>z(x<sub>i</sub>, b)</i>) are first obtained from the column
 splines, Then, an one-dimensional cubic spline interpolation is performed on those <i>N</i>
 values to interpolate the value at <i>(a, b)</i> (i.e., <i>z(a, b)</i>).
 <para/>
 Like in the one-dimensional case, natural splines are constructed.<para> See also: </para>CubicSpline</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BicubicSpline.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BicubicSpline.interpolate(com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BicubicInterpolation">
			<summary>Bicubic interpolation is the two-dimensional equivalent of cubic Hermite spline interpolation.
 For a given point, a piecewise interpolation is performed using smooth cubic splines which are
 fitted using the four surrounding points and their partial- and cross-derivatives.
 <para/>
 Like in the one-dimensional case, this method allows the user to specify the derivatives, which
 will control the shape of the interpolated surface.<para> See also: </para><a href="http://en.wikipedia.org/wiki/bicubic_interpolation">Wikipedia: Bicubic
 interpolation</a><para> See also: </para>CubicHermite</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BicubicInterpolation.#ctor">
			<summary>Create a new instance which computes the partial derivatives using
 <para></para>PartialDerivativesByCenteredDifferencing.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BicubicInterpolation.#ctor(com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BicubicInterpolation.PartialDerivatives)">
			<summary>Create a new instance which uses the given derivatives to interpolate. Note that the
 derivatives need not necessarily be exactly correct, but will be the derivatives present in
 the interpolated surface.</summary>
			<param name="derivatives">the derivatives used for the interpolation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BicubicInterpolation.interpolate(com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BicubicInterpolation.PartialDerivatives">
			<summary>Specify the partial derivatives defined at points on a <para></para>BivariateGrid.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BicubicInterpolation.PartialDerivatives.dx(com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid,System.Int32,System.Int32)">
			<summary>Get the partial derivative \(\frac{\partial z}{\partial x}\), at the given position in
 the grid.</summary>
			<param name="grid">the grid for which to get the partial derivative</param>
			<param name="i">the index along the x-axis</param>
			<param name="j">the index along the y-axis</param>
			<returns>\(\frac{\partial z}{\partial x}\) at the given point</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BicubicInterpolation.PartialDerivatives.dy(com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid,System.Int32,System.Int32)">
			<summary>Get the partial derivative \(\frac{\partial z}{\partial y}\), at the given position in
 the grid.</summary>
			<param name="grid">the grid for which to get the partial derivative</param>
			<param name="i">the index along the x-axis</param>
			<param name="j">the index along the y-axis</param>
			<returns>\(\frac{\partial z}{\partial y}\) at the given point</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BicubicInterpolation.PartialDerivatives.dxdy(com.numericalmethod.suanshu.analysis.curvefit.interpolation.bivariate.BivariateGrid,System.Int32,System.Int32)">
			<summary>Get the cross derivative \(\frac{\partial^2 z}{\partial x \partial y}\), at the given
 position in the grid.</summary>
			<param name="grid">the grid for which to get the partial derivative</param>
			<param name="i">the index along the x-axis</param>
			<param name="j">the index along the y-axis</param>
			<returns>\(\frac{\partial^2 z}{\partial x \partial y}\) at the given point</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.OnlineInterpolator">
			<summary>An online interpolator allows dynamically adding more points for interpolation.
 Note: the function is no longer immutable.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.OnlineInterpolator.addData(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary>Add more points for interpolation.</summary>
			<param name="f">the points to be interpolated</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.NevilleTable">
			<summary>Neville&apos;s algorithm is a polynomial interpolation algorithm.
 Given <i>n + 1</i> points, there is a unique polynomial of degree &#8804; <i>n</i> which associates
 with them.
 Neville&apos;s algorithm evaluates this polynomial for a given input <i>x</i>.
 <para/>
 This implementation is based on filling out the Neville table. This table can be used in two
 ways.
 First, it can be used to compute the interpolated function <i>f(x)</i>.
 Second, it can be used in an incremental manner by adding a few, say one, data points each time
 to allow for examination of the table values.<para> See also: </para><a href="http://en.wikipedia.org/wiki/neville_algorithm">Wikipedia: Neville&apos;s algorithm</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.NevilleTable.#ctor(System.Int32,com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary>Construct a Neville table of size <i>n</i>, initialized with data <i>{(x, y)}</i>.
 The size <i>n</i> is only indicative. If there are more data points than <i>n</i>, the table
 size grows accordingly.</summary>
			<param name="n">indicative size; make this big for reservation to add new data points</param>
			<param name="f">the points to be interpolated</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.NevilleTable.#ctor(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary>Construct a Neville table of size <i>n</i>, initialized with data <i>{(x, y)}</i>.</summary>
			<param name="f">the points to be interpolated</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.NevilleTable.#ctor">
			<summary>Construct an empty Neville table.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.NevilleTable.addData(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.NevilleTable.N">
			<summary>Get the number of data points.</summary>
			<returns>the number of data points</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.NevilleTable.getTable">
			<summary>Get a copy of the Neville table.</summary>
			<returns>a copy of the table</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.NevilleTable.x">
			<summary>Get a copy of the <i>x</i>&apos;s.</summary>
			<returns>a copy of <i>x</i>&apos;s.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.NevilleTable.get(System.Int32,System.Int32)">
			<summary>Get the value of a table entry.</summary>
			<param name="i">row index, counting from 0</param>
			<param name="j">column index, counting from 0</param>
			<returns>the value of the table entry</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.NevilleTable.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.LinearInterpolator">
			<summary>Define a univariate function by linearly interpolating between adjacent points.<para> See also: </para><a href="http://en.wikipedia.org/wiki/linear_interpolation">Wikipedia: Linear
 interpolation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.LinearInterpolator.#ctor(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary>Construct a univariate function by linearly interpolating between adjacent points.</summary>
			<param name="f">the points to be interpolated</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.LinearInterpolator.addData(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.LinearInterpolator.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.RecursiveGridInterpolation">
			<summary>This algorithm works by recursively calling lower order interpolation (hence the cost is
 exponential), until the given univariate algorithm can be used when the remaining dimension
 becomes one.
 <para/>
 This general algorithm, together with any given univariate interpolation algorithm, works for an
 arbitrary number of dimensions.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.RecursiveGridInterpolation.#ctor(com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.Interpolation)">
			<summary>Create an n-dimensional interpolation with a given univariate interpolation algorithm.</summary>
			<param name="univariate">the univariate interpolation algorithm</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.RecursiveGridInterpolation.interpolate(com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateGrid)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateRegularGrid">
			<summary>A regular grid is a tessellation of n-dimensional Euclidean space by congruent parallelotopes
 (e.g. bricks), meaning that grid points are <em>equally-spaced</em>. This is a special case of
 rectilinear grid. This implementation is backed by a <para></para>MultivariateArrayGrid.<para> See also: </para><a href="http://en.wikipedia.org/wiki/regular_grid">Wikipedia: Regular grid</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateRegularGrid.#ctor(com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalCollection,com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateRegularGrid.EquallySpacedVariable[])">
			<summary>Create a new instance where the dependent variable is specified by a
 <para></para>MultiDimensionalCollection and the independent variables form the specified grid.</summary>
			<param name="y">the values of the dependent variable</param>
			<param name="x">each element specifies the independent variables along one dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateRegularGrid.y(System.Int32[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateRegularGrid.x(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateRegularGrid.x(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateRegularGrid.size(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateRegularGrid.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateRegularGrid.x0(System.Int32)">
			<summary>Get the value of \(\mathbf{x_i}_0\), the first value of the independent variable \(x_i\).
 The value of \(x_i_j\) can be computed as \(x_i_0 + (j\times\delta_{x_i})\).</summary>
			<param name="i">the dimension index of the independent variable <i>x<sub>i</sub></i></param>
			<returns>\(x_i_0\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateRegularGrid.deltaX(System.Int32)">
			<summary>Get the distance between two adjacent points along the axis with the given index.</summary>
			<param name="i">the dimension index of the independent variable <i>x<sub>i</sub></i></param>
			<returns>\(\delta_{x_i}\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateRegularGrid.EquallySpacedVariable">
			<summary>Specify the positioning and spacing along one dimension.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateRegularGrid.EquallySpacedVariable.#ctor(System.Double,System.Double)">
			<summary>Create a new instance which specifies the position of the first element and the spacing
 along a dimension as the given values.</summary>
			<param name="x0">the position of the first element along the dimension</param>
			<param name="deltaX">the spacing between two adjacent elements along the dimension</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateGridInterpolation">
			<summary>Interpolation on a <em>rectilinear</em> multi-dimensional grid.
 <para/>
 This requirement is imposed by most higher-order methods. Other methods exist but their
 performance is generally inferior.<para> See also: </para><a href="http://en.wikipedia.org/wiki/multivariate_interpolation">Wikipedia: Multivariate
 interpolation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateGridInterpolation.interpolate(com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateGrid)">
			<summary>Construct a real valued function from a grid of observations.</summary>
			<param name="grid">the grid of observations</param>
			<returns>the interpolated function</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateGrid">
			<summary>A multivariate <em>rectilinear</em> (not necessarily uniform) grid of <c>double</c> values. The
 independent variables are labeled <i>x<sub>i</sub></i> and the dependent variable is <i>y</i>.
 Each independent variable adds another dimension to the grid.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateGrid.y(System.Int32[])">
			<summary>Get the value of the dependent variable <i>y</i> at the given indices in the grid.</summary>
			<param name="indices">the indices of the independent variables in the grid</param>
			<returns>\(y(\mathbf{x})\), the value of the dependent variable at \(\mathbf{x}\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateGrid.x(System.Int32,System.Int32)">
			<summary>Get the value of the independent variable <i>x<sub>i</sub></i> at the given index.</summary>
			<param name="i">the dimension index of the independent variable <i>x<sub>i</sub></i></param>
			<param name="j">the index of the value in the specified dimension <i>x<sub>i</sub></i></param>
			<returns>\(x_i_j\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateGrid.x(System.Int32)">
			<summary>Get all the values of the independent variable <i>x<sub>i</sub></i> as an array.</summary>
			<param name="i">the dimension index of the independent variable <i>x<sub>i</sub></i></param>
			<returns>\(x_i\)&apos;s</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateGrid.size(System.Int32)">
			<summary>Get the size of the grid in the given dimension <i>x<sub>i</sub></i>.</summary>
			<param name="i">the dimension index of the independent variable <i>x<sub>i</sub></i></param>
			<returns>the size of the dimension</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateGrid.dimension">
			<summary>Get the total number of dimensions of the grid.</summary>
			<returns>the number of dimensions</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateArrayGrid">
			<summary>Implementation of <para></para>MultivariateGrid, backed by the given
 <para></para>MultiDimensionalCollection instance.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateArrayGrid.#ctor(com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalCollection,System.Double[][])">
			<summary>Create a new instance where the dependent variable is specified by a
 <para></para>MultiDimensionalCollection and the independent variables form the specified grid.</summary>
			<param name="y">the values of the dependent variable</param>
			<param name="x">each element specifies the grid of independent variables along one dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateArrayGrid.y(System.Int32[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateArrayGrid.x(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateArrayGrid.x(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateArrayGrid.size(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultivariateArrayGrid.dimension">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultiLinearInterpolation">
			<summary>Implementation of linear interpolation for an arbitrary number of dimensions. The algorithm works
 by recursively calling lower order <para></para>LinearInterpolation linear interpolation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultiLinearInterpolation.#ctor">
			<summary>Create an instance with <para></para>LinearInterpolation as the implementation of the univariate
 linear interpolation algorithm.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultiCubicSpline">
			<summary>Implementation of natural cubic spline interpolation for an arbitrary number of dimensions. The
 algorithm works by recursively calling lower order
 <para></para>CubicSpline cubic spline interpolation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.multivariate.MultiCubicSpline.#ctor">
			<summary>Create an instance with <para></para>CubicSpline as the implementation of the univariate cubic
 spline interpolation algorithm.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.NewtonPolynomial">
			<summary>Newton polynomial is the interpolation polynomial for a given set of data points in the Newton
 form. Given a set of (<i>k+1</i>) data points
 \[
 (x_0, y_0),\ldots,(x_k, y_k),
 \]
 the Newton form can be written as
 \[
 N(x) = [y_0] + [y_0,y_1](x-x_0) + \cdots + [y_0,\ldots,y_k](x-x_0)(x-x_1)\cdots(x-x_{k-1})
 \]
 where \([y_0,\ldots,y_j]\) is the notation for divided differences.<para> See also: </para><a href="http://en.wikipedia.org/wiki/newton_polynomial">Wikipedia: Newton polynomial</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.NewtonPolynomial.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.NewtonPolynomial.fit(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.LinearInterpolation">
			<summary>(Piecewise-)Linear interpolation fits a curve by interpolating linearly between two adjacent
 data-points. For points on the curve which lie outside the data, the nearest segment is used (for
 extrapolation).<para> See also: </para><a href="http://en.wikipedia.org/wiki/linear_interpolation">Wikipedia: Linear
 Interpolation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.LinearInterpolation.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.LinearInterpolation.fit(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.Interpolation">
			<summary>Interpolation is a method of constructing new data points within the range of a discrete set of
 known data points. In engineering and science, one often has a number of data points, obtained by
 sampling or experimentation, which represent the values of a function for a limited number of
 values of the independent variable. It is often required to interpolate (i.e. estimate) the value
 of that function for an intermediate value of the independent variable.
 <para/>
 This interface extends from <para></para>CurveFitting as interpolation is a special case of curve
 fitting that the interpolated function must pass through all the given points. Hence, this
 interface declares no extra method, and is just used to state the property of the output
 function.<para> See also: </para><a href="http://en.wikipedia.org/wiki/interpolation">Wikipedia: Interpolation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.Interpolation.fit(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary>
 <para/>
 The interpolated function must pass through all the given points.</summary>
			<param name="f"></param>
			<returns>the interpolated function</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.DividedDifferences">
			<summary>Divided differences is recursive division process for calculating the coefficients in the
 interpolation polynomial in the Newton form.<para> See also: </para><a href="http://en.wikipedia.org/wiki/divided_differences">Wikipedia: Divided
 differences</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.DividedDifferences.#ctor(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary>Construct divided differences from a given collection of ordered pairs.</summary>
			<param name="pairs">the collection of ordered pairs</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.DividedDifferences.#ctor(com.numericalmethod.suanshu.analysis.function.tuple.SortedOrderedPairs)">
			<summary>Construct divided differences from a given sorted collection of ordered pairs.</summary>
			<param name="sortedPairs">the sorted collection of ordered pairs</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.DividedDifferences.getDifference(System.Int32)">
			<summary>Get the divided difference of the given order.</summary>
			<param name="order">the order of divided difference</param>
			<returns>the divided difference</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.DividedDifferences.maxOrder">
			<summary>Get the maximum order which is limited by the number of points given for the computation.</summary>
			<returns>the maximum order of difference</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicSpline">
			<summary>The (natural) cubic spline interpolation fits a cubic polynomial between each pair of adjacent
 points such that adjacent cubics are continuous in their first and second derivative.
 <para/>
 This implementation fits <em>natural</em> splines, meaning that the second derivative at both
 ends are zero.<para> See also: </para><a href="http://en.wikipedia.org/wiki/natural_cubic_spline">Wikipedia: Spline
 interpolation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicSpline.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicSpline.fit(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicHermite">
			<summary>Cubic Hermite spline interpolation is a piecewise spline interpolation, in which each polynomial
 is in Hermite form which consists of two control points and two control tangents.
 <para/>
 Unlike <para></para>CubicSpline interpolation, where the interpolated splines depend on each point,
 this method performs piecewise interpolation. The method for computing the control tangents is
 non-unique and various approaches exist.<para> See also: </para><a href="http://en.wikipedia.org/wiki/cubic_interpolation">Wikipedia: Cubic Hermite
 spline</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicHermite.#ctor">
			<summary>Construct an instance with <para></para>Tangents#CATMULL_ROM as the method for computing tangents.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicHermite.#ctor(com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicHermite.Tangent)">
			<summary>Construct an instance with the given method to compute tangents.</summary>
			<param name="tangent">computes the control tangents used for the interpolation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicHermite.fit(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicHermite.Tangent">
			<summary>The method for computing the control tangent at a given index. A variety of methods
 exist, which will affect the shape and properties of the interpolated function (such as
 preserving monotonicity).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicHermite.Tangent.tangentAt(com.numericalmethod.suanshu.analysis.function.tuple.SortedOrderedPairs,System.Int32)">
			<summary>Compute the tangent at the given index <i>k</i>, from the given collection of points.</summary>
			<param name="pairs">the points from which the tangent is computed</param>
			<param name="k">the point index at which the tangent is computed</param>
			<returns>the tangent at the k-th point</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicHermite.Tangents">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicHermite.Tangents.CATMULL_ROM">
			<summary>Catmull-Rom splines are a special case of Cardinal splines and are defined as:
 \[
 (\frac{\partial y}{\partial x})_k = \frac{y_{k+1} - y_{k-1}}{x_{k+1} - x_{k-1}}.
 \]
 At the boundaries, two adjacent points are used instead.<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/cubic_interpolation#catmull.e2.80.93rom_spline">
 Wikipedia: Cubic Hermite spline - Catmull-Rom spline</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicHermite.Tangents.FINITE_DIFFERENCE">
			<summary>The simplest choice is the three-point difference, not requiring constant interval
 lengths. The tangent at point k is defined as:
 \[
 m_k = \frac{y_{k+1}-y_k}{2(x_{k+1}-x_{k})} + \frac{y_k-y_{k-1}}{2(x_k-x_{k-1})}
 \]
 for internal points, and one-sided difference at the endpoints.<para> See also: </para><a href="http://en.wikipedia.org/wiki/cubic_interpolation#finite_difference">
 Wikipedia: Cubic Hermite spline - Finite difference</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicHermite.Tangents.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.curvefit.interpolation.univariate.CubicHermite.Tangents.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.differentiability.C2">
			<summary>A function, <i>f</i>, is said to be of class C<sup>2</sup> if the first and second derivatives, <i>f&apos;</i> and <i>f&apos;&apos;</i>, exist.<para> See also: </para><a href="http://en.wikipedia.org/wiki/smooth_function">Wikipedia: Smooth function</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.differentiability.C2.H">
			<summary>Get the Hessian matrix function, <i>H</i>, of a real valued function <i>f</i>.</summary>
			<returns>the Hessian matrix function</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.differentiability.C1">
			<summary>A function, <i>f</i>, is said to be of class C<sup>1</sup> if the derivative <i>f&apos;</i> exists.<para> See also: </para><a href="http://en.wikipedia.org/wiki/smooth_function">Wikipedia: Smooth function</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.differentiability.C1.g">
			<summary>Get the gradient function, <i>g</i>, of a real valued function <i>f</i>.</summary>
			<returns>the gradient function</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.multivariate.MultivariateFiniteDifference">
			<summary>A partial derivative of a multivariate function is the derivative with respect to one of the variables with the others held constant.
 This implementation applies recursively the (first order) finite difference on the function.
 For example,
 \[
 {\partial^2 \over \partial x_1 \partial x_2} = {\partial \over \partial x_2}({\partial \over \partial x_1})
 \]

 Each of the two univariate derivatives is computed using the central difference method.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/partial_derivative">Wikipedia: Partial derivative</a></item>
 <item><a href="http://en.wikipedia.org/wiki/finite_difference">Wikipedia: Finite difference</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.MultivariateFiniteDifference.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,System.Int32[])">
			<summary>Construct the partial derivative of a multi-variable function.
 <para/>
 For example,
 <c>varidx = new int[]{1, 2}</c> means
 \[
 f_{x_1,x_2} = {\partial^2 \over \partial x_1 \partial x_2} = {\partial \over \partial x_2}({\partial \over \partial x_1})
 \]</summary>
			<param name="f">the real multivariate function to take derivative of</param>
			<param name="varidx">the variable indices of the derivative, counting from 1 up to the domain dimension of <i>f</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.MultivariateFiniteDifference.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Evaluate numerically the partial derivative of <i>f</i> at point <i>x</i>.
 <para/>
 Make sure that <i>h</i> and <i>x+h</i> are representable in floating point precision
 so that the difference between <i>x+h</i> and <i>x</i> is exactly <i>h</i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/numerical_differentiation#practical_considerations">Wikipedia: Practical considerations</a></summary>
			<param name="x">the point to evaluate the derivative at</param>
			<returns>the numerical partial derivative of <i>f</i> at point <i>x</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.MultivariateFiniteDifference.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Evaluate numerically the partial derivative of <i>f</i> at point <i>x</i> with step size <i>h</i>.
 It could be challenging to automatically determine the step size <i>h</i>, esp. when <i>|x|</i> is near 0.
 It may, for example, require an analysis that involves <i>f&apos;</i> and <i>f&apos;&apos;</i>.
 The user may want to experiment with different <i>h</i>s by calling this function.</summary>
			<param name="x">the point to evaluate the derivative of <i>f</i> at</param>
			<param name="h">the step size</param>
			<returns>the numerical partial derivative of <i>f</i> at point <i>x</i> with step size <i>h</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.multivariate.JacobianFunction">
			<summary>The Jacobian function, <i>J(x)</i>, evaluates the Jacobian of a real vector-valued function <i>f</i> at a point <i>x</i>.
 <i>J(x)</i> has the same domain as <i>f(x)</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.JacobianFunction.#ctor(com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction)">
			<summary>Construct the Jacobian function of a real scalar function <i>f</i>.</summary>
			<param name="f">a real scalar function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.JacobianFunction.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.JacobianFunction.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.JacobianFunction.dimensionOfRange">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.multivariate.Jacobian">
			<summary>The Jacobian matrix is the matrix of all first-order partial derivatives of a vector-valued function.
 For a <i>R<sup>n</sup>-&gt;R<sup>m</sup></i> function, we have a \(m \times n\) matrix.
 \[
 J=\begin{bmatrix} \dfrac{\partial y_1}{\partial x_1} &amp; \cdots &amp; \dfrac{\partial y_1}{\partial x_n} \\ \vdots &amp; \ddots &amp; \vdots \\ \dfrac{\partial y_m}{\partial x_1} &amp; \cdots &amp; \dfrac{\partial y_m}{\partial x_n} \end{bmatrix}
 \]
 <para/>
 This implementation computes the Jacobian matrix numerically using the finite difference method.<para> See also: </para><a href="http://en.wikipedia.org/wiki/jacobian_matrix_and_determinant">Wikipedia: Jacobian matrix and determinant</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.Jacobian.#ctor(com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct the Jacobian matrix for a multivariate function <i>f</i> at point <i>x</i>.</summary>
			<param name="f">a multivariate function</param>
			<param name="x">the point to evaluate the Jacobian matrix at</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.Jacobian.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct the Jacobian matrix for a multivariate function <i>f</i> at point <i>x</i>.</summary>
			<param name="f">a multivariate function in the form of an array of univariate functions</param>
			<param name="x">the point to evaluate the Jacobian matrix at</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.Jacobian.#ctor(java.util.List,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct the Jacobian matrix for a multivariate function <i>f</i> at point <i>x</i>.</summary>
			<param name="f">a multivariate function in the form of a list of univariate functions</param>
			<param name="x">the point to evaluate the Jacobian matrix at</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.multivariate.HessianFunction">
			<summary>The Hessian function, <i>H(x)</i>, evaluates the Hessian of a real scalar function <i>f</i> at a point <i>x</i>.
 <i>H(x)</i> has the same domain as <i>f(x)</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.HessianFunction.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary>Construct the Hessian function of a real scalar function <i>f</i>.</summary>
			<param name="f">a real scalar function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.HessianFunction.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.HessianFunction.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.HessianFunction.dimensionOfRange">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.multivariate.Hessian">
			<summary>The Hessian matrix is the square matrix of the second-order partial derivatives of a multivariate function.
 Mathematically, the Hessian of a scalar function is an \(n \times n\) matrix,
 where <i>n</i> is the domain dimension of <i>f</i>.
 For a scalar function <i>f</i>, we have
 \[
 H(f) = \begin{bmatrix}
 \frac{\partial^2 f}{\partial x_1^2} &amp; \frac{\partial^2 f}{\partial x_1\,\partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_1\,\partial x_n} \\ \\
 \frac{\partial^2 f}{\partial x_2\,\partial x_1} &amp; \frac{\partial^2 f}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_2\,\partial x_n} \\ \\
 \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ \\
 \frac{\partial^2 f}{\partial x_n\,\partial x_1} &amp; \frac{\partial^2 f}{\partial x_n\,\partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_n^2}
 \end{bmatrix}
 \]
 <para/>
 This implementation computes the Hessian matrix numerically using the finite difference method.
 We assume that the function <i>f</i> is continuous so the Hessian matrix is square and symmetric.<para> See also: </para><a href="http://en.wikipedia.org/wiki/hessian_matrix">Wikipedia: Hessian matrix</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.Hessian.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct the Hessian matrix for a multivariate function <i>f</i> at point <i>x</i>.</summary>
			<param name="f">a multivariate function</param>
			<param name="x">the point to evaluate the Hessian of <i>f</i> at</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.multivariate.GradientFunction">
			<summary>The gradient function, <i>g(x)</i>, evaluates the gradient of a real scalar function <i>f</i> at a point <i>x</i>.
 <i>g(x)</i> has the same domain as <i>f(x)</i>. Its range dimension is the same as the domain dimension.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.GradientFunction.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary>Construct the gradient function of a real scalar function <i>f</i>.</summary>
			<param name="f">a real scalar function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.GradientFunction.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.GradientFunction.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.GradientFunction.dimensionOfRange">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.multivariate.Gradient">
			<summary>The gradient of a scalar field is a vector field which points in the direction of the greatest
 rate of increase of the scalar field, and of which the magnitude is the greatest rate of change.
 Mathematically, the gradient of a scalar function is a vector of size <i>n</i>, where <i>n</i> is
 the domain dimension of <i>f</i>.
 \[
 \nabla{f} = {\partial f \over \partial x_1}, \dots, {\partial f \over \partial x_n}
 \]
 The gradient vector is computed numerically using the finite difference method, e.g.,
 <para></para>MultivariateFiniteDifference.<para> See also: </para><a href="http://en.wikipedia.org/wiki/gradient">Wikipedia: Gradient</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.Gradient.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct the gradient vector for a multivariate function <i>f</i> at point <i>x</i>.</summary>
			<param name="f">a multivariate function</param>
			<param name="x">the point to evaluate the gradient of <i>f</i> at</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.multivariate.BorderedHessian">
			<summary>A bordered Hessian matrix consists of the Hessian of a multivariate function <i>f</i>,
 and the gradient of a multivariate function <i>g</i>.
 We assume that the function <i>f</i> is continuous so that the bordered Hessian matrix is square
 and symmetric.
 For scalar functions <i>f</i> and <i>g</i>, we have
 \[
 H(f,g) = \begin{bmatrix}
 0 &amp; \frac{\partial g}{\partial x_1} &amp; \frac{\partial g}{\partial x_2} &amp; \cdots &amp; \frac{\partial
 g}{\partial x_n} \\ \\
 \frac{\partial g}{\partial x_1} &amp; \frac{\partial^2 f}{\partial x_1^2} &amp; \frac{\partial^2
 f}{\partial x_1\,\partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_1\,\partial x_n} \\ \\
 \frac{\partial g}{\partial x_2} &amp; \frac{\partial^2 f}{\partial x_2\,\partial x_1} &amp;
 \frac{\partial^2 f}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_2\,\partial x_n} \\
 \\
 \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ \\
 \frac{\partial g}{\partial x_n} &amp; \frac{\partial^2 f}{\partial x_n\,\partial x_1} &amp;
 \frac{\partial^2 f}{\partial x_n\,\partial x_2} &amp; \cdots &amp; \frac{\partial^2 f}{\partial x_n^2}
 \end{bmatrix}
 \]
 <para/>
 This implementation computes the bordered Hessian matrix numerically using the finite difference
 method.<para> See also: </para><a href="http://en.wikipedia.org/wiki/hessian_matrix#bordered_hessian">Wikipedia: Bordered
 Hessian</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.multivariate.BorderedHessian.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct the bordered Hessian matrix for multivariate functions <i>f</i> and <i>g</i> at
 point <i>x</i>.
 The dimension is \((n+1) \times (n+1)\),
 where <i>n</i> is the domain dimension of both <i>f</i> and <i>g</i>.</summary>
			<param name="f">a multivariate function, usually an objective function</param>
			<param name="g">a multivariate function, usually a constraint function</param>
			<param name="x">the point to evaluate the bordered Hessian at</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.Ridders">
			<summary>Ridders&apos; method computes the numerical derivative of a function.
 In general it gives a higher precision than the simple finite differencing method,
 c.f., <para></para>com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference.
 Ridders&apos; method tries a sequence of decreasing <i>h</i>&apos;s to compute the derivatives,
 and then extrapolate to zero using Neville&apos;s algorithm.
 The choice of the initial <i>h</i> is critical.
 If <i>h</i> is too big, the value computed could be inaccurate.
 If <i>h</i> is too small, due to rounding error, we might be computing the &quot;same&quot; value over and over again for different <i>h</i>&apos;s.<para> See also: </para>&quot;C. J. F. Ridders, &quot;Accurate computation of F&apos;(x) and F&apos;&apos;(x),&quot; in Adv. Eng. Sftw., 4, 75-76. 1982.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.Ridders.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Int32,System.Double,System.Int32)">
			<summary>Construct the derivative function of a univariate function using Ridder&apos;s method.</summary>
			<param name="f">the <para></para>UnivariateRealFunction to take derivative of</param>
			<param name="order">the order of differentiation</param>
			<param name="rate">the rate at which the increment <i>h</i> decreases; <c>rate</c> should be a simple number such as 0.75, not like 0.66666666666...</param>
			<param name="discretization">the number of points for extrapolation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.Ridders.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Int32)">
			<summary>Construct the derivative function of a univariate function using Ridder&apos;s method.</summary>
			<param name="f">the <para></para>UnivariateRealFunction to take derivative of</param>
			<param name="order">the order of the derivative</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.Ridders.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,System.Int32[],System.Double,System.Int32)">
			<summary>Construct the derivative function of a vector-valued function using Ridder&apos;s method.
 <para/>
 By convention,
 <c>varidx = new int[]{1, 2}</c> means
 \[
 f_{x_1,x_2} = {\partial^2 f \over \partial x_1 \partial x_2} = {\partial \over \partial x_2}{\partial \over \partial x_1}
 \]
 <para/>
 The indices count from 1 up to the number of variables of <i>f</i>,
 i.e., the domain dimension of <i>f</i>.</summary>
			<param name="f">the multivariate function to take derivative of</param>
			<param name="varidx">specify the variable indices, numbering from 1 up to the domain dimension of <i>f</i></param>
			<param name="rate"><c>rate</c> should be a simple number, not like 0.66666666666...</param>
			<param name="discretization">the number of points used for extrapolation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.Ridders.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,System.Int32[])">
			<summary>Construct the derivative function of a vector-valued function using Ridder&apos;s method.
 <para/>
 By convention,
 <c>varidx = new int[]{1, 2}</c> means
 \[
 f_{x_1,x_2} = {\partial^2 f \over \partial x_1 \partial x_2} = {\partial \over \partial x_2}{\partial \over \partial x_1}
 \]
 <para/>
 The indices count from 1 up to the number of variables of <i>f</i>,
 i.e., the domain dimension of <i>f</i>.</summary>
			<param name="f">the real multivariate function to take derivative of</param>
			<param name="varidx">specify the variable indices, numbering from 1 up to the domain dimension of <i>f</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.Ridders.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>
 <para/>
 Make sure that <i>h</i> and <i>x+h</i> are representable in floating point precision
 so that the difference between <i>x+h</i> and <i>x</i> is exactly <i>h</i>, the step size.<para> See also: </para><a href="http://en.wikipedia.org/wiki/numerical_differentiation#practical_considerations">Wikipedia: Practical considerations</a></summary>
			<param name="x">the point to evaluate the derivative of <i>f</i> at</param>
			<returns><i>f&apos;(x)</i>, the numerical derivative of <i>f</i> at point <i>x</i> using Ridders&apos; method</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.Ridders.evaluate(System.Double)">
			<summary>Evaluate <i>f&apos;(x)</i>, where <i>f</i> is a <para></para>UnivariateRealFunction.<para> See also: </para><a href="http://en.wikipedia.org/wiki/numerical_differentiation#practical_considerations">Wikipedia: Practical considerations</a></summary>
			<param name="x">the point to evaluate the derivative of <i>f</i> at</param>
			<returns><i>f&apos;(x)</i>, the numerical derivative of <i>f</i> at point <i>x</i> using Ridders&apos; method</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.Ridders.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Evaluate numerically the derivative of <i>f</i> at point <i>x</i>, <i>f&apos;(x)</i>, with step size <i>h</i>.
 It could be challenging to automatically determine the step size <i>h</i>, esp. when <i>|x|</i> is near 0.
 It may, for example, require an analysis that involves <i>f&apos;</i> and <i>f&apos;&apos;</i>.
 The user may want to experiment with different <i>h</i>s by calling this function.</summary>
			<param name="x">the point to evaluate <i>f</i> at</param>
			<param name="h">the step size</param>
			<returns><i>f&apos;(x)</i>, the numerical derivative of <i>f</i> at point <i>x</i> with step size <i>h</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference">
			<summary>A finite difference (divided by a small increment) is an approximation of the derivative of a
 function.
 The accuracy depends on the function to take the derivative of.
 In general, the accuracy of central difference is the best while those of forward and backward
 differences are more or less the same.
 For finite difference, the higher an order of a derivative, the less accurate it gets.
 For example, approximating the 5-th derivative is much less accurate than approximating the 1st
 derivative.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/finite_difference">Wikipedia: Finite
 difference</a></item>
 <item><a href="http://en.wikipedia.org/wiki/difference_operator">Wikipedia: Difference
 operator</a></item>
 <item><a
 href="http://en.wikipedia.org/wiki/numerical_differentiation#practical_considerations">Wikipedia:
 Practical considerations</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Int32,com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference.Type)">
			<summary>Construct an approximate derivative function for <i>f</i> using finite difference.</summary>
			<param name="f">a univariate function</param>
			<param name="order">the order of the derivative</param>
			<param name="type">the type of finite difference to use, c.f., <para></para>Type</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference.evaluate(System.Double,System.Double)">
			<summary>Evaluate numerically the derivative of <i>f</i> at point <i>x</i>, <i>f&apos;(x)</i>, with step
 size <i>h</i>.
 It could be challenging to automatically determine the step size <i>h</i>, esp. when
 <i>|x|</i> is near 0.
 It may, for example, require an analysis that involves <i>f&apos;</i> and <i>f&apos;&apos;</i>.
 The user may want to experiment with different <i>h</i>s by calling this function.</summary>
			<param name="x">the point to evaluate the derivative of <i>f</i> at</param>
			<param name="h">step size</param>
			<returns><i>f&apos;(x)</i>, the numerical derivative of <i>f</i> at point <i>x</i> with step size
 <i>h</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference.df(System.Double,System.Double)">
			<summary>Compute the finite difference for <i>f</i> at <i>x</i> with an increment <i>h</i> for the
 <i>n</i>-th order using either forward, backward, or central difference.<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/difference_operator#higher-order_differences">Wikipedia:
 Higher-order differences</a></summary>
			<param name="x">the point to evaluate the function at</param>
			<param name="h">the increment</param>
			<returns>\(\Delta^n_hf(x)\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference.Type">
			<summary>the available types of finite difference</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference.Type.FORWARD">
			<summary>forward difference</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference.Type.BACKWARD">
			<summary>backward difference</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference.Type.CENTRAL">
			<summary>central difference</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference.Type.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.FiniteDifference.Type.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.univariate.DPolynomial">
			<summary>This is the first order derivative function of a <para></para>Polynomial, which, again, is a polynomial.<para> See also: </para>Polynomial</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.DPolynomial.#ctor(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary>Construct the derivative function of a <para></para>Polynomial, which, again, is a polynomial.</summary>
			<param name="polynomial">a polynomial</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.univariate.DGaussian">
			<summary>This is the first order derivative function of a <para></para>Gaussian function, \({d \mathrm{\phi}(x) \over dx}\).<para> See also: </para>Gaussian</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.DGaussian.#ctor(com.numericalmethod.suanshu.analysis.function.special.gaussian.Gaussian)">
			<summary>Construct the derivative function of a Gaussian function.</summary>
			<param name="phi">a <para></para>Gaussian function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.DGaussian.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.univariate.DGamma">
			<summary>This is the first order derivative function of the Gamma function, \({d \mathrm{\Gamma}(x) \over dx}\).<para> See also: </para>Gamma</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.DGamma.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.DGamma.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.univariate.Dfdx">
			<summary>The first derivative is a measure of how a function changes as its input changes.
 In other words, a derivative is how much a quantity changes if the input changes (by a very small amount).
 The derivative of a function at a particular point is the best linear approximation of the function at that point.
 For a univariate real function, the derivative at a point is the slope of the tangent line to the function at that point.
 <para/>
 This implementation is a simple wrapper class around the built-in derivative functions, e.g., <para></para>DBeta, <para></para>DErf,
 and the numerical derivative computation classes, e.g., <para></para>FiniteDifference and <para></para>Ridders.<para> See also: </para><a href="http://en.wikipedia.org/wiki/derivative">Wikipedia: Derivative</a><para> See also: </para>FiniteDifference</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.Dfdx.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.analysis.differentiation.univariate.Dfdx.Method)">
			<summary>Construct the first order derivative function of a univariate function <i>f</i>.</summary>
			<param name="f">a univariate function</param>
			<param name="method">the numerical method to use, c.f., <para></para>Method</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.Dfdx.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Construct, using the central finite difference, the first order derivative function of a univariate function <i>f</i>.</summary>
			<param name="f">a univariate function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.Dfdx.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.univariate.Dfdx.Method">
			<summary>the available methods to compute the numerical derivative</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.differentiation.univariate.Dfdx.Method.FINITE_DIFFERENCE">
			<summary>Finite difference: approximate a derivative using grid points.<para> See also: </para>FiniteDifference</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.differentiation.univariate.Dfdx.Method.RIDDERS">
			<summary>Ridders&apos; method: try a sequence of decreasing increments to the compute derivative, and then extrapolate to zero using Neville&apos;s algorithm.
 It in general gives a better approximation.<para> See also: </para>Ridders</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.Dfdx.Method.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.Dfdx.Method.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.univariate.DErf">
			<summary>This is the first order derivative function of the Error function, <para></para>Erf.
 \[
 {d \over dx}\mbox{Erf}(x) = \frac{2}{\sqrt{\pi}}\exp(-x^2)
 \]<para> See also: </para>Erf</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.DErf.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.DErf.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.univariate.DBetaRegularized">
			<summary>This is the first order derivative function of the Regularized Incomplete Beta function, <para></para>BetaRegularized, w.r.t the upper limit, <i>x</i>.
 \[
 {\partial \over \partial x} \mathrm{B_x}(p, q) = \frac{x^{p-1}(1-x)^{q-1}}{\mathrm{B_x}(p, q)}
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/beta_function#incomplete_beta_function">Wikipedia: Incomplete beta function</a><para> See also: </para>BetaRegularized</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.DBetaRegularized.#ctor(System.Double,System.Double)">
			<summary>Construct the derivative function of the Regularized Incomplete Beta function, <para></para>BetaRegularized.</summary>
			<param name="p">the shape parameter</param>
			<param name="q">the shape parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.DBetaRegularized.evaluate(System.Double)">
			<summary>Evaluate \({\partial \over \partial x} \mathrm{B_x}(p, q)\).</summary>
			<param name="x">\(0 \le x \le 1\)</param>
			<returns>\({\partial \over \partial x} \mathrm{B_x}(p, q)\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentiation.univariate.DBeta">
			<summary>This is the first order derivative function of the <para></para>Beta function w.r.t <i>x</i>, \({\partial \over \partial x} \mathrm{B}(x, y)\).
 \[
 {\partial \over \partial x} \mathrm{B}(x, y) = \mathrm{B}(x, y) (\psi(x) - \psi(x + y))
 \]
 where \(x &gt; 0, y &gt; 0\), \(\psi\) is the <para></para>Digamma function.<para> See also: </para><a href="http://en.wikipedia.org/wiki/beta_function#derivatives">Wikipedia: Derivatives</a><para> See also: </para>Beta</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.DBeta.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentiation.univariate.DBeta.evaluate(System.Double,System.Double)">
			<summary>Evaluate \({\partial \over \partial x} \mathrm{B}(x, y)\).</summary>
			<param name="x"><i>x &gt; 0</i></param>
			<param name="y"><i>y &gt; 0</i></param>
			<returns>\({\partial \over \partial x} \mathrm{B}(x, y)\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.SubFunction">
			<summary>A sub-function, <i>g</i>, is defined over a subset of the domain of another (original) function,
 <i>f</i>.
 <i>g(x) = f(x)</i> when they are both defined.
 This implementation constructs a sub-function by restricting/fixing the values of a subset of
 variables of another function.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.function.SubFunction.f">
			<summary>the original, unrestricted function</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.function.SubFunction.fixing">
			<summary>the restrictions or fixed values</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.SubFunction.#ctor(com.numericalmethod.suanshu.analysis.function.Function,java.util.Map)">
			<summary>Construct a sub-function.</summary>
			<param name="f">the original, unrestricted function</param>
			<param name="fixing">the values held fixed for a subset of variables</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.SubFunction.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.SubFunction.dimensionOfRange">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.SubFunction.isFixedIndex(System.Int32)">
			<summary>Check whether a particular index corresponds a fixed variable/value.</summary>
			<param name="i">an index, counting from 1</param>
			<returns><c>true</c> if <i>x<sub>i</sub></i> is fixed to some value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.SubFunction.getVariablePart(System.Double[])">
			<summary>Given an input to the original function, this extracts the variable parts (excluding the
 fixed values).</summary>
			<param name="z">an input to the original function</param>
			<returns>the variable part in <c>z</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.SubFunction.getAllParts(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,java.util.Map)">
			<summary>Combine the variable and fixed values to form an input to the original function.</summary>
			<param name="variables">the non-fixed variables/values to the restricted function</param>
			<param name="fixed">the fixed values to the original function</param>
			<returns>an input to the original function</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.FunctionOps">
			<summary>These are some commonly used mathematical functions.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.FunctionOps.modpow(System.Int64,System.Int64,System.Int64)">
			<summary><code><i>
 b<sup>e</sup> mod m
 </i></code>
 We use the fact that
 <code><i>
 (a * b) mod m = ((a mod m) * (b mod m)) mod m
 </i></code>
 <em>This code may fail without being noticed for very large numbers because overflow in
 integer operations does not throw any exception in the JVM.</em><para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/modular_exponentiation">Wikipedia: Modular
 exponentiation</a></item>
 <item><a
 href="http://en.wikipedia.org/wiki/modular_exponentiation#right-to-left_binary_method">Wikipedia:
 Right-to-left binary method</a></item>
 <item>&quot;Bruce Schneier, &quot;p. 244,&quot; Applied Cryptography, 2e, ISBN 0-471-11709-9.&quot;</item>
 </list></summary>
			<param name="base">positive integer <i>b</i></param>
			<param name="exponent">positive integer <i>e</i></param>
			<param name="modulus">positive integer <i>m</i></param>
			<returns><i>b<sup>e</sup> mod m</i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if not all inputs are positive integers</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.FunctionOps.mod(System.Int64,System.Int64)">
			<summary>Compute the positive modulus of a number.
 If <i>x</i> is positive, we return <i>x mod m</i>; otherwise, we return the smallest positive
 integer less than <i>m</i>, having the same modulo.
 For example,
 <code><i>
 -1 mod 5 = 4
 </i></code><para> See also: </para><a href="http://en.wikipedia.org/wiki/modulo_operator">Wikipedia: Modulo operation</a></summary>
			<param name="x">an integer</param>
			<param name="m">the modulus</param>
			<returns><i>x mod m</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.FunctionOps.dotProduct(System.Int64[],System.Int64[])">
			<summary>\(x_1 \cdot x_2\)
 <para/>
 This operation is called inner product when used in the context of vector space.<para> See also: </para><a href="http://en.wikipedia.org/wiki/dot_product">Wikipedia: Dot product</a></summary>
			<param name="x1">a <c>long</c> array</param>
			<param name="x2">a <c>long</c> array</param>
			<returns>\(x_1 \cdot x_2\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.FunctionOps.dotProduct(System.Double[],System.Double[])">
			<summary>\(x_1 \cdot x_2\)
 <para/>
 This operation is called inner product when used in the context of vector space.<para> See also: </para><a href="http://en.wikipedia.org/wiki/dot_product">Wikipedia: Dot product</a></summary>
			<param name="x1">a <c>double</c> array</param>
			<param name="x2">a <c>double</c> array</param>
			<returns>\(x_1 \cdot x_2\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.FunctionOps.factorial(System.Int32)">
			<summary><i>n!</i><para> See also: </para><a href="http://en.wikipedia.org/wiki/factorial">Wikipedia: Factorial</a></summary>
			<param name="n">an integer</param>
			<returns><i>n!</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.FunctionOps.combination(System.Int32,System.Int32)">
			<summary>Compute the combination function or binomial coefficient.
 It is the number of subsets of size <i>k</i> in a larger set of <i>n</i> elements.<para> See also: </para><a href="http://en.wikipedia.org/wiki/combination">Wikipedia: Combination</a></summary>
			<param name="n">the size of the full set</param>
			<param name="k">the size of a combination</param>
			<returns>\(\frac{n!}{(n-k)! k!}\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.FunctionOps.permutation(System.Int32,System.Int32)">
			<summary>Compute the permutation function.
 It is the number of size-<c>k</c>-permutations from a larger set of <i>n</i> elements.<para> See also: </para><a href="http://en.wikipedia.org/wiki/permutations">Wikipedia: Permutation</a></summary>
			<param name="n">the size of the full set</param>
			<param name="k">the size of a permutation</param>
			<returns>\(\frac{n!}{(n-k)!}\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.FunctionOps.linearInterpolate(System.Double,System.Double,System.Double,System.Double,System.Double)">
			<summary>Linear interpolation between two points.<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/linear_interpolation#linear_interpolation_between_two_known_points">Wikipedia:
 Linear interpolation between two known points</a></summary>
			<param name="x"><i>x</i></param>
			<param name="x0"><i>x0</i></param>
			<param name="y0"><i>y0</i></param>
			<param name="x1"><i>x1</i></param>
			<param name="y1"><i>y1</i></param>
			<returns>the linear interpolation between two points</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.FunctionOps.gcd(System.Int32,System.Int32)">
			<summary>Calculates the greatest common divisor of integer a and integer b.<para> See also: </para><a href="https://en.wikipedia.org/wiki/greatest_common_divisor">Wikipedia: Greatest
 common divisor</a></summary>
			<param name="a">an integer</param>
			<param name="b">an integer</param>
			<returns>the greatest common divisor of a and b</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.FunctionOps.lcm(System.Int32,System.Int32)">
			<summary>Calculates the least common multiple of integer a and integer b.<para> See also: </para><a href="https://en.wikipedia.org/wiki/greatest_common_divisor">Wikipedia: Greatest
 common divisor</a></summary>
			<param name="a">an integer</param>
			<param name="b">an integer</param>
			<returns>the least common multiple of <i>a</i> and <i>b</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.Function">
			<summary>The mathematical concept of a function expresses the idea that one quantity (the argument of the function, also known as the input) completely determines another quantity (the value, or output).
 The argument (domain) and value (range) may be real numbers (as in <para></para>RealScalarFunction), but they can also be elements from any given sets.<para> See also: </para><a href="http://en.wikipedia.org/wiki/function_(mathematics)">Wikipedia: Function (mathematics)</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.Function.evaluate(System.Object)">
			<summary>Evaluate the function <i>f</i> at <i>x</i>, where <i>x</i> is from the domain.</summary>
			<param name="x"><i>x</i></param>
			<returns><i>f(x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.Function.dimensionOfDomain">
			<summary>Get the number of variables the function has.
 For example, for a univariate function, the domain dimension is 1; for a bivariate function, the domain dimension is 2.</summary>
			<returns>the number of variables</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.Function.dimensionOfRange">
			<summary>Get the dimension of the range space of the function.
 For example, for a <i>R<sup>n</sup>-&gt;R<sup>m</sup></i> function, the dimension of the range is <i>m</i>.</summary>
			<returns>the dimension of the range</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.Function.EvaluationException">
			<summary>This is the <para></para>RuntimeException thrown when it fails to evaluate an expression.
 E.g., when there are not two arguments passed in a <para></para>BivariateRealFunction.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.Function.EvaluationException.#ctor(System.String)">
			<summary>Constructs an <c>EvaluationException</c> with the specified detail message.</summary>
			<param name="msg">the detail message. The detail message is saved for later retrieval by the <para></para>#getMessage() method.</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.matrix.RntoMatrix">
			<summary>This interface is a function that maps from <i>R<sup>n</sup></i> to a Matrix space.
 The function takes <i>n</i> real arguments and output a matrix.
 /[
 f(x_1, x_2, ..., x_n) = A
 /]</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.matrix.R2toMatrix">
			<summary>This is a function that maps from <i>R<sup>2</sup></i> to a Matrix space.
 It takes two real arguments and outputs one matrix value. That is,
 /[
 f(x_1, x_2) = A
 /]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.matrix.R2toMatrix.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.matrix.R2toMatrix.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.matrix.R2toMatrix.dimensionOfRange">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.matrix.R2toMatrix.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.matrix.R2toMatrix.evaluate(System.Double,System.Double)">
			<summary>Evaluate <i>f(x<sub>1</sub>, x<sub>2</sub>) = A</i>.</summary>
			<param name="x1"><c>x1</c></param>
			<param name="x2"><c>x2</c></param>
			<returns><c>f(x1, x2)</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix">
			<summary>This is a function that maps from <i>R<sup>1</sup></i> to a Matrix space.
 It takes one real argument and outputs one matrix value. That is,
 /[
 f(x) = A
 /]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix.dimensionOfRange">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix.evaluate(System.Double)">
			<summary>Evaluate <i>f(x) = A</i>.</summary>
			<param name="x"><i>x</i></param>
			<returns><i>f(x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.matrix.R1toConstantMatrix">
			<summary>A constant matrix function maps a real number to a constant matrix: \(R^n \rightarrow A\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.matrix.R1toConstantMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a constant matrix function.</summary>
			<param name="A">the constant matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.matrix.R1toConstantMatrix.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.ScaledPolynomial">
			<summary>This constructs a scaled polynomial that has neither too big or too small coefficients,
 hence avoiding overflow or underflow.
 This scaling factor is automatically computed from the coefficients of the given polynomial and
 is a power of the base.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.ScaledPolynomial.#ctor(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial,System.Double)">
			<summary>Construct a scaled polynomial, with a base of the scaling factor.</summary>
			<param name="p">a polynomial</param>
			<param name="base">base of the scaling factor</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.ScaledPolynomial.#ctor(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary>Construct a scaled polynomial, with 2 as the base of the scaling factor.</summary>
			<param name="p">a polynomial</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.QuadraticSyntheticDivision">
			<summary>Divide a polynomial <i>P(x)</i> by a quadratic monomial <i>(x<sup>2</sup> + ux + v)</i>
 to give the quotient <i>Q(x)</i> and the remainder <i>(b * (x + u) + a)</i>.
 The polynomial remainder theorem says:
 <code><i>
 P(x) = (x<sup>2</sup> + ux + v) Q(x) + (b * (x + u) + a)
 </i></code></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.QuadraticSyntheticDivision.#ctor(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial,com.numericalmethod.suanshu.analysis.function.polynomial.QuadraticMonomial)">
			<summary>Divide a polynomial by a quadratic monomial.</summary>
			<param name="polynomial">a polynomial</param>
			<param name="quadratic">a quadratic monomial</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.QuadraticSyntheticDivision.quotient">
			<summary>Get the quotient <i>Q(x)</i>.</summary>
			<returns><i>Q(x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.QuadraticSyntheticDivision.a">
			<summary>Get <i>a</i> as in the remainder <i>(b * (x + u) + a)</i>.</summary>
			<returns><i>a</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.QuadraticSyntheticDivision.b">
			<summary>Get <i>b</i> as in the remainder <i>(b * (x + u) + a)</i>.</summary>
			<returns><i>b</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.QuadraticMonomial">
			<summary>A quadratic monomial has this form: <i>x<sup>2</sup> + ux + v</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.QuadraticMonomial.#ctor(System.Double,System.Double)">
			<summary>Construct a quadratic monomial.</summary>
			<param name="u"><i>u</i> as in <i>(x<sup>2</sup> + ux + v)</i></param>
			<param name="v"><i>v</i> as in <i>(x<sup>2</sup> + ux + v)</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.QuadraticMonomial.u">
			<summary>Get <i>u</i> as in <i>(x<sup>2</sup> + ux + v)</i>.</summary>
			<returns><i>u</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.QuadraticMonomial.v">
			<summary>Get <i>v</i> as in <i>(x<sup>2</sup> + ux + v)</i>.</summary>
			<returns><i>v</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial">
			<summary>A polynomial is a <para></para>UnivariateRealFunction that represents a finite length expression constructed from variables and constants,
 using the operations of addition, subtraction, multiplication, and constant non-negative whole number exponents.
 Specifically, it has the form
 \[
 p(x) = a_0x^n + a_1x^{n-1} + ... + a_{n-1}x + a_n
 \]
 This implementation is immutable.<para> See also: </para><a href="http://en.wikipedia.org/wiki/polynomial">Wikipedia: Polynomial</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.ZERO">
			<summary>a polynomial representing <i>0</i></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.ONE">
			<summary>a polynomial representing <i>1</i></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.#ctor(System.Double[])">
			<summary>Construct a polynomial from an array of coefficients.
 The first/0-th entry corresponds to the <i>x<sup>n</sup></i> term.
 The last/n-th entry corresponds to the constant term.
 The degree of the polynomial is <i>n</i>, the array length minus 1.
 <para/>
 For example,
 <blockquote><c>
 new Polynomial(1, -2, 3, 2)
 </c></blockquote>
 creates an instance of <c>Polynomial</c> representing <i>x<sup>3</sup> - 2x<sup>2</sup> + 3x + 2</i>.</summary>
			<param name="coefficients">the polynomial coefficients</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.#ctor(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary>Copy constructor.</summary>
			<param name="that">a polynomial</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.degree">
			<summary>Get the degree of this polynomial.
 It is equal to the largest exponent of the variable.
 For example, <i>x<sup>4</sup> + 1</i> has a degree of 4.</summary>
			<returns>the polynomial degree</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.getCoefficients">
			<summary>Get a copy of the polynomial coefficients.
 In general, <c>coefficients[i]</c> is the coefficient of <i>x<sup>n-i</sup></i>, where <i>n</i> is the polynomial degree.
 Specifically, <c>coefficients[0]</c> is the leading coefficient and <c>coefficients[n]</c> the constant term.</summary>
			<returns>a copy of the polynomial coefficients</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.getCoefficient(System.Int32)">
			<summary>Get <i>a<sub>n-i</sub></i>, the coefficient of <i>x<sup>n-i</sup></i>.<para> See also: </para>#getCoefficients()</summary>
			<param name="i">the <i>i-th</i> coefficient in this polynomial, counting from 0</param>
			<returns><i>a<sub>n-i</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.getNormalization">
			<summary>Get the normalized version of this polynomial so the leading coefficient is 1.</summary>
			<returns>a scaled version of the polynomial that has a leading coefficient 1</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.evaluate(java.lang.Number)">
			<summary>Evaluate this polynomial at <i>x</i>.</summary>
			<param name="x">the argument</param>
			<returns><i>p(x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.evaluate(System.Double)">
			<summary>Evaluate this polynomial at <i>x</i>.</summary>
			<param name="x">the argument</param>
			<returns><i>p(x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.evaluate(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Evaluate this polynomial at <i>x</i>.</summary>
			<param name="z">the argument</param>
			<returns><i>p(x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.add(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.minus(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.multiply(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.pow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.scaled(com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.scaled(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.HornerScheme">
			<summary>Horner scheme is an algorithm for the efficient evaluation of polynomials in monomial form.
 It can also be seen as a fast algorithm for dividing a polynomial by a linear polynomial with Ruffini&apos;s rule.
 <para/>
 The polynomial remainder theorem says:
 <code><i>
 P(x) = Q(x)(x - x<sub>0</sub>) + P(x<sub>0</sub>)
 </i></code>
 We thus can compute the value of a polynomial <i>P(x)</i> at <i>x<sub>0</sub></i>,
 i.e., <i>P(x<sub>0</sub>)</i>, and at the same time the quotient <i>Q(x)</i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/horner_scheme">Wikipedia: Horner scheme</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.HornerScheme.#ctor(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial,System.Double)">
			<summary>Evaluate a polynomial at <i>x</i>.</summary>
			<param name="polynomial">a polynomial</param>
			<param name="x">a point to evaluate the polynomial at</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.HornerScheme.remainder">
			<summary>Get the remainder, <i>P(x<sub>0</sub>)</i>.</summary>
			<returns>the remainder</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.HornerScheme.quotient">
			<summary>Get the quotient, <i>Q(x)</i>.</summary>
			<returns>the quotient</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.CauchyPolynomial">
			<summary>The Cauchy&apos;s polynomial of a polynomial takes this form:
 <code><i>
 C(x) = |p_n|x^n + |p_{n-1}|x^{n-1} + ... + |p_1|x - |p_0| = 0
 </i></code>

 Note: the sign of the constant is negative.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.CauchyPolynomial.#ctor(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.CauchyPolynomial.lowerBound">
			<summary>Cauchy&apos;s lower bound on polynomial zeros is the unique positive root of the Cauchy polynomial.</summary>
			<returns>Cauchy&apos;s lower bound</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRootFormula">
			<summary>This is a quartic equation solver that solves \(ax^4 + bx^3 + cx^2 + dx + e = 0\) using a root-finding formula.<para> See also: </para><a href="http://planetmath.org/encyclopedia/quarticformula.html">PlanetMath: QuarticRoot Formula</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRootFormula.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRootFormula.solve(System.Double,System.Double,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRootFormula.solve(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary>Solve \(ax^4 + bx^3 + cx^2 + dx + e = 0\).</summary>
			<param name="polynomial">a quartic equation to be solved</param>
			<returns>the roots of the quartic equation</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if the polynomial degree is not 4</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRootFerrari">
			<summary>This is a quartic equation solver that solves \(ax^4 + bx^3 + cx^2 + dx + e = 0\) using the Ferrari method.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/quartic_function#ferrari.27s_solution">Wikipedia: Ferrari&apos;s solution</a></item>
 <item><a href="http://mathworld.wolfram.com/quarticequation.html">QuarticRoot Equation from Wolfram MathWorld</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRootFerrari.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRootFerrari.solve(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
			<summary>Solve \(ax^4 + bx^3 + cx^2 + dx + e = 0\).<para> See also: </para><a href="http://en.wikipedia.org/wiki/quartic_function#ferrari.27s_solution">Wikipedia: Ferrari&apos;s solution</a></summary>
			<param name="a"><i>a</i></param>
			<param name="b"><i>b</i></param>
			<param name="c"><i>c</i></param>
			<param name="d"><i>d</i></param>
			<param name="e"><i>e</i></param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns>the list of roots</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRootFerrari.solve(System.Double,System.Double,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRootFerrari.solve(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary>Solve \(ax^4 + bx^3 + cx^2 + dx + e = 0\).</summary>
			<param name="polynomial">a quartic equation to be solved</param>
			<returns>the roots of the quartic equation</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if the polynomial degree is not 4</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRoot">
			<summary>This is a quartic equation solver that solves \(ax^4 + bx^3 + cx^2 + dx + e = 0\).<para> See also: </para><a href="http://en.wikipedia.org/wiki/quartic_function">Wikipedia: QuarticRoot equation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRoot.#ctor(com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRoot.QuarticSolver)">
			<summary>Construct a quartic equation solver.</summary>
			<param name="solver">the implementation of a <c>QuarticSolver</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRoot.#ctor">
			<summary>Construct a quartic equation solver.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRoot.solve(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary>Solve \(ax^4 + bx^3 + cx^2 + dx + e = 0\).</summary>
			<param name="polynomial">a quartic equation to be solved</param>
			<returns>the roots of the quartic equation</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if the polynomial degree is not 4</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRoot.QuarticSolver">
			<summary>This defines a quartic equation solver.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuarticRoot.QuarticSolver.solve(System.Double,System.Double,System.Double,System.Double,System.Double)">
			<summary>Solve \(ax^4 + bx^3 + cx^2 + dx + e = 0\).</summary>
			<param name="a"><i>a</i></param>
			<param name="b"><i>b</i></param>
			<param name="c"><i>c</i></param>
			<param name="d"><i>d</i></param>
			<param name="e"><i>e</i></param>
			<returns>the list of roots</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuadraticRoot">
			<summary>This is a solver for finding the roots of a quadratic equation, \(ax^2 + bx + c = 0\).
 The roots are:
 \[
 \frac{-b}{2a} \pm \frac{\sqrt{b^2-4ac}}{2a}
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/quadratic_equation">Wikipedia: Quadratic equation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuadraticRoot.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuadraticRoot.solve(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial,System.Double)">
			<summary>Solve \(ax^2 + bx + c = 0\).</summary>
			<param name="polynomial">a quadratic equation to be solved</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns>the roots of the quadratic equation</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if the polynomial degree is not 2</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.QuadraticRoot.solve(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.root.PolyRootSolver">
			<summary>A root (or a zero) of a polynomial <i>p</i> is a member <i>x</i> in the domain of <i>p</i> such that <i>p(x)</i> vanishes.
 That is, <i>p(x) = 0</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.PolyRootSolver.solve(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.root.PolyRoot">
			<summary>This is a solver for finding the roots of a polynomial equation.
 A root (or a zero) of a polynomial <i>p</i> is a member <i>x</i> in the domain of <i>p</i> such
 that <i>p(x)</i> vanishes.
 That is, <i>p(x) = 0</i>.
 By the fundamental theorem of algebra, every polynomial of degree <i>n</i> has <i>n</i> roots.
 The roots can be both real (<c>double</c>) or <para></para>Complex.
 The Abel-Ruffini theorem says that we have analytical solution for polynomials of degree up to 4.
 <para/>
 This implementation solves a polynomial of degree 1 by <para></para>LinearRoot, degree 2 by
 <para></para>QuadraticRoot, degree 3 by <para></para>CubicRoot,
 degree 4 by <para></para>QuarticRoot, and others by the Jenkins-Traub algorithm
 <para></para>JenkinsTraubReal.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/root_(mathematics)">
 Wikipedia: PolyRoot (mathematics)</a></item>
 <item><a href="http://en.wikipedia.org/wiki/fundamental_theorem_of_algebra">
 Wikipedia: Fundamental theorem of algebra</a></item>
 <item><a href="http://en.wikipedia.org/wiki/abel-ruffini_theorem">
 Wikipedia: Abel-Ruffini theorem</a></item>
 <item><a href="http://en.wikipedia.org/wiki/jenkins-traub_algorithm">
 Wikipedia: Jenkins-Traub algorithm</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.PolyRoot.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.PolyRoot.solve(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary>Get the roots/zeros of a polynomial.</summary>
			<param name="polynomial">the polynomial to be solved</param>
			<returns>the roots of the polynomial</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if the polynomial is a constant, hence no solution</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.PolyRoot.getRealRoots(java.util.List)">
			<summary>Get a copy of only the real roots of a polynomial.
 The union of these and <para></para>#getComplexRoots(java.util.List) are all the roots.</summary>
			<param name="roots">all the roots of a polynomial</param>
			<returns>a copy of the real roots</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.PolyRoot.getComplexRoots(java.util.List)">
			<summary>Get a copy of only the <para></para>Complex but not real roots of a polynomial.
 The union of these and <para></para>#getRealRoots(java.util.List) are all the roots.</summary>
			<param name="roots">all the roots of a polynomial</param>
			<returns>a copy of the <para></para>Complex roots</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.root.LinearRoot">
			<summary>This is a solver for finding the roots of a linear equation.
 A linear equation is an algebraic equation in which
 each term is either a constant or the product of a constant and (the first power of) a single
 variable.
 That is, it has this form: <i>ax + b = 0</i>.
 The solution is simply
 <code><i>x = -b/a</i></code><para> See also: </para><a href="http://en.wikipedia.org/wiki/linear_equation">Wikipedia: LinearRoot equation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.LinearRoot.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.LinearRoot.solve(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary>Solve <i>ax + b = 0</i>.</summary>
			<param name="polynomial">a linear equation to be solved</param>
			<returns>the root of the linear equation</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if the polynomial degree is not 1</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.root.CubicRoot">
			<summary>This is a cubic equation solver. This implementation solves \(ax^3 + bx^2 + cx + d = 0\) using
 Cardano&apos;s method.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/cubic_function">Wikipedia: CubicRoot equation</a></item>
 <item><a href="http://en.wikipedia.org/wiki/cubic_function#cardano.27s_method">
 Wikipedia: Cardano&apos;s method</a></item>
 <item><a href="http://en.wikipedia.org/wiki/cubic_function#root-finding_formula">
 Wikipedia: Root-finding formula for cubic equation</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.CubicRoot.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.CubicRoot.solve(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary>Solve \(ax^3 + bx^2 + cx + d = 0\).</summary>
			<param name="polynomial">a cubic equation to be solved</param>
			<returns>the roots of the cubic equation</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if the polynomial degree is not 3</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.polynomial.root.jenkinstraub.JenkinsTraubReal">
			<summary>The Jenkins-Traub algorithm is a fast globally convergent iterative method for solving for polynomial roots.<para> See also: </para><list type="bullet">
 <item>&quot;Jenkins, M. A. and Traub, J. F. (1970), A Three-Stage Algorithm for Real Polynomials Using QuadraticRoot Iteration, SIAM J. Numer. Anal., 7(4), 545-566.&quot;</item>
 <item>&quot;Jenkins, M. A. (1975), Algorithm 493: Zeros of a Real Polynomial, ACM TOMS, 1, 178-189.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/jenkins-traub_algorithm_for_polynomial_zeros">Wikipedia: Jenkins-Traub algorithm</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.jenkinstraub.JenkinsTraubReal.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.polynomial.root.jenkinstraub.JenkinsTraubReal.solve(com.numericalmethod.suanshu.analysis.function.polynomial.Polynomial)">
			<summary>Solve a polynomial equation.</summary>
			<param name="polynomial">a polynomial equation to be solved</param>
			<returns>the roots of the polynomial equation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.TrivariateRealFunction">
			<summary>A trivariate real function takes three real arguments and outputs one real value.
 That is, <i>y = f(x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>)</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.TrivariateRealFunction.evaluate(System.Double,System.Double,System.Double)">
			<summary>Evaluate <i>y = f(x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>)</i>.</summary>
			<param name="x1"><i>x<sub>1</sub></i></param>
			<param name="x2"><i>x<sub>2</sub></i></param>
			<param name="x3"><i>x<sub>3</sub></i></param>
			<returns><i>f(x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarSubFunction">
			<summary>This constructs a <para></para>RealScalarFunction from another <para></para>RealScalarFunction by
 restricting/fixing the values of a subset of variables.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarSubFunction.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,java.util.Map)">
			<summary>Construct a scalar sub-function.</summary>
			<param name="f">the unrestricted/original function</param>
			<param name="fixing">the values held fixed for a subset of variables</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarSubFunction.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarSubFunction.evaluate(System.Double)">
			<summary>Evaluate the function <i>f</i> at <i>x</i>.</summary>
			<param name="x"><i>x</i></param>
			<returns><i>f(x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction">
			<summary>A real valued function a \(R^n \rightarrow R\) function, \(y = f(x_1, ..., x_n)\).
 The function takes <i>n</i> real arguments and output one real value.<para> See also: </para><a href="http://en.wikipedia.org/wiki/real-valued_function">Wikipedia: Real-valued function</a></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.R1Projection">
			<summary>Projection creates a real-valued function <para></para>RealScalarFunction from a vector-valued function <para></para>RealVectorFunction by
 taking only one of its coordinate components in the vector output.
 For example, suppose we have a \(R^n \rightarrow R^m\) function, \(f_1 = [y_1, y_2, y_3]&apos;\).
 We construct a \(R^n \rightarrow R\) function by taking its second coordinate.
 That is, \(f_2 = y_2\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.R1Projection.#ctor(com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction,System.Int32)">
			<summary>Construct a \(R^n \rightarrow R\) projection from a \(R^n \rightarrow R^m\) function <i>f</i>.</summary>
			<param name="f">a vector-valued function</param>
			<param name="dimension">the dimension/coordinate of the <i>f</i> value to output</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.R1Projection.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction">
			<summary>A quadratic function takes this form: \(f(x) = \frac{1}{2} \times x&apos;Hx + x&apos;p + c\).<para> See also: </para><list type="bullet">
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Section 13.2, Convex QP Problems with Equality Constraints,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/quadratic_function">Wikipedia: Quadratic function</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Construct a quadratic function of this form: \(f(x) = \frac{1}{2} \times x&apos;Hx + x&apos;p + c\).</summary>
			<param name="H">a symmetric, positive semi-definite matrix</param>
			<param name="p">a vector</param>
			<param name="c">a constant</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a quadratic function of this form: \(f(x) = \frac{1}{2} \times x&apos;Hx + x&apos;p\).</summary>
			<param name="H">a symmetric, positive semi-definite matrix</param>
			<param name="p">a vector</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction)">
			<summary>Copy constructor.</summary>
			<param name="f">a quadratic function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction.Hessian">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction.p">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.BivariateRealFunction">
			<summary>A bivariate real function takes two real arguments and outputs one real value.
 That is, <i>y = f(x<sub>1</sub>,x<sub>2</sub>)</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.BivariateRealFunction.evaluate(System.Double,System.Double)">
			<summary>Evaluate <i>y = f(x<sub>1</sub>,x<sub>2</sub>)</i>.</summary>
			<param name="x1"><i>x<sub>1</sub></i></param>
			<param name="x2"><i>x<sub>2</sub></i></param>
			<returns><i>f(x<sub>1</sub>, x<sub>2</sub>)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.AbstractTrivariateRealFunction">
			<summary>A trivariate real function takes three real arguments and outputs one real value.
 That is, <i>y = f(x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>)</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.AbstractTrivariateRealFunction.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.AbstractTrivariateRealFunction.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.AbstractRealScalarFunction">
			<summary>This abstract implementation implements <para></para>RealScalarFunction#dimensionOfRange()  by always
 returning 1, and <para></para>RealScalarFunction#dimensionOfDomain()  by returning the input argument
 for the dimension of domain.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.AbstractRealScalarFunction.#ctor(System.Int32)">
			<summary>Construct an instance with the dimension of the domain.</summary>
			<param name="domainDimension">the dimension of the domain</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.AbstractRealScalarFunction.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.AbstractRealScalarFunction.dimensionOfRange">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.AbstractBivariateRealFunction">
			<summary>A bivariate real function takes two real arguments and outputs one real value.
 That is, <i>y = f(x<sub>1</sub>,x<sub>2</sub>)</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.AbstractBivariateRealFunction.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.AbstractBivariateRealFunction.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction">
			<summary>A univariate real function takes one real argument and outputs one real value.
 That is, <i>y = f(x)</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction.evaluate(System.Double)">
			<summary>Evaluate <i>y = f(x)</i>.</summary>
			<param name="x"><i>x</i></param>
			<returns><i>f(x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.StepFunction">
			<summary>A step function (or staircase function) is a finite linear combination of indicator functions of
 intervals.
 Informally speaking, a step function is a piecewise constant function having only finitely many
 pieces.

 <para/>
 Note: this function is mutable for convenience. It allows dynamically adding more points to the
 function.
 It is handy when, e.g., merging two sets of points.<para> See also: </para><a href="http://en.wikipedia.org/wiki/step_function">Wikipedia: Step function</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.StepFunction.#ctor(System.Double)">
			<summary>Construct an empty step function.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.StepFunction.#ctor(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs,System.Double)">
			<summary>Construct a step function from a collection ordered pairs.</summary>
			<param name="f">a collection of ordered pairs</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.StepFunction.#ctor(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary>Construct a step function from a collection ordered pairs.</summary>
			<param name="f">a collection of ordered pairs</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.StepFunction.add(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary>Dynamically add points to the step function.</summary>
			<param name="f">a collection of ordered pairs</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.StepFunction.x">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.StepFunction.y">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.StepFunction.minDomain">
			<summary>Get the smallest abscissae.</summary>
			<returns>the smallest abscissae</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.StepFunction.maxDomain">
			<summary>Get the biggest abscissae.</summary>
			<returns>the biggest abscissae</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.StepFunction.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.StepFunction.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction">
			<summary>A continued fraction representation of a number has this form:
 \[
 z = b_0 + \cfrac{a_1}{b_1 + \cfrac{a_2}{b_2 + \cfrac{a_3}{b_3 + \cfrac{a_4}{b_4 + \ddots\,}}}}
 \]
 <i>a<sub>i</sub></i> and <i>b<sub>i</sub></i> can be functions of <i>x</i>, which in turn makes <i>z</i> a function of <i>x</i>.
 <para/>
 The sequence <i>z<sub>n</sub></i> may or may not converge.
 In theory,
 <i>z<sub>n</sub></i> can be written as a fraction: \(z_n = \frac{A_n}{B_n}\).
 <i>A<sub>n</sub></i> and <i>B<sub>n</sub></i> can be computed by the fundamental recurrence formulas.
 In practice, we compute <i>z<sub>n</sub></i> using the modified Lentz&apos;s method from Thompson and Barnett.
 This method may suffer from the &quot;false convergence&quot; problem.
 That is, differences between successive convergents become small, seeming to indicate convergence,
 but then increase again by many orders of magnitude before finally converging.<para> See also: </para><list type="bullet">
 <item>&quot;I. J. Thompson, A. R. Barnett, &quot;Coulomb and Bessel functions of complex arguments and order,&quot; J. Comput. Phys, 1986.&quot;</item>
 <item>&quot;W. J. Lentz, &quot;Generating Bessel Functions In Mie Scattering Calculations Using Continued Fractions,&quot; Applied Optics, Vol. 15, Issue 3, p. 668-671.&quot;</item>
 <item>&quot;W. Gautschi, Math. Comput, 31, 994(1997).&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/generalized_continued_fraction">Wikipedia: Generalized continued fraction</a></item>
 <item><a href="http://en.wikipedia.org/wiki/fundamental_recurrence_formulas">Wikipedia: Fundamental recurrence formulas</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.Partials,System.Double,System.Int32)">
			<summary>Construct a continued fraction.</summary>
			<param name="partials">the definition in terms of partial numerators and partial denominators</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.Partials,System.Int32,System.Int32)">
			<summary>Construct a continued fraction.</summary>
			<param name="partials">the definition in terms of partial numerators and partial denominators</param>
			<param name="scale">the accuracy</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.Partials)">
			<summary>Construct a continued fraction.</summary>
			<param name="partials">the definition in terms of partial numerators and partial denominators</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.evaluate(System.Double)">
			<summary>

 This implementation adopts the modified Lentz&apos;s method, using <c>double</c> arithmetics.
 It is quick.
 However, the precision is limited by the double precision of the intermediate results.
 This (and probably other implementations using double precision math) may give poor results for some continued fraction.</summary>
			<param name="x"><i>x</i></param>
			<returns>an <em>approximation</em> of <i>z</i></returns>
			<exception cref="T:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.MaxIterationsExceededException">if it does not converge before the maximum number of iterations;
                                        repeat with a bigger epsilon, or use the BigDecimal version of the algorithm</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.evaluate(java.math.BigDecimal)">
			<summary>Evaluate <i>z</i>.

 This implementation adopts the modified Lentz&apos;s method using arbitrary precision arithmetics <para></para>java.math.BigDecimal.</summary>
			<param name="x"><i>x</i></param>
			<returns>an <em>approximation</em> of <i>z</i></returns>
			<exception cref="T:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.MaxIterationsExceededException">if it does not converge before the maximum number of iterations; repeat with a bigger epsilon</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.MaxIterationsExceededException">
			<summary><para></para>RuntimeException thrown when the continued fraction fails to converge for a given epsilon before a certain number of iterations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.MaxIterationsExceededException.#ctor(System.Int32)">
			<summary>Construct a new <c>MaxIterationsExceededException</c>, indicating the number of iterations.</summary>
			<param name="nIterations">the number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.MaxIterationsExceededException.getMaxIterations">
			<summary>Get the maximum number of iterations.</summary>
			<returns>the maximum number of iterations</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.Partials">
			<summary>This interface defines a continued fraction in terms of
 the partial numerators <i>a<sub>n</sub></i>, and the partial denominators <i>b<sub>n</sub></i>.
 \[
 z = b_0 + \cfrac{a_1}{b_1 + \cfrac{a_2}{b_2 + \cfrac{a_3}{b_3 + \cfrac{a_4}{b_4 + \ddots\,}}}}
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.Partials.A(System.Int32,System.Double)">
			<summary>Compute <i>a<sub>n</sub></i>.</summary>
			<param name="n">an index that counts from 1</param>
			<param name="x"><i>x</i></param>
			<returns><i>a<sub>n</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.ContinuedFraction.Partials.B(System.Int32,System.Double)">
			<summary>Compute <i>b<sub>n</sub></i>.</summary>
			<param name="n">an index that counts from 0</param>
			<param name="x"><i>x</i></param>
			<returns><i>b<sub>n</sub></i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.AbstractUnivariateRealFunction">
			<summary>A univariate real function takes one real argument and outputs one real value.
 That is, <i>y = f(x)</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.AbstractUnivariateRealFunction.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.AbstractUnivariateRealFunction.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorSubFunction">
			<summary>This constructs a <para></para>RealVectorFunction from another <para></para>RealVectorFunction by
 restricting/fixing the values of a subset of variables.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorSubFunction.#ctor(com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction,java.util.Map)">
			<summary>Construct a vector-valued sub-function.</summary>
			<param name="f">the unrestricted/original function</param>
			<param name="fixing">the values held fixed for a subset of variables</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorSubFunction.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction">
			<summary>A vector-valued function a \(R^n \rightarrow R^m\) function, \([y_1,...,y_m] = f(x_1,...,x_n)\).
 The function takes <i>n</i> real arguments and output <i>m</i> real values in the form of a vector.<para> See also: </para><a href="http://en.wikipedia.org/wiki/vector-valued_function">Wikipedia: Vector-valued function</a></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.rn2rm.AbstractRealVectorFunction">
			<summary>This abstract implementation implements <para></para>RealVectorFunction#dimensionOfDomain()  and
 <para></para>RealVectorFunction#dimensionOfRange()  by returning the input arguments at constructor.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2rm.AbstractRealVectorFunction.#ctor(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2rm.AbstractRealVectorFunction.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.rn2rm.AbstractRealVectorFunction.dimensionOfRange">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.beta.LogBeta">
			<summary>This class represents the log of Beta function <c>log(B(x, y))</c>.

 <blockquote><c><code>
                       &#915;(x)&#915;(y)
 log(B(x, y)) = log ( ----------- ) = log&#915;(x) + log&#915;(y) - log&#915;(x + y)
                        &#915;(x+y)
 </code></c></blockquote>

 <c>x &gt; 0, y &gt; 0</c>

 <para/>
 The R equivalent function is <c>lbeta</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/beta_function">Wikipedia: Beta function</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.beta.LogBeta.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.beta.LogBeta.evaluate(System.Double,System.Double)">
			<summary>Compute <c>log(B(x,y))</c>.</summary>
			<param name="x"><c>x &gt;= 0</c></param>
			<param name="y"><c>y &gt;= 0</c></param>
			<returns><c>log(B(x,y))</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.beta.BetaRegularizedInverse">
			<summary>The inverse of the Regularized Incomplete Beta function is defined at:
 \[
 x = I^{-1}_{(p,q)}(u), 0 \le u \le 1
 \]
 <para/>
 The R equivalent function is <c>qbeta</c>.<para> See also: </para><list type="bullet">
 <item>&quot;Amparo Gil, Javier Segura, and Nico M. Temme, &quot;Section 10.5,&quot; Numerical Methods for Special Functions.&quot;</item>
 <item>&quot;John Maddock, Paul A. Bristow, Hubert Holin, and Xiaogang Zhang. &quot;Notes for The Incomplete Beta Function Inverses,&quot; Boost Library.&quot;</item>
 <item>&quot;K. L. Majumder, and G. P. Bhattacharjee, Algorithm AS 63: The Incomplete Beta Integral, 1973.&quot;</item>
 <item>&quot;Cran, G. W., K. J. Martin, and G. E. Thomas, &quot;Remark AS R19 and Algorithm AS 109,&quot; Applied Statistics, 26, 111-114, 1977, and subsequent remarks (AS83 and correction).&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.beta.BetaRegularizedInverse.#ctor(System.Double,System.Double)">
			<summary>Construct an instance of \(I^{-1}_{(p,q)}(u)\) with parameters <i>p</i> and <i>p</i>.</summary>
			<param name="p"><i>p &gt; 0</i></param>
			<param name="q"><i>q &gt; 0</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.beta.BetaRegularizedInverse.evaluate(System.Double)">
			<summary>Evaluate \(I^{-1}_{(p,q)}(u)\).</summary>
			<param name="u">\(0 \le u \le 1\)</param>
			<returns>\(I^{-1}_{(p,q)}(u)\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.beta.BetaRegularized">
			<summary>The Regularized Incomplete Beta function is defined as:
 \[
 I_x(p,q) = \frac{B(x;\,p,q)}{B(p,q)} = \frac{1}{B(p,q)} \int_0^x t^{p-1}\,(1-t)^{q-1}\,dt, p &gt; 0, q &gt; 0
 \]
 <para/>
 The R equivalent function is <c>pbeta</c>.<para> See also: </para><list type="bullet">
 <item>&quot;Amparo Gil, Javier Segura, and Nico M. Temme. &quot;Sections 6.7,&quot; Numerical Methods for Special Functions.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/beta_function#incomplete_beta_function">Wikipedia: Incomplete beta function</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.beta.BetaRegularized.#ctor(System.Double,System.Double)">
			<summary>Construct an instance of <i>I<sub>x</sub>(p,q)</i> with the parameters <i>p</i> and <i>q</i>.</summary>
			<param name="p"><i>p &gt; 0</i></param>
			<param name="q"><i>q &gt; 0</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.beta.BetaRegularized.p">
			<summary>Get <i>p</i>, the shape parameter.</summary>
			<returns><i>p</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.beta.BetaRegularized.q">
			<summary>Get <i>q</i>, the shape parameter.</summary>
			<returns><i>q</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.beta.BetaRegularized.evaluate(System.Double)">
			<summary>Evaluate <i>I<sub>x</sub>(p,q)</i>.</summary>
			<param name="x"><i>0 &#8804; x &#8804; 1</i></param>
			<returns><i>I<sub>x</sub>(p,q)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.beta.Beta">
			<summary>The beta function defined as:
 \[
 B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}= \int_0^1t^{x-1}(1-t)^{y-1}\,dt, x &gt; 0, y &gt; 0
 \]
 <para/>
 The R equivalent function is <c>beta</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/beta_function">Wikipedia: Beta function</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.beta.Beta.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.beta.Beta.evaluate(System.Double,System.Double)">
			<summary>Evaluate <i>B(x,y)</i>.</summary>
			<param name="x"><i>x &gt; 0</i></param>
			<param name="y"><i>y &gt; 0</i></param>
			<returns><i>B(x,y)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.Trigamma">
			<summary>The trigamma function is defined as the logarithmic derivative of the digamma function. That is,
 \[
 \psi_1(z) = \frac{d}{dz} \psi(z)
 \]
 This implementation is based on Algorithm 121.<para> See also: </para><list type="bullet">
 <item>&quot;B. E. Schneider, &quot;Algorithm 121: Trigamma Function,&quot; JSTOR. Vol. 27, No. 1, 1978.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/trigamma_function">Wikipedia: Trigamma function</a></item>
 <item>&quot;http://pmtksupport.googlecode.com/svn/trunk/lightspeed2.3/trigamma.m&quot;</item>
 <item>&quot;http://www.math.mcmaster.ca/peter/s743/trigamma.html&quot;</item>
 <item>&quot;http://lib.stat.cmu.edu/apstat/121&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.Trigamma.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.Trigamma.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.LogGamma">
			<summary>The log-Gamma function, \(\log (\Gamma(z))\), for positive real numbers, is the log of the Gamma function.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/gamma_function">Wikipedia: Gamma function</a></item>
 <item><a href="http://en.wikipedia.org/wiki/lanczos_approximation">Wikipedia: Lanczos approximation</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.LogGamma.#ctor(com.numericalmethod.suanshu.analysis.function.special.gamma.LogGamma.Method,com.numericalmethod.suanshu.analysis.function.special.gamma.Lanczos)">
			<summary>Construct an instance of log-Gamma.</summary>
			<param name="method">the Lanczos computation to use</param>
			<param name="lanczos">the Lanczos approximation to use</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.LogGamma.#ctor">
			<summary>Construct an instance of log-Gamma.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.LogGamma.evaluate(System.Double)">
			<summary>Evaluate the log of the Gamma function in the positive real domain.</summary>
			<param name="x">a real number &gt; 0</param>
			<returns>\(\log (\Gamma(z))\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.LogGamma.Method">
			<summary>the available methods to compute \(\log (\Gamma(z))\)</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.function.special.gamma.LogGamma.Method.LANCZOS">
			<summary>Lanczos approximation.
 <para/>
 This accuracy can be made arbitrary precise.
 Yet, the computations can be time-consuming.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.function.special.gamma.LogGamma.Method.LANCZOS_QUICK">
			<summary>Quick Lanczos approximation,
 where all computations are done in <c>double</c> precision.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.LogGamma.Method.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.LogGamma.Method.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.Lanczos">
			<summary>The Lanczos approximation is a method for computing the Gamma function numerically, published by Cornelius Lanczos in 1964.
 This implementation is based on the notes of Paul Godfrey and the discussion of Viktor T. Toth.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/lanczos_approximation">Wikipedia: Lanczos approximation</a></item>
 <item><a href="http://my.fit.edu/~gabdo/gamma.txt">A note on the computation of the convergent Lanczos complex Gamma approximation.</a></item>
 <item><a href="http://www.rskey.org/lanczos.htm">The Lanczos Approximation</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.Lanczos.#ctor(System.Double,System.Int32,System.Int32)">
			<summary>Construct a Lanczos approximation instance.
 <para/>
 Recommended settings are
 <blockquote><c>
 g = 607.0 / 128.0;
 n = 15;
 scale = 30;
 </c></blockquote></summary>
			<param name="g"><i>g</i></param>
			<param name="n"><i>n</i></param>
			<param name="scale">precision</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.Lanczos.#ctor">
			<summary>Construct a Lanczos approximation instance using default parameters.
 The default parameters are:
 <blockquote><c>
 g = 607.0 / 128.0;
 n = 15;
 scale = 30;
 </c></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.Lanczos.logGammaQuick(System.Double)">
			<summary>Compute log-gamma for a <em>positive</em> value <i>x</i>.
 All operations are in <c>double</c> precision.</summary>
			<param name="x"><i>x</i> in <c>double</c></param>
			<returns><c>lgamma(x)</c> in <c>double</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.Lanczos.logGamma(System.Double)">
			<summary>Compute log-gamma for a <em>positive</em> value <i>x</i>.
 The accuracy of this function is only as good as the precision of <c>double</c>.</summary>
			<param name="x"><i>x</i> in <c>double</c></param>
			<returns><c>lgamma(x)</c> in <c>double</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.Lanczos.logGamma(java.math.BigDecimal)">
			<summary>Compute log-gamma for a <em>positive</em> value <i>x</i> to arbitrary precision.</summary>
			<param name="x"><i>x</i> in <c>BigDecimal</c></param>
			<returns><c>lgamma(x)</c> in <c>BigDecimal</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaUpperIncomplete">
			<summary>The Upper Incomplete Gamma function is defined as:
 \[
 \Gamma(s,x) = \int_x^{\infty} t^{s-1}\,e^{-t}\,{\rm d}t = Q(s,x) \times \Gamma(s)
 \]
 The integrand has the same form as the Gamma function, but the lower limit of the integration is a variable.
 The upper limit is fixed.<para> See also: </para><a href="http://en.wikipedia.org/wiki/incomplete_gamma_function">Wikipedia: Incomplete gamma function</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaUpperIncomplete.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaUpperIncomplete.evaluate(System.Double,System.Double)">
			<summary>Compute <i>&#915;(s,x)</i>.</summary>
			<param name="s"><i>s &gt; 0</i></param>
			<param name="x"><i>x &#8805; 0</i></param>
			<returns><i>&#915;(s,x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaRegularizedQ">
			<summary>The Regularized Incomplete Gamma Q function is defined as:
 \[
 Q(s,x)=\frac{\Gamma(s,x)}{\Gamma(s)}=1-P(s,x), s \geq 0, x \geq 0
 \]
 The algorithm used for computing the regularized incomplete Gamma Q function depends on the values of <i>s</i> and <i>x</i>.
 <list type="bullet">
 <item>For \(s &gt; 100\), <i>Q</i> is approximated using the Gauss-Legendre quadrature.</item>
 <item>For \(x &lt; s + 1\), <i>Q</i> is approximated using the Pearson&apos;s series representation.</item>
 <item>Otherwise, <i>Q</i> is approximated using the continued fraction expression by Legendre.</item>
 </list>
 The R equivalent function is <c>pgamma</c>. E.g., <c>pgamma(x, s, lower=FALSE)</c>.<para> See also: </para><list type="bullet">
 <item>&quot;B Shea.&quot; Algorithm AS 239: Chi-squared and Incomplete Gamma Integral,&quot; Applied Statistics. Volume 37, Number 3, 1988, pages 466-473.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/regularized_gamma_function#regularized_gamma_functions_and_poisson_random_variables">Wikipedia: Regularized Gamma functions and Poisson random variables</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaRegularizedQ.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaRegularizedQ.evaluate(System.Double,System.Double)">
			<summary>Evaluate <i>Q(s,x)</i>.</summary>
			<param name="s"><i>s &#8805; 0</i></param>
			<param name="x"><i>x &#8805; 0</i></param>
			<returns><i>Q(s,x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaRegularizedPInverse">
			<summary>The inverse of the Regularized Incomplete Gamma P function is defined as:
 \[
 x = P^{-1}(s,u), 0 \geq u \geq 1
 \]
 <list type="bullet">
 <item>When <c>s &gt; 1</c>, we use the asymptotic inversion method.</item>
 <item>When <c>s &lt;= 1</c>, we use an approximation of <i>P(s,x)</i> together with a higher-order Newton like method.</item>
 </list>
 In both cases, the estimated value is then improved using Halley&apos;s method, c.f., <para></para>HalleyRoot.
 <para/>
 The R equivalent function is <c>qgamma</c>. E.g., <c>qgamma(u, s, lower=TRUE)</c>.<para> See also: </para><list type="bullet">
 <item>&quot;Amparo Gil, Javier Segura, and Nico M. Temme. &quot;Sections 8.3, 10.3.1, 10.6,&quot; Numerical
 Methods for Special Functions.&quot;</item>
 <item><a
 href="http://en.wikipedia.org/wiki/regularized_gamma_function#regularized_gamma_functions_and_poisson_random_variables">
 Wikipedia: Regularized Gamma functions and Poisson random variables</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaRegularizedPInverse.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaRegularizedPInverse.evaluate(System.Double,System.Double)">
			<summary>Evaluate <i>x = P<sup>-1</sup>(s,u)</i>.</summary>
			<param name="s"><i>s &gt; 0</i></param>
			<param name="u"><i>0 &#8804; u &#8804; 1</i></param>
			<returns><i>P<sup>-1</sup>(s,u)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaRegularizedP">
			<summary>The Regularized Incomplete Gamma P function is defined as:
 \[
 P(s,x) = \frac{\gamma(s,x)}{\Gamma(s)} = 1 - Q(s,x), s \geq 0, x \geq 0
 \]
 <para/>
 The R equivalent function is <c>pgamma</c>. E.g., <c>pgamma(x, s, lower=TRUE)</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/regularized_gamma_function#regularized_gamma_functions_and_poisson_random_variables">Wikipedia: Regularized Gamma functions and Poisson random variables</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaRegularizedP.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaRegularizedP.evaluate(System.Double,System.Double)">
			<summary>Evaluate <i>P(s,x)</i>.</summary>
			<param name="s"><i>s &#8805; 0</i></param>
			<param name="x"><i>x &#8805; 0</i></param>
			<returns><i>P(s,x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaLowerIncomplete">
			<summary>The Lower Incomplete Gamma function is defined as:
 \[
 \gamma(s,x) = \int_0^x t^{s-1}\,e^{-t}\,{\rm d}t = P(s,x)\Gamma(s)
 \]
 <i>P(s,x)</i> is the Regularized Incomplete Gamma P function.
 <para/>
 The integrand has the same form as the Gamma function, but the upper limit of the integration is
 a variable.
 The lower limit is fixed.<para> See also: </para><a href="http://en.wikipedia.org/wiki/incomplete_gamma_function">
 Wikipedia: Incomplete gamma function</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaLowerIncomplete.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaLowerIncomplete.evaluate(System.Double,System.Double)">
			<summary>Evaluate \(\gamma(s,x)\).</summary>
			<param name="s"><i>s &gt; 0</i></param>
			<param name="x"><i>x &#8805; 0</i></param>
			<returns>\(\gamma(s,x)\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaLanczosQuick">
			<summary>Lanczos approximation, computations are done in <c>double</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/lanczos_approximation">Wikipedia: Lanczos approximation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaLanczosQuick.#ctor">
			<summary>Construct an instance of a Gamma function, computed using the Lanczos approximation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaLanczosQuick.#ctor(System.Double,System.Int32,System.Int32)">
			<summary>Construct an instance of a Gamma function, computed using the Lanczos approximation.
 <para/>
 Recommended settings are
 <blockquote><c>
 g = 607.0 / 128.0;
 n = 15;
 scale = 30;
 </c></blockquote></summary>
			<param name="g"><i>g</i></param>
			<param name="n"><i>n</i></param>
			<param name="scale">precision</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaLanczosQuick.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaLanczos">
			<summary>Lanczos approximation provides a way to compute the Gamma function such that the accuracy can be made arbitrarily precise.
 Yet, the computations can be time-consuming if done in, e.g., <para></para>BigDecimal.<para> See also: </para><a href="http://en.wikipedia.org/wiki/lanczos_approximation">Wikipedia: Lanczos approximation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaLanczos.#ctor">
			<summary>Construct an instance of a Gamma function, computed using the Lanczos approximation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaLanczos.#ctor(System.Double,System.Int32,System.Int32)">
			<summary>Construct an instance of a Gamma function, computed using the Lanczos approximation.
 <para/>
 Recommended settings are
 <blockquote><c>
 g = 607.0 / 128.0;
 n = 15;
 scale = 30;
 </c></blockquote></summary>
			<param name="g"><i>g</i></param>
			<param name="n"><i>n</i></param>
			<param name="scale">precision</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaLanczos.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaGergoNemes">
			<summary>The Gergo Nemes&apos; algorithm is very simple and quick to compute the Gamma function, if accuracy is not critical.
 It may work better for large input.<para> See also: </para><a href="http://en.wikipedia.org/wiki/stirling%27s_approximation#a_version_suitable_for_calculators">Wikipedia: A version suitable for calculators</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaGergoNemes.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.GammaGergoNemes.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.Gamma">
			<summary>The Gamma function is an extension of the factorial function to real and complex numbers, with its argument shifted down by 1.
 For real numbers, it is defined as:
 \[
 \Gamma(z) = \int_0^\infty e^{-t} t^{z-1} dt
 \]<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/gamma_function">Wikipedia: Gamma function</a></item>
 <item><a href="http://en.wikipedia.org/wiki/lanczos_approximation">Wikipedia: Lanczos approximation</a></item>
 <item><a href="http://en.wikipedia.org/wiki/stirling%27s_approximation">Wikipedia: Stirling&apos;s approximation</a></item>
 <item><a href="http://en.wikipedia.org/wiki/spouge%27s_approximation">Wikipedia: Spouge&apos;s approximation</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.Gamma.evaluate(System.Double)">
			<summary>Evaluate \(\Gamma(z) = \int_0^\infty e^{-t} t^{z-1} dt\).</summary>
			<param name="x"><i>x</i></param>
			<returns>\(\Gamma(z)\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gamma.Digamma">
			<summary>The digamma function is defined as the logarithmic derivative of the gamma function. That is,
 \[
 \psi(x) =\frac{d}{dx} \ln{\Gamma(x)}= \frac{\Gamma&apos;(x)}{\Gamma(x)}
 \]
 <para/>
 This implementation is based on Algorithm 610.<para> See also: </para><list type="bullet">
 <item>&quot;D. E. Amos, &quot;Algorithm 610: A Portable FORTRAN Subroutine for Derivatives of the Psi Function,&quot; ACM Transactions on Mathematical Software (TOMS), Volume 9, Issue 4 (December 1983), p. 494 - 502.&quot;</item>
 <item>&quot;Shanjie Zhang, Jianming Jin, Computation of Special Functions. Wiley-Interscience; Har/Dis edition (July 12, 1996).&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/digamma_function">Wikipedia: Digamma function</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.Digamma.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gamma.Digamma.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gaussian.StandardCumulativeNormal">
			<summary>The cumulative Normal distribution function describes the probability of a Normal random variable falling in the interval \((-\infty, x]\).
 It is defined as:
 /[
 F(x;\,\mu,\sigma^2)
 = \Phi\left(\frac{x-\mu}{\sigma}\right)
 = \frac12\left[\, 1 + \operatorname{erf}\left(\frac{x-\mu}{\sigma\sqrt{2}}\right)\,\right],\quad x\in\mathbb{R}
 /]
 <para/>
 The R equivalent function is <c>pnorm</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/cumulative_normal#cumulative_distribution_function">Wikipedia: Cumulative distribution function</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.StandardCumulativeNormal.evaluate(System.Double)">
			<summary>Evaluate \(F(x;\,\mu,\sigma^2)\).</summary>
			<param name="x"><i>x</i></param>
			<returns>\(F(x;\,1,1)\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gaussian.Gaussian">
			<summary>The Gaussian function is defined as:
 \[
 f(x) = a e^{- { \frac{(x-b)^2 }{ 2 c^2} } }
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/gaussian_function">Wikipedia: Gaussian function</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.Gaussian.#ctor(System.Double,System.Double,System.Double)">
			<summary>Construct an instance of the Gaussian function.</summary>
			<param name="a"><i>a</i></param>
			<param name="b"><i>b</i></param>
			<param name="c"><i>c</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.Gaussian.#ctor">
			<summary>Construct an instance of the standard Gaussian function: \(f(x) = e^{-{\frac{(x)^2}{2}}}\)</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.Gaussian.a">
			<summary>Get <i>a</i>.</summary>
			<returns><i>a</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.Gaussian.b">
			<summary>Get <i>b</i>.</summary>
			<returns><i>b</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.Gaussian.c">
			<summary>Get <i>c</i>.</summary>
			<returns><i>c</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.Gaussian.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gaussian.ErfInverse">
			<summary>The inverse of the Error function is defined as:
 \[
 \operatorname{erf}^{-1}(x)
 \]<para> See also: </para><list type="bullet">
 <item>&quot;Paul Glasserman, &quot;Section 2.3,&quot; Monte Carlo Methods in Financial Engineering.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/error_function">Wikipedia: Error function</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.ErfInverse.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.ErfInverse.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gaussian.Erfc">
			<summary>This complementary Error function is defined as:
 \[
 \operatorname{erfc}(x)
 = 1-\operatorname{erf}(x)
 = \frac{2}{\sqrt{\pi}} \int_x^{\infty} e^{-t^2}\,dt
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/error_function">Wikipedia: Error function</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.Erfc.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.Erfc.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gaussian.Erf">
			<summary>The Error function is defined as:
 \[
 \operatorname{erf}(x) = \frac{2}{\sqrt{\pi}}\int_{0}^x e^{-t^2} dt
 \]<para> See also: </para><list type="bullet">
 <item>&quot;Paul Glasserman, &quot;Section 2.3,&quot; Monte Carlo Methods in Financial Engineering.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/error_function">Wikipedia: Error function</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.Erf.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.Erf.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gaussian.CumulativeNormalMarsaglia">
			<summary>Marsaglia is about 3 times slower but is more accurate to compute the cumulative standard Normal.
 It has a maximum relative error less than 1e-15 for 0 &lt; <i>x</i> less than 6.23025,
 and relative error &lt; 1e-12 for bigger <i>x</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.CumulativeNormalMarsaglia.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.CumulativeNormalMarsaglia.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gaussian.CumulativeNormalInverse">
			<summary>The inverse of the cumulative standard Normal distribution function is defined as:
 \[
 N^{-1}(u)
 /]
 <para/>
 This implementation uses the Beasley-Springer-Moro algorithm.
 It has a maximum absolute error of 3e-9 out to seven standard deviations.
 The error is maximal when <i>u</i> is around 0.5.
 <para/>
 The R equivalent function is <c>qnorm</c>.<para> See also: </para><list type="bullet">
 <item>&quot;Moro, B, The full monte. Risk 8 (Feb): 57-58, 1995&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/cumulative_normal#cumulative_distribution_function">Wikipedia: Cumulative distribution function</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.CumulativeNormalInverse.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.CumulativeNormalInverse.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.special.gaussian.CumulativeNormalHastings">
			<summary>Hastings algorithm is faster but less accurate way to compute the cumulative standard Normal.
 It has a maximum absolute error less than 7.5e-8.<para> See also: </para><list type="bullet">
 <item>&quot;Hastings, C., Jr. &quot;Approximations for Digital Computers,&quot; Princeton University Press, Princeton, NJ. 1995.&quot;</item>
 <item>&quot;Abramowitz, M., and Stegun, I.A, Handbook of Mathematical Functions, National Bureau of Standards, Washington, D.C. Reprinted by Dover, New York. 1964.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.CumulativeNormalHastings.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.special.gaussian.CumulativeNormalHastings.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.tuple.Triple">
			<summary>A triple is a tuple of length three. It represents an ordered list of three elements, written by
 convention as <i>(x, y, z)</i>.
 <para/>
 This class is immutable.<para> See also: </para><a href="http://en.wikipedia.org/wiki/tuple">Wikipedia: Tuple</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.Triple.#ctor(System.Double,System.Double,System.Double)">
			<summary>Creates a new triple with the given values.</summary>
			<param name="x">the first element</param>
			<param name="y">the second element</param>
			<param name="z">the third element</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.Triple.x">
			<summary>Return the value of the first element of the triple.</summary>
			<returns>the first element, x</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.Triple.y">
			<summary>Return the value of the second element of the triple.</summary>
			<returns>the second element, y</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.Triple.z">
			<summary>Return the value of the third element of the triple.</summary>
			<returns>the third element, z</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.Triple.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.tuple.SortedOrderedPairs">
			<summary>The ordered pairs are first sorted by abscissa, then by ordinate. Hence, this allows random
 access of the stored pairs.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.SortedOrderedPairs.#ctor(com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.SortedOrderedPairs.#ctor(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.SortedOrderedPairs.x">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.SortedOrderedPairs.y">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.SortedOrderedPairs.get(System.Int32)">
			<summary>Get the ordered pair at index i.</summary>
			<param name="i">the index</param>
			<returns>the pair at index i</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.SortedOrderedPairs.size">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.tuple.PartialFunction">
			<summary>A partial function from <i>X</i> to <i>Y</i> is a function <i>f: X&apos; &#8594; Y</i>, where <i>X&apos;</i>
 is a subset of <i>X</i>. It generalizes the concept of a function by not forcing <i>f</i> to map
 every element of <i>X</i> to an element of <i>Y</i> (only some subset <i>X&apos;</i> of <i>X</i>).
 <para/>
 A partial function is a special type of binary relation, which does not allow duplicated
 abscissae in its collection of ordered pairs.
 <para/>
 This class is immutable.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.PartialFunction.#ctor(System.Double[],System.Double[])">
			<summary>Construct a partial function from {(x,y)}.</summary>
			<param name="x">elements in A</param>
			<param name="y">elements in A</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.PartialFunction.x">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.PartialFunction.y">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.PartialFunction.size">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.tuple.PairComparatorByAbscissaOnly">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.PairComparatorByAbscissaOnly.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.PairComparatorByAbscissaOnly.#ctor(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.PairComparatorByAbscissaOnly.compare(com.numericalmethod.suanshu.analysis.function.tuple.Pair,com.numericalmethod.suanshu.analysis.function.tuple.Pair)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.tuple.PairComparatorByAbscissaFirst">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.PairComparatorByAbscissaFirst.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.PairComparatorByAbscissaFirst.#ctor(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.PairComparatorByAbscissaFirst.compare(com.numericalmethod.suanshu.analysis.function.tuple.Pair,com.numericalmethod.suanshu.analysis.function.tuple.Pair)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.tuple.Pair">
			<summary>An ordered pair (x,y) is a pair of mathematical objects.
 In the ordered pair (x,y), the object a is called the first entry, and the object b the second
 entry of the pair.
 Alternatively, the objects are called the first and second coordinates, or the left and right
 projections of the ordered pair.
 The order in which the objects appear in the pair is significant: the ordered pair (x,y) is
 different from the ordered pair (y,x) unless x = y.
 <para/>
 This class is immutable.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.Pair.#ctor(System.Double,System.Double)">
			<summary>Construct a pair.</summary>
			<param name="x"><i>x</i></param>
			<param name="y"><i>y</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.Pair.x">
			<summary><i>x</i></summary>
			<returns><i>x</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.Pair.y">
			<summary><i>y</i></summary>
			<returns><i>y</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.Pair.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.Pair.hashCode">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.Pair.compareTo(com.numericalmethod.suanshu.analysis.function.tuple.Pair)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs">
			<summary>Cartesian products and binary relations (and hence the ubiquitous functions) are defined in terms
 of ordered pairs.<para> See also: </para><a href="http://en.wikipedia.org/wiki/ordered_pairs">Wikipedia: Ordered pair</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs.x">
			<summary>Get the abscissae.</summary>
			<returns>the abscissae</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs.y">
			<summary>Get the ordinates.</summary>
			<returns>the ordinates</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.OrderedPairs.size">
			<summary>Get the number of points.</summary>
			<returns>the number of points</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.function.tuple.DuplicatedAbscissae">
			<summary>This exception is thrown when a function has two same x-abscissae, hence ill-defined.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.DuplicatedAbscissae.#ctor">
			<summary>Construct an instance.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.function.tuple.DuplicatedAbscissae.#ctor(System.String)">
			<summary>Construct a <c>DuplicatedAbscissae</c> runtime exception with an error message.</summary>
			<param name="msg">the error message</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.Lebesgue">
			<summary>Lebesgue integration is the general theory of integration of a function with respect to a general measure.
 <para/>
 This implementation defines an Lebesgue integral as a dot product between the integrand <i>f</i> and the measure <i>d&#956;</i>.
 \[
 \int_E f \, d \mu = \int_E f(x) \, \mu(dx) \approx \sum_E f(x)\mu(dx)
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.Lebesgue.#ctor(System.Double[],System.Double[])">
			<summary>Construct a Lebesgue integral.</summary>
			<param name="fx">the integrand values</param>
			<param name="du">the measure values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.Lebesgue.value">
			<summary>Get the integral value.</summary>
			<returns>the integral value</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.Riemann">
			<summary>This is a wrapper class that integrates a function by using an appropriate integrator together with Romberg&apos;s method.
 The integral can be definite or indefinite.
 For an indefinite integral, it requires the specification of a substitution rule (change of variable).<para> See also: </para><a href="http://en.wikipedia.org/wiki/riemann_integral">Wikipedia: Riemann integral</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.Riemann.#ctor(System.Double,System.Int32)">
			<summary>Construct an integrator.</summary>
			<param name="precision">the convergence threshold</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.Riemann.#ctor">
			<summary>Construct an integrator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.Riemann.integrate(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.Riemann.integrate(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.SubstitutionRule)">
			<summary>Integrate a function, <i>f</i>, from <i>a</i> to <i>b</i> possibly using change of variable.</summary>
			<param name="f">a univariate function</param>
			<param name="a">the lower limit</param>
			<param name="b">the upper limit</param>
			<param name="change">the substitution rule; <c>null</c> for a definite integral (no singularity)</param>
			<returns>\(\int_a^b\! f(x)\, dx\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.Riemann.getPrecision">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.IterativeIntegrator">
			<summary>An iterative integrator computes an integral by a series of sums, which approximates the value of the integral.
 The sum is refined iteratively, generally, by using a finer discretization of the integrand.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.IterativeIntegrator.h">
			<summary>Get the discretization size for the current iteration.</summary>
			<returns>the discretization size</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.IterativeIntegrator.next(System.Int32,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,System.Double)">
			<summary>Compute a refined sum for the integral.</summary>
			<param name="iteration">the index/count for the current iteration, counting from 1</param>
			<param name="f">the integrand</param>
			<param name="a">the lower limit</param>
			<param name="b">the upper limit</param>
			<param name="sum0">the last sum</param>
			<returns>a refined sum</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.IterativeIntegrator.getMaxIterations">
			<summary>Get the maximum number of iterations for this iterative procedure.
 For those integrals that do not converge, we need to put a bound on the number of iterations to avoid infinite looping.</summary>
			<returns>the maximum number of iterations</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.Integrator">
			<summary>This defines the interface for the numerical integration of definite integrals of univariate functions.<para> See also: </para><a href="http://en.wikipedia.org/wiki/numerical_integration">Wikipedia: Numerical integration</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.Integrator.integrate(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double)">
			<summary>Integrate function <i>f</i> from <i>a</i> to <i>b</i>,
 \[
 \int_a^b\! f(x)\, dx
 \]</summary>
			<param name="f">a univariate function</param>
			<param name="a">the lower limit</param>
			<param name="b">the upper limit</param>
			<returns>\(\int_a^b\! f(x)\, dx\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.Integrator.getPrecision">
			<summary>Get the convergence threshold. The usage depends on the specific integrator.
 For example, for an <para></para>IterativeIntegrator,
 the integral is considered converged if the relative error of two successive sums is less than the threshold.</summary>
			<returns>the precision</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.ChangeOfVariable">
			<summary>Change of variable can easy the computation of some integrals, such as improper integrals.
 The idea is to transform a dependent variable, <i>x</i>, to another variable, <i>t</i>, so that the &quot;new&quot; integral is easier to compute.
 <para/>
 We set
 /[
 x = x(t)
 t = x^{-1}(x) = t(x)
 /]
 such that,
 /[
 \int_{a}^{b} f(x)\,dx = \int_{t(a)}^{t(b)} f(x)x&apos;(t)\, dt
 /]<para> See also: </para><a href="http://en.wikipedia.org/wiki/integration_by_substitution">Wikipedia: Integration by substitution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.ChangeOfVariable.#ctor(com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.SubstitutionRule,com.numericalmethod.suanshu.analysis.integration.univariate.riemann.Integrator)">
			<summary>Construct an integrator that uses change of variable to do integration.</summary>
			<param name="change">the substitution formula</param>
			<param name="integrator">the integrator.
                   If there is a singularity at an endpoint, the integrator should use an <em>open</em> formula such as <para></para>Midpoint;
                   otherwise, use an integrator with a <em>closed</em> formula such as <para></para>Trapezoidal.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.ChangeOfVariable.integrate(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.ChangeOfVariable.fdx(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Get the integrand in the &quot;transformed&quot; integral, <i>g(t) = f(x(t)) * x&apos;(t)</i>.</summary>
			<param name="f">the integrand in the original integral</param>
			<returns>the integrand in the &quot;transformed&quot; integral</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.ChangeOfVariable.getPrecision">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.GaussLegendreQuadrature">
			<summary>Gauss-Legendre quadrature considers the simplest case of uniform weighting: \(w(x) = 1\). Hence,
 this method is useful for functions \(f(x)\) which can be approximated by polynomials. Therefore,
 this method is for finding the integral
 \[
 \int_{-1}^1 f(x)\,dx
 \]
 where \(f(x)\) can be well approximated by a polynomial.
 <para/>
 For finding an integral over the interval [a,b], that is,
 \[
 \int_{a}^b f(x)\,dx
 \]
 change of variable can be used.
 <para/>
 Generating evaluation points is done by finding roots of Legendre polynomials, hence the name of
 this method. Finding the roots has to be done numerically, but the coefficients can be computed
 directly. Since the roots lie within the open interval (-1, 1), the formulae are open integration
 formulae.<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/gaussian_quadrature#gauss.e2.80.93legendre_quadrature">
 Wikipedia: Gaussian quadrature - Gauss-Legendre quadrature</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.GaussLegendreQuadrature.#ctor(System.Int32)">
			<summary>Create an integrator of order n.</summary>
			<param name="n">the number of points in the quadrature rule</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.GaussLaguerreQuadrature">
			<summary>Gauss-Laguerre quadrature exploits the fact that quadrature approximations are open integration
 formulas (i.e. the values of the endpoints are not required) to evaluate of integrals in the
 range \([0, \infty )\).
 <para/>
 The choice of weighting function \(\exp(-x)\) results in the evaluation points being the roots of
 Laguerre Polynomials, which have to be found numerically.
 <para/>
 Therefore, this method is useful for finding the integral
 \[
 \int_0^\infty f(x) e^{-x} \, dx.
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/gauss%e2%80%93laguerre_quadrature">Wikipedia:
 Gauss-Laguerre quadrature</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.GaussLaguerreQuadrature.#ctor(System.Int32,System.Double)">
			<summary>Create an integrator of order n.</summary>
			<param name="n">the number of points in the quadrature rule</param>
			<param name="precision">the precision of the estimates of the coefficients</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.GaussianQuadrature">
			<summary>A quadrature rule is a method of numerical integration in which we approximate the integral of a
 function by a weighted sum of sample points. That is,
 \[
 \int_{a}^b f(x)\,dx \approx \sum_{i=1}^n c_i f(x_i).
 \]
 <para/>
 By a suitable choice of the points \(x_i\) and the weights \(c_i\), an <i>n</i>-point weighted
 sum will yield an exact result for polynomials of degree <i>(2n-1)</i> or less, which is known
 as a Gaussian quadrature rule.
 <para/>
 Gaussian quadrature will only produce accurate results if \(f(x)\) is well approximated by a
 polynomial function within the range [-1,1]. However, if the integrated function can be written
 as \(f(x) = W(x) g(x)\) where \(g(x)\) is approximately polynomial and \(W(x)\) is known, then
 there are alternative weights \(w_i&apos;\) such that
 \[
 \int_{a}^b f(x)\,dx =\int_{a}^b W(x) g(x)\,dx \approx \sum_{i=1}^n w_i&apos; g(x_i).
 \]
 <para/>
 Note that the precision for Gaussian quadrature rules cannot be specified, and hence calling
 <para></para>Integrator#getPrecision() will throw an <para></para>UnsupportedOperationException.<para> See also: </para><a href="http://en.wikipedia.org/wiki/gaussian_quadrature">Wikipedia: Gaussian
 quadrature</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.GaussianQuadrature.#ctor(com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.GaussianQuadratureRule)">
			<summary>Create a Gaussian quadrature integrator with the given quadrature rule.</summary>
			<param name="rule">the Gaussian quadrature rule</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.GaussianQuadrature.integrate(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.GaussianQuadrature.getPrecision">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.GaussHermiteQuadrature">
			<summary>Gauss-Hermite quadrature exploits the fact that quadrature approximations are open integration
 formulas (that is, the values of the endpoints are not required) to evaluate of integrals in the
 range \((-\infty, \infty )\).
 <para/>
 The weighting function in this case is \(\exp(-x^2)\), which results in the evaluation points
 being roots of Hermite polynomials.
 <para/>
 Therefore, the method can be used for finding the integral
 \[
 \int_{-\infty}^{+\infty} e^{-x^2} f(x)\,dx.
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/gauss%e2%80%93hermite_quadrature">Wikipedia:
 Gauss-Hermite quadrature</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.GaussHermiteQuadrature.#ctor(System.Int32)">
			<summary>Create an integrator of order n.</summary>
			<param name="n">the number of points in the quadrature rule</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.GaussChebyshevQuadrature">
			<summary>Gauss-Chebyshev Quadrature uses the following weighting function:
 \[
 w(x) = \frac{1}{\sqrt{1 - x^2}}
 \]
 to evaluate integrals in the interval (-1, 1). Therefore, this method can be used for finding the
 integral
 \[
 \int_{-1}^{+1} \frac {f(x)} {\sqrt{1 - x^2} }\,dx.
 \]
 <para/>
 This results in the evaluation points being roots of Chebyshev polynomials. In this method, both
 the coefficients and the evaluation points can be calculated directly.<para> See also: </para><a href="http://en.wikipedia.org/wiki/chebyshev%e2%80%93gauss_quadrature">Wikipedia:
 Chebyshev-Gauss quadrature</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.GaussChebyshevQuadrature.#ctor(System.Int32)">
			<summary>Create an integrator of order n.</summary>
			<param name="n">the number of points in the quadrature rule</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.OrthogonalPolynomialFamily">
			<summary>This factory class produces a family of orthogonal polynomials.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.OrthogonalPolynomialFamily.getPolynomial(System.Int32)">
			<summary>Return an instance of the polynomial class of a given order.</summary>
			<param name="order">the order of the polynomial</param>
			<returns>the polynomial instance</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LegendreRule">
			<summary><para> See also: </para><a href="http://en.wikipedia.org/wiki/legendre_polynomials">Wikipedia: Legendre
 polynomials</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LegendreRule.#ctor(System.Int32)">
			<summary>Create a Legendre rule of the given order.</summary>
			<param name="n">the number of points in the quadrature rule</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LegendreRule.getEvaluationPoints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LegendreRule.getCoefficients">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LegendreRule.getWeighting(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LegendreRule.supportsInterval(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LegendrePolynomials">
			<summary>A Legendre polynomial is defined by the recurrence relation below.
 \[
 P_0(x) = 1,\quad P_1(x) = x, \quad (n+1) P_{n+1}(x) = (2n+1) x P_n(x) - n P_{n-1}(x).
 \]
 <para/>
 Legendre polynomials are derived from a differential equation encountered in physics and
 engineering.<para> See also: </para><a href="http://en.wikipedia.org/wiki/legendre_polynomials">Wikipedia: Legendre
 polynomials</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LegendrePolynomials.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LegendrePolynomials.getPolynomial(System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LaguerreRule">
			<summary><para> See also: </para><a href="http://en.wikipedia.org/wiki/laguerre_polynomials">Wikipedia: Laguerre
 polynomials</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LaguerreRule.#ctor(System.Int32,System.Double)">
			<summary>Create a Laguerre rule of the given order.</summary>
			<param name="n">the number of points in the quadrature rule</param>
			<param name="precision">the precision of the estimates of the coefficients</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LaguerreRule.getEvaluationPoints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LaguerreRule.getCoefficients">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LaguerreRule.getWeighting(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LaguerreRule.supportsInterval(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LaguerrePolynomials">
			<summary>Laguerre polynomials are defined by the recurrence relation below.
 \[
 L_0(x) = 1,\quad L_1(x) = 1 - x, \quad (k+1) L_{k+1}(x) = (2k+1-x) L_k(x) - k L_{n-1}(x).
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/laguerre_polynomials">Wikipedia: Laguerre
 polynomials</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LaguerrePolynomials.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.LaguerrePolynomials.getPolynomial(System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.HermiteRule">
			<summary><para> See also: </para><a href="http://en.wikipedia.org/wiki/hermite_polynomials">Wikipedia: Hermite
 polynomials</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.HermiteRule.#ctor(System.Int32)">
			<summary>Create a Hermite rule of the given order.</summary>
			<param name="n">the number of points in the quadrature rule</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.HermiteRule.getEvaluationPoints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.HermiteRule.getCoefficients">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.HermiteRule.getWeighting(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.HermiteRule.supportsInterval(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.HermitePolynomials">
			<summary>A Hermite polynomial is defined by the recurrence relation below.
 \[
 H_0(x) = 1,\quad H_1(x) = 2x, \quad (k+1) H_{k+1}(x) = 2x H_k(x) - 2k H_{k-1}(x).
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/hermite_polynomials">Wikipedia: Hermite
 polynomials</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.HermitePolynomials.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.HermitePolynomials.getPolynomial(System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.GaussianQuadratureRule">
			<summary>This interface defines a Gaussian quadrature rule used in Gaussian quadrature.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.GaussianQuadratureRule.getEvaluationPoints">
			<summary>Get the evaluation points for the quadrature rule (\(x_i\)).</summary>
			<returns>the evaluation points</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.GaussianQuadratureRule.getCoefficients">
			<summary>Get the coefficients \(c_i\) associated with each evaluation point \(x_i\).</summary>
			<returns>the coefficients of the evaluation points</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.GaussianQuadratureRule.getWeighting(System.Double)">
			<summary>Get the weighting \(w(x_i)\) associated with a point \(x_i\).</summary>
			<param name="x">the evaluation point</param>
			<returns>the weighting of the given evaluation point \(w(x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.GaussianQuadratureRule.supportsInterval(System.Double,System.Double)">
			<summary>Return whether the given interval <i>(a,b)</i> is supported by this rule.</summary>
			<param name="a">the start point of the interval</param>
			<param name="b">the end point of the interval</param>
			<returns><c>true</c> if the interval is supported</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.ChebyshevRule">
			<summary><para> See also: </para><a href="http://en.wikipedia.org/wiki/chebyshev%e2%80%93gauss_quadrature">
 Wikipedia: Chebyshev-Gauss quadrature</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.ChebyshevRule.#ctor(System.Int32)">
			<summary>Create a Chebyshev rule of the given order.</summary>
			<param name="n">the number of points in the quadrature rule</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.ChebyshevRule.getEvaluationPoints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.ChebyshevRule.getCoefficients">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.ChebyshevRule.getWeighting(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.gaussian.rule.ChebyshevRule.supportsInterval(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Trapezoidal">
			<summary>The Trapezoidal rule is a closed type Newton-Cotes formula, where the integral interval is evenly divided into <i>N</i> sub-intervals.
 Each sub-interval is divided into two in each iteration.<para> See also: </para><a href="http://en.wikipedia.org/wiki/trapezoidal_rule">Wikipedia: Trapezoidal rule</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Trapezoidal.#ctor(System.Double,System.Int32)">
			<summary>Construct an integrator that implements the Trapezoidal rule.</summary>
			<param name="precision">the convergence threshold</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Simpson">
			<summary>Simpson&apos;s rule can be thought of as a special case of Romberg&apos;s method.
 It is the weighted average (or extrapolation) of two successive iterations of the <para></para>Trapezoidal rule.
 Simpson&apos;s rule is often an accurate integration rule.
 Simpson&apos;s is expected to improve on the trapezoidal rule for functions which are twice continuously differentiable.
 However for rougher functions the trapezoidal rule is likely to be more preferable.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/simpson%27s_rule">Wikipedia: Simpson&apos;s rule</a></item>
 <item><a href="http://en.wikipedia.org/wiki/rectangle_rule">Wikipedia: Rectangle method</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Simpson.#ctor(System.Double,System.Int32)">
			<summary>Construct an integrator that implements Simpson&apos;s rule.</summary>
			<param name="precision">the convergence threshold</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Simpson.integrate(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Simpson.next(System.Int32,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Simpson.h">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Simpson.getMaxIterations">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Simpson.getPrecision">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Romberg">
			<summary>Romberg&apos;s method computes an integral by generating a sequence of estimations of the integral value and then doing an extrapolation.
 The estimations are extrapolated to where the discretization is 0.
 Simpson&apos;s rule is a special case of Romberg&apos;s method, with the number of points for extrapolation equal to 2.<para> See also: </para><a href="http://en.wikipedia.org/wiki/romberg_integration">Wikipedia: Romberg&apos;s method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Romberg.#ctor(com.numericalmethod.suanshu.analysis.integration.univariate.riemann.IterativeIntegrator)">
			<summary>Extend an integrator using Romberg&apos;s method.</summary>
			<param name="integrator">an iterative integrator that must do at least 2 iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Romberg.integrate(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Romberg.getPrecision">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes">
			<summary>The Newton-Cotes formulae, also called the Newton-Cotes quadrature rules or simply Newton-Cotes rules,
 are a group of formulae for numerical integration (also called quadrature) based on evaluating the integrand at equally-spaced points.
 A number of standard numerical quadrature methods are special cases of the more general Newton-Cotes formula,
 e.g., the Trapezoidal rule (<c>rate = 2</c>), the Midpoint method (<c>rate = 2</c> and specifying <c>OPEN</c> formula).
 <para/>
 This implementation is based on the Euler-Maclaurin formula.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/newton%e2%80%93cotes_formulas">Wikipedia: Newton-Cotes formulas</a></item>
 <item><a href="http://en.wikipedia.org/wiki/euler_maclaurin">Wikipedia: Euler-Maclaurin formula</a></item>
 <item><a href="http://en.wikipedia.org/wiki/trapezoidal_rule">Wikipedia: Trapezoidal rule</a></item>
 <item><a href="http://en.wikipedia.org/wiki/rectangle_rule">Wikipedia: Rectangle method</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes.#ctor(System.Int32,com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes.Type,System.Double,System.Int32)">
			<summary>Construct an instance of the Newton-Cotes quadrature.</summary>
			<param name="rate">the rate of further sub-dividing an integral interval. For example, when <c>rate = 2</c>, we divide <i>[x<sub>i</sub>, x<sub>i+1</sub>]</i> into two equal length intervals. This is equivalent to the Trapezoidal rule.</param>
			<param name="type">specifying whether to use CLOSED or OPEN formula</param>
			<param name="precision">the precision required, e.g., <c>1e-8</c></param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes.integrate(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes.next(System.Int32,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes.h">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes.getMaxIterations">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes.getPrecision">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes.Type">
			<summary>There are two types of the Newton-Cotes method: OPEN and CLOSED.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes.Type.CLOSED">
			<summary>The first and the last terms in the Euler-Maclaurin formula are included in the sum.
 They are:
 <i>1/2 * f(x<sub>0</sub>)</i>, and
 <i>1/2 * f(x<sub>n</sub>)</i>.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes.Type.OPEN">
			<summary>The first and the last terms in the Euler-Maclaurin formula are not included in the sum.
 This is to avoid computing for end points where <i>f(x)</i> cannot be evaluated.
 Instead, we use the mid-point to make the first rough estimate of the integral.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes.Type.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.NewtonCotes.Type.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Midpoint">
			<summary>The midpoint rule computes an approximation to a definite integral,
 made by finding the area of a collection of rectangles whose heights are determined by the values of the function.
 Specifically, the interval over which the function is to be integrated is divided into equal subintervals of length.
 The rectangles are then drawn.
 The approximation to the integral is then calculated by adding up the areas (base multiplied by height) of the rectangles.<para> See also: </para><a href="http://en.wikipedia.org/wiki/rectangle_rule">Wikipedia: Rectangle method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.newtoncotes.Midpoint.#ctor(System.Double,System.Int32)">
			<summary>Construct an integrator that implements the Midpoint rule.</summary>
			<param name="precision">the convergence threshold</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.SubstitutionRule">
			<summary>A substitution rule specifies \(x(t)\) and \(\frac{\mathrm{d} x}{\mathrm{d} t}\).
 <para/>
 We set
 /[
 x = x(t)
 t = x^{-1}(x) = t(x)
 /]
 such that,
 /[
 \int_{a}^{b} f(x)\,dx = \int_{t(a)}^{t(b)} f(x)x&apos;(t)\, dt
 /]<para> See also: </para><a href="http://en.wikipedia.org/wiki/substitution_rule">Wikipedia: Integration by substitution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.SubstitutionRule.x">
			<summary>the transformation: <i>x(t)</i></summary>
			<returns><i>x(t)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.SubstitutionRule.dx">
			<summary>the first order derivative of the transformation: <i>x&apos;(t) = dx(t)/dt</i></summary>
			<returns><i>x&apos;(t) = dx(t)/dt</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.SubstitutionRule.ta">
			<summary>Get the lower limit of the integral.</summary>
			<returns>the lower limit</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.SubstitutionRule.tb">
			<summary>Get the upper limit of the integral.</summary>
			<returns>the upper limit</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.StandardInterval">
			<summary>This transformation is for mapping integral region from <i>[a, b]</i> to <i>[-1, 1]</i>.
 The substitution rule is
 \[
 \int_{a}^{b}f(x)dx = \int_{-1}^{1}\frac{b-a}{2}f(\frac{(b-a)t+(a+b)}{2})dt
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.StandardInterval.#ctor(System.Double,System.Double)">
			<summary>Construct a <c>StandardInterval</c> substitution rule.</summary>
			<param name="a">the lower limit</param>
			<param name="b">the upper limit</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.StandardInterval.x">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.StandardInterval.dx">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.StandardInterval.ta">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.StandardInterval.tb">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.PowerLawSingularity">
			<summary>This transformation is good for an integral which diverges at one of the end points.
 <para/>
 For singularity at the lower limit, we have \((x-a)^{-\gamma}\) diverging near \(x = a\), \(0 \leq \gamma &lt; 1\).
 The substitution rule is
 \[
 \int_{a}^{b}f(x)dx = \int_{0}^{(b-a)^{1-\gamma}}\frac{t^{\frac{\gamma}{1-\gamma}}f(t^\frac{1}{1-\gamma}+a)}{1-\gamma}dt, b &gt; a
 \]
 <para/>
 For singularity at the upper limit, we have \((x-b)^{-\gamma}\) diverging near \(x = b\), \(0 \leq \gamma &lt; 1\).
 \[
 \int_{a}^{b}f(x)dx = \int_{0}^{(b-a)^{1-\gamma}}\frac{t^{\frac{\gamma}{1-\gamma}}f(b-t^\frac{1}{1-\gamma})}{1-\gamma}dt, b &gt; a
 \]
 A common case is when \(\gamma = 0.5\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.PowerLawSingularity.#ctor(com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.PowerLawSingularity.PowerLawSingularityType,System.Double,System.Double,System.Double)">
			<summary>Construct a <c>PowerLawSingularity</c> substitution rule.</summary>
			<param name="type">the type of end point divergence</param>
			<param name="gamma">the exponential</param>
			<param name="a">the lower limit</param>
			<param name="b">the upper limit</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.PowerLawSingularity.x">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.PowerLawSingularity.dx">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.PowerLawSingularity.ta">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.PowerLawSingularity.tb">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.PowerLawSingularity.PowerLawSingularityType">
			<summary>the type of end point divergence</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.PowerLawSingularity.PowerLawSingularityType.UPPER">
			<summary>diverge near <i>x = b</i></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.PowerLawSingularity.PowerLawSingularityType.LOWER">
			<summary>diverge near <i>x = a</i></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.PowerLawSingularity.PowerLawSingularityType.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.PowerLawSingularity.PowerLawSingularityType.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.NoChangeOfVariable">
			<summary>This is a dummy substitution rule that does not change any variable. It is mainly for testing purpose.
 The substitution is
 \[
 \int_{a}^{b}f(x)dx = \int_{a}^{b}f(t)dt
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.NoChangeOfVariable.#ctor(System.Double,System.Double)">
			<summary>Construct an <c>NoChangeOfVariable</c> substitution rule.</summary>
			<param name="a">the lower limit</param>
			<param name="b">the upper limit</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.NoChangeOfVariable.x">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.NoChangeOfVariable.dx">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.NoChangeOfVariable.ta">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.NoChangeOfVariable.tb">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.MixedRule">
			<summary>The mixed rule is good for functions that fall off rapidly at infinity, e.g., \(e^{x^2}\) or \(e^x\)
 The integral region is \((0, +\infty)\).
 The tricky part of using this transformation is to figure out a good range for <i>t</i>.
 If there is information about the integrand available, <para></para>SubstitutionRule#ta() and <para></para>SubstitutionRule#tb() should be overridden.
 The substitution is
 \[
 x = e^{t - e^{-t}}
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/tanh-sinh_quadrature">Wikipedia: Tanh-sinh quadrature</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.MixedRule.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,System.Double)">
			<summary>Construct a <c>MixedRule</c> substitution rule.</summary>
			<param name="f">the integrand</param>
			<param name="a">the lower limit</param>
			<param name="b">the upper limit</param>
			<param name="c">usually either 0 or 0.5 * PI</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.InvertingVariable">
			<summary>This is the inverting-variable transformation. It is good for
 <list type="bullet">
 <item>\(b \to \infty, a &gt; 0\)</item>
 <item>\(a \to -\infty, b &lt; 0\)</item>
 <item>any function that decreases toward infinity faster than \(\frac{1}{x^2}\)</item>
 </list>
 The integrator for this substitution should use an OPEN formula to avoid computing for the end point where <i>t = 0</i>.
 The substitution is
 \[
 \int_{a}^{b}f(x)dx = \int_{1/b}^{1/a}\frac{1}{t^2}f(\frac{1}{t})dt, ab &gt; 0
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.InvertingVariable.#ctor(System.Double,System.Double)">
			<summary>Construct an <c>InvertingVariable</c> substitution rule.</summary>
			<param name="a">the lower limit</param>
			<param name="b">the upper limit</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.InvertingVariable.x">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.InvertingVariable.dx">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.InvertingVariable.ta">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.InvertingVariable.tb">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.Exponential">
			<summary>This transformation is good for when the lower limit is finite, the upper limit is infinite, and the integrand falls off exponentially.
 The integrator for this substitution should use an OPEN formula to avoid computing for the end point where <i>t = 0</i>.
 The substitution is
 \[
 \int_{a}^{\infty}f(x)dx = \int_{0}^{e^a}f(-\log (t))\frac{\mathrm{d} t}{t}
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.Exponential.#ctor(System.Double)">
			<summary>Construct an <c>Exponential</c> substitution rule.</summary>
			<param name="a">the lower limit</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.Exponential.x">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.Exponential.dx">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.Exponential.ta">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.Exponential.tb">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.DoubleExponential4RealLine">
			<summary>This transformation is good for the region \((-\infty, +\infty)\).
 The tricky part of using this transformation is to figure out a good range for <i>t</i>.
 If there is information about the integrand available, <para></para>SubstitutionRule#ta() and <para></para>SubstitutionRule#tb() should be overridden.
 The substitution is
 <code><i>
 x = sinh(c sinh(t))
 </i></code><para> See also: </para><a href="http://en.wikipedia.org/wiki/tanh-sinh_quadrature">Wikipedia: Tanh-sinh quadrature</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.DoubleExponential4RealLine.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,System.Double)">
			<summary>Construct a <c>DoubleExponential4RealLine</c> substitution rule.</summary>
			<param name="f">the integrand</param>
			<param name="a">the lower limit</param>
			<param name="b">the upper limit</param>
			<param name="c">usually either 0 or 0.5 * PI</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.DoubleExponential4HalfRealLine">
			<summary>This transformation is good for the region \((0, +\infty)\).
 The tricky part of using this transformation is to figure out a good range for <i>t</i>.
 If there is information about the integrand available, <para></para>SubstitutionRule#ta() and <para></para>SubstitutionRule#tb() should be overridden.
 The substitution is
 <code><i>
 x = exp(2c sinh(t))
 </i></code><para> See also: </para><a href="http://en.wikipedia.org/wiki/tanh-sinh_quadrature">Wikipedia: Tanh-sinh quadrature</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.DoubleExponential4HalfRealLine.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,System.Double)">
			<summary>Construct a <c>DoubleExponential4HalfRealLine</c> substitution rule.</summary>
			<param name="f">the integrand</param>
			<param name="a">the lower limit</param>
			<param name="b">the upper limit</param>
			<param name="c">usually either 0 or 0.5 * PI</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.DoubleExponential">
			<summary>This transformation speeds up the convergence of the Trapezoidal Rule exponentially.
 It applies to a finite integral region <i>[a, b]</i>.
 The tricky part of using this transformation is to figure out a good range for <i>t</i>.
 If there is information about the integrand available, <para></para>SubstitutionRule#ta() and <para></para>SubstitutionRule#tb() should be overridden.
 The substitution is
 <code><i>
 x = 0.5 * (b + a) + 0.5 * (b - a) * tanh(c * sinh(t))
 </i></code><para> See also: </para><a href="http://en.wikipedia.org/wiki/tanh-sinh_quadrature">Wikipedia: Tanh-sinh quadrature</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.DoubleExponential.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,System.Double)">
			<summary>Construct a <c>DoubleExponential</c> substitution rule by trying to automatically determine the substitution rule.</summary>
			<param name="f">the integrand</param>
			<param name="a">the lower limit</param>
			<param name="b">the upper limit</param>
			<param name="c">a constant; usually either 0 or 0.5 * PI</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.DoubleExponential.x">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.DoubleExponential.dx">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.DoubleExponential.ta">
			<summary>

 The accuracy of using the double exponential transformation lies in choosing the correct region of <i>t</i> for integration.
 It is very hard to determine the region without knowing about the function, such as where the singularities are.
 If the region of <i>t</i> is known, override this function.</summary>
			<returns>the lower limit</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.integration.univariate.riemann.substitution.DoubleExponential.tb">
			<summary>

 The accuracy of using the double exponential transformation lies in choosing the correct region of <i>t</i> for integration.
 It is very hard to determine the region without knowing about the function, such as where the singularities are.
 If the region of <i>t</i> is known, override this function.</summary>
			<returns>the upper limit</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.root.multivariate.NewtonSystemRoot">
			<summary>This class solves the root for a non-linear system of equations. The procedure is the following.
 <list type="number">
 <item>choose an initial guess for the root of the system</item>
 <item>evaluate the Jacobian at the current best solution, <i>x_old</i></item>
 <item>solve the linear system <i>J(x_old)Z = -f(x_old)</i>, where <i>Z = x_new - x_old</i></item>
 <item>obtain <i>x_new</i> by using <i>x_new = x_old + Z</i></item>
 <item>repeat until either it converges or the maximum number of iterations is reached</item>
 <item>return the best solution thus far</item>
 </list><para> See also: </para>&quot;Butt, R., &apos;p. 790 - 799&apos;, Applied Linear Algebra and Optimization Using MATLAB&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.multivariate.NewtonSystemRoot.#ctor(System.Double,System.Int32)">
			<summary>Constructs an instance of Newton&apos;s root finding algorithm for a system of non-linear
 equations.</summary>
			<param name="accuracy">the convergence tolerance</param>
			<param name="maxIter">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.multivariate.NewtonSystemRoot.solve(com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Searches for a root, <i>x</i> such that <i>f(x) = 0</i>.</summary>
			<param name="f">a multivariate function</param>
			<param name="guess">an initial guess of the root</param>
			<returns>an approximate root</returns>
			<exception cref="T:com.numericalmethod.suanshu.analysis.root.univariate.NoRootFoundException">when the search fails to find a root</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.multivariate.NewtonSystemRoot.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Searches for a root, <i>x</i> such that <i>f(x) = 0</i>.</summary>
			<param name="f">a system of equations</param>
			<param name="guess">an initial guess of the root</param>
			<returns>an approximate root</returns>
			<exception cref="T:com.numericalmethod.suanshu.analysis.root.univariate.NoRootFoundException">when the search fails to find a root</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.root.univariate.Uniroot">
			<summary>A root-finding algorithm is a numerical algorithm for finding a value <i>x</i> such that <i>f(x) = 0</i>, for a given function <i>f</i>.
 Such an <i>x</i> is called a root of the function <i>f</i>.
 <para/>
 The R equivalent function is <c>uniroot</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/root_finding"> Wikipedia: Root-finding algorithm</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.Uniroot.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,System.Double[])">
			<summary>Search for a root, <i>x</i>, in the interval <i>[lower, upper]</i> such that <i>f(x) = 0</i>.</summary>
			<param name="f">a univariate function</param>
			<param name="lower">the lower bound of the bracketing interval</param>
			<param name="upper">the upper bound of the bracketing interval</param>
			<param name="guess">an initial guess of the root within <i>[lower, upper]</i>.
 Note that <c>guess</c> is a <c>double[]</c>.
 This signature allows multiple initial guesses for certain types of uniroot algorithms, e.g., Brent&apos;s algorithm.</param>
			<returns>an approximate root</returns>
			<exception cref="T:com.numericalmethod.suanshu.analysis.root.univariate.NoRootFoundException">when the search fails to find a root</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.root.univariate.NoRootFoundException">
			<summary>This is the <para></para>Exception thrown when it fails to find a root.
 It may contain some information about the state before it throws the exception.
 It may be be useful in situations where an (approximate) root is needed at the sacrifice of accuracy.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.NoRootFoundException.#ctor(System.Double,System.Double)">
			<summary>Construct a <c>NoRootFoundException</c>.
 This object gives a snapshot/information of the uniroot algorithm before it throws the exception.</summary>
			<param name="x">the best approximate root found before throwing exception</param>
			<param name="fx">the function value <i>f(x)</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.NoRootFoundException.x">
			<summary>the best approximate root found so far</summary>
			<returns>a root</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.NoRootFoundException.fx">
			<summary>Get <i>f(x)</i>.</summary>
			<returns><i>f(x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.root.univariate.NewtonRoot">
			<summary>The Newton-Raphson method is as follows: one starts with an initial guess which is reasonably
 close to the true root, then the function is approximated by its tangent line (which can be
 computed using the tools of calculus), and one computes the x-intercept of this tangent line
 (which is easily done with elementary algebra). This x-intercept will typically be a better
 approximation to the function&apos;s root than the original guess, and the method can be iterated. It
 has the following properties.
 <list type="bullet">
 <item>The function to be solved is assumed to be continuous and smooth (1st derivative
 exists).</item>
 <item>The solution converges quadratically, when the multiplicity of the root is 1; otherwise, it
 is linear.</item>
 <item>The solution may fail to converge when the derivative is or is close to 0.</item>
 <item>The solution may fail to converge if the initial guess is far away from the true value.</item>
 </list><para> See also: </para><a href="http://en.wikipedia.org/wiki/newton_method"> Wikipedia: Newton&apos;s method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.NewtonRoot.#ctor(System.Double,System.Int32)">
			<summary>Constructs an instance of Newton&apos;s root finding algorithm.</summary>
			<param name="tol">the convergence tolerance</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.NewtonRoot.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.NewtonRoot.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.NewtonRoot.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double)">
			<summary>Searches for a root, <i>x</i>, in the interval <i>[lower, upper]</i> such that <i>f(x) =
 0</i>.</summary>
			<param name="f">a univariate function</param>
			<param name="df">the first order derivative</param>
			<param name="guess">an initial guess of the root within <i>[lower, upper]</i></param>
			<returns>an approximate root</returns>
			<exception cref="T:com.numericalmethod.suanshu.analysis.root.univariate.NoRootFoundException">when the search fails to find a root</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.root.univariate.HalleyRoot">
			<summary>Halley&apos;s method is an iterative root finding method for a univariate function
 with a continuous second derivative, i.e., a C<sup>2</sup> function.
 It has the following properties.
 <list type="bullet">
 <item>The function to be solved is assumed to be continuous and smooth (1st derivative exists).</item>
 <item>The 1st derivative is assumed to be continuous and smooth (2nd derivative exists).</item>
 <item>The rate of convergence for solution is cubic.</item>
 </list><para> See also: </para><a href="http://en.wikipedia.org/wiki/halley_method"> Wikipedia: Halley&apos;s method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.HalleyRoot.#ctor(System.Double,System.Int32)">
			<summary>Construct an instance of Halley&apos;s root finding algorithm.</summary>
			<param name="tol">the convergence tolerance</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.HalleyRoot.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.HalleyRoot.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.HalleyRoot.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double)">
			<summary>Search for a root, <i>x</i>, in the interval <i>[lower, upper]</i> such that <i>f(x) = 0</i>.</summary>
			<param name="f">a univariate function</param>
			<param name="df">the first order derivative</param>
			<param name="d2f">the second order derivative</param>
			<param name="guess">an initial guess of the root within <i>[lower, upper]</i></param>
			<returns>an approximate root</returns>
			<exception cref="T:com.numericalmethod.suanshu.analysis.root.univariate.NoRootFoundException">when the search fails to find a root</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.root.univariate.BrentRoot">
			<summary>Brent&apos;s root-finding algorithm combines super-linear convergence with reliability of bisection.
 It uses the secant method or inverse quadratic interpolation whenever possible because they converge faster,
 but falls back to the more robust bisection method if necessary.
 Unlike <para></para>NewtonRoot and <para></para>HalleyRoot, it does not need the derivatives of the function.
 Brent&apos;s algorithm is the preferred method of choice for root-finding.<para> See also: </para><a href="http://en.wikipedia.org/wiki/brent's_method"> Wikipedia: Brent&apos;s method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.BrentRoot.#ctor(System.Double,System.Int32)">
			<summary>Construct an instance of Brent&apos;s root finding algorithm.</summary>
			<param name="tol">the convergence tolerance</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.BrentRoot.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.BrentRoot.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.root.univariate.BisectionRoot">
			<summary>The bisection method repeatedly bisects an interval and then selects a subinterval in which a
 root must lie for further processing. It is a very simple and robust method, but it is also
 relatively slow.
 <para/>
 The method is guaranteed to converge to a root of <i>f(x)</i> if it is a continuous function on
 the interval <i>[a, b]</i> and <i>f(a)</i> and <i>f(b)</i> have opposite signs. The absolute
 error is halved at each step so the method converges <em>linearly</em>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/bisection_method">Wikipedia: Bisection method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.BisectionRoot.#ctor">
			<summary>Create an instance with <para></para>Constants#EPSILON as the tolerance and
 <para></para>Integer#MAX_VALUE as the maximum number of iterations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.BisectionRoot.#ctor(System.Double,System.Int32)">
			<summary>Create an instance with the tolerance for convergence and the maximum number of iterations.</summary>
			<param name="tol">the tolerance</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.root.univariate.BisectionRoot.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,System.Double,System.Double[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.sequence.Summation">
			<summary>Summation is the operation of adding a sequence of numbers; the result is their sum or total.
 If numbers are added sequentially from left to right, any intermediate result is a partial sum,
 prefix sum, or running total of the summation.
 For a finite sequence of such elements, summation always produces a well-defined sum (possibly by
 virtue of the convention for empty sums).
 Given the <para></para>Summation.Terms, <i>x<sub>i</sub></i>, we have
 \[
 S = \sum (x_i)
 \]
 If a <c>threshold</c> is specified, the summation is treated as a convergent series.
 The summing process stops after \(x_i &lt; \texttt{threshold}\).
 <para/>
 Sample usages:
 <code><c>
      Summation series = new Summation(new Summation.Term() {

         public double evaluate(double i) {
              return i;
          }
      });
      double sum = series.sum(1, 100);
 </c></code>
 <code><c>
      Summation series = new Summation(new Summation.Term() {

          public double evaluate(double i) {
              return 1d / i;
          }
      }, 0.0001);
      double sum = series.sumToInfinity(1);
 </c></code><para> See also: </para><a href="http://en.wikipedia.org/wiki/summation">Wikipedia: Summation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Summation.#ctor(com.numericalmethod.suanshu.analysis.sequence.Summation.Term,System.Double)">
			<summary>Construct a summation series.
 It is assumed that the terms are smaller than a <c>threshold</c> for all terms after a
 certain index.</summary>
			<param name="term">the terms to sum up</param>
			<param name="threshold">the convergence threshold. When a term falls below it, the summing process
                  stops. For a finite summation, it should be set to 0.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Summation.#ctor(com.numericalmethod.suanshu.analysis.sequence.Summation.Term)">
			<summary>Construct a <em>finite</em> summation series.</summary>
			<param name="term">the terms to sum up</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Summation.sum(System.Int32,System.Int32)">
			<summary>Sum up the terms from <c>from</c> to <c>to</c> with the increment 1.</summary>
			<param name="from">the starting index</param>
			<param name="to">the ending index (inclusive)</param>
			<returns>the sum</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Summation.sum(System.Int32,System.Int32,System.Int32)">
			<summary>Sum up the terms from <c>from</c> to <c>to</c> with the increment <c>inc</c>.</summary>
			<param name="from">the starting index</param>
			<param name="to">the ending index (inclusive)</param>
			<param name="inc">the increment</param>
			<returns>the sum</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Summation.sum(System.Double,System.Double,System.Double)">
			<summary>Sum up the terms from <c>from</c> to <c>to</c> with the increment <c>inc</c>.</summary>
			<param name="from">the starting index</param>
			<param name="to">the ending index (inclusive)</param>
			<param name="inc">the increment</param>
			<returns>the sum</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Summation.sum(System.Double[])">
			<summary>Partial summation of the selected terms.</summary>
			<param name="indices">the indices to the selected terms</param>
			<returns>the sum</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Summation.sumToInfinity(System.Int32)">
			<summary>Sum up the terms from <c>from</c> to infinity with increment 1 until the series converges.</summary>
			<param name="from">the starting index</param>
			<returns>the sum</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Summation.sumToInfinity(System.Double,System.Double)">
			<summary>Sum up the terms from <c>from</c> to infinity with increment <c>inc</c> until the series
 converges.</summary>
			<param name="from">the starting index</param>
			<param name="inc">the increment</param>
			<returns>the sum</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.sequence.Summation.Term">
			<summary>Define the terms in a summation series.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Summation.Term.evaluate(System.Double)">
			<summary>Evaluate the term for an index.</summary>
			<param name="i">the index</param>
			<returns><i>x<sub>i</sub></i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.sequence.Sequence">
			<summary>A sequence is an ordered list of (real) numbers.
 Although some sequences, e.g., Fibonacci, have infinitely many elements,
 we can, in practice, compute only finitely many of them.<para> See also: </para><a href="http://en.wikipedia.org/wiki/sequence">Wikipedia: Sequence</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Sequence.length">
			<summary>Get the number of <em>computed</em> terms in the sequence.</summary>
			<returns>the length of sequence</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Sequence.get(System.Int32)">
			<summary>Get the <i>i</i>-th entry in the sequence, counting from 1.</summary>
			<param name="i">an index</param>
			<returns>the <i>i</i>-th entry in the sequence</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Sequence.getAll">
			<summary>Get a copy of the whole (finite) sequence in <c>double[]</c>.</summary>
			<returns>a copy of all the computed terms in the sequence</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.sequence.Fibonacci">
			<summary>A Fibonacci sequence starts with 0 and 1 as the first two numbers.
 Each subsequent number is the sum of the previous two.
 For example,
 <blockquote>
 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 </blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/fibonacci_number">Wikipedia: Fibonacci number</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Fibonacci.#ctor(System.Int32)">
			<summary>Construct a Fibonacci sequence.</summary>
			<param name="length">the number of terms to generate</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Fibonacci.length">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Fibonacci.get(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.sequence.Fibonacci.getAll">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrderWith2ndDerivative">
			<summary>Some ODE solvers require the second derivative for more accurate Taylor series approximation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrderWith2ndDerivative.#ctor(com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction,com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double)">
			<summary>Constructs a first order ODE with initial values.</summary>
			<param name="dy"><i>y&apos; = F(x,y)</i></param>
			<param name="ddy"><i>y&apos;&apos; = F(x,y)</i></param>
			<param name="y0"><i>y<sub>0</sub></i></param>
			<param name="x0">the start point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i></param>
			<param name="x1">the end point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrderWith2ndDerivative.#ctor(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double)">
			<summary>Constructs a first order ODE with initial values.</summary>
			<param name="dy"><i>y&apos; = F(x,y)</i></param>
			<param name="ddy"><i>y&apos;&apos; = F(x,y)</i></param>
			<param name="y0"><i>y<sub>0</sub></i></param>
			<param name="x0">the start point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i></param>
			<param name="x1">the end point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrderWith2ndDerivative.ddy">
			<summary>Gets <i>y&apos;&apos; = F(x,y)</i>.</summary>
			<returns><i>y&apos;&apos; = F(x,y)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder">
			<summary>A first order ordinary differential equation (ODE) initial value problem (IVP) takes the
 following form.
 \[
 y&apos; = f(x, y) \\
 y(x_0) = y_0
 \]
 where <i>y<sub>0</sub></i> is known, and the solution of the problem is <i>y(x)</i> for the
 integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/ordinary_differential_equation">Wikipedia: Ordinary
 differential equation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder.#ctor(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double)">
			<summary>Constructs a first order ODE with the given vector-valued function and its initial values.</summary>
			<param name="dy">the first order derivative function <i>y&apos; = F(x, y)</i></param>
			<param name="y0"><i>y<sub>0</sub></i></param>
			<param name="x0">the start point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i></param>
			<param name="x1">the end point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction[],System.Double[],System.Double,System.Double)">
			<summary>Constructs a system of first order ODEs <i>{Y<sub>i</sub>}</i> with their initial values
 <i>{y<sub>i0</sub>}</i>.
 \[
 y_1&apos; = Y_1(x, y_1, y_2, y_3, ...), y_1(0) = y_{10}\\
 y_2&apos; = Y_2(x, y_1, y_2, y_3, ...), y_2(0) = y_{20}\\
 y_3&apos; = Y_3(x, y_1, y_2, y_3, ...), y_3(0) = y_{30}\\
 ...
 \]</summary>
			<param name="Y">the differentials, <i>{Y<sub>i</sub>}</i></param>
			<param name="y0">the initial values, <i>{y<sub>i</sub>(0)}</i></param>
			<param name="x0">the start point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i></param>
			<param name="x1">the end point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder.#ctor(com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double)">
			<summary>Constructs a first order ODE with the given vector-valued function and its initial values.</summary>
			<param name="F"><i>F(x, y) = y&apos;</i></param>
			<param name="y0"><i>y<sub>0</sub></i></param>
			<param name="x0">the start point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i></param>
			<param name="x1">the end point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder.#ctor(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE)">
			<summary>Reduces a high order ODE to a system of first order ODEs.<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/ordinary_differential_equation#reduction_to_a_first_order_system">
 Wikipedia: Reduction to a first order system</a></summary>
			<param name="ode">the high order ODE</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder.convertToDerivativeFunction(com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction,System.Int32)">
			<summary>Converts the given vector function to a first order derivative function.</summary>
			<param name="F">the vector-valued function <i>F(x, y<sub>1</sub>, ..., y<sub>n</sub>)</i></param>
			<param name="dimension">the dimension of the derivative function</param>
			<returns>the converted first order derivative function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder.dy">
			<summary>Gets the first order derivative function.</summary>
			<returns>the first order derivative function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder.dimension">
			<summary>Gets the dimension of <i>y</i>.</summary>
			<returns>the dimension of <i>y</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder.y0">
			<summary>Gets the initial value of <i>y</i>, that is, <i>y<sub>0</sub></i>.</summary>
			<returns><i>y<sub>0</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder.x0">
			<summary>Gets the start point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i>.</summary>
			<returns><i>x<sub>0</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder.x1">
			<summary>Gets the end point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i>.</summary>
			<returns><i>x<sub>1</sub></i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE">
			<summary>An ordinary differential equation (ODE) is an equation in which there is only one independent
 variable and one or more derivatives of a dependent variable with respect to the independent
 variable, so that all the derivatives occurring in the equation are ordinary derivatives.
 A (high order) ordinary differential equation of order <i>n</i> takes this form.
 \[
 y^{(n)} = F(x,y,y&apos;,\ \dotsc,\ y^{(n-1)})
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/ordinary_differential_equation">Wikipedia: Ordinary
 differential equation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,System.Double[],System.Double,System.Double)">
			<summary>Construct an ODE of order <i>n</i> together with its initial values.</summary>
			<param name="F"><i>y<sup>(n)</sup> = F(x, y, y&apos;, ..., y<sup>(n-1)</sup>)</i></param>
			<param name="initials"><i>y(x<sub>0</sub>), y&apos;(x<sub>0</sub>), ...,
                 y<sup>(n-1)</sup>(x<sub>0</sub>)</i></param>
			<param name="x0">the start point of the integrating interval <i>[x<sub>0</sub>,
                 x<sub>1</sub>]</i></param>
			<param name="x1">the end point of the integrating interval <i>[x<sub>0</sub>,
                 x<sub>1</sub>]</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE.F">
			<summary>Get the differential, \(y^{(n)} = F\).</summary>
			<returns>the differential</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE.y0(System.Int32)">
			<summary>Get the initial value for the <i>n</i>-th order (derivative).</summary>
			<param name="order">the differentiation order</param>
			<returns>the initial value for the <i>n</i>-th order</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE.x0">
			<summary>Get the start point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i>.</summary>
			<returns><i>x<sub>0</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE.x1">
			<summary>Get the end point of the integrating interval <i>[x<sub>0</sub>, x<sub>1</sub>]</i>.</summary>
			<returns><i>x<sub>1</sub></i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction">
			<summary>Defines the derivative function <i>F(x, y)</i> for ODE problems.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction.evaluate(System.Double,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Computes the derivative at the given point, <i>x</i>.</summary>
			<param name="x">the independent variable, <i>x</i></param>
			<param name="y">the dependent variable, <i>y</i></param>
			<returns>the derivative <i>F(x, y)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction.dimension">
			<summary>Gets the dimension of <i>y</i>.</summary>
			<returns>the dimension of <i>y</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.ODESolver">
			<summary>Solver for <para></para>ODE1stOrder first order ODE problems.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.ODESolver.solve(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder)">
			<summary>Solves the given ODE problem.</summary>
			<param name="ode">the ODE problem</param>
			<returns>the solution</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.ODESolution">
			<summary>Solution to an ODE problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.ODESolution.#ctor(System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Create a solution with estimated values at the given points.</summary>
			<param name="x">the values of the independent variable</param>
			<param name="y">the corresponding values of the dependent variable.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.ODESolution.x">
			<summary>Get the values of the independent variable.</summary>
			<returns><i>x</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.ODESolution.y">
			<summary>Get the corresponding values of the dependent variable.</summary>
			<returns><i>y</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.ODEIntegrator">
			<summary>This defines the interface for the numerical integration of a
 <para></para>ODE1stOrder first order ODE, for a sequence of pre-defined steps.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.ODEIntegrator.integrate(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder,System.Double[])">
			<summary>This is the integration method that approximates the solution of a
 <para></para>ODE1stOrder first order ODE.</summary>
			<param name="ode">the ODE</param>
			<param name="x">the times, x-axis, grid points, or the variable values</param>
			<returns>the function values, <i>y</i>, at the grid points</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.EulerMethod">
			<summary>The Euler method is a first-order numerical procedure for solving ordinary differential equations
 (ODEs) with a given initial value. It is the most basic explicit method for numerical integration
 of ordinary differential equations and is the simplest Runge-Kutta method. The Euler method is a
 first-order method, which means that the local error (error per step) is proportional to the
 square of the step size, and the global error (error at a given time) is proportional to the step
 size. It also suffers from stability problems. For these reasons, the Euler method is not often
 used in practice. It serves as the basis to construct more complicated methods.<para> See also: </para><list type="bullet">
 <item>D. Greenspan, Numerical Solution of Ordinary Differential Equations: for Classical,
 Relativistic and Nano Systems, 1st ed, Wiley-VCH, 2006.</item>
 <item><a href="http://en.wikipedia.org/wiki/euler_method">Wikipedia: Euler method</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.EulerMethod.#ctor(System.Double)">
			<summary>Constructs an Euler&apos;s method instance, with the given step size.</summary>
			<param name="h">the constant step size</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.EulerMethod.#ctor(System.Int32)">
			<summary>Constructs an Euler&apos;s method instance, with the given number of steps.</summary>
			<param name="N">the number of steps</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.extrapolation.SemiImplicitExtrapolation">
			<summary>Semi-Implicit Extrapolation is a method of solving ordinary differential equations, that is
 similar to <para></para>BurlischStoerExtrapolation Burlisch-Stoer extrapolation. However, instead
 of using the regular explicit Euler&apos;s method to compute mid-point estimates, this algorithm uses
 a Taylor series approximation to the implicit backward Euler&apos;s method:
 \[
 x_{k+1} = x_k + h f(t_{k+1}, x_{k+1})
 \]
 <para/>
 This method is more computationally expensive but has a tendency to remain stable for larger step
 sizes. In particular, it is useful for solving stiff ODEs.<para> See also: </para><a href="http://en.wikipedia.org/wiki/explicit_and_implicit_methods">Wikipedia: Explicit and
 implicit methods</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.extrapolation.SemiImplicitExtrapolation.#ctor(System.Double,System.Int32)">
			<summary>Create an instance of this algorithm with the given precision parameter and the maximum
 number of iterations allowed.</summary>
			<param name="epsilon">the relative precision required</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.extrapolation.SemiImplicitExtrapolation.solve(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.extrapolation.SemiImplicitExtrapolation.solve(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrderWith2ndDerivative)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.extrapolation.BurlischStoerExtrapolation">
			<summary>Burlisch-Stoer extrapolation (or Gragg-Bulirsch-Stoer (GBS)) algorithm combines three powerful
 ideas: Richardson extrapolation, the use of rational function extrapolation in Richardson-type
 applications, and the modified midpoint method, to obtain numerical solutions to ordinary
 differential equations (ODEs) with high accuracy and comparatively little computational effort.
 The extrapolation is achieved with numerical calculation with decreasing step sizes. The basic
 technique used to compute approximations is known as the <em>modified midpoint method</em>:
 \[
 q_{k+1} = q_{k-1} + 2 h f(\alpha + k h, q_k),
 \]
 where \(q_k\) are the estimates, \(h\) is the step size and \(\alpha\) is the time point of the
 initial value. Since the recursive equation requires two previous values, \(q_1\) is computed
 using Euler&apos;s method.<para> See also: </para><a href="http://en.wikipedia.org/wiki/bulirsch%e2%80%93stoer_algorithm">Wikipedia:
 Bulirsch-Stoer algorithm</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.extrapolation.BurlischStoerExtrapolation.#ctor(System.Double,System.Int32)">
			<summary>Create an instance of the algorithm with the precision parameter and the maximum number of
 iterations allowed.</summary>
			<param name="epsilon">the relative precision required</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.extrapolation.BurlischStoerExtrapolation.solve(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder)">
			<summary>Perform the extrapolation. The algorithm will stop when the desired precision is reached or
 the maximum number of iterations is exceeded, whichever comes first.
 <para/>
 If the given error criterion cannot be achieved within the given maximum number of
 iterations, an <para></para>UnsatisfiableErrorCriterionException will be thrown.</summary>
			<param name="ode">the ODE problem</param>
			<returns>the solution</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.AdamsBashforthMoulton">
			<summary>This class uses an Adams-Bashford predictor and an Adams-Moulton corrector of the specified
 order. This is an order-<i>n</i> multi-step method which uses the last <i>n</i> computed points
 based on Newton&apos;s backward difference interpolating polynomial of degree (<i>n-1</i>) (unlike
 single-step methods which only use the most recent value to compute the next solution point).
 Since the predictor and the corrector are not self-starting, a single-step method such as a
 Runge-Kutta method is used to compute the first <i>n</i> points.<para> See also: </para><a href="http://en.wikipedia.org/wiki/linear_multistep_method">Wikipedia: Linear multistep
 method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.AdamsBashforthMoulton.#ctor(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector,System.Double)">
			<summary>Create a new instance of the Adams-Bashforth-Moulton method using the given
 predictor-corrector pair. <para></para>RungeKutta2 is used for initializing the first <i>n</i>
 points.</summary>
			<param name="predictorCorrector">the Adams-Bashforth and Adams-Moulton formulae that are used</param>
			<param name="stepSize">the step size between each approximation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.AdamsBashforthMoulton.#ctor(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector,System.Double,com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.ODEIntegrator)">
			<summary>Create a new instance of the Adams-Bashforth-Moulton method using the given
 predictor-corrector pair and the given ODE integrator.</summary>
			<param name="predictorCorrector">the Adams-Bashforth and Adams-Moulton formulae that are used</param>
			<param name="stepSize">the step size between each approximation</param>
			<param name="integrator">the integrator for initializing the first <i>n</i> points</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.AdamsBashforthMoulton.solve(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder)">
			<summary>Solve an ODE using the Adams-Bashforth-Moulton method.</summary>
			<param name="ode">the ODE problem</param>
			<returns>the solution</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector5">
			<summary>The Adams-Bashforth predictor and the Adams-Moulton corrector of order 5.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector5.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector5.order">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector5.predict(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,System.Double,System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector5.correct(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,System.Double,System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector4">
			<summary>The Adams-Bashforth predictor and the Adams-Moulton corrector of order 4.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector4.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector4.order">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector4.predict(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,System.Double,System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector4.correct(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,System.Double,System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector3">
			<summary>The Adams-Bashforth predictor and the Adams-Moulton corrector of order 3.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector3.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector3.order">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector3.predict(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,System.Double,System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector3.correct(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,System.Double,System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector2">
			<summary>The Adams-Bashforth predictor and the Adams-Moulton corrector of order 2.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector2.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector2.order">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector2.predict(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,System.Double,System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector2.correct(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,System.Double,System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector1">
			<summary>The Adams-Bashforth predictor and the Adams-Moulton corrector of order 1.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector1.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector1.order">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector1.predict(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,System.Double,System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector1.correct(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,System.Double,System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector">
			<summary>The Adams-Bashforth predictor and the Adams-Moulton corrector pair.<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/linear_multistep_method#families_of_multistep_methods">
 Wikipedia: Linear multistep method - Families of multistep methods</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector.order">
			<summary>Get the order of this predictor-corrector pair.</summary>
			<returns>order</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector.predict(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,System.Double,System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.multistep.adamsbashforthmoulton.ABMPredictorCorrector.correct(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,System.Double,System.Double[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaStepper">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaStepper.step(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaIntegrator">
			<summary>This integrator works with a single-step stepper which estimates the solution for the next step
 given the solution of the current step.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaIntegrator.#ctor(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaStepper)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaIntegrator.integrate(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder,System.Double[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaFehlberg">
			<summary>The Runge-Kutta-Fehlberg method is a version of the classic Runge-Kutta method, which
 additionally uses step-size control and hence allows specification of a local truncation error
 bound.
 <para/>
 In particular, the algorithm estimates the error by comparing the results of the 5th and the 4th
 order Runge-Kutta solutions. This step requires six evaluations of the input method.
 <para/>
 To be conservative, a safety factor &#947; is included in the step size update formula, to make
 the new step size somewhat smaller than that predicted to yield the local error exactly equal to
 the error upper bound.
 <para/>
 In this implementation, the step size is updated by this formula:
 \[
 h_1 = \gamma \left( \frac{\max\left\{ \left \| y \right \|, 1 \right\} \epsilon}{\left \| E
 \right \|} \right)^{1/5} h_0,
 \]
 where \(\gamma\) is the safety factor, \(y\) and \(E\) are the current abscissa and error
 respectively, \(\epsilon\) is the lower bound of the local truncation error, until the error
 criterion
 \[
 \left \| E \right \| \le \max\left\{ \left \| y \right \|, 1 \right\} \epsilon
 \]
 is met.<para> See also: </para><a href="http://en.wikipedia.org/wiki/runge-kutta-fehlberg_method">
 Wikipedia: Runge-Kutta-Fehlberg method</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaFehlberg.DEFAULT_SAFETY_FACTOR">
			<summary>Default value for the safety factor &#947;.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaFehlberg.#ctor(System.Double,System.Double)">
			<summary>Create a new instance of the Runge-Kutta-Fehlberg method for the given parameters, with the
 <para></para>#DEFAULT_SAFETY_FACTOR default safety factor value.</summary>
			<param name="epsilon">the upper bound on the local truncation error</param>
			<param name="minStepSize">the lower bound on step size</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaFehlberg.#ctor(System.Double,System.Double,System.Double)">
			<summary>Create a new instance of the Runge-Kutta-Fehlberg method with the given safety factor.</summary>
			<param name="epsilon">the upper bound on the local truncation error</param>
			<param name="minStepSize">the lower bound on step size</param>
			<param name="gamma">the safety factor (0 &lt; &#947; &#8804; 1)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaFehlberg.solve(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder)">
			<summary>Solve the given ODE using Runge-Kutta-Fehlberg method. The result will range from &#945; to
 &#946;, where the steps taken depends on the execution of the algorithm, which in turn
 depends on the accuracy of the respective step sizes.
 <para/>
 If the error criterion cannot be satisfied using step sizes greater than or equal to
 <c>hMin</c>, an <para></para>UnsatisfiableErrorCriterionException will be thrown. In this case,
 either <c>hMin</c> has to be decreased or <c>epsilon</c> has to be increased.</summary>
			<param name="ode">the ODE problem</param>
			<returns>the solution</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta8">
			<summary>This is the eighth-order Runge-Kutta formula.<para> See also: </para>&quot;D. Greenspan, &quot;eqs. 2.26,&quot; Numerical Solution of Ordinary Differential Equations: for
 Classical, Relativistic and Nano Systems, 1st ed, Wiley-VCH, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta8.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta8.step(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta7">
			<summary>This is the seventh-order Runge-Kutta formula.<para> See also: </para>&quot;D. Greenspan, &quot;eqs. 2.25,&quot; Numerical Solution of Ordinary Differential Equations: for
 Classical, Relativistic and Nano Systems, 1st ed, Wiley-VCH, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta7.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta7.step(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta6">
			<summary>This is the sixth-order Runge-Kutta formula.<para> See also: </para>&quot;D. Greenspan, &quot;eqs. 2.24,&quot; Numerical Solution of Ordinary Differential Equations: for
 Classical, Relativistic and Nano Systems, 1st ed, Wiley-VCH, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta6.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta6.step(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta5">
			<summary>This is the fifth-order Runge-Kutta formula.<para> See also: </para><list type="bullet">
 <item>&quot;Fae&apos;q A. A. Radwan, &quot;Solutions of Initial Value Problems Using Fifth-Order Runge-Kutta
 Method Using Excel Spreadsheet,&quot; Pakistan Journal of Applied Science 2(1):44-47, 2002.&quot;</item>
 <item>&quot;D. Greenspan, &quot;eqs. 2.22,&quot; Numerical Solution of Ordinary Differential Equations: for
 Classical, Relativistic and Nano Systems, 1st ed, Wiley-VCH, 2006.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta5.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta5.step(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Double)">
			<summary><para> See also: </para>&quot;Fae&apos;q A. A. Radwan, &quot;Solutions of Initial Value Problems Using Fifth-Order Runge-Kutta
 Method Using Excel Spreadsheet,&quot; Pakistan Journal of Applied Science 2(1):44-47, 2002.&quot;</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta4">
			<summary>This is the fourth-order Runge-Kutta formula.<para> See also: </para>&quot;D. Greenspan, &quot;eqs. 2.21,&quot; Numerical Solution of Ordinary Differential Equations: for
 Classical, Relativistic and Nano Systems, 1st ed, Wiley-VCH, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta4.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta4.step(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta3">
			<summary>This is the third-order Runge-Kutta formula.<para> See also: </para>&quot;D. Greenspan, &quot;eqs. 2.20,&quot; Numerical Solution of Ordinary Differential Equations: for
 Classical, Relativistic and Nano Systems, 1st ed, Wiley-VCH, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta3.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta3.step(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta2">
			<summary>This is the second-order Runge-Kutta formula, which can be implemented efficiently with a
 three-step algorithm.<para> See also: </para>&quot;D. Greenspan, &quot;eqs. 2.12, 2.13, 2.14,&quot; Numerical Solution of Ordinary Differential
 Equations: for Classical, Relativistic and Nano Systems, 1st ed, Wiley-VCH, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta2.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta2.step(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta10">
			<summary>This is the tenth-order Runge-Kutta formula.<para> See also: </para>&quot;D. Greenspan, &quot;Table 2.2,&quot; Numerical Solution of Ordinary Differential Equations: for
 Classical, Relativistic and Nano Systems, 1st ed, Wiley-VCH, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta10.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta10.step(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta1">
			<summary>This is the first-order Runge-Kutta formula, which is the same as the Euler method. It is the
 most basic explicit method for numerical integration of ordinary differential equations
 and is the simplest Runge-Kutta method.<para> See also: </para><list type="bullet">
 <item>D. Greenspan, Numerical Solution of Ordinary Differential Equations: for Classical,
 Relativistic and Nano Systems, 1st ed, Wiley-VCH, 2006.</item>
 <item><a href="http://en.wikipedia.org/wiki/euler_method">Wikipedia: Euler method</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta1.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta1.step(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.DerivativeFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta">
			<summary>The Runge-Kutta methods are an important family of implicit and explicit iterative methods for
 the approximation of solutions of ordinary differential equations. These techniques were
 developed around 1900 by the German mathematicians C. Runge and M.W. Kutta.<para> See also: </para><list type="bullet">
 <item>D. Greenspan, Numerical Solution of Ordinary Differential Equations: for Classical,
 Relativistic and Nano Systems, 1st ed, Wiley-VCH, 2006.</item>
 <item><a href="http://en.wikipedia.org/wiki/runge%e2%80%93kutta_methods">Wikipedia: Runge-Kutta
 methods</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta.#ctor(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaStepper,System.Double)">
			<summary>Constructs a Runge-Kutta algorithm with the given integrator and the constant step size.</summary>
			<param name="stepper">the integrator algorithm</param>
			<param name="h">constant step size</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta.#ctor(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKuttaStepper,System.Int32)">
			<summary>Constructs a Runge-Kutta algorithm with the given integrator and the constant number of
 steps.</summary>
			<param name="stepper">the integrator algorithm</param>
			<param name="N">constant number of steps</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.solver.rungekutta.RungeKutta.solve(com.numericalmethod.suanshu.analysis.differentialequation.ode.ivp.problem.ODE1stOrder)">
			<summary>Solves a first order ODE.</summary>
			<param name="ode">the ODE problem</param>
			<returns>the solution</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.elliptic.dim2.PoissonEquation2D">
			<summary>Poisson&apos;s equation is an elliptic PDE that takes the following general form.
 \[
 \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} = f(x, y)
 \]
 with Dirichlet boundary conditions:
 \[
 u(0, y) = g(0, y) \\
 u(a, y) = g(a, y) \\
 u(x, 0) = g(x, 0) \\
 u(x, b) = g(x, b)
 \]
 assuming that the domain of the independent variables is a rectangular region in the x-y plane.
 <para/>
 Note that LaPlace&apos;s equation emerges as a special case when \(f(x, y) = 0\).<para> See also: </para><a href="http://en.wikipedia.org/wiki/poisson_equation">Wikipedia: Poisson&apos;s equation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.elliptic.dim2.PoissonEquation2D.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.analysis.function.rn2r1.BivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.BivariateRealFunction)">
			<summary>Constructs a Poisson&apos;s equation problem.</summary>
			<param name="a">the region of interest <i>(0, a)</i></param>
			<param name="b">the region of interest <i>(0, b)</i></param>
			<param name="f">the forcing term in the equation <i>f(x, y)</i></param>
			<param name="g">the Dirichlet boundary condition <i>g(x, y)</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.elliptic.dim2.PoissonEquation2D.a">
			<summary>Gets the width (x-axis) of the rectangular region.</summary>
			<returns>the x size of the region</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.elliptic.dim2.PoissonEquation2D.b">
			<summary>Gets the height (y-axis) of the rectangular region.</summary>
			<returns>the y size of the region</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.elliptic.dim2.PoissonEquation2D.f(System.Double,System.Double)">
			<summary>The forcing term.</summary>
			<param name="x">the first independent variable</param>
			<param name="y">the second independent variable</param>
			<returns>f(x, y), the forcing function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.elliptic.dim2.PoissonEquation2D.g(System.Double,System.Double)">
			<summary>The boundary value function. These are Dirichlet (or first-type) boundary conditions.</summary>
			<param name="x">the first independent variable</param>
			<param name="y">the second independent variable</param>
			<returns>g(x, y), the boundary condition</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.elliptic.dim2.IterativeCentralDifference">
			<summary>An iterative central difference algorithm to obtain a numerical approximation to Poisson&apos;s
 equations with Dirichlet boundary conditions.
 <para/>
 It proceeds as follows: The area <i>(0,0), (a,0), (0,b), (a,b)</i> is divided into a grid of the
 specified size. The value at each interior point is initialized as the average of the boundary
 points. At each iteration, successive over-relaxation (SOR) (an extension of the Gauss-Seidel or
 Liebmann&apos;s method, which is a special case when <i>&#945;</i> is 1) is used to compute improved
 estimates from the three-point central difference approximation to Poisson&apos;s equation:
 \[
 \frac{u_{k+1,j} - 2u_{k,j} + u_{k-1,j}}{\Delta x^2} + \frac{u_{k,j+1} - 2u_{k,j} +
 u_{k,j-1}}{\Delta y^2} = f_{k, j}
 \]
 where \(u_{k,j} = u(x_k, y_j)\) is the estimate at \((k, j)\) in the grid.
 <para/>
 This is a second-order method with a truncation error of order \(O(\Delta x^2 + \Delta y^2)\).<para> See also: </para><a href="http://en.wikipedia.org/wiki/gauss-seidel_sor">Wikipedia: Gauss-Seidel SOR</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.elliptic.dim2.IterativeCentralDifference.#ctor(System.Double,System.Int32)">
			<summary>Create an instance of this method with the given error bound as the convergence criterion,
 and the maximum number of iterations allowed. The iteration stops when the difference between
 successive iterations is within the given error bound.</summary>
			<param name="errorBound">the error bound (convergence criterion)</param>
			<param name="maxIterations">the maximum number of iterations allowed</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.elliptic.dim2.IterativeCentralDifference.solve(com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.elliptic.dim2.PoissonEquation2D,System.Int32,System.Int32)">
			<summary>Solve a Poisson&apos;s equation problem, with the given grid resolution parameters.
 <para/>
 <para></para>UnsatisfiableErrorCriterionException is thrown when the iteration cannot converge to
 the specified error bound within the maximum allowed number of iterations.</summary>
			<param name="pde">the Poisson&apos;s equation</param>
			<param name="m">the number of points along the x-axis of the grid</param>
			<param name="n">the number of points along the y-axis of the grid</param>
			<returns>the solution grid</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim1.WaveEquation1D">
			<summary>A one-dimensional wave equation is a hyperbolic PDE that takes the following form.
 \[
 \frac{\partial^2 u}{\partial t^2} = \beta \frac{\partial^2 u}{\partial x^2}
 \]
 with both boundary ends fixed at 0, that is,
 \[
 u(t, 0) = u(t, a) = 0
 \]
 and two initial conditions, namely <i>u</i> and its first time derivative <i>u<sub>t</sub></i>:
 \[
 u(0, x) = f(x), 0 &lt; x &lt; a \\
 u_t(0, x) = g(x), 0 &lt; x &lt; a
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/wave_equation">Wikipedia: Wave equation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim1.WaveEquation1D.#ctor(System.Double,System.Double,System.Double,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Constructs an one-dimensional wave equation.</summary>
			<param name="beta">the wave coefficient <i>&#946;</i> in the equation</param>
			<param name="T">the time period of interest <i>(0, T)</i></param>
			<param name="a">the region of interest <i>(0, a)</i></param>
			<param name="f">the initial condition of <i>u</i>, i.e., <i>u(0, x)</i></param>
			<param name="g">the initial condition of the time-derivative of <i>u</i>, i.e.,
 <i>u<sub>t</sub>(0,x)</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim1.WaveEquation1D.beta">
			<summary>Gets the value of the wave coefficient <i>&#946;</i></summary>
			<returns>the wave coefficient <i>&#946;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim1.WaveEquation1D.T">
			<summary>Gets the time period of interest, that is, the range of <i>t</i>,
 <i>(0 &lt; t &lt; T)</i>.</summary>
			<returns>the time period of interest</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim1.WaveEquation1D.a">
			<summary>Gets the size of the one-dimensional space, that is, the range of <i>x</i>,
 <i>(0 &lt; x &lt; a)</i>.</summary>
			<returns>the size of the space</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim1.WaveEquation1D.f(System.Double)">
			<summary>Gets the value of the initial condition of <i>u</i> at <i>x</i>.</summary>
			<param name="x">the position</param>
			<returns><i>f(x) = u(0, x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim1.WaveEquation1D.g(System.Double)">
			<summary>Gets the value of the initial condition of the time derivative of <i>u</i> at <i>x</i>.</summary>
			<param name="x">the position</param>
			<returns><i>g(x) = u<sub>t</sub>(0, x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim1.ExplicitCentralDifference1D">
			<summary>This explicit central difference method is a numerical technique for solving
 <para></para>WaveEquation1D the one-dimensional wave equation by the following explicit
 three-point central difference equation.
 \[
 \frac{u^{k+1}_j - 2u^k_j + u^{k-1}_j}{\Delta t^2}
 = \beta \frac{u^{k}_{j+1} - 2u^k_j + u^{k}_{j-1}}{\Delta x^2}
 \]
 where \(u^k_j = u(t_k, x_j)\) is the estimate at \((k, j)\) in the grid.
 <para/>
 This method is <em>NOT</em> unconditionally stable. Specifically, it is up to the user to ensure
 that:
 \[
 \Delta t^2 \leq \frac{\Delta x^2}{\beta}
 \]
 where \(\Delta t = \frac{T}{m}\) and \(\Delta x = \frac{a}{n+1}\), by specifying the grid
 resolution parameters <c>m</c> and <c>n</c>.
 <para/>
 This is a second-order method with a truncation error of order \(O(\Delta t^2 + \Delta x^2)\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim1.ExplicitCentralDifference1D.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim1.ExplicitCentralDifference1D.solve(com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim1.WaveEquation1D,System.Int32,System.Int32)">
			<summary>Solve an one-dimensional wave equation, with the resolution parameters of the solution grid.</summary>
			<param name="pde">the wave equation problem</param>
			<param name="m">the number of grid points along the time-axis</param>
			<param name="n">the number of grid points along the space-axis</param>
			<returns>the solution grid</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim2.WaveEquation2D">
			<summary>A two-dimensional wave equation is a hyperbolic PDE that takes the following form.
 \[
 \frac{\partial^2 u}{\partial t^2}
 = \beta (\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2})
 \]
 with fixed boundary condition, that is,
 \[
 u(t, 0, 0) = u(t, a, 0) = u(t, 0, b) = u(t, a, b) = 0
 \]
 and two initial conditions, namely \(u\) and its first time derivative \(u_t\):
 \[
 u(0, x, y) = f(x, y), 0 &lt; x &lt; a, 0 &lt; y &lt; b \\
 u_t(0, x, y) = g(x, y), 0 &lt; x &lt; a, 0 &lt; y &lt; b
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/wave_equation">Wikipedia: Wave equation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim2.WaveEquation2D.#ctor(System.Double,System.Double,System.Double,System.Double,com.numericalmethod.suanshu.analysis.function.rn2r1.BivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.BivariateRealFunction)">
			<summary>Create a two-dimensional wave equation.</summary>
			<param name="beta">the beta in the equation</param>
			<param name="T">the time period of interest <i>(0, T)</i></param>
			<param name="a">the size of the region along the x-axis, <i>x &#8712; (0, a)</i></param>
			<param name="b">the size of the region along the y-axis <i>y &#8712; (0, b)</i></param>
			<param name="f">the initial condition of <i>u</i>, i.e., <i>u(0, x, y)</i></param>
			<param name="g">the initial condition of the time-derivative of <i>u</i>, i.e.,
 <i>u<sub>t</sub>(0,x,y)</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim2.WaveEquation2D.beta">
			<summary>Get the value of the wave coefficient <i>&#946;</i></summary>
			<returns>the wave coefficient <i>&#946;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim2.WaveEquation2D.T">
			<summary>Get the time period of interest, that is, the range of <i>t</i>,
 <i>(0 &lt; t &lt; T)</i>.</summary>
			<returns>the time period of interest</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim2.WaveEquation2D.a">
			<summary>Get the size of the two-dimensional space along the x-axis, that is, the range of <i>x</i>,
 <i>(0 &lt; x &lt; a)</i>.</summary>
			<returns>the size of the space along the x-axis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim2.WaveEquation2D.b">
			<summary>Get the size of the two-dimensional space along the y-axis, that is, the range of <i>y</i>,
 <i>(0 &lt; y &lt; b)</i>.</summary>
			<returns>the size of the space along the y-axis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim2.WaveEquation2D.f(System.Double,System.Double)">
			<summary>Get the initial condition of <i>u</i> at the given point <i>(x,y)</i>.</summary>
			<param name="x">the x-coordinate</param>
			<param name="y">the y-coordinate</param>
			<returns><i>u(0, x, y)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim2.WaveEquation2D.g(System.Double,System.Double)">
			<summary>Get the initial condition of the time derivative of <i>u</i> at the given point <i>(x,y)</i>.</summary>
			<param name="x">the x-coordinate</param>
			<param name="y">the y-coordinate</param>
			<returns><i>u<sub>t</sub>(0, x, y)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim2.ExplicitCentralDifference2D">
			<summary>This explicit central difference method is a numerical technique for solving
 <para></para>WaveEquation2D the two-dimensional wave equation by the following explicit
 three-point central difference equation.
 \[
 \frac{u^{k+1}_{ij} - 2u^k_{ij} + u^{k-1}_{ij}}{\Delta t^2}
 = \beta \left( \frac{u^{k}_{i+1,j} - 2u^k_{ij} + u^{k}_{i-1,j}}{\Delta x^2}
 + \frac{u^{k}_{i,j+1} - 2u^k_{ij} + u^{k}_{i,j-1}}{\Delta y^2}
 \right)
 \]
 where \(u^k_{ij} = u(t_k,x_i,y_j)\) is the estimate at \((k, i, j)\) in the grid.
 <para/>
 This method is <em>NOT</em> unconditionally stable. Specifically, it is up to the user to ensure
 that:
 \[
 \Delta t^2 \leq \frac{\Delta x^2 + \Delta y^2}{4 \beta}
 \]
 where \(\Delta t = \frac{T}{m}\), \(\Delta x = \frac{a}{n+1}\) and \(\Delta y = \frac{b}{p+1}\),
 by specifying the grid resolution parameters <c>m</c>, <c>n</c>, and <c>p</c>.
 <para/>
 This is a second-order method with a truncation error of order
 \(O(\Delta t^2 + \Delta x^2 + \Delta y^2)\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim2.ExplicitCentralDifference2D.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim2.ExplicitCentralDifference2D.solve(com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.hyperbolic.dim2.WaveEquation2D,System.Int32,System.Int32,System.Int32)">
			<summary>Solve a two-dimensional wave equation, with the resolution parameters of the solution grid.</summary>
			<param name="pde">the wave equation problem</param>
			<param name="m">the number of grid points along the time-axis (excluding the initial condition)</param>
			<param name="n">the number of grid points along the x-axis (excluding the two boundaries)</param>
			<param name="p">the number of grid points along the y-axis (excluding the two boundaries)</param>
			<returns>the solution grid</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.PropagationOverTime">
			<summary>Computes the grid values at the next time step. Given the grid values at time <i>t</i>, we are
 able to propagate the grid values at time <i>t+1</i> by solving a system of linear equations. We
 may solve the linear system using various methods.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.PropagationOverTime.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.PropagationByThomas">
			<summary>Propagate the grid values at the next time step using the Thomas algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.PropagationByThomas.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.PropagationByLU">
			<summary>Propagate the grid values at the next time step using the LU algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.PropagationByLU.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.CrankNicolsonConvectionDiffusionEquation1D">
			<summary>This class uses the Crank-Nicolson scheme to obtain a numerical solution of a one-dimensional
 convection-diffusion PDE. The complexity of this algorithm is \(O(mn^3)\), where <i>m</i> is the
 number of grid points in the time-axis, <i>n</i> is the number of grid points in the space-axis.
 The truncation error is of order \(O(\Delta t^2 + \Delta x^2)\).
 <para/>
 The advantage of the Crank-Nicolson scheme is that it guarantees unconditional stability, but
 only under the situation that the coefficients of the PDE (such as \sigma and \mu) are fixed
 (may be relaxed to be linear in state variable). Unconditional stability means that the solution
 will not be oscillating no matter what you choose for the step size (but doesn&apos;t mean that the
 solution is close to the true result). In general for non-linear \sigma and \mu, the stability
 cannot be guaranteed. It is very possible to get an oscillating result especially near the
 boundary grids, but currently our solver can do nothing about this. Even if we find a possible
 scheme to deal with the boundary points with second-order accuracy, we do not always get stable
 solutions under non-linear coefficients. Hence, our solver works well only under some conditions
 (e.g., fixed contants, domain not too big) but not for a general case.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.CrankNicolsonConvectionDiffusionEquation1D.#ctor">
			<summary>Constructs an instance of the Crank-Nicolson solver for a 1 dimensional convection-diffusion
 PDE.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.CrankNicolsonConvectionDiffusionEquation1D.#ctor(com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.PropagationOverTime)">
			<summary>Constructs an instance of the Crank-Nicolson solver for a 1 dimensional convection-diffusion
 PDE.</summary>
			<param name="propagation">the linear system solver to use</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.CrankNicolsonConvectionDiffusionEquation1D.solve(com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D,System.Int32,System.Int32)">
			<summary>Solves a 1 dimensional convection-diffusion equation.</summary>
			<param name="pde">a 1 dimensional convection-diffusion equation</param>
			<param name="m">the number of grid points along the time-axis (excluding the initial condition)</param>
			<param name="n">the number of grid points along the space-axis (excluding the two boundaries)</param>
			<returns>the solution \(u(t,x)\) at the grid points</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D">
			<summary>The convection–diffusion equation is a combination of the diffusion and convection (advection)
 equations, and describes physical phenomena where particles, energy, or other physical quantities
 are transferred inside a physical system due to two processes: diffusion and convection.
 Depending on context, the same equation can be called the advection–diffusion equation,
 drift–diffusion equation, Smoluchowski equation (after Marian Smoluchowski), or (generic) scalar
 transport equation.
 <para/>
 A one-dimensional general convection-diffusion equation is of the following form.
 \[
 \frac{\partial u}{\partial t} = \sigma(t,x) \frac{\partial^2 u}{\partial x^2}
 - \mu(t,x) \frac{\partial u}{\partial x} + R(t,x),
 \]
 The initial condition has this form:
 \[
 u(0,x) = f(x), ~0 &lt; x &lt; a
 \]
 The mixed boundary conditions have this form:
 \[
 (1-c_1)u(t,0) - c_1\frac{\partial u}{\partial x}(t,0) = g_1(t), \\
 (1-c_2)u(t,a) + c_2\frac{\partial u}{\partial x}(t,a) = g_2(t)
 \]
 where \(0 \le c_k \le 1, k = 1, 2\).<para> See also: </para><a href="http://en.wikipedia.org/wiki/convection-diffusion_equation">
 Wikipedia: Convection-diffusion equation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.BivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.BivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.BivariateRealFunction,System.Double,System.Double,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Constructs a convection-diffusion equation problem.</summary>
			<param name="sigma">the diffusion coefficient (or diffusivity) \(\sigma(t,x)\)</param>
			<param name="mu">the convection coefficient \(\mu(t,x)\)</param>
			<param name="R">the sources (or sinks) <i>R(t,x)</i></param>
			<param name="a">the region of interest <i>(0, a)</i></param>
			<param name="T">the time period of interest <i>(0, T)</i></param>
			<param name="f">the initial condition of <i>u</i>, i.e., <i>u(0,x)</i></param>
			<param name="c1">the coefficient in the mixed boundary condition at <i>x = 0</i></param>
			<param name="g1">the mixed boundary condition at <i>x = 0</i></param>
			<param name="c2">the coefficient in the mixed boundary condition at <i>x = a</i></param>
			<param name="g2">the mixed boundary condition at <i>x = a</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D.sigma(System.Double,System.Double)">
			<summary>Gets the diffusion coefficient at the given time <i>t</i> and position <i>x</i>.</summary>
			<param name="t">the time</param>
			<param name="x">the position</param>
			<returns>the diffusion coefficient \(\sigma(t,x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D.mu(System.Double,System.Double)">
			<summary>Gets the convection coefficient at the given time <i>t</i> and position <i>x</i>.</summary>
			<param name="t">the time</param>
			<param name="x">the position</param>
			<returns>the convection coefficient \(\mu(t,x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D.R(System.Double,System.Double)">
			<summary>Gets the source (or sink) value at the given time <i>t</i> and position <i>x</i>.</summary>
			<param name="t">the time</param>
			<param name="x">the position</param>
			<returns>the source (or sink) <i>R(t,x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D.a">
			<summary>Gets the size of the one-dimensional space, that is, the range of <i>x</i>,
 <i>(0 &lt; x &lt; a)</i>.</summary>
			<returns>the size of the space</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D.T">
			<summary>Gets the time period of interest, that is, the range of <i>t</i>,
 <i>(0 &lt; t &lt; T)</i>.</summary>
			<returns>the time period of interest</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D.f(System.Double)">
			<summary>Gets the initial condition of <i>u</i> at the given position <i>x</i>.</summary>
			<param name="x">the position</param>
			<returns><i>u(0, x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D.c1">
			<summary>Gets the coefficient <i>c<sub>1</sub></i> in the mixed boundary condition at the boundary
 <i>x = 0</i>.
 \[
 (1-c_1)u(t,0) - c_1\frac{\partial u}{\partial x}(t,0) = g_1(t)
 \]
 where \(0 \leq c_1 \leq 1\). If \(c_1 = 0\), this is the Dirichlet boundary condition. If
 \(c_1 = 1\), this is the Neumann boundary condition.</summary>
			<returns>the coefficient <i>c<sub>1</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D.g1(System.Double)">
			<summary>The value of the linear combination of \(u\) and \(\frac{\partial u}{\partial x}\) at the
 boundary \(x = 0\) at the given time \(t\).
 \[
 (1-c_1)u(t,0) - c_1\frac{\partial u}{\partial x}(t,0) = g_1(t)
 \]</summary>
			<param name="t">the time</param>
			<returns>\(g_1(t)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D.c2">
			<summary>Gets the coefficient <i>c<sub>2</sub></i> in the mixed boundary condition at the boundary
 <i>x = a</i>.
 \[
 (1-c_2)u(t,a) + c_2\frac{\partial u}{\partial x}(t,a) = g_2(t)
 \]
 where \(0 \leq c_2 \leq 1\). If \(c_2 = 0\), this is the Dirichlet boundary condition. If
 \(c_2 = 1\), this is the Neumann boundary condition.</summary>
			<returns>the coefficient <i>c<sub>2</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.convectiondiffusionequation.ConvectionDiffusionEquation1D.g2(System.Double)">
			<summary>The value of the linear combination of \(u\) and \(\frac{\partial u}{\partial x}\) at the
 boundary \(x = a\) at the given time \(t\).
 \[
 (1-c_2)u(t,a) + c_2\frac{\partial u}{\partial x}(t,a) = g_2(t)
 \]</summary>
			<param name="t">the time</param>
			<returns>\(g_2(t)\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.HeatEquation1D">
			<summary>A one-dimensional heat equation (or diffusion equation) is a parabolic PDE that takes the
 following form.
 \[
 \frac{\partial u}{\partial t} = \beta \frac{\partial^2 u}{\partial x^2},
 \]
 The initial condition has this form:
 \[
 u(0,x) = f(x), 0 &lt; x &lt; a
 \]
 The mixed boundary conditions have this form:
 \[
 (1-c_1)u(t,0) - c_1\frac{\partial u}{\partial x}(t,0) = g_1(t), \\
 (1-c_2)u(t,a) + c_2\frac{\partial u}{\partial x}(t,a) = g_2(t)
 \]
 where \(0 \leq c_k \leq 1, k = 1, 2\).<para> See also: </para><a href="http://en.wikipedia.org/wiki/parabolic_partial_differential_equation">
 Wikipedia: Parabolic partial differential equation</a><para> See also: </para><a href="http://en.wikipedia.org/wiki/heat_equation">Wikipedia: Heat equation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.HeatEquation1D.#ctor(System.Double,System.Double,System.Double,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,System.Double,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Constructs a heat equation problem.</summary>
			<param name="beta">the beta in the equation</param>
			<param name="a">the region of interest <i>(0, a)</i></param>
			<param name="T">the time period of interest <i>(0, T)</i></param>
			<param name="f">the initial condition of <i>u</i>, i.e., <i>u(0,x)</i></param>
			<param name="c1">the coefficient in the mixed boundary condition at <i>x = 0</i></param>
			<param name="g1">the mixed boundary condition at <i>x = 0</i></param>
			<param name="c2">the coefficient in the mixed boundary condition at <i>x = a</i></param>
			<param name="g2">the mixed boundary condition at <i>x = a</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.HeatEquation1D.beta">
			<summary>Gets <i>&#946;</i> in the equation (also called <em>thermal diffusivity</em> in case of the
 heat equation).</summary>
			<returns><i>&#946;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.HeatEquation1D.a">
			<summary>Gets the size of the one-dimensional space, that is, the range of <i>x</i>,
 <i>(0 &lt; x &lt; a)</i>.</summary>
			<returns>the size of the space</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.HeatEquation1D.T">
			<summary>Gets the time period of interest, that is, the range of <i>t</i>,
 <i>(0 &lt; t &lt; T)</i>.</summary>
			<returns>the time period of interest</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.HeatEquation1D.f(System.Double)">
			<summary>Gets the initial condition of <i>u</i> at the given position <i>x</i>.</summary>
			<param name="x">the position</param>
			<returns><i>u(0, x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.HeatEquation1D.c1">
			<summary>Gets the coefficient <i>c<sub>1</sub></i> in the mixed boundary condition at the boundary
 <i>x = 0</i>.
 \[
 (1-c_1)u(t,0) - c_1\frac{\partial u}{\partial x}(t,0) = g_1(t)
 \]
 where \(0 \leq c_1 \leq 1\). If \(c_1 = 0\), this is the Dirichlet boundary condition. If
 \(c_1 = 1\), this is the Neumann boundary condition.</summary>
			<returns>the coefficient <i>c<sub>1</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.HeatEquation1D.c2">
			<summary>Gets the coefficient <i>c<sub>2</sub></i> in the mixed boundary condition at the boundary
 <i>x = a</i>.
 \[
 (1-c_2)u(t,a) + c_2\frac{\partial u}{\partial x}(t,a) = g_2(t)
 \]
 where \(0 \leq c_2 \leq 1\). If \(c_2 = 0\), this is the Dirichlet boundary condition. If
 \(c_2 = 1\), this is the Neumann boundary condition.</summary>
			<returns>the coefficient <i>c<sub>2</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.HeatEquation1D.g2(System.Double)">
			<summary>Gets the value of the linear combination of \(u\) and \(\frac{\partial u}{\partial x}\) at
 the
 boundary \(x = a\) at the given time \(t\).
 \[
 (1-c_2)u(t,a) + c_2\frac{\partial u}{\partial x}(t,a) = g_2(t)
 \]</summary>
			<param name="t">the time</param>
			<returns>\(g_2(t)\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.CrankNicolson1D">
			<summary>The Crank-Nicolson method is an algorithm for obtaining a numerical solution to parabolic PDE
 problems. It is based on central difference in space, and the trapezoidal rule in time, giving
 second-order convergence in time. That is, the solution is computed using this implicit equation:
 \[
 \frac{u_{j}^{k + 1} - u_{j}^{k}}{\Delta t} =
 \frac{\beta}{2}\left(
 \frac{u_{j+1}^{k+1} - 2u_{j}^{k+1} + u_{j-1}^{k+1}}{\Delta x^2} +
 \frac{u_{j+1}^{k} - 2u_{j}^{k} + u_{j-1}^{k}}{\Delta x^2}
 \right)
 \]
 where \(u^k_j = u(t_k,x_j)\) is the estimate at \((k, j)\) in the grid.
 <para/>
 This is a second-order method with a truncation error of order \(O(\Delta t^2 + \Delta x^2)\).
 <para/>
 The solution is computed along a two-dimensional grid (e.g. time and space). Note that due to the
 way that the boundary values are given, the resulting grid will NOT contain the values at the
 boundaries and attempting to access \(u^k_0\) or \(u^k_{n+1}\) will result in an
 <para></para>UnsupportedOperationException being thrown.<para> See also: </para><a href="http://en.wikipedia.org/wiki/cranknicolson_method">
 Wikipedia: Crank-Nicolson method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.CrankNicolson1D.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.CrankNicolson1D.solve(com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim1.heatequation.HeatEquation1D,System.Int32,System.Int32)">
			<summary>Solve the given one-dimensional heat equation.</summary>
			<param name="pde">the PDE problem</param>
			<param name="m">the number of grid points along the time-axis (excluding the initial condition)</param>
			<param name="n">the number of grid points along the space-axis (excluding the two boundaries)</param>
			<returns>the solution \(u(t,x)\) at the grid points</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.HeatEquation2D">
			<summary>A two-dimensional heat equation (or diffusion equation) is a parabolic PDE that takes the
 following form.
 \[
 \frac{\partial u}{\partial t}
 = \beta (\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}),
 \]
 with an initial condition of the form:
 \[
 u(0, x, y) = f(x, y), 0 &lt; x &lt; a, 0 &lt; y &lt; b
 \]
 and Dirichlet boundary conditions of the form:
 \[
 u(t, x, y) = g(t, x, y), (x, y) \in \delta R,
 \]
 where \(\delta R\) is the boundary of the surface <i>R</i>. This class of PDE problem is used to
 model heat or diffusion in two dimensions.<para> See also: </para><a href="http://en.wikipedia.org/wiki/parabolic_partial_differential_equation">
 Wikipedia: Parabolic partial differential equation</a><para> See also: </para><a href="http://en.wikipedia.org/wiki/heat_equation">Wikipedia: Heat equation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.HeatEquation2D.#ctor(System.Double,System.Double,System.Double,System.Double,com.numericalmethod.suanshu.analysis.function.rn2r1.BivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.TrivariateRealFunction)">
			<summary>Constructs a two-dimensional heat equation problem.</summary>
			<param name="beta">the beta in the equation</param>
			<param name="T">the time period of interest <i>(0, T)</i></param>
			<param name="a">the size of the region along the x-axis, <i>x &#8712; (0, a)</i></param>
			<param name="b">the size of the region along the y-axis <i>y &#8712; (0, b)</i></param>
			<param name="f">the initial condition of <i>u</i>, i.e., <i>u(0,x,y)</i></param>
			<param name="g">the boundary condition at <i>x = 0, a</i> and <i>y = 0, b</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.HeatEquation2D.beta">
			<summary>Gets the coefficient in the PDE (thermal diffusivity in case of the heat equation).</summary>
			<returns><i>&#946;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.HeatEquation2D.T">
			<summary>Gets the time period of interest, that is, the range of <i>t</i>,
 <i>(0 &lt; t &lt; T)</i>.</summary>
			<returns>the time period of interest</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.HeatEquation2D.a">
			<summary>Gets the size of the two-dimensional space along the x-axis, that is, the range of <i>x</i>,
 <i>(0 &lt; x &lt; a)</i>.</summary>
			<returns>the size of the space along the x-axis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.HeatEquation2D.b">
			<summary>Gets the size of the two-dimensional space along the y-axis, that is, the range of <i>y</i>,
 <i>(0 &lt; y &lt; b)</i>.</summary>
			<returns>the size of the space along the y-axis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.HeatEquation2D.f(System.Double,System.Double)">
			<summary>Gets the initial condition of <i>u</i> at the given point <i>(x,y)</i>.</summary>
			<param name="x">the x-coordinate</param>
			<param name="y">the y-coordinate</param>
			<returns><i>u(0, x, y)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.HeatEquation2D.g(System.Double,System.Double,System.Double)">
			<summary>Gets the boundary condition at the given boundary point <i>(x,y)</i> at the given time point
 <i>t</i>.</summary>
			<param name="t">the time point</param>
			<param name="x">the x-coordinate</param>
			<param name="y">the y-coordinate</param>
			<returns>u(t, x, y)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.AlternatingDirectionImplicitMethod">
			<summary>Alternating direction implicit (ADI) method is an implicit method for obtaining numerical
 approximations to the solution of a <para></para>HeatEquation2D. The idea behind the ADI method
 is to split the finite difference equations into two, one with the x-derivative taken implicitly
 and the next with the y-derivative taken implicitly, that allows solving the symmetric and
 tridiagonal systems of linear equations by using LU decomposition, at each step. Solutions are
 computed on a three-dimensional grid (time and x- and y-coordinates).
 <para/>
 This method is unconditionally stable and is a second-order method with a truncation error of
 order \(O(\Delta t^2 + \Delta x^2 + \Delta y^2)\).
 <para/>
 Since a linear system for each row/column at the same time step can be solved independently,
 parallel computation by multi-core processor can be used for higher performance. By default, this
 option is turned on.<para> See also: </para><a href="http://en.wikipedia.org/wiki/alternating_direction_implicit_method">
 Wikipedia: Alternating direction implicit method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.AlternatingDirectionImplicitMethod.#ctor(System.Double)">
			<summary>Create an ADI method with the given precision parameter. By default, multi-core parallel
 computation is used for higher performance.</summary>
			<param name="epsilon">the precision parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.AlternatingDirectionImplicitMethod.#ctor(System.Double,System.Boolean)">
			<summary>Create an ADI method with the given precision parameter, and choice for using multi-core
 parallel computation for higher performance.</summary>
			<param name="epsilon">the precision parameter</param>
			<param name="parallel"><c>true</c> to turn on parallel computation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.AlternatingDirectionImplicitMethod.solve(com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.parabolic.dim2.HeatEquation2D,System.Int32,System.Int32,System.Int32)">
			<summary>Solve the given two-dimensional heat equation problem, with the given numbers of points along
 the three axes in the grid (time, x, and y).</summary>
			<param name="pde">the heat equation problem</param>
			<param name="m">the number of grid points along the time-axis (excluding the initial condition)</param>
			<param name="n">the number of grid points along the x-axis (excluding the boundary)</param>
			<param name="p">the number of grid points along the y-axis (excluding the boundary)</param>
			<returns>the solution grid</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid2D">
			<summary>A solution to a two-dimensional PDE, which is applicable to methods which produce the solution
 as a three-dimensional grid of time and space. The valid index ranges are <i>0 &#8804; k &#8804; m</i>,
 <i>0 &#8804; i &#8804; n+1</i> and <i>0 &#8804; j &#8804; p+1</i>, where <i>k=0</i> is the initial condition
 and boundaries are located at <i>i=0</i>, <i>i=n+1</i>, <i>j=0</i> and <i>j=p+1</i> respectively.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid2D.u(System.Int32,System.Int32,System.Int32)">
			<summary>Get the value of the grid point at <i>(t<sub>k</sub>, x<sub>i</sub>, y<sub>j</sub>)</i>.</summary>
			<param name="k">the index along the time-axis</param>
			<param name="i">the index along the x-axis</param>
			<param name="j">the index along the y-axis</param>
			<returns>the value at the grid point</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid2D.t(System.Int32)">
			<summary>Get the value on the time-axis at index <c>k</c>.</summary>
			<param name="k">the index of the grid point</param>
			<returns><i>t<sub>k</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid2D.x(System.Int32)">
			<summary>Get the value on the x-axis at index <c>i</c>.</summary>
			<param name="i">the index of the grid point</param>
			<returns><i>x<sub>i</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid2D.y(System.Int32)">
			<summary>Get the value on the y-axis at index <c>j</c>.</summary>
			<param name="j">the index of the grid point</param>
			<returns><i>y<sub>j</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid2D.m">
			<summary>Get the number of interior time-axis grid points in the solution.</summary>
			<returns>the number of solution grid points along the time-axis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid2D.n">
			<summary>Get the number of interior x-axis grid points in the solution.</summary>
			<returns>the number of solution grid points along the x-axis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid2D.p">
			<summary>Get the number of interior y-axis grid points in the solution.</summary>
			<returns>the number of solution grid points along the y-axis</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid1D">
			<summary>A solution to an one-dimensional PDE, which is applicable to methods which produce the solution
 as a grid of time and space. The valid index ranges are <i>0 &#8804; k &#8804; m</i> and
 <i>0 &#8804; j &#8804; n+1</i>, where <i>k=0</i> is the initial condition and the values at the
 boundaries are at <i>j=0</i> and <i>j=n+1</i> respectively.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid1D.u(System.Int32,System.Int32)">
			<summary>Gets the value of the grid point at <i>(t<sub>k</sub>, x<sub>j</sub>)</i>.</summary>
			<param name="k">the index along the time axis</param>
			<param name="j">the index along the space axis</param>
			<returns>the value at that point</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid1D.t(System.Int32)">
			<summary>Gets the value on the time axis at index <c>k</c>.</summary>
			<param name="k">the index of the grid point</param>
			<returns><i>t<sub>k</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid1D.x(System.Int32)">
			<summary>Gets the value on the space axis at index <c>j</c>.</summary>
			<param name="j">the index of the grid point</param>
			<returns><i>x<sub>j</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid1D.m">
			<summary>Gets the number of interior time-axis grid points in the solution.</summary>
			<returns>the number of solution grid points along the time-axis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionTimeSpaceGrid1D.n">
			<summary>Gets the number of interior space-axis grid points in the solution.</summary>
			<returns>the number of solution grid points along the space-axis</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionGrid2D">
			<summary>A solution to a bivariate PDE, which is applicable to methods which produce the solution as a
 two-dimensional grid. The indices are within ranges <i>0 &#8804; k &#8804; (m+1)</i> and
 <i>0 &#8804; j &#8804; (n+1)</i>, where the boundaries lie at <i>0</i> and <i>(m+1)</i> and <i>0</i>
 and <i>(n+1)</i> respectively.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionGrid2D.u(System.Int32,System.Int32)">
			<summary>Gets the value of the grid point at <i>(x<sub>k</sub>, y<sub>j</sub>)</i>.</summary>
			<param name="k">the index along the x-axis</param>
			<param name="j">the index along the y-axis</param>
			<returns>the value at that point</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionGrid2D.x(System.Int32)">
			<summary>Gets the value on the x-axis at index <c>k</c>.</summary>
			<param name="k">the index of the grid point</param>
			<returns><i>x<sub>k</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionGrid2D.y(System.Int32)">
			<summary>Gets the value on the y-axis at index <c>j</c>.</summary>
			<param name="j">the index of the grid point</param>
			<returns><i>y<sub>j</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionGrid2D.m">
			<summary>Gets the number of interior x-axis grid points in the solution.</summary>
			<returns>the number of solution grid points along the x-axis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.pde.finitedifference.PDESolutionGrid2D.n">
			<summary>Gets the number of interior y-axis grid points in the solution.</summary>
			<returns>the number of solution grid points along the y-axis</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.PDESolver">
			<summary>A PDE solver solves a set of PDEs.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.pde.PDE">
			<summary>A partial differential equation (PDE) is a differential equation that contains unknown
 multivariable functions and their partial derivatives.<para> See also: </para><a href="http://en.wikipedia.org/wiki/partial_differential_equation">Wikipedia: Partial
 differential equation</a></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.analysis.differentialequation.UnsatisfiableErrorCriterionException">
			<summary>An exception that is thrown when the error criterion cannot be met.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.UnsatisfiableErrorCriterionException.#ctor(System.String)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.analysis.differentialequation.UnsatisfiableErrorCriterionException.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverageByExtension">
			<summary>This implements a moving average filter with these properties:
 1) both past and future observations are used in smoothing;
 2) the head is prepended with the first element in the inputs (x_t = x_1 for t &lt; 1);
 3) the tail is appended with the last element in the inputs (x_t = x_n for t &gt; n).
 When the filter length is even, more of the filter is forward in time than backward.
 Note that both past as well as future values are used in generating the outputs.
 Be cautious to use this in a forecasting model.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverageByExtension.#ctor(System.Double[])">
			<summary>Construct a moving average filter with prepending and appending.</summary>
			<param name="filter">the filter coefficients in reverse time order</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverageByExtension.transform(System.Double[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverage">
			<summary>This applies a linear filter to a univariate time series using the moving average estimation.
 <code><c>
 y[i] = f[1]*x[i+o] + … + f[p]*x[i+o-(p-1)]
 </c></code>
 <i>o</i> is the offset, depending on whether only past values or both past and future values centered around lag 0 are used.
 When a symmetric window is used and the filter length is even, more of the filter is forward in time than backward.

 <para/>
 The R equivalent function is <c>filter</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverage.#ctor(System.Double[],com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverage.Side)">
			<summary>Construct a moving average filter.</summary>
			<param name="filter">the filter coefficients in reverse time order</param>
			<param name="side">specify the data window to use</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverage.#ctor(System.Double[])">
			<summary>Construct a moving average filter using a symmetric window.</summary>
			<param name="filter">the filter coefficients in reverse time order</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverage.transform(System.Double[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverage.Side">
			<summary>the available types of moving average filtering</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverage.Side.SYMMETRIC_WINDOW">
			<summary>Use a symmetric window of past and future values, centered around lag 0.
 When the filter length is even, more of the filter is forward in time than backward.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverage.Side.PAST">
			<summary>Use only past values.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverage.Side.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.MovingAverage.Side.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.Filter">
			<summary>A filter, for signal processing, takes (real) input signal and transforms it to (real) output signal.
 Often, a filter system performs mathematical operations on a sampled, discrete-time signal to reduce or enhance certain aspects of that signal.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/filter_design">Wikipedia: Filter design</a></item>
 <item><a href="http://en.wikipedia.org/wiki/digital_filter">Wikipedia: Digital filter</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.dsp.univariate.operation.system.doubles.Filter.transform(System.Double[])">
			<summary>Transforms the input signal into the output signal.</summary>
			<param name="xt">the input signal</param>
			<returns>the filtered signal</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.geometry.TrigMath">
			<summary>A collection of trigonometric functions complementary to those in Java&apos;s <para></para>Math class.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.angle(System.Double,System.Double,System.Double)">
			<summary>Returns the angle \(\alpha\) opposite the side <c>a</c>, given the three side-lengths of the
 triangle.</summary>
			<param name="a">the side opposite the angle to compute</param>
			<param name="b">the side b</param>
			<param name="c">the side c</param>
			<returns>the angle \(alpha\) opposite the side a</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.angle(com.numericalmethod.suanshu.analysis.function.tuple.Pair,com.numericalmethod.suanshu.analysis.function.tuple.Pair,com.numericalmethod.suanshu.analysis.function.tuple.Pair)">
			<summary>Given a the coordinates of A, B and C, the apices of triangle ABC, returns the value of the
 angle \(alpha\) at apex A.</summary>
			<param name="A">a pair containing the coordinates of apex A, the angle at which is returned</param>
			<param name="B">a pair containing the coordinates of apex B</param>
			<param name="C">a pair containing the coordinates of apex C</param>
			<returns>the angle at apex A</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.cosec(System.Double)">
			<summary>Returns the cosecant of an angle. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or an infinity, then the result is <c>NaN</c>.</item>
 <item>If the argument is zero then the result is infinity with the same sign as the
 argument.</item>
 </list></summary>
			<param name="a">an angle in radians</param>
			<returns>the cosecant of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.sec(System.Double)">
			<summary>Returns the secant of an angle. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or an infinity, then the result is <c>NaN</c>.</item>
 </list></summary>
			<param name="a">an angle in radians</param>
			<returns>the secant of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.cot(System.Double)">
			<summary>Returns the cotangent of an angle. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or an infinity, then the result is <c>NaN</c>.</item>
 <item>If the argument is zero then the result is infinity with the same sign as the
 argument.</item>
 </list></summary>
			<param name="a">an angle in radians</param>
			<returns>the cotangent of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.csch(System.Double)">
			<summary>Returns the hyperbolic cosecant of a hyperbolic angle. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> then the result is <c>NaN</c>.</item>
 <item>If the argument is an infinity then the result is zero with the same sign as the
 argument.</item>
 <item>If the argument is zero then the result is positive infinity.</item>
 </list></summary>
			<param name="a">a hyperbolic angle</param>
			<returns>the hyperbolic cosecant of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.sech(System.Double)">
			<summary>Returns the hyperbolic secant of a hyperbolic angle. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> then the result is <c>NaN</c>.</item>
 <item>If the argument is an infinity then the result is zero with the same sign as the
 argument.</item>
 </list></summary>
			<param name="a">a hyperbolic angle</param>
			<returns>the hyperbolic secant of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.coth(System.Double)">
			<summary>Returns the hyperbolic cotangent of a hyperbolic angle. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> then the result is <c>NaN</c>.</item>
 <item>If the argument is an infinity then the result is one with the same sign as the
 argument.</item>
 <item>If the argument is zero then the result is infinity with the same sign as the
 argument.</item>
 </list></summary>
			<param name="a">a hyperbolic angle</param>
			<returns>the hyperbolic cotangent of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.vers(System.Double)">
			<summary>Returns the versed sine or versine of an angle. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or an infinity then the result is <c>NaN</c>.</item>
 </list></summary>
			<param name="a">an angle in radians</param>
			<returns>the versed sine of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.covers(System.Double)">
			<summary>Returns the coversed sine or coversine of an angle. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or an infinity then the result is <c>NaN</c>.</item>
 </list></summary>
			<param name="a">an angle in radians</param>
			<returns>the coversed sine of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.hav(System.Double)">
			<summary>Returns the haversed sine or haversine of an angle. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or an infinity then the result is <c>NaN</c>.</item>
 </list></summary>
			<param name="a">an angle in radians</param>
			<returns>the haversed sine of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.exsec(System.Double)">
			<summary>Returns the exsecant of an angle. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or an infinity then the result is <c>NaN</c>.</item>
 </list></summary>
			<param name="a">an angle in radians</param>
			<returns>the exsecant of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.sinc(System.Double)">
			<summary>Returns the unnormalized sinc function of an angle. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or an infinity then the result is <c>NaN</c>.</item>
 </list></summary>
			<param name="a">an angle in radians</param>
			<returns>the unnormalized sinc of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.acot(System.Double)">
			<summary>Returns the arc cotangent of a value; the returned angle is in the range -<i>pi/2</i> through
 <i>pi/2</i>. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c>, then the result is <c>NaN</c>.</item>
 <item>If the argument is zero, then the result is <c>NaN</c>.</item>
 </list></summary>
			<param name="a">the value whose arg cotangent is to be returned</param>
			<returns>the arc cotangent of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.acot2(System.Double,System.Double)">
			<summary>Returns the angle <i>theta</i> from the conversion of rectangular coordinates (x, y) to polar
 coordinates (r, <i>theta</i>). This method computes the phase <i>theta</i> by computing an
 arc tangent of y/x in the range of -<i>pi</i> to <i>pi</i>. Special cases:
 <list type="bullet">
 <item>If either argument is <c>NaN</c>, then the result is <c>NaN</c>.</item>
 <item>If the first argument is positive and the second argument is positive zero, or the first
 argument is positive infinity and finite and the second argument is positive, then the result
 is positive zero.</item>
 <item>If the first argument is positive and the second argument is negative zero, or the first
 argument is positive infinity and the second argument is negative and finite, then the
 result is negative zero.</item>
 <item>If the first argument is negative and the second argument is positive zero, or the first
 argument is negative infinity and finite and the second argument is positive, then the result
 is the <c>double</c> value closest to <i>pi</i>.</item>
 <item>If the first argument is negative and the second argument is negative zero, or the first
 argument is negative infinity and the second argument is negative and finite, then the result
 is the <c>double</c> value closest to -<i>pi</i>.</item>
 <item>If the first argument is positive zero or negative zero and the second argument is
 positive, or the first argument is finite and the second argument is positive infinity, then
 the result is the <c>double</c> value closest to <i>pi</i>/2.</item>
 <item>If the first argument is positive zero or negative zero and the second argument is
 negative, or the first argument is finite and the second argument is negative infinity, then
 the result is the <c>double</c> value closest to -<i>pi</i>/2.</item>
 <item>If both arguments are positive infinity, then the result is the <c>double</c> value
 closest to <i>pi</i>/4.</item>
 <item>If the first argument is negative infinity and the second argument is positive infinity,
 then the result is the <c>double</c> value closest to 3*<i>pi</i>/4.</item>
 <item>If the first argument is positive infinity and the second argument is negative infinity,
 then the result is the <c>double</c> value closest to -<i>pi</i>/4.</item>
 <item>If both arguments are negative infinity, then the result is the <c>double</c> value
 closest to -3*<i>pi</i>/4.</item>
 </list></summary>
			<param name="x">the abscissa coordinate</param>
			<param name="y">the ordinate coordinate</param>
			<returns>the theta component of the point (r, <i>theta</i>) in polar coordinates that
         corresponds to the point (x, y) in Cartesian coordinates.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.asec(System.Double)">
			<summary>Returns the arc secant of a value; the returned angle is in the range 0.0 through <i>pi</i>.
 Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or its absolute value is less than 1, then the result is
 <c>NaN</c>.</item>
 </list></summary>
			<param name="a">the value whose arc secant is to be returned</param>
			<returns>the arc secant of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.acsc(System.Double)">
			<summary>Returns the arc cosecant of a value; the returned angle is in the range -<i>pi</i>/2 through
 <i>pi</i>/2. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or its absolute value is less than 1, then the result is
 <c>NaN</c>.</item>
 </list></summary>
			<param name="a">the value whose arc cosecant is to be returned</param>
			<returns>the arc cosecant of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.asinh(System.Double)">
			<summary>Returns the arc hyperbolic sine of a value. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c>, then the result is <c>NaN</c>.</item>
 <item>If the argument is is an infinity, then the result is an infinity with the same sign as
 the argument.</item>
 </list></summary>
			<param name="a">the value whose arc hyperbolic sine is to be returned</param>
			<returns>the arc hyperbolic sine of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.acosh(System.Double)">
			<summary>Returns the arc hyperbolic cosine of a value; the returned hyperbolic angle is positive.
 Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or its value is less than 1, then the result is
 <c>NaN</c>.</item>
 </list></summary>
			<param name="a">the value whose arc hyperbolic cosine is to be returned</param>
			<returns>the arc hyperbolic sine of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.atanh(System.Double)">
			<summary>Returns the arc hyperbolic tangent of a value. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or its absolute value is greater than 1, then the result
 is <c>NaN</c>.</item>
 </list></summary>
			<param name="a">the value whose arc hyperbolic tangent is to be returned</param>
			<returns>the arc hyperbolic tangent of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.acoth(System.Double)">
			<summary>Returns the arc hyperbolic cotangent of a value. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> or its absolute value is less than 1, then the result is
 <c>NaN</c>.</item>
 </list></summary>
			<param name="a">the value whose arc hyperbolic cotangent is to be returned</param>
			<returns>the arc hyperbolic cotangent of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.asech(System.Double)">
			<summary>Returns the arc hyperbolic secant of a value. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c>, its value is negative or its value is greater than 1,
 then the result is <c>NaN</c>.</item>
 </list></summary>
			<param name="a">the value whose arc hyperbolic secant is to be returned</param>
			<returns>the arc hyperbolic secant of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.acsch(System.Double)">
			<summary>Returns the arc hyperbolic cosecant of a value. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c>, then the result is <c>NaN</c>.</item>
 <item>If the argument is zero, then the result is infinity with the same sign as the
 argument.</item>
 </list></summary>
			<param name="a">the value whose arc hyperbolic cosecant is to be returned</param>
			<returns>the arc hyperbolic cosecant of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.aexsec(System.Double)">
			<summary>Returns the arc exsecant of a value; the returned angle is in the range 0.0 through
 <i>pi</i>. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c> then the result is <c>NaN</c>.</item>
 </list></summary>
			<param name="a">the value whose arc exsecant is to be returned</param>
			<returns>the arc exsecant of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.avers(System.Double)">
			<summary>Returns the arc versine of a value; the returned angle is in the range zero through
 <i>pi</i>. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c>, negative or greater than 2 then the result is
 <c>NaN</c>.</item>
 </list></summary>
			<param name="a">the value whose arc versine is to be returned</param>
			<returns>the arc versine of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.acovers(System.Double)">
			<summary>Returns the arc coversine of a value; the returned angle is in the range -<i>pi</i>/2 through
 <i>pi</i>/2. Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c>, negative or greater than 2 then the result is
 <c>NaN</c>.</item>
 </list></summary>
			<param name="a">the value whose arc coversine is to be returned</param>
			<returns>the arc coversine of the argument</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.TrigMath.ahav(System.Double)">
			<summary>Returns the arc haversine of a value; the returned angle is in the range 0 to <i>pi</i>.
 Special cases:
 <list type="bullet">
 <item>If the argument is <c>NaN</c>, negative or greater than one then the result is
 <c>NaN</c>.</item>
 </list></summary>
			<param name="a">the value whose arc haversine is to be returned</param>
			<returns>the arc haversine of the argument</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.geometry.Point">
			<summary>Represent a <i>n</i>-dimensional point.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.Point.#ctor(System.Double[])">
			<summary>Create a point with given coordinates.</summary>
			<param name="coordinates">the coordinates of the point</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.Point.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Create a point with given coordinates.</summary>
			<param name="coordinates">the coordinates of the point</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.Point.getCoordinates">
			<summary>Get the coordinates of the point.</summary>
			<returns>the coordinates</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.Point.dimension">
			<summary>Get the dimension of the coordinate space.</summary>
			<returns>the dimension of the coordinate space</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.Point.distance(com.numericalmethod.suanshu.geometry.Point)">
			<summary>Compute the Euclidean distance between this point and the given point.</summary>
			<param name="pt">another point</param>
			<returns>the distance</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.geometry.LineSegment">
			<summary>Represent a line segment.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.LineSegment.#ctor(com.numericalmethod.suanshu.geometry.Point,com.numericalmethod.suanshu.geometry.Point)">
			<summary>Create a line segment with two given endpoints.</summary>
			<param name="p1">the first endpoint</param>
			<param name="p2">the second endpoint</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.LineSegment.getEndPoint1">
			<summary>Get the first endpoint.</summary>
			<returns>the first endpoint</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.LineSegment.getEndPoint2">
			<summary>Get the second endpoint.</summary>
			<returns>the second endpoint</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.LineSegment.dimension">
			<summary>Get the dimension of the coordinate space.</summary>
			<returns>the dimension of the coordinate space</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.LineSegment.length">
			<summary>Get the length of the line segment.</summary>
			<returns>the line length</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.LineSegment.distance(com.numericalmethod.suanshu.geometry.Point)">
			<summary>Calculate the shortest distance between a point and this line segment in Euclidean geometry.
 If the projection of the point on the line is outside of the segment, the distance between
 the point and the closest endpoint of the line segment is returned.</summary>
			<param name="p">the point</param>
			<returns>the distance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.LineSegment.perpendicularDistance(com.numericalmethod.suanshu.geometry.Point)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.geometry.polyline.RamerDouglasPeucker">
			<summary>The Ramer-Douglas-Peucker algorithm simplifies a <para></para>PolygonalChain by removing vertices
 which do not affect the shape of the curve to a given tolerance.
 <para/>
 The algorithm works by finding the point which is farthest from the line segment defined by the
 endpoints. If the distance is within a specified tolerance, all vertices are removed but the
 endpoints. Otherwise, the list of line segments is divided into two parts: from the first point
 to the farthest point, and from the farthest point to the last point, then the algorithm
 recursively calls itself with these two parts (and the farthest point is kept).<para> See also: </para><a href="http://en.wikipedia.org/wiki/ramer-douglas-peucker_algorithm"> Wikipedia:
 Ramer-Douglas-Peucker algorithm</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.polyline.RamerDouglasPeucker.#ctor(System.Double)">
			<summary>Create an algorithm instance with a given threshold for the maximum distance between the
 original chain and a point in the simplified chain.</summary>
			<param name="threshold">the threshold (non-negative)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.polyline.RamerDouglasPeucker.simplify(com.numericalmethod.suanshu.geometry.polyline.PolygonalChain)">
			<summary>Simplify the given polygonal chain.</summary>
			<param name="chain">the original polygonal curve</param>
			<returns>the simplified curve</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.geometry.polyline.PolygonalChainByArray">
			<summary>An immutable <para></para>PolygonalChain that is backed by an <para></para>ArrayList.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.polyline.PolygonalChainByArray.#ctor(java.util.List)">
			<summary>Create a new instance which uses the given vertices. All vertices must have the same size or
 an <para></para>IllegalArgumentException will be thrown.</summary>
			<param name="vertices">the vertices in the polygonal chain</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.polyline.PolygonalChainByArray.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.polyline.PolygonalChainByArray.vertices">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.geometry.polyline.PolygonalChain">
			<summary>A polygonal chain, polygonal curve, polygonal path, or piecewise linear curve, is a connected
 series of line segments. More formally, a polygonal chain <i>P</i> is a curve specified by a
 sequence of points called its vertices so that the curve consists of the line segments connecting
 the consecutive vertices.
 <para/>
 This interface represents a polygonal chain, in an arbitrary dimensional Cartesian space. It is
 specified by a finite, ordered list of points.<para> See also: </para><a href="http://en.wikipedia.org/wiki/polygonal_chain">Wikipedia: Polygonal chain</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.polyline.PolygonalChain.vertices">
			<summary>Get a list of the vertices defining the chain. All points must have the same dimension.</summary>
			<returns>the vertices defining the chain</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.geometry.polyline.PolygonalChain.dimension">
			<summary>Get the number of dimensions of this polygonal chain.</summary>
			<returns>the number of dimensions of this chain</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.algorithm.shortestpath.ShortestPath">
			<summary>In graph theory, a shortest path algorithm finds a path between two vertices in a graph such that
 the sum of the weights of its constituent edges is minimized.<para> See also: </para><a href="http://en.wikipedia.org/wiki/shortest_path_problem">Wikipedia: Shortest path problem</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.shortestpath.ShortestPath.distance(System.Object)">
			<summary>Gets the shortest distance from the source to a vertex.</summary>
			<param name="v">a vertex</param>
			<returns>the shortest distance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.shortestpath.ShortestPath.lastEdge(System.Object)">
			<summary>Gets the last edge of a vertex on its shortest distance from the source.</summary>
			<param name="v">a vertex that is different from the source</param>
			<returns>the last edge of a vertex on its shortest distance from the source;
         <c>null</c> if <c>v</c> is inaccessible from the source</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.algorithm.shortestpath.Dijkstra">
			<summary>Dijkstra&apos;s algorithm is a graph search algorithm that solves the single-source shortest path
 problem for a graph with non-negative edge path costs, producing a shortest path tree. This
 implementation based on a min-priority queue implemented by a Fibonacci heap runs in \(O(|E|+|V|\log|V|)\).
 It is asymptotically the fastest known single-source shortest-path algorithm for arbitrary
 directed graphs with unbounded non-negative weights.<para> See also: </para><a href="http://en.wikipedia.org/wiki/dijkstra's_algorithm">Wikipedia: Dijkstra&apos;s algorithm</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.shortestpath.Dijkstra.#ctor(com.numericalmethod.suanshu.graph.DiGraph,System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.shortestpath.Dijkstra.distance(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.shortestpath.Dijkstra.lastEdge(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.algorithm.traversal.TraversalFromRoots">
			<summary>A graph traversal is the problem of visiting all the nodes in a graph in a particular manner.
 For a directed graph, this implementation chooses as roots those vertices that have no incoming
 arcs.<para> See also: </para><a href="http://en.wikipedia.org/wiki/graph_search_algorithm">Wikipedia: Graph traversal</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.graph.algorithm.traversal.TraversalFromRoots.g">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.TraversalFromRoots.#ctor(com.numericalmethod.suanshu.graph.Graph)">
			<summary>Constructs a traversal order of a graph.</summary>
			<param name="g">a graph</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.TraversalFromRoots.track(System.Object,System.Int32)">
			<summary>Runs the traversal algorithm on a graph from a designated root.</summary>
			<param name="root">a root</param>
			<param name="time">the initial time</param>
			<returns>the nodes visited</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.TraversalFromRoots.traverse(System.Object,System.Int32)">
			<summary>Runs the traversal algorithm on a graph from a designated root.</summary>
			<param name="root">a root</param>
			<param name="time">the initial time</param>
			<returns>the vertices visited</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.TraversalFromRoots.getOrderedNodes">
			<summary>Gets the collection of visited nodes to build a spanning tree.</summary>
			<returns>the collection of visited nodes</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.algorithm.traversal.GraphTraversal">
			<summary>A spanning tree <i>T</i> of a connected, undirected graph <i>G</i> is a tree composed of all the
 vertices and some (or perhaps all) of the edges of <i>G</i>. Informally, a spanning tree of
 <i>G</i> is a selection of edges of <i>G</i> that form a tree spanning every vertex. That is,
 every vertex lies in the tree, but no cycles (or loops) are formed.<para> See also: </para><a href="http://en.wikipedia.org/wiki/spanning_tree">Wikipedia: Spanning tree</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.GraphTraversal.getOrderedNodes">
			<summary>Gets the list of visited nodes, in the order of being visited.</summary>
			<returns>the list of visited nodes</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.algorithm.traversal.GraphTraversal.Node">
			<summary>This is a node in a spanning tree.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.GraphTraversal.Node.#ctor(System.Object)">
			<summary>Constructs a node for a spanning tree.</summary>
			<param name="vertex">the node</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.GraphTraversal.Node.setParent(System.Object)">
			<summary>Sets the parent of the node.</summary>
			<param name="parent">the parent of the node</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.GraphTraversal.Node.parent">
			<summary>Gets the parent of the node.</summary>
			<returns>the parent of the node</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.GraphTraversal.Node.vertex">
			<summary>Gets the node.</summary>
			<returns>the node</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.GraphTraversal.Node.setVisitTime(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.GraphTraversal.Node.visitTime">
			<summary>Gets the first visit time of this node.</summary>
			<returns>the first visit time</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.GraphTraversal.Node.compareTo(com.numericalmethod.suanshu.graph.algorithm.traversal.GraphTraversal.Node)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.GraphTraversal.Node.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS">
			<summary>This class implements the depth-first-search using iteration.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/depth-first_search">Wikipedia: Depth-first
 search</a></item>
 <item>http://stackoverflow.com/questions/10342306/non-recursive-depth-first-search-dfs-using-a-stack</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.#ctor(com.numericalmethod.suanshu.graph.Graph)">
			<summary>Constructs a DFS tree of a graph.</summary>
			<param name="g">a graph</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.track(System.Object,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.DFS(com.numericalmethod.suanshu.graph.Graph,System.Object,System.Int32)">
			<summary>Runs the depth-first-search on a graph from a designated root.</summary>
			<param name="g">a graph</param>
			<param name="root">a root</param>
			<param name="time">the initial time</param>
			<returns>the nodes visited</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.getOrderedNodes">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.isCyclic">
			<summary>Checks if the graph is cyclic.</summary>
			<returns><c>true</c> if the graph is cyclic</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node">
			<summary>This is a node in a DFS-spanning tree.</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.color">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.finishTime">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.isCyclic">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.#ctor(System.Object)">
			<summary>Constructs a node for a spanning tree.</summary>
			<param name="vertex">the node</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.color">
			<summary>Gets the color of this node.</summary>
			<returns>the color</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.finishTime">
			<summary>Gets the finish time, the time to finish visiting its sub-tree, of this node.</summary>
			<returns>the finish time</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.isCyclic">
			<summary>Check whether this node is on a cyclic path of the graph.</summary>
			<returns><c>true</c> if this node is on a cyclic path of the graph</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.Color">
			<summary>This is the coloring scheme of visits.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.Color.WHITE">
			<summary>not seen</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.Color.GRAY">
			<summary>on the current path</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.Color.BLACK">
			<summary>seen and done</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.Color.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.DFS.Node.Color.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.algorithm.traversal.BottomUp">
			<summary>This implementation traverses a directed acyclic graph starting from the leaves at the bottom,
 and reaches the roots.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.BottomUp.#ctor(com.numericalmethod.suanshu.graph.DAGraph)">
			<summary>Constructs a <tt>BottomUp</tt> traversal instance.</summary>
			<param name="g">a directed acyclic graph</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.BottomUp.getOrderedNodes(java.util.Collection)">
			<summary>Gets the list of visited nodes, in the order of being visited.</summary>
			<param name="leaves">the leave nodes, ordered by their anticipated visiting order</param>
			<returns>the list of visited nodes</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.BottomUp.getOrderedNodes">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.algorithm.traversal.BFS">
			<summary>This class implements the breadth-first-search using iteration.<para> See also: </para><a href="http://en.wikipedia.org/wiki/breadth-first_search">Wikipedia: Breadth-first
 search</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.BFS.#ctor(com.numericalmethod.suanshu.graph.Graph)">
			<summary>Constructs a BFS tree of a graph.</summary>
			<param name="g">a graph</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.BFS.track(System.Object,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.BFS.BFS(com.numericalmethod.suanshu.graph.Graph,System.Object,System.Int32)">
			<summary>Runs the breadth-first-search on a graph from a designated root.</summary>
			<param name="g">a graph</param>
			<param name="root">a root</param>
			<param name="time">the initial time</param>
			<returns>the nodes visited</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.BFS.getOrderedNodes">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.algorithm.traversal.BFS.Node">
			<summary>This is a node in a BFS-spanning tree.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.BFS.Node.#ctor(System.Object)">
			<summary>Constructs a node for a spanning tree.</summary>
			<param name="vertex">the node</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.BFS.Node.setParent(com.numericalmethod.suanshu.graph.algorithm.traversal.BFS.Node)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.BFS.Node.depth">
			<summary>Gets the depth of this node.</summary>
			<returns>the depth</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.algorithm.traversal.BFS.Node.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.WeightedEdge">
			<summary>A weighted edge has a weight or a cost associated with it.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.WeightedEdge.cost">
			<summary>Gets the cost or weight of this edge.</summary>
			<returns>the edge cost</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.WeightedArc">
			<summary>A weighted arc is an arc that has a weight or a cost associated with it.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.UndirectedEdge">
			<summary>A tagging interface for implementations of an undirected graph
 that accept only undirected edges.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.UnDiGraph">
			<summary>An undirected graph is a graph, or set of nodes connected by edges, where an edge does not
 differentiate between (a, b) or (b, a).<para> See also: </para><a href="http://en.wikipedia.org/wiki/graph_(mathematics)#undirected_graph">Wikipedia: Undirected graph</a></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.Tree">
			<summary>A tree is an undirected graph in which any two vertices are connected by exactly one simple path.
 Consequently, each vertex in a tree has only one parent.<para> See also: </para><a href="http://en.wikipedia.org/wiki/tree_(graph_theory)">Wikipedia: Tree (graph theory)</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.Tree.parent(System.Object)">
			<summary>Gets the unique parent of a vertex.</summary>
			<param name="v">a vertex</param>
			<returns>the parent of <c>v</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.RootedTree">
			<summary>A rooted tree is a directed graph, and has a root to measure distance from the
 root.<para> See also: </para><a href="http://en.wikipedia.org/wiki/graph_(mathematics)#simple_graph">Wikipedia: Simple graph</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.RootedTree.root">
			<summary>Gets the root of this tree.
 The root is defined to be the vertex with respect to which
 vertex depth is measured.</summary>
			<returns>the root of this tree</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.RootedTree.depth(System.Object)">
			<summary>Gets the (unweighted) distance of a vertex from the root of the vertex.</summary>
			<param name="v">the vertex whose depth is to be computed</param>
			<returns>the length of the shortest unweighted path from its root to the vertex</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.RootedTree.height">
			<summary>Gets the maximum depth in this tree.</summary>
			<returns>the maximum depth in this tree</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.RootedTree.subTree(System.Object)">
			<summary>Gets a sub-tree starting from a vertex.</summary>
			<param name="v">the root of the sub-tree</param>
			<returns>the sub-tree</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.HyperEdge">
			<summary>A hyper-edge connects a set of vertices of any size.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.HyperEdge.vertices">
			<summary>Gets the set of vertices associated with the edge.</summary>
			<returns>the set of vertices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.HyperEdge.neighbors(System.Object)">
			<summary>Gets the set of neighboring vertices connected to <c>vertex</c>.</summary>
			<param name="vertex">a vertex</param>
			<returns>the set of vertices connected to <c>vertex</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.GraphUtils">
			<summary>These are the utility functions to manipulate <c>Graph</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.containsVertex(com.numericalmethod.suanshu.graph.Graph,System.Object)">
			<summary>Returns true if this graph&apos;s vertex collection contains <c>v</c></summary>
			<param name="g">a graph</param>
			<param name="v">the vertex whose presence is being queried</param>
			<returns><c>true</c> if this graph contains the vertex</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.containsEdge(com.numericalmethod.suanshu.graph.Graph,com.numericalmethod.suanshu.graph.HyperEdge)">
			<summary>Returns true if this graph&apos;s edge collection contains <c>e</c></summary>
			<param name="g">a graph</param>
			<param name="e">the edge whose presence is being queried</param>
			<returns><c>true</c> if this graph contains the edge</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.numberOfEdges(com.numericalmethod.suanshu.graph.Graph)">
			<summary>Gets the number of edges in this graph.</summary>
			<param name="g">a graph</param>
			<returns>the number of edges in this graph</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.numberOfVertices(com.numericalmethod.suanshu.graph.Graph)">
			<summary>Gets the number of vertices in this graph.</summary>
			<param name="g">a graph</param>
			<returns>the number of vertices in this graph</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.getNeighbors(com.numericalmethod.suanshu.graph.Graph,System.Object)">
			<summary>Gets the set of vertices which are connected to <c>v</c> via any edges in this graph.</summary>
			<param name="g">a graph</param>
			<param name="v">a vertex</param>
			<returns>the neighbors of the vertex</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.getEdges(com.numericalmethod.suanshu.graph.Graph,System.Object,System.Object)">
			<summary>Gets the set of edges that connect the two vertices.
 Direction is not taken into account.</summary>
			<param name="g">a graph</param>
			<param name="v1">a vertex</param>
			<param name="v2">a vertex (could be the same as <c>v1</c>)</param>
			<returns>the set of edges that connect <c>v1</c> and <c>v2</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.removeIsolatedVertices(com.numericalmethod.suanshu.graph.Graph)">
			<summary>Removes those nodes that have no edges from a graph.</summary>
			<param name="g">a graph</param>
			<returns>a purged graph</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.addEdges(com.numericalmethod.suanshu.graph.Graph,com.numericalmethod.suanshu.graph.HyperEdge[])">
			<summary>Add a set of edges to a graph.</summary>
			<param name="g">a graph</param>
			<param name="edges">edges</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.addVertices(com.numericalmethod.suanshu.graph.Graph,System.Object[])">
			<summary>Add a set of vertices to a graph.</summary>
			<param name="G">a graph</param>
			<param name="V">vertices</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.equals(com.numericalmethod.suanshu.graph.Graph,com.numericalmethod.suanshu.graph.Graph)">
			<summary>Check if two graphs are equal in terms of node values and edges.</summary>
			<param name="g1">a graph</param>
			<param name="g2">a graph</param>
			<returns><c>true</c> if the two graphs are equal</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.isAcyclic(com.numericalmethod.suanshu.graph.UnDiGraph)">
			<summary>Check if an undirected graph is acyclic.</summary>
			<param name="g">an undirected graph</param>
			<returns><c>true</c> if the undirected graph is acyclic</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.isConnected(com.numericalmethod.suanshu.graph.UnDiGraph)">
			<summary>Check whether an undirected graph is connected.<para> See also: </para>&quot;http://www.brpreiss.com/books/opus4/html/page561.html&quot;</summary>
			<param name="g">a graph</param>
			<returns><c>true</c> if an undirected graph is connected</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.di2UnDiGraph(com.numericalmethod.suanshu.graph.DiGraph)">
			<summary>Converts a directed graph into an undirected graph by removing the direction of all arcs.</summary>
			<param name="diG">a directed graph</param>
			<returns>an undirected graph</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.getDisjointGraphs(com.numericalmethod.suanshu.graph.UnDiGraph,com.numericalmethod.suanshu.graph.GraphUtils.GraphFactory)">
			<summary>Separate an undirected graph into disjointed connected graphs.</summary>
			<param name="g">an undirected graph</param>
			<param name="gCtor">a factory to construct instances of the graph type</param>
			<returns>a collection of disjointed connected graphs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.getDisjointGraphs(com.numericalmethod.suanshu.graph.UnDiGraph)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.getParents(com.numericalmethod.suanshu.graph.DiGraph,System.Object)">
			<summary>Get the set of vertices that have an outgoing arc pointing to a vertex.</summary>
			<param name="g">a directed graph</param>
			<param name="v">a vertex</param>
			<returns>the set of parents/predecessors vertices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.numberOfParents(com.numericalmethod.suanshu.graph.DiGraph,System.Object)">
			<summary>Gets the number of parents.</summary>
			<param name="g">a graph</param>
			<param name="v">a vertex</param>
			<returns>the number of parents</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.getChildren(com.numericalmethod.suanshu.graph.DiGraph,System.Object)">
			<summary>Get the set of vertices that have an incoming arc coming from a vertex.</summary>
			<param name="g">a graph</param>
			<param name="v">a vertex</param>
			<returns>the set of children/successor vertices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.numberOfChildren(com.numericalmethod.suanshu.graph.DiGraph,System.Object)">
			<summary>Gets the number of children.</summary>
			<param name="g">a graph</param>
			<param name="v">a vertex</param>
			<returns>the number of children</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.isStronglyConnected(com.numericalmethod.suanshu.graph.DiGraph)">
			<summary>Check whether a directed graph is strongly connected.<para> See also: </para>&quot;http://www.brpreiss.com/books/opus4/html/page562.html&quot;</summary>
			<param name="g">a directed graph</param>
			<returns><c>true</c> if a directed graph is strongly connected</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.unDi2DAGraph(com.numericalmethod.suanshu.graph.UnDiGraph,System.Object,com.numericalmethod.suanshu.graph.GraphUtils.EdgeFactory)">
			<summary>Converts an undirected graph into a directed acyclic graph, arcs are created from the edges
 by parent-child relations as determined by breadth-first-search. Cyclic, same-depth edges are
 removed from the graph.</summary>
			<param name="g">an (connected) undirected graph</param>
			<param name="root">a designated root</param>
			<param name="edgeFactory">the method to create an edge in the new directed acyclic graph</param>
			<returns>a directed acyclic graph</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.unDi2DAGraph(com.numericalmethod.suanshu.graph.UnDiGraph,System.Object)">
			<summary>Converts an undirected graph into a directed acyclic graph, arcs are created from the edges
 by
 parent-child relations as determined by breadth-first-search. Cyclic, same-depth edges are
 removed from the graph.</summary>
			<param name="g">an undirected graph</param>
			<param name="root">a designated root</param>
			<returns>a directed acyclic graph</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.GraphUtils.GraphFactory">
			<summary>The factory to construct instances of the graph type.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.GraphFactory.getGraph">
			<summary>Creates an empty graph.</summary>
			<returns>an empty graph</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.GraphUtils.EdgeFactory">
			<summary>This interface specifies how an edge is created for two nodes.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.GraphUtils.EdgeFactory.getEdge(System.Object,System.Object,System.Object)">
			<summary>Creates an edge between two nodes.</summary>
			<param name="v">a node</param>
			<param name="u">a node</param>
			<param name="info">other information about the edge</param>
			<returns>an edge between the two nodes</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.Graph">
			<summary>A graph is a representation of a set of objects where some pairs of the objects are connected by
 links. The interconnected objects are represented by mathematical abstractions called vertices,
 and the links that connect some pairs of vertices are called edges. In other words,
 \(G = \left \langle V, E \right \rangle\).<para> See also: </para><a href="http://en.wikipedia.org/wiki/graph_(mathematics)">Wikipedia: Graph
 (mathematics)</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.Graph.vertices">
			<summary>Gets the set of all vertices in this graph.</summary>
			<returns>all vertices in this graph</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.Graph.edges">
			<summary>Gets the set of all edges in this graph.</summary>
			<returns>all edges in this graph</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.Graph.edges(System.Object)">
			<summary>Gets the set of all edges associated with a vertex in this graph.</summary>
			<param name="v">a vertex</param>
			<returns>all edges associated with a vertex</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.Graph.addVertex(System.Object)">
			<summary>Adds a vertex to this graph.
 Does nothing if <c>v</c> is already in the graph.</summary>
			<param name="v">the vertex to add</param>
			<returns>this graph (for builder pattern)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.Graph.addEdge(com.numericalmethod.suanshu.graph.HyperEdge)">
			<summary>Adds an edge to this graph.
 Does nothing if <c>e</c> is already in the graph.
 If the edge contains new vertices, those will be added to the graph.</summary>
			<param name="e">the edge to add</param>
			<returns>this graph (for builder pattern)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.Graph.removeVertex(System.Object)">
			<summary>Removes a vertex from this graph.
 Does nothing if <c>v</c> is not in the graph.
 The edges associated with this vertex are also removed.</summary>
			<param name="v">the vertex to be removed</param>
			<returns>this graph (for builder pattern)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.Graph.removeEdge(com.numericalmethod.suanshu.graph.HyperEdge)">
			<summary>Removes an edge from this graph.
 Does nothing if <c>e</c> is not in the graph.
 The vertices associated with the edge is not removed.</summary>
			<param name="e">the edge to be removed</param>
			<returns>this graph (for builder pattern)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.Forest">
			<summary>A forest is a disjoint union of trees.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.Forest.trees">
			<summary>Get the disjoint set of trees.</summary>
			<returns>the trees</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.Edge">
			<summary>An edge connects a pair of vertices.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.Edge.neighbor(System.Object)">
			<summary>Gets the neighboring vertex connected to <c>vertex</c>.</summary>
			<param name="vertex">a vertex</param>
			<returns>the neighboring vertex</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.DiGraph">
			<summary>A directed graph or digraph is a graph, or set of nodes connected by edges, where the edges have
 a direction associated with them.<para> See also: </para><a href="http://en.wikipedia.org/wiki/directed_graph">Wikipedia: Directed graph</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.DiGraph.outgoingArcs(System.Object)">
			<summary>Gets the set of all outgoing arcs associated with a vertex in this graph.</summary>
			<param name="v">a vertex</param>
			<returns>all outgoing arcs associated with a vertex</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.DiGraph.incomingArcs(System.Object)">
			<summary>Gets the set of all incoming arcs associated with a vertex in this graph.</summary>
			<param name="v">a vertex</param>
			<returns>all incoming arcs associated with a vertex</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.DiGraph.parents(System.Object)">
			<summary>Gets the set of all parents of this vertex.</summary>
			<param name="v">a vertex</param>
			<returns>the set of all parents</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.DiGraph.children(System.Object)">
			<summary>Gets the set of all children of this vertex.</summary>
			<param name="v">a vertex</param>
			<returns>the set of all children</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.DAGraph">
			<summary>A directed acyclic graph (DAG), is a directed graph with no directed cycles. A graph has no
 directed cycles if and only if it has a topological ordering.<para> See also: </para><a href="http://en.wikipedia.org/wiki/directed_acyclic_graph">Wikipedia: Directed acyclic graph</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.DAGraph.topologicalOrder(System.Object)">
			<summary>Get the topological order of a vertex.</summary>
			<param name="v">a vertex</param>
			<returns>the topological order of a vertex</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.Arc">
			<summary>An arc is an ordered pair of vertices. It is also called a &quot;directed edge&quot;.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.Arc.head">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.Arc.tail">
			<summary>Get the tail of this arc.</summary>
			<returns>the tail</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.community.GirvanNewmanUnDiGraph">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.GirvanNewmanUnDiGraph.#ctor(com.numericalmethod.suanshu.graph.UnDiGraph)">
			<summary>Construct an instance of the Girvan-Newman algorithm.</summary>
			<param name="g">an undirected graph</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.community.GirvanNewman">
			<summary>The Girvan–Newman algorithm detects communities in complex systems. It progressively removes
 edges from the original graph. Those edges are the least central, i.e., most &quot;between&quot;
 communities.<para> See also: </para><a href="http://en.wikipedia.org/wiki/girvan%e2%80%93newman_algorithm">
 Wikipedia: Girvan–Newman algorithm</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.GirvanNewman.#ctor(com.numericalmethod.suanshu.graph.UnDiGraph,com.numericalmethod.suanshu.graph.community.GirvanNewman.EdgeBetweenessCtor,com.numericalmethod.suanshu.graph.GraphUtils.GraphFactory)">
			<summary>Construct an instance of the Girvan-Newman algorithm.</summary>
			<param name="g">an undirected graph</param>
			<param name="ebCtor">a customized constructor of edge-betweeness</param>
			<param name="gCtor">a factory to construct instances of the graph type</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.GirvanNewman.removeMaxEdge">
			<summary>Removes the edge with the highest edge-betweeness. Recalculate the betweenness of all edges
 affected by the removal.</summary>
			<returns>the highest edge-betweeness; <c>Double.NaN</c> if there is no edge to remove</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.GirvanNewman.clusters">
			<summary>Gets all the clusters, each of which is connected.</summary>
			<returns>all the clusters</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.GirvanNewman.numberOfClusters">
			<summary>Gets the number of connected clusters.</summary>
			<returns>the number of connected clusters</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.GirvanNewman.value(com.numericalmethod.suanshu.graph.UndirectedEdge)">
			<summary>Get the edge-betweeness of an edge.</summary>
			<param name="edge">an edge</param>
			<returns>the edge-betweeness</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.GirvanNewman.maxEdge">
			<summary>Gets the edge with the maximal edge-betweeness.</summary>
			<returns>the edge with the maximal edge-betweeness</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.GirvanNewman.maxValue">
			<summary>Get the maximum of edge-betweeness.</summary>
			<returns>the maximum of edge-betweeness</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.GirvanNewman.maxClusterSize">
			<summary>Get the size of the maximal cluster.</summary>
			<returns>the size of the maximal cluster</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.GirvanNewman.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.community.GirvanNewman.EdgeBetweenessCtor">
			<summary>This allows customization of the computation of edge-betweeness.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.GirvanNewman.EdgeBetweenessCtor.getEdgeBetweeness(com.numericalmethod.suanshu.graph.UnDiGraph)">
			<summary>Construct an <tt>EdgeBetweeness</tt> from an undirected graph.</summary>
			<param name="g">an undirected graph</param>
			<returns>a (customized) <tt>EdgeBetweeness</tt></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.community.EdgeBetweeness">
			<summary>The edge betweenness centrality is defined as the number of the shortest paths that go through an
 edge in a graph or network.<para> See also: </para><a href="http://www.springerreference.com/docs/html/chapterdbid/309289.html">Edge
 Betweenness Centrality</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.EdgeBetweeness.#ctor(com.numericalmethod.suanshu.graph.UnDiGraph)">
			<summary>Computes the edge-betweeness-es of all edges in an undirected graph.</summary>
			<param name="g">an undirected graph</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.EdgeBetweeness.contains(com.numericalmethod.suanshu.graph.UndirectedEdge)">
			<summary>Checks if the graph contains an edge.</summary>
			<param name="edge">an edge</param>
			<returns><c>true</c> if the graph contains an edge</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.EdgeBetweeness.value(com.numericalmethod.suanshu.graph.UndirectedEdge)">
			<summary>Gets the edge-betweeness of an edge.</summary>
			<param name="edge">an edge</param>
			<returns>the edge-betweeness</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.EdgeBetweeness.edges">
			<summary>Gets the set of all edges in the graph.</summary>
			<returns>the set of all edges</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.EdgeBetweeness.maxEdge">
			<summary>Gets the edge with the maximal edge-betweeness.</summary>
			<returns>the edge with the maximal edge-betweeness; <c>null</c> if no edge in the cluster</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.EdgeBetweeness.maxValue">
			<summary>Gets the maximum of edge-betweeness-es.</summary>
			<returns>the maximal edge-betweeness-es</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.EdgeBetweeness.isEmpty">
			<summary>Checks if there is no edge, e.g., all vertices are isolated.</summary>
			<returns><c>true</c> if there is no edge</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.community.EdgeBetweeness.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.type.VertexTree">
			<summary>A <para></para>VertexTree is both a tree and a vertex/node.This implementation builds a tree
 incrementally and recursively (combining trees).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.#ctor(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.data">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.parents(com.numericalmethod.suanshu.graph.type.VertexTree)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.children(com.numericalmethod.suanshu.graph.type.VertexTree)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.root">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.depth(com.numericalmethod.suanshu.graph.type.VertexTree)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.height">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.subTree(com.numericalmethod.suanshu.graph.type.VertexTree)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.parent(com.numericalmethod.suanshu.graph.type.VertexTree)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.vertices">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.edges">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.edges(com.numericalmethod.suanshu.graph.type.VertexTree)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.addVertex(com.numericalmethod.suanshu.graph.type.VertexTree)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.addEdge(com.numericalmethod.suanshu.graph.Arc)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.removeVertex(com.numericalmethod.suanshu.graph.type.VertexTree)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.removeEdge(com.numericalmethod.suanshu.graph.Arc)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.topologicalOrder(com.numericalmethod.suanshu.graph.type.VertexTree)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.outgoingArcs(com.numericalmethod.suanshu.graph.type.VertexTree)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.incomingArcs(com.numericalmethod.suanshu.graph.type.VertexTree)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.VertexTree.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.type.SparseUnDiGraph">
			<summary>This class implements the sparse undirected graph representation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseUnDiGraph.#ctor">
			<summary>Construct an empty graph.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseUnDiGraph.#ctor(com.numericalmethod.suanshu.graph.UnDiGraph)">
			<summary>(Copy) construct a graph from another graph.</summary>
			<param name="g">a graph</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.type.SparseTree">
			<summary>This class implements the sparse tree representation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.#ctor(System.Object)">
			<summary>Construct a tree with a root.</summary>
			<param name="root">the tree root</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.root">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.depth(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.height">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.vertices">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.edges">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.edges(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.addVertex(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.addEdge(com.numericalmethod.suanshu.graph.Arc)">
			<summary>Add an edge to the tree, connecting v1, the parent and v2..., the children.
 v1 must already exist in the tree, and the children must not already exist.</summary>
			<param name="e">an edge</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.removeVertex(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.removeEdge(com.numericalmethod.suanshu.graph.Arc)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.parent(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.subTree(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.rotate(System.Object)">
			<summary>This method re-pivots the tree with a new root vertex.</summary>
			<param name="v">the new root</param>
			<returns>a re-pivoted tree</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.topologicalOrder(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.outgoingArcs(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.incomingArcs(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.parents(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseTree.children(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.type.SparseGraph">
			<summary>This class implements the sparse graph representation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseGraph.#ctor">
			<summary>Construct an empty graph.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseGraph.#ctor(com.numericalmethod.suanshu.graph.Graph)">
			<summary>(Copy) construct a graph from another graph.</summary>
			<param name="g">a graph</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseGraph.vertices">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseGraph.edges">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseGraph.edges(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseGraph.addVertex(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseGraph.addEdge(com.numericalmethod.suanshu.graph.HyperEdge)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseGraph.removeVertex(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseGraph.removeEdge(com.numericalmethod.suanshu.graph.HyperEdge)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseGraph.contains(System.Object)">
			<summary>Check if this graph contains a vertex.</summary>
			<param name="v">a vertex</param>
			<returns><c>true</c> if this graph contains the vertex</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseGraph.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.type.SparseDiGraph">
			<summary>This class implements the sparse directed graph representation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDiGraph.#ctor">
			<summary>Construct an empty graph.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDiGraph.#ctor(com.numericalmethod.suanshu.graph.DiGraph)">
			<summary>(Copy) construct a graph from another graph.</summary>
			<param name="g">a graph</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDiGraph.outgoingArcs(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDiGraph.incomingArcs(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDiGraph.parents(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDiGraph.children(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDiGraph.vertices">
			<summary>Gets the set of all vertices in this graph, sorted by the number of parents. A root has no
 parents.</summary>
			<returns>all vertices in this graph</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDiGraph.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.type.SparseDAGraph">
			<summary>This class implements the sparse directed acyclic graph representation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDAGraph.#ctor(System.Boolean)">
			<summary>Construct an empty directed acyclic graph.</summary>
			<param name="toCheckCyclicity"><c>true</c> if to check cyclicity each time an edge is added (slow
                         performance)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDAGraph.#ctor">
			<summary>Construct an empty directed acyclic graph.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDAGraph.#ctor(com.numericalmethod.suanshu.graph.DAGraph)">
			<summary>(Copy) construct a directed acyclic graph from another directed acyclic graph.</summary>
			<param name="g">a graph</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDAGraph.addEdge(com.numericalmethod.suanshu.graph.Arc)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDAGraph.topologicalOrder(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SparseDAGraph.isAcyclic">
			<summary>Runs validity check to ensure that this DA graph is indeed acyclic.</summary>
			<returns><c>true</c> if this graph is acyclic</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.type.SimpleEdge">
			<summary>A simple edge has two vertices.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleEdge.#ctor(System.Object,System.Object,System.Double)">
			<summary>Construct a simple edge.</summary>
			<param name="v1">a vertex</param>
			<param name="v2">a vertex</param>
			<param name="cost">the edge cost</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleEdge.#ctor(System.Object,System.Object)">
			<summary>Construct a simple edge.</summary>
			<param name="v1">a vertex</param>
			<param name="v2">a vertex</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleEdge.cost">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleEdge.vertices">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleEdge.neighbors(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleEdge.neighbor(System.Object)">
			<summary>Get the unique neighboring vertex connected to <c>vertex</c>.
 It may be the same as <c>vertex</c> to account for self loop.</summary>
			<param name="vertex">a vertex</param>
			<returns>the unique neighboring vertex; <c>null</c> if <c>vertex</c> is not in the edge</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleEdge.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.graph.type.SimpleArc">
			<summary>A simple arc has two vertices: head and tail.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleArc.#ctor(System.Object,System.Object,System.Double)">
			<summary>Construct a simple arc.</summary>
			<param name="head">head vertex</param>
			<param name="tail">tail vertex</param>
			<param name="cost">the edge cost</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleArc.#ctor(System.Object,System.Object)">
			<summary>Construct a simple arc.</summary>
			<param name="head">head vertex</param>
			<param name="tail">tail vertex</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleArc.cost">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleArc.head">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleArc.tail">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleArc.neighbor(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleArc.neighbors(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleArc.vertices">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.graph.type.SimpleArc.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.interval.RealInterval">
			<summary>This is an interval on the real line.
 <para/>
 This class is immutable.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.RealInterval.#ctor(java.lang.Double,java.lang.Double)">
			<summary>Construct an interval on the real line.</summary>
			<param name="begin">the beginning of this interval</param>
			<param name="end">the end of this interval</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.RealInterval.lower">
			<summary>Get the lower bound of this interval.</summary>
			<returns>the lower bound of this interval</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.RealInterval.upper">
			<summary>Get the upper bound of this interval.</summary>
			<returns>the upper bound of this interval</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.interval.Intervals">
			<summary>This is a disjoint set of intervals. When adding a new interval, all overlapping intervals are merged into one interval.
 This implementation keeps the disjoint intervals sorted in ascending order.
 Suppose <i>I_1</i> is indexed before <i>I_2</i>.
 The end of <i>I_1</i> is strictly smaller than the begin of <i>I_2</i>, as defined by the partial ordering relation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Intervals.#ctor">
			<summary>Construct an empty set of intervals.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Intervals.#ctor(com.numericalmethod.suanshu.interval.Interval)">
			<summary>Construct a set that contains only one interval.</summary>
			<param name="interval">an interval</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Intervals.#ctor(java.lang.Comparable,java.lang.Comparable)">
			<summary>Construct a set that contains only one interval <i>[begin, end]</i>.</summary>
			<param name="begin">the begin of an interval</param>
			<param name="end">the end of an interval</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Intervals.#ctor(com.numericalmethod.suanshu.interval.Interval[])">
			<summary>Construct a set of intervals.</summary>
			<param name="intervals">intervals</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Intervals.#ctor(com.numericalmethod.suanshu.interval.Intervals)">
			<summary>Copy constructor.</summary>
			<param name="that">a set of intervals</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Intervals.size">
			<summary>Get the number of disjoint intervals.</summary>
			<returns>the number of disjoint intervals</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Intervals.get(System.Int32)">
			<summary>Get the <i>i</i>-th interval.
 The intervals are sorted such that
 if <i>I_1</i> is indexed before <i>I_2</i>,
 then the end of <i>I_1</i> is strictly smaller than the begin of <i>I_2</i>.</summary>
			<param name="i">the index, counting from 1</param>
			<returns>the <i>i</i>-th interval</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Intervals.add(com.numericalmethod.suanshu.interval.Interval)">
			<summary>Add an interval to the set.
 The union remains disjoint and sorted.</summary>
			<param name="interval">an interval</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Intervals.add(com.numericalmethod.suanshu.interval.Interval[])">
			<summary>Add intervals to the set.
 The union remains disjoint and sorted.</summary>
			<param name="intervals">intervals</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Intervals.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Intervals.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Intervals.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.interval.IntervalRelation">
			<summary>Allen&apos;s Interval Algebra is a calculus for temporal reasoning that was introduced by James F. Allen in 1983.
 The calculus defines possible relations between time intervals and
 provides a composition table that can be used as a basis for reasoning about temporal descriptions of events.
 This implementation has the 13 base relations that capture the possible relations between two intervals.<para> See also: </para><a href="http://en.wikipedia.org/wiki/allen's_interval_algebra">Wikipedia: Allen&apos;s Interval Algebra</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.BEFORE">
			<summary>X takes place before Y.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.AFTER">
			<summary>X takes place after Y.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.MEET">
			<summary>X meets Y.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.MEET_INVERSE">
			<summary>Y meets X.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.OVERLAP">
			<summary>X overlaps with Y.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.OVERLAP_INVERSE">
			<summary>Y overlaps with X.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.START">
			<summary>X starts Y.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.START_INVERSE">
			<summary>Y starts X.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.DURING">
			<summary>X during Y.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.DURING_INVERSE">
			<summary>Y during X.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.FINISH">
			<summary>X finishes Y</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.FINISH_INVERSE">
			<summary>Y finishes X.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.interval.IntervalRelation.EQUAL">
			<summary>X is equal to Y.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.IntervalRelation.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.IntervalRelation.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.IntervalRelation.isBetween(com.numericalmethod.suanshu.interval.Interval,com.numericalmethod.suanshu.interval.Interval)">
			<summary>Check if <i>X</i> and <i>Y</i> satisfy a certain relation.</summary>
			<param name="X">an interval</param>
			<param name="Y">an interval</param>
			<returns><c>true</c> is if <i>X</i> and <i>Y</i> satisfy the relation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.interval.Interval">
			<summary>For a partially ordered set, there is a binary relation, denoted as &#8804;, that indicates that,
 for certain pairs of elements in the set, one of the elements precedes the other.
 An interval is defined as follows.
 For <i>a &#8804; b</i>, an interval <i>[a,b]</i> is the set of elements <i>x</i> satisfying <i>a &#8804; x &#8804; b</i> (i.e. <i>a &#8804; x</i> and <i>x &#8804; b</i>).
 It contains at least the elements <i>a</i> and <i>b</i>.
 <para/>
 An <c>Interval</c> is immutable.<para> See also: </para><a href="http://en.wikipedia.org/wiki/partially_ordered_set#interval">Wikipedia: Interval</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Interval.#ctor(java.lang.Comparable,java.lang.Comparable)">
			<summary>Construct an interval.</summary>
			<param name="begin">the beginning of this interval</param>
			<param name="end">the end of this interval</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Interval.begin">
			<summary>Get the beginning of this interval.</summary>
			<returns>the beginning of this interval</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Interval.end">
			<summary>Get the end of this interval.</summary>
			<returns>the end of this interval</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Interval.relations(com.numericalmethod.suanshu.interval.Interval)">
			<summary>Determine the interval relations between <c>this</c> and <c>Y</c>.</summary>
			<param name="Y">an interval</param>
			<returns>the set of satisfied relations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Interval.is(com.numericalmethod.suanshu.interval.IntervalRelation,com.numericalmethod.suanshu.interval.Interval)">
			<summary>Check whether <c>this</c> and <c>Y</c> satisfies a certain Allen&apos;s interval relation.</summary>
			<param name="relation">an <para></para>IntervalRelation</param>
			<param name="Y">an interval</param>
			<returns><c>true</c> if <c>this</c> and <c>Y</c> satisfies <c>relation</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Interval.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Interval.hashCode">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.interval.Interval.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.CartesianProduct">
			<summary>The Cartesian product can be generalized to the n-ary Cartesian product over <i>n</i> sets <i>X<sub>1</sub>, ..., X<sub>n</sub></i>.
 \[
 X_1\times\cdots\times X_n = \{(x_1, \ldots, x_n): x_i \in X_i \}
 \]
 It is a set of n-tuples.<para> See also: </para><a href="http://en.wikipedia.org/wiki/cartesian_product#n-ary_product">Wikipedia: n-ary product</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.CartesianProduct.#ctor(System.Object[][])">
			<summary>Construct an <para></para>Iterable of all combinations of arrays, taking one element from each array.
 <para/>
 For example, suppose we have two arrays:
 <code>
 {1, 2}
 {3, 4, 5}
 </code>

 The possible combinations are:
 <code>
 {1, 3}
 {1, 4}
 {1, 5}
 {2, 3}
 {2, 4}
 {2, 5}
 </code></summary>
			<param name="sets">arrays of elements</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.CartesianProduct.iterator">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.Bins">
			<summary>This class divides the items based on their keys into a number of bins.
 Information can be extracted from each bin.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.Bins.#ctor(System.Int32)">
			<summary>Constructs an empty bin of valued items.</summary>
			<param name="n">the number of bins</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.Bins.#ctor(System.Int32,java.util.Map)">
			<summary>Constructs a bin with valued items.</summary>
			<param name="n">the number of bins</param>
			<param name="items">a collection of valued items</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.Bins.add(System.Double,System.Object)">
			<summary>Add a valued item to the bin.</summary>
			<param name="key">the value</param>
			<param name="item">the item</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.Bins.getBins">
			<summary>Divides the items into <c>n</c> bins. If the total cannot be evenly
 divided, the last bin may be not fully filled. If the <i>n</i>-th bin is
 empty, only <i>n - 1</i> bins are returned.</summary>
			<returns>the bins</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.Bins.getBinKeyValues(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary>Applies a function to the key of each bin.</summary>
			<param name="f">a function to be applied on the keys</param>
			<returns>the functional values of the keys</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.Bins.getBinObjectValues(com.numericalmethod.suanshu.analysis.function.Function)">
			<summary>Applies a function to the items of each bin.</summary>
			<param name="f">a function to be applied on the items</param>
			<returns>the functional values of the items</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.Bins.maxBinSize">
			<summary>Gets the maximal size of the bins.</summary>
			<returns>the maximal size of the bins</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.ActiveSet">
			<summary>This class keeps track of the active and inactive indices.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.#ctor(System.Boolean)">
			<summary>Construct a working set of active/inactive indices.</summary>
			<param name="sorted">indicator of whether the indices are sorted</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.#ctor(System.Boolean,java.util.Collection)">
			<summary>Construct a working set of active/inactive indices.</summary>
			<param name="sorted">indicator of whether the indices are sorted</param>
			<param name="indices">the active indices</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.#ctor(System.Boolean,System.Int32[])">
			<summary>Construct a working set of active/inactive indices.</summary>
			<param name="sorted">indicator of whether the indices are sorted</param>
			<param name="indices">the active indices</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.addActive(java.util.Collection)">
			<summary>Add active indices.</summary>
			<param name="indices">a collection of active constraint indices</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.addActive(System.Int32[])">
			<summary>Add active indices.</summary>
			<param name="indices">an array of active constraint indices</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.addInactive(java.util.Collection)">
			<summary>Add inactive indices.</summary>
			<param name="indices">a collection of inactive constraint indices</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.addInactive(System.Int32[])">
			<summary>Add inactive indices.</summary>
			<param name="indices">an array of inactive constraint indices</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.addActive(System.Int32)">
			<summary>Add an active constraint by index.</summary>
			<param name="j">an index of an active constraint</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.addInactive(System.Int32)">
			<summary>Add an inactive constraint by index.</summary>
			<param name="j">an index of an inactive constraint</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.removeActive(System.Int32)">
			<summary>Remove an active index.</summary>
			<param name="j">an active index to be removed.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.removeInactive(System.Int32)">
			<summary>Remove an inactive index.</summary>
			<param name="j">an inactive index to be removed.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.removeActiveByIndex(System.Int32)">
			<summary>Remove an active constraint by index.</summary>
			<param name="i">an active index, counting from 1</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.removeInactiveByIndex(System.Int32)">
			<summary>Remove an active constraint by index.</summary>
			<param name="i">an inactive index, counting from 1</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.activeSize">
			<summary>Get the number of active indices.</summary>
			<returns>the number of active indices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.inactiveSize">
			<summary>Get the number of inactive indices.</summary>
			<returns>the number of inactive indices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.containActive(System.Int32)">
			<summary>Check if the active set contains a certain index.</summary>
			<param name="j">an index of an active constraint</param>
			<returns><c>true</c> if the active set contains <c>j</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.containInactive(System.Int32)">
			<summary>Check if the inactive set contains a certain index.</summary>
			<param name="j">an index of an inactive constraint</param>
			<returns><c>true</c> if the inactive set contains <c>j</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.getActiveIndices">
			<summary>Get all active indices.</summary>
			<returns>all active indices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.getInactiveIndices">
			<summary>Get all inactive indices.</summary>
			<returns>all inactive indices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.getActive(System.Int32)">
			<summary>Get the i-th active index.</summary>
			<param name="i">an index.</param>
			<returns>the i-th active index</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.getInactive(System.Int32)">
			<summary>Get the i-th inactive index.</summary>
			<param name="i">an index, counting from 1</param>
			<returns>the i-th inactive index</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.ActiveSet.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.bb.BranchAndBound">
			<summary>Branch-and-Bound (BB or B&amp;B) is a general algorithm for finding optimal solutions of various optimization problems,
 especially in discrete and combinatorial optimization.
 It consists of a systematic enumeration of all candidate solutions, where large subsets of fruitless candidates are discarded en masse,
 by using upper and lower estimated bounds of the quantity being optimized.
 <para/>
 This implementation is solving a <em>minimization</em> problem.<para> See also: </para><a href="http://en.wikipedia.org/wiki/branch_and_bound">Wikipedia: Branch and bound</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.BranchAndBound.#ctor(com.numericalmethod.suanshu.misc.algorithm.bb.ActiveList,com.numericalmethod.suanshu.misc.algorithm.bb.BBNode)">
			<summary>Solve a minimization problem using a branch-and-bound algorithm.</summary>
			<param name="activeList">the node popping strategy, e.g., depth-first-search, best-first-search</param>
			<param name="root">the root node of a minimization problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.BranchAndBound.#ctor(com.numericalmethod.suanshu.misc.algorithm.bb.BBNode)">
			<summary>Solve a minimization problem using a branch-and-bound algorithm using depth-first search.</summary>
			<param name="root">the root node of a minimization problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.BranchAndBound.minimum">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.BranchAndBound.minimizer">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.BranchAndBound.setInitials(com.numericalmethod.suanshu.misc.algorithm.bb.BBNode[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.BranchAndBound.step">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.BranchAndBound.search(com.numericalmethod.suanshu.misc.algorithm.bb.BBNode[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.bb.BBNode">
			<summary>A branch-and-bound algorithm maintains a tree of nodes to keep track of the search paths and the pruned paths.
 The <para></para>BranchAndBound code works in conjunction with a node class that implements this interface.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.BBNode.solution">
			<summary>the solution to the sub-problem associated with this node</summary>
			<returns>the solution to the sub-problem associated with this node</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.BBNode.value">
			<summary>the value of this node</summary>
			<returns>the value of this node</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.BBNode.isCandidate">
			<summary>Check if this node is a possible solution to the original problem, e.g., not pruned.</summary>
			<returns><c>true</c> if this node is a possible solution to the original problem</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.BBNode.branching">
			<summary>Get the children of this node by using the branching operation.</summary>
			<returns>the children of this node</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.bb.ActiveList">
			<summary>This interface defines the node popping strategy used in a branch-and-bound algorithm, e.g., depth-first-search, best-first-search.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.ActiveList.isEmpty">
			<summary>Returns <c>true</c> if this collection contains no elements.</summary>
			<returns><c>true</c> if this collection contains no elements</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.ActiveList.add(com.numericalmethod.suanshu.misc.algorithm.bb.BBNode)">
			<summary>Add a node to the active list.</summary>
			<param name="node">a node</param>
			<returns><c>true</c> if this collection changed as a result of the call</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.ActiveList.clear">
			<summary>Removes all of the elements from this collection.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.bb.ActiveList.pop">
			<summary>Get the next node.</summary>
			<returns>the next node</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.count.Ties">
			<summary>Count the number of occurrences of each distinctive value.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.count.Ties.#ctor(java.util.List)">
			<summary>Count the number of occurrences of each distinctive value.</summary>
			<param name="objects">the objects in which to count ties</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.count.Ties.objects">
			<summary>Get the set of objects counted.</summary>
			<returns>the set of objects counted</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.count.Ties.values">
			<summary>Get the numbers of occurrences of the objects.</summary>
			<returns>the numbers of occurrences of the objects</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.count.Ties.get(System.Object)">
			<summary>Get the number of occurrences of an object.</summary>
			<param name="obj">an object</param>
			<returns>the number of occurrences</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.count.Counter">
			<summary>A counter keeps track of the number of occurrences of numbers.
 Two numbers are considered the same if they are close enough by a user specified number of decimal points.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.count.Counter.#ctor">
			<summary>Construct a counter with no rounding. Two numbers are considered the same if they have the same binary representations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.count.Counter.#ctor(System.Int32)">
			<summary>Construct a counter. Two numbers are considered the same if they are close enough by a number of decimal points.</summary>
			<param name="scale">a precision in terms of the number of decimal points</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.count.Counter.add(System.Double)">
			<summary>Add a number to the counter.</summary>
			<param name="number">a <c>double</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.count.Counter.add(System.Double[])">
			<summary>Add numbers to the counter.</summary>
			<param name="numbers"><c>double</c>s</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.count.Counter.count(System.Double)">
			<summary>Get the count, i.e., the number of occurrences, of a particular number.
 If the counter has not seen the number before, it returns 0.</summary>
			<param name="number">a number</param>
			<returns>the count</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.count.Counter.keySet">
			<summary>Get the set of numbers the counter has seen.</summary>
			<returns>a set of seen numbers</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.iterative.IterativeMethod">
			<summary>An iterative method is a mathematical procedure that generates a sequence of
 improving approximate solutions for a class of problems.
 A specific implementation of an iterative method, including the termination
 criteria, is an algorithm of the iterative method.
 <para/>
 This interface defines the structure of an iterative algorithm: initials,
 iteration step, and convergence criterion.<para> See also: </para><a href="http://en.wikipedia.org/wiki/iterative_method">Wikipedia: Iterative method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.IterativeMethod.setInitials(System.Object[])">
			<summary>Supply the starting points for the search.
 This can also initialize the state of the algorithm for a new search.</summary>
			<param name="initials">the initial guesses</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.IterativeMethod.step">
			<summary>Do the next iteration.</summary>
			<returns>the information about this step</returns>
			<exception cref="T:java.lang.Exception">when an error occurs during the search</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.IterativeMethod.search(System.Object[])">
			<summary>Search for a solution that optimizes the objective function from the
 given starting points.
 This method typically calls first <para></para>#setInitials(S...) and then
 iteratively <para></para>#step().
 It implements a default convergence criterion.</summary>
			<param name="initials">the initial guesses</param>
			<returns>an (approximate) optimizer</returns>
			<exception cref="T:java.lang.Exception">when an error occurs during the search</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.VectorMonitor">
			<summary>This <para></para>IterationMonitor stores all vectors generated during iterations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.VectorMonitor.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.VectorMonitor.addIterate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.NullMonitor">
			<summary>This <para></para>IterationMonitor does nothing when a new iterate is added.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.NullMonitor.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.NullMonitor.addIterate(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor">
			<summary>To debug an iterative algorithm, such as in <para></para>IterativeMethod, it is
 useful to keep track of the all states generated in the iterations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IterationMonitor.addIterate(System.Object)">
			<summary>Record a new iteration state.</summary>
			<param name="s">the new iteration state</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IteratesMonitor">
			<summary>This <para></para>IterationMonitor stores all states generated during iterations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IteratesMonitor.#ctor">
			<summary>Construct a monitor to keep track of the states in all iterations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IteratesMonitor.addIterate(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.IteratesMonitor.getIterates">
			<summary>Get a list of all iterative states.</summary>
			<returns>the list of iterates</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.CountMonitor">
			<summary>This <para></para>IterationMonitor counts the number of iterates generated, hence
 the number of iterations.
 Note that the initial guess of solution is usually added
 as the first iterate. Therefore, method <para></para>#getCount() normally
 return an integer greater than or equal to 1 if the iterative method is
 implemented properly.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.CountMonitor.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.CountMonitor.addIterate(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.monitor.CountMonitor.getCount">
			<summary>Get the number of iterations.</summary>
			<returns>the number of iterations</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance">
			<summary>The tolerance criteria for an iterative algorithm to stop.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.Tolerance.isResidualSmall(System.Double)">
			<summary>Checks if the updated residual satisfies the tolerance criteria.</summary>
			<param name="norm">the norm of the updated residual</param>
			<returns><c>true</c> if the residual norm is small enough</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.RelativeTolerance">
			<summary>The stopping criteria is that the norm of the residual <i>r</i> relative to
 the input <c>base</c> is equal to or smaller than the specified
 <c>tolerance</c>, that is,
 <blockquote><i>
 ||r||<sub>2</sub>/base &#8804; tolerance
 </i></blockquote></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.RelativeTolerance.DEFAULT_TOLERANCE">
			<summary>default tolerance</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.RelativeTolerance.#ctor(System.Double)">
			<summary>Construct an instance with <para></para>#DEFAULT_TOLERANCE.</summary>
			<param name="base">the base value for computing the relative residual</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.RelativeTolerance.#ctor(System.Double,System.Double)">
			<summary>Construct an instance with specified <c>tolerance</c>.</summary>
			<param name="base">the base value for computing the relative residual</param>
			<param name="tolerance">the residual norm criteria</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.RelativeTolerance.isResidualSmall(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.AbsoluteTolerance">
			<summary>The stopping criteria is that the norm of the residual <i>r</i> is equal to
 or smaller than the specified <c>tolerance</c>, that is,
 <blockquote><i>
 ||r||<sub>2</sub> &#8804; tolerance
 </i></blockquote></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.AbsoluteTolerance.DEFAULT_TOLERANCE">
			<summary>default tolerance</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.AbsoluteTolerance.#ctor">
			<summary>Construct an instance with <para></para>#DEFAULT_TOLERANCE.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.AbsoluteTolerance.#ctor(System.Double)">
			<summary>Construct an instance with specified <c>tolerance</c>.</summary>
			<param name="tolerance">the residual norm criteria</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.algorithm.iterative.tolerance.AbsoluteTolerance.isResidualSmall(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.StringUtils">
			<summary>Utility methods for string manipulation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.StringUtils.isNullOrEmpty(System.String)">
			<summary>Checks if a string is either null or empty.</summary>
			<param name="s">a string</param>
			<returns><c>true</c> if and only if the string is either null or empty</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.StringUtils.paste(java.util.Collection,System.String)">
			<summary>Concatenates <c>String</c>s into one <c>String</c>.</summary>
			<param name="collection">the collection of strings to be concatenated</param>
			<param name="delimiter">the separation symbol for the strings</param>
			<returns>the concatenated string</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.PrecisionUtils">
			<summary>Precision-related utility functions.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.PrecisionUtils.autoEpsilon(System.Double[])">
			<summary><em>Guess</em> a reasonable precision parameter.
 In numerical computing, we often need to <em>guess</em> how small a number needs to be for it
 to be considered 0.
 Changing the threshold often changes the results, e.g., the numerical rank of a matrix.
 <para/>
 This method suggests a more &apos;objective&apos; way to determine the &apos;correct&apos; epsilon from the
 inputs. Roughly,
 <blockquote><i>
 auto &#949; = |max(inputs)| * sqrt(number of inputs) * machine &#949; * 10
 </i></blockquote></summary>
			<param name="inputs"><c>double</c>s</param>
			<returns>a precision parameter</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.PrecisionUtils.autoEpsilon(System.Double[][])">
			<summary><em>Guess</em> a reasonable precision parameter.
 In numerical computing, we often need to <em>guess</em> how small a number needs to be for it
 to be considered 0.
 Changing the threshold often changes the results, e.g., the numerical rank of a matrix.
 <para/>
 This method suggests a more &apos;objective&apos; way to determine the &apos;correct&apos; epsilon from the
 inputs. Roughly,
 <blockquote><i>
 auto &#949; = |max(inputs)| * sqrt(number of inputs) * machine &#949; * 10
 </i></blockquote></summary>
			<param name="inputs">arrays of <c>double[]</c>s</param>
			<returns>a precision parameter</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.PrecisionUtils.autoEpsilon(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable)">
			<summary><em>Guess</em> a reasonable precision parameter.
 In numerical computing, we often need to <em>guess</em> how small a number needs to be for it
 to be considered 0.
 Changing the threshold often changes the results, e.g., the numerical rank of a matrix.
 <para/>
 This method suggests a more &apos;objective&apos; way to determine the &apos;correct&apos; epsilon from the
 inputs. Roughly,
 <blockquote><i>
 auto &#949; = |max(inputs)| * sqrt(number of inputs) * machine &#949; * 10
 </i></blockquote></summary>
			<param name="A">a matrix</param>
			<returns>a precision parameter</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.PhysicalConstants">
			<summary>A collection of fundamental physical constants. Physical constants are taken (unless otherwise
 noted) from the <i>NIST Reference on Constants, Units and Uncertainty</i>. These values are
 represented in SI units.<para> See also: </para><a href="http://physics.nist.gov/cuu/constants/index.html">CODATA Internationally
 recommended values of the Fundamental Physical Constants (2010 values)</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.ABSOLUTE_ZERO_T0">
			<summary>The absolute zero temperature in Celsius (&#176;C).<para> See also: </para><a href="http://www1.bipm.org/en/si/si_brochure/chapter2/2-1/2-1-1/kelvin.html">Unit of
 thermodynamic temperature (kelvin), SI Brochure, 8th edition. Bureau International des Poids
 et Mesures</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.ATOMIC_MASS_MU">
			<summary>The atomic mass constant \(m_u\) in kilograms (kg).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.AVOGADRO_NA">
			<summary>The Avogadro constant \(N_A\), \(L\) in units per mole (mol<sup>-1</sup>).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.BOLTZMANN_K">
			<summary>The Boltzmann constant \(k\) in joule per kelvin (J K<sup>-1</sup>).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.CHARACTERISTIC_IMPEDANCE_Z0">
			<summary>The characteristic impedance of vacuum \(Z_0\) in ohms (&#937;).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.CONDUCTANCE_QUANTUM_G0">
			<summary>The conductance quantum \(G_0\) in siemens (s).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.ELECTRIC_EPSILON0">
			<summary>The electric permittivity or electrical constant \(\epsilon_0\) in farads per meter
 (F m<sup>-1</sup>).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.ELECTRON_MASS_ME">
			<summary>The electron rest mass \(m_e\) in kilograms (kg).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.ELECTRON_VOLT_EV">
			<summary>The electron volt \(eV\) in joules (J).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.ELEMENTARY_CHARGE_E">
			<summary>The elementary charge \(e\) in coulombs (C).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.FARADAY_F">
			<summary>The Faraday constant \(F\) in coulombs per mole (C mol<sup>-1</sup>).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.FINE_STRUCTURE_ALPHA">
			<summary>The fine-structure constant \(\alpha\) (dimensionless).<para> See also: </para><a href="http://en.wikipedia.org/wiki/fine-structure_constant">Wikipedia: Fine-structure
 constant</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.GRAVITATIONAL_G">
			<summary>The Newtonian constant of gravitation \(G\) in meters cubed per kilogram per second squared
 (m<sup>3</sup> kg<sup>-1</sup> s<sup>-2</sup>).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.INVERSE_FINE_STRUCTURE_ALPHA1">
			<summary>The inverse fine-structure constant \(\alpha^{-1}\) (dimensionless).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.LIGHT_SPEED_C">
			<summary>The speed of light in a vacuum \(c\), \(c_0\) in meters per second (m s<sup>-1</sup>).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.MAGNETIC_MU0">
			<summary>The magnetic constant \(\mu_0\) in henries per meter (H m<sup>-1</sup>) or newtons per ampere
 squared (N A<sup>-2</sup>).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.MAGNETIC_FLUX_QUANTUM_PHI0">
			<summary>The magnetic flux quantum \(\Phi_0\) in webers (Wb).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.MOLAR_GAS_R">
			<summary>The molar gas constant \(R\) in joule per kelvin mole (J mol<sup>-1</sup> K<sup>-1</sup>).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.NEUTRON_MASS_M">
			<summary>The neutron mass in kilograms (kg).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.PLANCK_H">
			<summary>The Planck constant \(h\) in joule seconds (J s).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.PLANCK_REDUCED_HBAR">
			<summary>The reduced Planck constant (or Dirac constant) \(\hbar\), defined as the Planck constant
 divided by 2&#960;, in joule seconds (J s).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.PROTON_ELECTRON_MASS_RATIO">
			<summary>The proton-electron mass ratio \(m_p/m_e\) (dimensionless).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.PROTON_MASS_MP">
			<summary>The proton mass \(m_p\) in kilograms (kg).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.RYDBERG_RINF">
			<summary>The Rydberg constant \(R_{\infty}\) in reciprocal meter (m<sup>-1</sup>).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.PhysicalConstants.STEFAN_BOLTZMANN_SIGMA">
			<summary>The Stegan-Boltzmann constant \(\sigma\) in (W m<sup>-2</sup> K<sup>-4</sup>).</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.ExceptionUtils">
			<summary>Exception-related utility functions.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ExceptionUtils.throwIfNotNull(java.lang.RuntimeException)">
			<summary>This is a wrapper method that throws a <c>RuntimeException</c> if it is not <c>null</c>.
 It is used to avoid the slow and expensive creation of an exception object on each checking.
 For a sample usage,
 <blockquote><c>
 throwIfNotNull(cond ? null : new RuntimeException(&quot;msg&quot;));
 </c></blockquote>
 It is important that we use lazy evaluation of the <c>if</c> statement.</summary>
			<param name="error">the error thrown if the condition is not satisfied</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.DeepCopyable">
			<summary>This interface provides a way to do polymorphic copying.
 <para/>
 An interface (a class) that extends (implements) this interface should
 override the return type of <para></para>#deepCopy() in the interface (class)
 itself to provide as much information as possible to avoid unnecessary casting.
 <para/>
 For example,
 <code><c>
 public interface Matrix extends DeepCopyable {
     ...
     Matrix deepCopy();
 }
 </c></code></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.DeepCopyable.deepCopy">
			<summary>The implementation returns an instance created from <c>this</c> by the copy
 constructor of the class, or just <c>this</c> if the instance itself is
 <em>immutable</em>.</summary>
			<returns>an independent (deep) copy of the instance</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.Constants">
			<summary>This class lists the global parameters and constants in this SuanShu library.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.Constants.MACH_EPS">
			<summary>the machine epsilon
 <para/>
 This is the difference between 1 and the smallest exactly representable number greater than
 1.<para> See also: </para><a href="http://en.wikipedia.org/wiki/machine_epsilon">Wikipedia: Machine epsilon</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.Constants.MACH_SCALE">
			<summary>the scale for the machine epsilon</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.Constants.EPSILON">
			<summary>the default epsilon used in this library</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.Constants.ROOT_2">
			<summary>\(\sqrt{2}\)</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.Constants.ROOT_2_PI">
			<summary>\(\sqrt{2\pi}\)</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.Constants.ROOT_PI">
			<summary>\(\sqrt{\pi}\)</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.Constants.PI_SQ">
			<summary>\(\pi^2\)</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.Constants.EULER_MASCHERONI">
			<summary>the Euler-Mascheroni constant<para> See also: </para><a href="http://en.wikipedia.org/wiki/euler%e2%80%93mascheroni_constant">Wikipedia:
 Euler-Mascheroni constant</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.Constants.APERY">
			<summary>the Apery&apos;s constant<para> See also: </para><a href="http://en.wikipedia.org/wiki/ap%c3%a9ry%27s_constant">Wikipedia: Apery&apos;s
 constant</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.Constants.GOLDEN_RATIO">
			<summary>the Golden ratio<para> See also: </para><a href="http://en.wikipedia.org/wiki/golden_ratio">Wikipedia: Golden ratio</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.Constants.unitRoundOff(System.Int32,System.Int32)">
			<summary>Get the unit round off as defined in the reference.<para> See also: </para>&quot;G. H. Golub, C. F. van Loan, &quot;Eq. 2.4.4, Section 2.4.1,&quot; Matrix Computations, 3rd
 edition.&quot;</summary>
			<param name="base">base, e.g., 10</param>
			<param name="precision">precision (number of digits)</param>
			<returns>the unit round off</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.Constants.unitRoundOff">
			<summary>Get the default unit round off.</summary>
			<returns>the default unit round off</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.ArrayUtils">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArrayUtils.leftShift(System.Object[])">
			<summary>Get a left shifted array. The rightmost element is filled by a <c>null</c>.</summary>
			<param name="arr">an array</param>
			<returns>a left shifted array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArrayUtils.rightShift(System.Object[])">
			<summary>Get a right shifted array. The leftmost element is filled by a <c>null</c>.</summary>
			<param name="arr">an array</param>
			<returns>a right shifted array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArrayUtils.reverse(System.Object[])">
			<summary>Reverse an array in place.</summary>
			<param name="arr">an array</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.ArgumentAssertion">
			<summary>Utility class for checking numerical arguments. Arguments of same primitive type of
 <c>double</c>, <c>int</c>, <c>long</c>, <c>short</c>, <c>float</c> and <c>byte</c> can be
 used as input arguments. If input arguments violate the assertion, an
 <para></para>IllegalArgumentException with appropriate error message will be thrown.
 <para/>
 For example:
 <code>
 <c>ArgumentAssertion.assertRangeLeftOpen(1.5, 1.0, 2.0); // double
 ArgumentAssertion.assertRangeLeftOpen(2, 1, 3); // int
 ArgumentAssertion.assertRangeLeftOpen(1.5f, 1.0f, 2.0f); // float
 </c>
 </code></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertRange(java.lang.Number,java.lang.Number,java.lang.Number,System.String)">
			<summary>Test whether the specified <para></para>Number occurs within the range [<c>low</c>, <c>high</c>]
 (both inclusive). Throw <para></para>IllegalArgumentException if not.</summary>
			<param name="x">the number to test</param>
			<param name="low">lower bound of the range, inclusive</param>
			<param name="high">upper bound of the range, inclusive</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertRangeOpen(java.lang.Number,java.lang.Number,java.lang.Number,System.String)">
			<summary>Test whether the specified <para></para>Number occurs within the range (<c>low</c>, <c>high</c>)
 (both exclusive). Throw <para></para>IllegalArgumentException if not.</summary>
			<param name="x">the number to test</param>
			<param name="low">lower bound of the range, exclusive</param>
			<param name="high">upper bound of the range, exclusive</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertRangeLeftOpen(java.lang.Number,java.lang.Number,java.lang.Number,System.String)">
			<summary>Test whether the specified <para></para>Number occurs within the range (<c>low</c>, <c>high</c>]
 (left exclusive, right inclusive). Throw <para></para>IllegalArgumentException if not.</summary>
			<param name="x">the number to test</param>
			<param name="low">lower bound of the range, exclusive</param>
			<param name="high">upper bound of the range, inclusive</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertRangeRightOpen(java.lang.Number,java.lang.Number,java.lang.Number,System.String)">
			<summary>Test whether the specified <para></para>Number occurs within the range [<c>low</c>, <c>high</c>)
 (left inclusive, right exclusive). Throw <para></para>IllegalArgumentException if not.</summary>
			<param name="x">the number to test</param>
			<param name="low">lower bound of the range, inclusive</param>
			<param name="high">upper bound of the range, exclusive</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertGreaterThan(java.lang.Number,java.lang.Number,System.String)">
			<summary>Test if <para></para>Number <c>x</c> is greater than <c>bound</c>. Throw
 <para></para>IllegalArgumentException if not.</summary>
			<param name="x">the number to test</param>
			<param name="bound">the number to see if <c>x</c> is greater than</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNotLessThan(java.lang.Number,java.lang.Number,System.String)">
			<summary>Test if <para></para>Number <c>x</c> is not less than <c>bound</c>. Throw
 <para></para>IllegalArgumentException if not.</summary>
			<param name="x">the number to test</param>
			<param name="bound">the number to see if <c>x</c> is not less than</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertLessThan(java.lang.Number,java.lang.Number,System.String)">
			<summary>Test if <para></para>Number <c>x</c> is less than <c>bound</c>. Throw
 <para></para>IllegalArgumentException if not.</summary>
			<param name="x">the number to test</param>
			<param name="bound">the number to see if <c>x</c> is less than</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNotGreaterThan(java.lang.Number,java.lang.Number,System.String)">
			<summary>Test if <para></para>Number <c>x</c> is not greater than <c>bound</c>. Throw
 <para></para>IllegalArgumentException if not.</summary>
			<param name="x">the number to test</param>
			<param name="bound">the number to see if <c>x</c> is not greater than</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertPositive(java.lang.Number,System.String)">
			<summary>Test if <para></para>Number <c>x</c> is positive. Throw <para></para>IllegalArgumentException if not.</summary>
			<param name="x">the number to test</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNonNegative(java.lang.Number,System.String)">
			<summary>Test if <para></para>Number <c>x</c> is non-negative. Throw <para></para>IllegalArgumentException if
 not.</summary>
			<param name="x">the number to test</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNegative(java.lang.Number,System.String)">
			<summary>Test if <para></para>Number <c>x</c> is negative. Throw <para></para>IllegalArgumentException if not.</summary>
			<param name="x">the number to test</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNonPositive(java.lang.Number,System.String)">
			<summary>Test if <para></para>Number <c>x</c> is non-positive. Throw <para></para>IllegalArgumentException if
 not.</summary>
			<param name="x">the number to test</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertEqual(java.lang.Number,java.lang.Number,System.String)">
			<summary>Test if <para></para>Number <c>x</c> equal to <c>bound</c>. Throw
 <para></para>IllegalArgumentException if not.</summary>
			<param name="x">the number to test</param>
			<param name="bound">the number to see if <c>x</c> is equal to</param>
			<param name="variableName">the display name of variable <c>x</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertEqual(java.lang.Number,java.lang.Number,System.String,System.String)">
			<summary>Test if two <para></para>Numbers <c>x1</c> and <c>x2</c> are equal. Throw
 <para></para>IllegalArgumentException if not.</summary>
			<param name="x1">the number <c>x1</c></param>
			<param name="x2">the number <c>x2</c></param>
			<param name="variableName1">the display name of variable <c>x1</c></param>
			<param name="variableName2">the display name of variable <c>x2</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertTrue(System.Boolean,System.String,System.Object[])">
			<summary>Check if an argument <c>condition</c> is true. Throw <para></para>IllegalArgumentException if
 it is false.</summary>
			<param name="condition">the argument condition to be checked</param>
			<param name="errorMessage">the error message if the condition is not true (format string can be used
                     with <c>args</c>, see
                     <para></para>String#format(java.lang.String, java.lang.Object[]) )</param>
			<param name="args">the arguments for the error message</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertFalse(System.Boolean,System.String,System.Object[])">
			<summary>Check if an argument <c>condition</c> is false. Throw <para></para>IllegalArgumentException if
 it is true.</summary>
			<param name="condition">the argument condition to be checked</param>
			<param name="errorMessage">the error message if the condition is not false (format string can be
                     used with <c>args</c>, see
                     <para></para>String#format(java.lang.String, java.lang.Object[]) )</param>
			<param name="args">the arguments for the error message</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNotNull(System.Object,System.String)">
			<summary>Check if <c>obj</c> is not <c>null</c>. Throw <para></para>IllegalArgumentException if it is
 <c>null</c>.</summary>
			<param name="obj">variable to be checked</param>
			<param name="variableName">the display name of variable <c>obj</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNull(System.Object,System.String)">
			<summary>Check if <c>obj</c> is <c>null</c>. Throw <para></para>IllegalArgumentException if it is not
 <c>null</c>.</summary>
			<param name="obj">variable to be checked</param>
			<param name="variableName">the display name of variable <c>obj</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNotNaN(System.Double,System.String)">
			<summary>Check if an argument is <em>NOT</em> a <para></para>Double#NaN. Throw
 <para></para>IllegalArgumentException if it is a <c>NaN</c>.</summary>
			<param name="d">the <c>double</c> variable</param>
			<param name="variableName">the display name of the variable</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNotInfinity(System.Double,System.String)">
			<summary>Check if an argument is <em>NOT</em> a <para></para>Double#POSITIVE_INFINITY nor
 <para></para>Double#NEGATIVE_INFINITY. Throw <para></para>IllegalArgumentException if it holds an
 infinite value.</summary>
			<param name="d">the <c>double</c> variable</param>
			<param name="variableName">the display name of the variable</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNormalDouble(System.Double,System.String)">
			<summary>Check if an argument is a normal <c>double</c> value (that is, <em>NOT</em>
 <para></para>Double#NaN nor infinity). Throw <para></para>IllegalArgumentException if it is not a
 normal <c>double</c> value.</summary>
			<param name="d">the <c>double</c> variable</param>
			<param name="variableName">the display name of the variable</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNotNaN(System.Single,System.String)">
			<summary>Check if an argument is <em>NOT</em> a <para></para>Float#NaN. Throw
 <para></para>IllegalArgumentException if it is a <c>NaN</c>.</summary>
			<param name="f">the <c>float</c> variable</param>
			<param name="variableName">the display name of the variable</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNotInfinity(System.Single,System.String)">
			<summary>Check if an argument is <em>NOT</em> a <para></para>Float#POSITIVE_INFINITY nor
 <para></para>Float#NEGATIVE_INFINITY. Throw <para></para>IllegalArgumentException if it holds an
 infinite value.</summary>
			<param name="f">the <c>float</c> variable</param>
			<param name="variableName">the display name of the variable</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.ArgumentAssertion.assertNormalFloat(System.Single,System.String)">
			<summary>Check if an argument is a normal <c>float</c> value (that is, <em>NOT</em>
 <para></para>Float#NaN nor infinity). Throw <para></para>IllegalArgumentException if it is not a
 normal <c>float</c> value.</summary>
			<param name="f">the <c>float</c> variable</param>
			<param name="variableName">the display name of the variable</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.Table">
			<summary>A table is a means of arranging data in rows and columns.<para> See also: </para><a href="http://en.wikipedia.org/wiki/table_(information)">Wikipedia: Table
 (information)</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.Table.nRows">
			<summary>Gets the number of rows.
 Rows count from 1.</summary>
			<returns>the number of rows</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.Table.nCols">
			<summary>Gets the number of columns.
 Columns count from 1.</summary>
			<returns>the number of columns</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalGrid">
			<summary>An arbitrary dimensional grid. The grid points along each dimension are specified by a
 <para></para>Discretization object. Elements inside this class are not ordered.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalGrid.#ctor(java.lang.Double[][])">
			<summary>Constructs a multi-dimensional grid of points.</summary>
			<param name="dimensions">specify the grid points in each dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalGrid.#ctor(System.Double[][])">
			<summary>Constructs a multi-dimensional grid of points.</summary>
			<param name="dimensions">specify the grid points in each dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalGrid.#ctor(com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalGrid.Discretization[])">
			<summary>Constructs a multi-dimensional grid of points.</summary>
			<param name="discretizations">specify the grid points in each dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalGrid.iterator">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalGrid.Discretization">
			<summary>Specifies the discretization of an interval.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalGrid.Discretization.#ctor(System.Double,System.Double,System.Double)">
			<summary>Constructs a discretization of an interval.</summary>
			<param name="begin">the begin of an interval</param>
			<param name="end">the end of an interval</param>
			<param name="step">the discretization or step size</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalCollection">
			<summary>A generic collection with an arbitrary number of dimensions. Crucially, it does not require the
 number of dimensions to be specified at compile time. For example, this is useful when the
 indices represent independent variables and the number of independent variables may change.
 <para/>
 Dimension in this case can be thought of as the number of indices. For example, a
 three-dimensional collection may have 10x10x10 elements and hence requires three indices.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalCollection.set(System.Object,System.Int32[])">
			<summary>Replaces the element at the specified position in this list with the specified element.</summary>
			<param name="element">element to be stored at the specified position</param>
			<param name="indices">the indices of the element to replace</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalCollection.get(System.Int32[])">
			<summary>Returns the element at the specified position in this collection.</summary>
			<param name="indices">the indices of the element to return</param>
			<returns>the element at the specified position in the list</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalCollection.size(System.Int32)">
			<summary>Returns the size of the collection along the given dimension.</summary>
			<param name="i">the index of the dimension for which to determine the size</param>
			<returns>the size of the collection along the given dimension</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalCollection.dimension">
			<summary>Returns the number of dimensions of the collection.</summary>
			<returns>the number of dimensions</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalArray">
			<summary>A generic multi-dimensional array, with an arbitrary number of dimensions.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalArray.#ctor(System.Int32[])">
			<summary>Creates an instance with the specified size along each dimension.</summary>
			<param name="sizes">the sizes of the dimensions</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalArray.#ctor(com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalCollection)">
			<summary>A copy constructor that constructs a shallow copy of the given collection of instances. That
 is, although the created array structure is independent of the input argument, the stored
 items are referencing the same collection of instances.</summary>
			<param name="that">the collection to copy</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalArray.set(System.Object,System.Int32[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalArray.get(System.Int32[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalArray.size(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MultiDimensionalArray.dimension">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.MathTable">
			<summary>A mathematical table consists of numbers showing the results of calculation with varying
 arguments. It can be used to simplify and drastically speed up computation. We use them to
 archive results for, for example, quantiles of difficult distribution functions, often computed
 by slow Monte Carlo simulation.
 <para/>
 This implementation provides various ways of looking up a table, esp. when an index is not
 exactly found in the table.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.#ctor(System.String[])">
			<summary>Constructs an empty table by headers.</summary>
			<param name="headers">the column names; they must be unique</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.#ctor(System.Int32)">
			<summary>Constructs an empty table.
 The headers are given default names.</summary>
			<param name="nColumns">the number of columns</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.getHeaders">
			<summary>Gets the column names.</summary>
			<returns>the headers</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.nColumns">
			<summary>Gets the number of columns in the table.</summary>
			<returns>the number of columns</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.addRow(System.Double,System.Double[])">
			<summary>Adds a row to the table.</summary>
			<param name="index">the row index</param>
			<param name="values">the row values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.addRows(System.Double[][])">
			<summary>Adds rows by a <c>double[][]</c>.
 The first number in each row/<c>double[]</c> is the row index.
 For example,
 <code>
 new double[][]{
 {1.0, 1.1, 1.2, 1.3},
 {2.0, 2.1, 2.2, 2.3},
 {3.0, 3.1, 3.2, 3.3},
 {4.0, 4.1, 4.2, 4.3}
 };
 </code>
 represents
 <code>
 1.0: {1.1, 1.2, 1.3}//row 1
 2.0: {2.1, 2.2, 2.3}//row 2
 3.0: {3.1, 3.2, 3.3}//row 3
 4.0: {4.1, 4.2, 4.3}//row 4
 </code></summary>
			<param name="data">a <c>double[][]</c> of table entries.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.getIndices">
			<summary>Gets a copy of the row indices.</summary>
			<returns>a copy of the row indices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.getRowOnOrBefore(System.Double)">
			<summary>Gets the row corresponding to a row index.
 If there is no row matching the exact index, the row with the biggest index but smaller than
 the specified index is returned.</summary>
			<param name="i">a row index</param>
			<returns>the corresponding row</returns>
			<exception cref="T:java.util.NoSuchElementException">if <c>i</c> is smaller than the first row index</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.getRowOnOrAfter(System.Double)">
			<summary>Gets the row corresponding to a row index.
 If there is no row matching the exact value, the row with the smallest index value but bigger
 than the specified value is returned.</summary>
			<param name="i">a row index</param>
			<returns>the corresponding row</returns>
			<exception cref="T:java.util.NoSuchElementException">if <c>i</c> is bigger than the last row index value</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.getRowsOnOrBefore(System.Double)">
			<summary>Gets the rows having the row index value equal to or just smaller than <c>i</c>.
 The returned <c>Iterator</c> allows iterating the rows in reversed order starting from the
 matching row.</summary>
			<param name="i">the row index</param>
			<returns>an <c>Iterator</c> of <c>Row</c>s at or above the matching row</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.getRowsOnOrAfter(System.Double)">
			<summary>Gets the rows having the row index value equal to or just bigger than <c>i</c>.
 The returned <c>Iterator</c> allows iterating the rows starting from the matching row.</summary>
			<param name="i">the row index</param>
			<returns>an <c>Iterator</c> of <c>Row</c>s at or below the matching row</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.get(System.Double,System.Int32)">
			<summary>Gets a particular table entry at [i,j].
 If there is no matching row to <c>i</c>, by default, we use linear interpolation between the
 row above and below. If <i>i</i> is smaller than the first row index, we return the value at
 [1,j]. A subclass may override this behavior to customize interpolation.</summary>
			<param name="i">a row index</param>
			<param name="j">a column index, counting from 1</param>
			<returns>the value at [i,j]</returns>
			<exception cref="T:java.util.NoSuchElementException">if <c>rowValue</c> is outside the table range</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.get(System.Double,System.String)">
			<summary>Gets a particular table entry at [i, &quot;header&quot;].
 If there is no matching row to <c>i</c>, by default, we use linear interpolation between the
 row above and below. If <i>i</i> is smaller than the first row index, we return the value at
 [1,&quot;header&quot;]. A subclass may override this behavior to customize interpolation.</summary>
			<param name="i">a row value index</param>
			<param name="header">the column name</param>
			<returns>the value at [i, &quot;header&quot;]</returns>
			<exception cref="T:java.util.NoSuchElementException">if <c>i</c> is outside the table range</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.MathTable.Row">
			<summary>A row is indexed by a number and contains multiple values.
 <para/>
 This class is immutable.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.Row.get(System.Int32)">
			<summary>Gets the value in the row by column index.</summary>
			<param name="j">a column index, counting from 1</param>
			<returns>the corresponding column value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.Row.get(System.String)">
			<summary>Gets the value in the row by column name.</summary>
			<param name="header">the column name</param>
			<returns>the corresponding column value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.MathTable.Row.toArray">
			<summary>Converts the row to a <c>double[]</c>, excluding the index.</summary>
			<returns>the <c>double[]</c> representation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet">
			<summary>This class implements the Set interface with a hash table, using reference-equality in place of
 object-equality when comparing keys and values.<para> See also: </para><a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4479578">Bug issue #4479578</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.#ctor">
			<summary>Construct an empty <c>IdentityHashSet</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.#ctor(java.util.Collection)">
			<summary>Construct an <c>IdentityHashSet</c> with a collection of items.</summary>
			<param name="col">a collection of items</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.isEmpty">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.contains(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.iterator">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.toArray">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.toArray(System.Object[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.add(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.remove(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.containsAll(java.util.Collection)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.addAll(java.util.Collection)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.retainAll(java.util.Collection)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.removeAll(java.util.Collection)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.clear">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.hashCode">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.IdentityHashSet.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable">
			<summary>This is a 2D table that can shrink or grow by row or by column. The labels to the rows and
 columns are for printing and debugging. The access to the table is by indices. All indices count
 from 1. Translation between labels and indices are provided.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.#ctor(System.Object[],System.Object[],System.Double[][])">
			<summary>Constructs a flexible table that can shrink or grow.</summary>
			<param name="rowLabels">the row labels</param>
			<param name="colLabels">the column labels</param>
			<param name="cells">the table content</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.#ctor(System.Object[],System.Object[])">
			<summary>Constructs a table by row and column labels, initializing the content to 0.</summary>
			<param name="rowLabels">the row labels</param>
			<param name="colLabels">the column labels</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.#ctor(System.Int32,System.Int32)">
			<summary>Constructs a table using default labeling.</summary>
			<param name="nRows">number of rows</param>
			<param name="nCols">number of columns</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.#ctor(com.numericalmethod.suanshu.misc.datastructure.FlexibleTable)">
			<summary>Copy constructor.</summary>
			<param name="that">another <c>FlexibleTable</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.nRows">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.nCols">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.set(System.Int32,System.Int32,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.get(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.getRow(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.getColumn(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.getIndexFromRowLabel(System.Object)">
			<summary>Translates a row label to a row index. The index counts from 1.</summary>
			<param name="label">a row label</param>
			<returns>the row index</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.getIndexFromColLabel(System.Object)">
			<summary>Translates a column label to a column index. The index counts from 1.</summary>
			<param name="label">a column label</param>
			<returns>the column index</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.getRowLabel(System.Int32)">
			<summary>Gets the label for row i.</summary>
			<param name="i">a row index, counting from 1</param>
			<returns>the label for row i</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.getColLabel(System.Int32)">
			<summary>Gets the label for column i.</summary>
			<param name="i">a column index, counting from 1</param>
			<returns>the label for column i</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.renameRow(System.Int32,System.Object)">
			<summary>Renames row i.</summary>
			<param name="i">a row index, counting from 1</param>
			<param name="label">the new label</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.renameCol(System.Int32,System.Object)">
			<summary>Renames column i.</summary>
			<param name="i">a column index, counting from 1</param>
			<param name="label">the new label</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.deleteRow(System.Int32)">
			<summary>Deletes row i.</summary>
			<param name="i">a row index, counting from 1</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.deleteCol(System.Int32)">
			<summary>Deletes column i.</summary>
			<param name="i">a column index, counting from 1</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.addRowAt(System.Int32,System.Object)">
			<summary>Adds a row at i.</summary>
			<param name="i">the row index, counting from 1</param>
			<param name="label">the row label</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.addRowAt(System.Int32)">
			<summary>Adds a row at i.</summary>
			<param name="i">the row index, counting from 1</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.addColAt(System.Int32,System.Object)">
			<summary>Adds a column at i.</summary>
			<param name="i">the column index, counting from 1</param>
			<param name="label">the column label</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.addColAt(System.Int32)">
			<summary>Adds a column at i.</summary>
			<param name="i">the column index, counting from 1</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.toMatrix">
			<summary>Gets a copy of the flexible table in the form of a matrix.</summary>
			<returns>a matrix representation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.FlexibleTable.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck">
			<summary>These are the utility functions for checking table dimension.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck.isColumn(com.numericalmethod.suanshu.misc.datastructure.Table)">
			<summary>Check if a table is a column.</summary>
			<param name="A">a table</param>
			<returns><c>true</c> if the table has only one column</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck.isRow(com.numericalmethod.suanshu.misc.datastructure.Table)">
			<summary>Check if a table is a row.</summary>
			<param name="A">a table</param>
			<returns><c>true</c> if the table has only one row</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck.isArray(com.numericalmethod.suanshu.misc.datastructure.Table)">
			<summary>Check if a table is a row or a column.</summary>
			<param name="A">a table</param>
			<returns><c>true</c> if the table has only one row or one column</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck.isSquare(com.numericalmethod.suanshu.misc.datastructure.Table)">
			<summary>Check if a table is square.</summary>
			<param name="A">a table</param>
			<returns><c>true</c> if the table has as many rows as it has columns</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck.isTall(com.numericalmethod.suanshu.misc.datastructure.Table)">
			<summary>Check if a table is tall.</summary>
			<param name="A">a table</param>
			<returns><c>true</c> if the table has no fewer rows than it has columns</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck.isFat(com.numericalmethod.suanshu.misc.datastructure.Table)">
			<summary>Check if a table is fat.</summary>
			<param name="A">a table</param>
			<returns><c>true</c> if the table has no fewer columns than it has rows</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck.isSameDimension(com.numericalmethod.suanshu.misc.datastructure.Table,com.numericalmethod.suanshu.misc.datastructure.Table)">
			<summary>Check if two tables have the same dimension.</summary>
			<param name="A1">a table</param>
			<param name="A2">a table</param>
			<returns><c>true</c> if the rows and columns, i.e. the dimensions of <i>A1</i> and <i>A2</i>, are equal</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck.throwIfDifferentDimension(com.numericalmethod.suanshu.misc.datastructure.Table,com.numericalmethod.suanshu.misc.datastructure.Table)">
			<summary>Throws if
 <blockquote><c>A1.nRows() != A2.nRows()</c></blockquote>
 Or
 <blockquote><c>A1.nCols() != A2.nCols()</c></blockquote></summary>
			<param name="A1">a table</param>
			<param name="A2">a table</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck.throwIfInvalidRow(com.numericalmethod.suanshu.misc.datastructure.Table,System.Int32)">
			<summary>Throws if accessing an out of range row.</summary>
			<param name="A">a table</param>
			<param name="i">a row index</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck.throwIfInvalidColumn(com.numericalmethod.suanshu.misc.datastructure.Table,System.Int32)">
			<summary>Throws if accessing an out of range column.</summary>
			<param name="A">a table</param>
			<param name="j">a column index</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck.throwIfIncompatible4Multiplication(com.numericalmethod.suanshu.misc.datastructure.Table,com.numericalmethod.suanshu.misc.datastructure.Table)">
			<summary>Throws if
 <blockquote><c>A1.nCols() != A2.nRows()</c></blockquote></summary>
			<param name="A1">a table</param>
			<param name="A2">a table</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.DimensionCheck.throwIfIncompatible4Multiplication(com.numericalmethod.suanshu.misc.datastructure.Table,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Throws if
 <blockquote><c>A.nCols() != v.size()</c></blockquote></summary>
			<param name="A">a table</param>
			<param name="v">a vector</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.time.TimeIntervals">
			<summary>This is a collection of time intervals <para></para>TimeInterval.<para> See also: </para>TimeInterval</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.TimeIntervals.#ctor">
			<summary>Construct an empty collection of time interval.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.TimeIntervals.#ctor(DateTime,DateTime)">
			<summary>Construct a collection consisting of one time interval.</summary>
			<param name="begin">the beginning time</param>
			<param name="end">the ending time</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.TimeIntervals.#ctor(com.numericalmethod.suanshu.interval.Interval)">
			<summary>Construct a collection consisting of one time interval.</summary>
			<param name="interval">a time interval</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.TimeIntervals.#ctor(com.numericalmethod.suanshu.interval.Interval[])">
			<summary>Construct a collection of time intervals.</summary>
			<param name="intervals">time intervals</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.TimeIntervals.#ctor(com.numericalmethod.suanshu.interval.Intervals)">
			<summary>Copy constructor.</summary>
			<param name="that">a collection of time intervals</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.time.TimeInterval">
			<summary>This is a time interval.
 <para/>
 This class is immutable.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.TimeInterval.#ctor(DateTime,DateTime)">
			<summary>Construct a time interval from two time points.</summary>
			<param name="begin">the beginning time</param>
			<param name="end">the ending time</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils">
			<summary>These are the utility functions to manipulate <c>JodaTime</c>.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.GMT">
			<summary>GMT</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.EST">
			<summary>EST</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.ORIGIN">
			<summary>This is the reference time &quot;origin&quot;: 1970 January 1, midnight, UTC.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.BEGINNING_OF_TIME">
			<summary>This represents a time before all (representable) times.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.BEGINNING_OF_TIME_LONG">
			<summary>This represents a time before all (representable) times, in <tt>long</tt> representation.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.ENDING_OF_TIME">
			<summary>This represents a time after all (representable) times.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.ENDING_OF_TIME_LONG">
			<summary>This represents a time after all (representable) times, in <tt>long</tt> representation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.getDate(System.Int32,System.Int32,System.Int32,DateTimeZone)">
			<summary>Construct a <para></para>DateTime instance with year, month, day, and time zone. It is set to mid-night.</summary>
			<param name="year">year</param>
			<param name="month">month of the year</param>
			<param name="day">day of the month</param>
			<param name="tz">time zone</param>
			<returns>a <tt>DateTime</tt> object</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.getDateTime(System.String)">
			<summary>Construct a <para></para>DateTime instance from a string which ends in TimeZone specification.</summary>
			<param name="str">the date-time string</param>
			<returns>a <para></para>DateTime representation</returns>
			<exception cref="T:java.text.ParseException">if there is an error parsing the string</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.getDateTime(System.String,java.text.DateFormat,DateTimeZone)">
			<summary>Construct a <para></para>DateTime instance from a string with no TimeZone specified.</summary>
			<param name="str">the date-time string</param>
			<param name="format">the formatter</param>
			<param name="tz">the time zone; <c>null</c> if default time zone</param>
			<returns>a <para></para>DateTime representation</returns>
			<exception cref="T:java.text.ParseException">if there is an error parsing the string</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.nextWeekDay(DateTime)">
			<summary>Get the next weekday, i.e., skipping Saturdays and Sundays.</summary>
			<param name="time">a <para></para>DateTime</param>
			<returns>next weekday</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.previousWeekDay(DateTime)">
			<summary>Get the previous weekday, i.e., skipping Saturdays and Sundays.</summary>
			<param name="time">a <para></para>DateTime</param>
			<returns>the previous weekday</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.plusWeekdayPeriod(DateTime,Period)">
			<summary>Add a weekday-period (i.e., skipping weekends) to a <para></para>DateTime.
 For example, adding a weekday-period of 2 days and 4 hours to a time
 instant representing Thursday 5pm results in a time instant at next
 Monday 9pm.</summary>
			<param name="time">the original time instant</param>
			<param name="period">the period to be added</param>
			<returns>the <para></para>DateTime after the period added</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.minusWeekdayPeriod(DateTime,Period)">
			<summary>Subtract a weekday-period (i.e., skipping weekends) from a <para></para>DateTime.
 For example, subtracting a weekday-period of 2 days and 4 hours from a
 time instant representing Monday 9pm results in a time instant at
 previous Thursday 5pm.</summary>
			<param name="time">the original time instant</param>
			<param name="period">the period to be added</param>
			<returns>the <para></para>DateTime after the period subtracted</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.isWeekend(DateTime)">
			<summary>Check if the given time is a weekend.</summary>
			<param name="time">a time</param>
			<returns><c>true</c> if the given time is a weekend</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.min(DateTime,DateTime)">
			<summary>Return the earlier of two <para></para>DateTime instances.</summary>
			<param name="t1">time 1</param>
			<param name="t2">time 2</param>
			<returns>the earlier of <c>t1</c> and <c>t2</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.max(DateTime,DateTime)">
			<summary>Return the later of two <para></para>DateTime instances.</summary>
			<param name="t1">time 1</param>
			<param name="t2">time 2</param>
			<returns>the later of <c>t1</c> and <c>t2</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.getNumberOfPeriodsBetween(DateTime,DateTime,Period)">
			<summary>Return the number of periods between two times, rounding up.</summary>
			<param name="t1">time 1</param>
			<param name="t2">time 2</param>
			<param name="period">a duration</param>
			<returns>the number of periods between t1 and t2</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.getPeriodicInstants(DateTime,Period,System.Int32)">
			<summary>Make a list of periodic time instants.</summary>
			<param name="startTime">start time</param>
			<param name="period">the period</param>
			<param name="nPeriods">the number of instants, excluding start time</param>
			<returns>a list of periodic time instants</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.getLastDayOfMonth(DateTime)">
			<summary>Get the last day of the month which contain a time.</summary>
			<param name="t">a time</param>
			<returns>the last day of the month <c>t</c> is in</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.datastructure.time.JodaTimeUtils.getLastMillisecondOfDay(DateTime)">
			<summary>Get the last millisecond the day which contain a time.</summary>
			<param name="t">a time</param>
			<returns>the last millisecond of the day <c>t</c> is in</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.license.Package">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.Package.validate(System.String)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.Package.validateAll(System.String[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.Package.validateAny(System.String[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.Package.validateVersion(System.String,System.String)">
			<summary>Check if a package is licensed up to a specified version.</summary>
			<param name="packageName">the name of the package</param>
			<param name="versionString">the version of the package</param>
			<returns><c>true</c> if the package is licensed for the given version</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.license.LicenseError">
			<summary>General error regarding the license, e.g., errors when loading license.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.LicenseError.#ctor(System.String)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.LicenseError.getMessage">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.LicenseError.fillInStackTrace">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.license.License">
			<summary>This is the license management system for the library. To use this library in the client program,
 you need a valid license. Before any API calls to this library, the client program needs to
 specify the license by either:
 <list type="bullet">
 <item>putting the license file with file term specified by <para></para>#DEFAULT_LICENSE_FILES under the
 same directory as the suanshu library jar file, runtime working directory, or classpath; or</item>
 <item>calling <para></para>#setLicenseFile(java.io.File) to specify the license file; or</item>
 <item>calling <para></para>#setLicenseKey(java.lang.String) to set the license key.</item>
 </list>
 <para/>
 By default, the license file is assumed to be located under the same directory as the suanshu
 library jar file, runtime working directory, or classpath. If the license file is moved to
 elsewhere, the client program can specify the new location by calling
 <para></para>#setLicenseFile(java.io.File).
 <para/>
 Another way to set the license programmatically is to call
 <para></para>#setLicenseKey(java.lang.String) with the key string. Once you got a valid license, you
 can copy the license key in the license file. Using <para></para>#setLicenseKey(java.lang.String), the
 file I/O for loading license file can be avoided.<para> See also: </para><a
 href="http://numericalmethod.com/blog/numerical-method-incorporation-limited-software-license-agreement-version-1-0/">
 License Agreement</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.license.License.LICENSE_FILE_PROPERTY">
			<summary>The system property term for setting license file.
 Besides <para></para>#setLicenseFile(java.io.File),
 license file can be specified by system property using -D option in &apos;java&apos; command.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.license.License.DEFAULT_LICENSE_FILES">
			<summary>Default license file names.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.license.License.DATE_FORMAT_STRING">
			<summary>Date format for all kinds of dates in a license file.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.License.setLicenseFile(java.io.File)">
			<summary>Overrides the default license file.
 This has to be called before the default license is loaded.
 <para/>
 A license file can only be set once.
 All subsequent calls will lead to <para></para>RuntimeException.</summary>
			<param name="licenseFile">the license file</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.License.setLicenseKey(System.String)">
			<summary>Sets the license key for this invocation.
 <para/>
 A license file can only be set once.
 All subsequent calls will lead to <para></para>RuntimeException.</summary>
			<param name="key">the license key</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.License.getVersion">
			<summary>Gets the version number. The version number is in the format:
 <blockquote><code>
 &lt;major version&gt;.&lt;minor version&gt;.&lt;bugfix version&gt;
 </code></blockquote></summary>
			<returns>the version number</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.License.getLicenseKey">
			<summary>Gets the license key string of the current license. The returned string
 can be passed into <para></para>#setLicenseKey(java.lang.String) for setting
 up license programmatically without file I/O.</summary>
			<returns>the license key string</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.License.getLicenseLocation">
			<summary>Gets the location of the current loaded license.</summary>
			<returns>the license location</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.license.InvalidLicense">
			<summary>This is the <para></para>LicenseError thrown when calling a class or method that is not yet licensed.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.InvalidLicense.#ctor(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.license.verifier.VersionVerifier">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.VersionVerifier.#ctor(com.numericalmethod.suanshu.misc.license.verifier.Version)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.VersionVerifier.verify(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.license.verifier.Version">
			<summary>Comparable version. A version number can be in one of the following forms:
 <code>
 1.2.3
 1.2.*
 1.*
 *
 </code></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.Version.#ctor">
			<summary>Create an ANY version instance.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.Version.#ctor(System.Int32)">
			<summary>Create a version with <c>major</c> version only. That is,
 <code>
 &lt;major&gt;.*
 </code></summary>
			<param name="major">the major version</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.Version.#ctor(System.Int32,System.Int32)">
			<summary>Create a version with <c>major</c> version and <c>minor</c> version only. That is,
 <code>
 &lt;major&gt;.&lt;minor&gt;.*
 </code></summary>
			<param name="major">the major version</param>
			<param name="minor">the minor version</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.Version.#ctor(System.Int32,System.Int32,System.Int32)">
			<summary>Create a version with all three parts, <c>major</c> version, <c>minor</c> version and
 <c>bugfix</c> version. That is,
 <code>
 &lt;major&gt;.&lt;minor&gt;.&lt;bugfix&gt;
 </code></summary>
			<param name="major">the major version</param>
			<param name="minor">the minor version</param>
			<param name="bugfix">the bugfix version</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.Version.parse(System.String)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.Version.compareTo(com.numericalmethod.suanshu.misc.license.verifier.Version)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.Version.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.license.verifier.SignatureVerifier">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.SignatureVerifier.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.SignatureVerifier.verify(com.numericalmethod.license.License)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.license.verifier.MacAddressVerifier">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.MacAddressVerifier.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.MacAddressVerifier.#ctor(java.util.Collection)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.MacAddressVerifier.verify(java.util.List)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm">
			<summary>The terms signed in a license file.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm.ORGANIZATION">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm.USER">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm.EMAIL">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm.MAC_ADDRESSES">
			<summary>Comma-separated list of MAC addresses. &apos;*&apos; can be used for ANY address.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm.VERSION">
			<summary><para> See also: </para>Version version format</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm.SUANSHU">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm.CREATION_DATE">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm.START_DATE">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm.EXPIRY">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.LicenseTerm.term">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.license.verifier.IkvmVerifier">
			<summary>Check if the library is an IKVM-translated version.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.IkvmVerifier.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.IkvmVerifier.verify">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.license.verifier.DateVerifier">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.DateVerifier.#ctor(java.util.Date)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.license.verifier.DateVerifier.verify(System.String,System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.parallel.Reference">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.Reference.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.Reference.get">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.Reference.set(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor">
			<summary>This class provides a framework for executing an algorithm in parallel. A
 thread pool is created when executing a list of tasks.

 <para/>
 Caution: Avoid using another executor within parallelized calls, this would
 create numerous threads, leading to much memory consumption and huge overhead
 for thread switching. It is recommended to parallelize the outermost-scoped
 tasks.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.#ctor">
			<summary>Creates an instance using default concurrency number, which is the
 number of available processors returned by
 <code><c>
 Runtime.getRuntime().availableProcessors()
 </c></code></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.#ctor(System.String)">
			<summary>Creates an instance with a specified executor name.</summary>
			<param name="executorName">the executor name (for debug purpose)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.#ctor(System.Int32)">
			<summary>Creates an instance with a specified concurrency number.</summary>
			<param name="concurrency">the maximum number of threads can be used when executing a list of tasks</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.#ctor(System.String,System.Int32)">
			<summary>Creates an instance with a specified concurrency number, and a name of
 the executor.</summary>
			<param name="executorName">the executor name (for debug purpose)</param>
			<param name="concurrency">the maximum number of threads can be used when executing a list of tasks</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.getSharedInstance">
			<summary>Gets the globally shared executor.
 <para/>
 <em>WARNING</em>: Please make sure that the tasks submitted to this executor do NOT call this
 executor again to avoid deadlock. Create your own executor if you are not 100% sure about
 this.</summary>
			<returns>the shared instance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.shutdown">
			<summary>Shuts down the executor gracefully. Calling this method will terminate the thread pool used
 by this executor, and hence return resources to the JVM.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.getConcurrency">
			<summary>Returns the number of threads used for parallel execution.</summary>
			<returns>the concurrency of this executor</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.executeAll(java.util.List)">
			<summary>Executes a list of <para></para>Callable tasks, and returns a list of results
 in the same sequential order as <c>tasks</c>.</summary>
			<param name="tasks">the list of tasks</param>
			<returns>a list of results</returns>
			<exception cref="T:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException">if one or more tasks throws an exception</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.executeAll(java.util.concurrent.Callable[])">
			<summary>Executes an arbitrary number of <para></para>Callable tasks, and returns a
 list of results in the same order. This is a convenient method and is the
 same as calling:
 <code><c>
 executeAll(Arrays.&lt;Callable&lt;T&gt;&gt;asList(tasks));
 </c></code></summary>
			<param name="tasks">the list of tasks</param>
			<returns>a list of results</returns>
			<exception cref="T:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException">if one or more tasks throws an exception</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.executeAny(java.util.List)">
			<summary>Executes a list of tasks in parallel, and returns the result from the
 earliest successfully completed tasks (without throwing an exception).</summary>
			<param name="tasks">the list of tasks</param>
			<returns>the earliest returned results</returns>
			<exception cref="T:java.util.concurrent.ExecutionException">if no task successfully completes</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.executeAny(java.util.concurrent.Callable[])">
			<summary>Executes a list of tasks in parallel, and returns the result from the
 earliest successfully completed tasks (without throwing an exception).
 This is a convenient method and is the same as calling:
 <code><c>
 executeAny(Arrays.&lt;Callable&lt;T&gt;&gt;asList(tasks));
 </c></code></summary>
			<param name="tasks">the list of tasks</param>
			<returns>the earliest returned results</returns>
			<exception cref="T:java.util.concurrent.ExecutionException">if no task successfully completes</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.forLoop(System.Int32,System.Int32,com.numericalmethod.suanshu.misc.parallel.LoopBody)">
			<summary>Calls
 <para></para>#forLoop(int, int, int, com.numericalmethod.suanshu.misc.parallel.LoopBody) forLoop
 with <c>increment</c> of 1.</summary>
			<param name="start">the first loop index (inclusive)</param>
			<param name="end">the last loop index (exclusive)</param>
			<param name="body">the loop body</param>
			<exception cref="T:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException">if one or more partitioned for-loop throws an exception</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.forLoop(System.Int32,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.parallel.LoopBody)">
			<summary>Runs a for-loop in parallel. A huge for-loop is partitioned into roughly
 equal size, and each partition is then run by a thread. This is similar
 to running a normal for-loop construct:
 <code><c>
 for (int i = start; i &lt; end; i += increment) {
     body.run(i);
 }
 </c></code></summary>
			<param name="start">the first loop index (inclusive)</param>
			<param name="end">the last loop index (exclusive)</param>
			<param name="increment">the increment of the loop index in each iteration</param>
			<param name="body">the loop body</param>
			<exception cref="T:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException">if one or more partitioned for-loop throws an exception</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.conditionalForLoop(System.Boolean,System.Int32,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.parallel.LoopBody)">
			<summary>Runs a parallel for-loop only if <c>conditionToParallelize</c> is <c>true</c>.
 Otherwise, the loop body will be executed in a single thread.</summary>
			<param name="conditionToParallelize">the condition to parallelize the for-loop execution</param>
			<param name="start">the first loop index (inclusive)</param>
			<param name="end">the last loop index (exclusive)</param>
			<param name="increment">the increment of the loop index in each iteration</param>
			<param name="body">the loop body</param>
			<exception cref="T:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException">if one or more partitioned for-loop throws an exception</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.conditionalForLoop(System.Boolean,System.Int32,System.Int32,com.numericalmethod.suanshu.misc.parallel.LoopBody)">
			<summary>Calls
 <para></para>#conditionalForLoop(boolean, int, int, int, com.numericalmethod.suanshu.misc.parallel.LoopBody) conditionalForLoop
 with <c>increment</c> of 1.</summary>
			<param name="conditionToParallelize">the condition to parallelize the for-loop execution</param>
			<param name="start">the first loop index (inclusive)</param>
			<param name="end">the last loop index (exclusive)</param>
			<param name="body">the loop body</param>
			<exception cref="T:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException">if one or more partitioned for-loop throws an exception</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.forEach(java.lang.Iterable,com.numericalmethod.suanshu.misc.parallel.IterationBody)">
			<summary>Runs a &quot;foreach&quot; loop in parallel. Multiple threads take elements from
 the iterable collection and run the loop body in parallel. Threads are
 coordinated such that two different threads will not run the loop body
 for the same element in the collection. This is similar to running a
 normal &quot;foreach&quot; construct:
 <code><c>
 for (T item : collection) {
     body.run(item);
 }
 </c></code></summary>
			<param name="iterable">the <para></para>Iterable collection</param>
			<param name="body">the loop body</param>
			<exception cref="T:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException">if one or more threads throws an exception</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.ParallelExecutor.conditionalForEach(System.Boolean,java.lang.Iterable,com.numericalmethod.suanshu.misc.parallel.IterationBody)">
			<summary>Calls
 <para></para>#forEach(java.lang.Iterable, com.numericalmethod.suanshu.misc.parallel.IterationBody) forEach
 only if <c>conditionToParallelize</c> is <c>true</c>.
 Otherwise, the loop body will be executed in a single thread.</summary>
			<param name="conditionToParallelize">the condition to parallelize the &quot;foreach&quot; execution</param>
			<param name="iterable">the <para></para>Iterable collection</param>
			<param name="body">the loop body</param>
			<exception cref="T:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException">if one or more threads throws an exception</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.parallel.Mutex">
			<summary>Provides mutual exclusive execution of a <c>Runnable</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.Mutex.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.Mutex.execute(java.lang.Runnable)">
			<summary>The <c>runnable</c> is executed under synchronization of this
 <c>Mutex</c> instance.</summary>
			<param name="runnable"></param>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException">
			<summary>This exception is thrown when any of the parallel tasks throws an exception during execution.
 This exception contains all the exceptions caught during execution.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException.#ctor(java.util.List,java.util.List)">
			<summary>Construct an exception with the (partial) results and all exceptions encountered during
 execution.</summary>
			<param name="results">the results obtained so far</param>
			<param name="exceptions">all exceptions encountered during execution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException.getResults">
			<summary>Get the results obtained so far.</summary>
			<returns>the results</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException.getExceptions">
			<summary>Get all exceptions encountered during execution.</summary>
			<returns>all exceptions encountered during execution</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.MultipleExecutionException.getMessage">
			<summary>
 Gather the stack traces for the thrown exceptions.</summary>
			<returns>the detailed messages of all the thrown exceptions</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.parallel.LoopBody">
			<summary>The implementation of this interface contains the code inside a for-loop
 construct.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.LoopBody.run(System.Int32)">
			<summary>This method contains the code inside the for-loop, as in a native
 for-loop like this:
 <code><c>
 for (int i = start; i &lt; end; i += increment) {
     // loop body
 }
 </c></code></summary>
			<param name="i">the current loop count</param>
			<exception cref="T:java.lang.Exception">any exception thrown during execution</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.misc.parallel.IterationBody">
			<summary>This interface defines the code snippet to be run in parallel.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.misc.parallel.IterationBody.run(System.Object)">
			<summary>Execute a (parallel) task.</summary>
			<param name="item">the task input</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.big.BigIntegerUtils">
			<summary>These are the utility functions to manipulate <para></para>BigInteger.<para> See also: </para><a href="http://java.sun.com/j2se/1.4.2/docs/api/java/math/biginteger.html">Class BigInteger</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigIntegerUtils.factorial(System.Int32)">
			<summary>Compute the <i>n</i> factorial.<para> See also: </para><a href="http://en.wikipedia.org/wiki/factorial">Wikipedia: Factorial</a></summary>
			<param name="n">an integer</param>
			<returns><c>n!</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigIntegerUtils.combination(System.Int32,System.Int32)">
			<summary>Compute the combination function or the binomial coefficient.
 It is the number of <i>k</i>-combinations (each of size <i>k</i>) from a set <i>k</i> with <i>n</i> elements (size <i>n</i>).<para> See also: </para><a href="http://en.wikipedia.org/wiki/combination">Wikipedia: Combination</a></summary>
			<param name="n">the size of the full set</param>
			<param name="k">the size of a combination</param>
			<returns><c>n! / (n-k)! / k!</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigIntegerUtils.permutation(System.Int32,System.Int32)">
			<summary>Compute the permutation function.
 It is the number of <i>k</i>-permutations (each of size <i>k</i>) from a set <i>k</i> with <i>n</i> elements (size <i>n</i>).<para> See also: </para><a href="http://en.wikipedia.org/wiki/permutations">Wikipedia: Permutation</a></summary>
			<param name="n">the size of the full set</param>
			<param name="k">the size of a permutation</param>
			<returns><c>n! / (n-k)!</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.big.BigDecimalUtils">
			<summary>These are the utility functions to manipulate <para></para>BigDecimal.<para> See also: </para><a href="http://java.sun.com/j2se/1.4.2/docs/api/java/math/bigdecimalutils.html">Class BigDecimal</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.big.BigDecimalUtils.PI">
			<summary>the value of PI<para> See also: </para><a href="http://www.joyofpi.com/pi.html">Joy of PI</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.compare(java.math.BigDecimal,java.math.BigDecimal,System.Int32)">
			<summary>Compare two <c>BigDecimal</c>s up to a precision.
 In other words, if the absolute difference between the two numbers falls below a threshold, they are considered equal.</summary>
			<param name="n1">a <c>BigDecimal</c></param>
			<param name="n2">a <c>BigDecimal</c></param>
			<param name="p">the threshold is <i>1e-p</i></param>
			<returns>-1, 0, or 1 when <c>n1</c> is numerically less than, equal to, or greater than <c>n2</c>, respectively</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.equals(java.math.BigDecimal,java.math.BigDecimal,System.Int32)">
			<summary>Check if two <c>BigDecimal</c>s are equal up to a precision.</summary>
			<param name="n1">a <c>BigDecimal</c></param>
			<param name="n2">a <c>BigDecimal</c></param>
			<param name="precision">the threshold is <i>1e-p</i></param>
			<returns><c>true</c> if the numbers are equal up to a precision</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.sum(java.math.BigDecimal[])">
			<summary>Sum up the <c>BigDecimal</c> numbers.</summary>
			<param name="big"><c>BigDecimal</c> numbers</param>
			<returns>the sum</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.sum(System.Double[])">
			<summary>Sum up big numbers.</summary>
			<param name="big">numbers</param>
			<returns>the sum</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.getWhole(java.math.BigDecimal)">
			<summary>Get the integral part of a number (discarding the fractional part).</summary>
			<param name="num">a <c>BigDecimal</c></param>
			<returns>the integral part of the number</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.getFractional(java.math.BigDecimal)">
			<summary>Get the fractional part of a number.
 This is the same as the number subtracting the whole part.
 For a -ve. number, the fractional part is also -ve.
 For example, for <i>-3.1415</i>, the whole is <i>-3</i> and the fractional part is <i>-0.1415</i>.</summary>
			<param name="num">a <c>BigDecimal</c></param>
			<returns>the fractional part of the number</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.pow(java.math.BigDecimal,java.math.BigDecimal)">
			<summary>Compute <i>a</i> to the power of <i>b</i>.</summary>
			<param name="a">a base</param>
			<param name="b">an exponent</param>
			<returns><i>a<sup>b</sup></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.pow(java.math.BigDecimal,java.math.BigDecimal,System.Int32)">
			<summary>Compute <i>a</i> to the power of <i>b</i>.</summary>
			<param name="a">a base</param>
			<param name="b">an exponent</param>
			<param name="scale">a precision parameter as in <para></para>BigDecimal</param>
			<returns><i>a<sup>b</sup></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.pow(java.math.BigDecimal,System.Int32)">
			<summary>Compute <i>a</i> to the power of <i>n</i>, where <i>n</i> is an integer.</summary>
			<param name="a">a base</param>
			<param name="n">an integer exponent</param>
			<returns><i>a<sup>n</sup></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.pow(java.math.BigDecimal,System.Int32,System.Int32)">
			<summary>Compute <i>a</i> to the power of <i>n</i>, where <i>n</i> is an integer.
 This is simply a wrapper around <para></para>BigDecimal#pow(int) but handles also negative exponents.
 Use <para></para>BigDecimal#pow(int) for arbitrary precision if the exponent is positive.</summary>
			<param name="a">a base</param>
			<param name="n">an exponent</param>
			<param name="scale">a precision parameter as in <para></para>BigDecimal</param>
			<returns><i>a<sup>n</sup></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.log(java.math.BigDecimal)">
			<summary>Compute <i>log(x)</i>.
 The base is <i>e</i>, hence the natural log.<para> See also: </para><a href="http://en.wikipedia.org/wiki/natural_logarithm">Wikipedia: Natural logarithm</a></summary>
			<param name="x">a number</param>
			<returns><i>log(x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.log(java.math.BigDecimal,System.Int32)">
			<summary>Compute <i>log(x)</i> up to a scale.
 The base is <i>e</i>, hence the natural log.<para> See also: </para><a href="http://en.wikipedia.org/wiki/natural_logarithm">Wikipedia: Natural logarithm</a></summary>
			<param name="x">a number</param>
			<param name="scale">a precision parameter as in <para></para>BigDecimal</param>
			<returns><i>log(x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.exp(System.Double)">
			<summary>Compute <i>e<sup>x</sup></i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/exponential_function">Wikipedia: Exponential function</a></summary>
			<param name="x">the exponent</param>
			<returns><i>e<sup>x</sup></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.exp(System.Double,System.Int32)">
			<summary>Compute <i>e<sup>x</sup></i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/exponential_function">Wikipedia: Exponential function</a></summary>
			<param name="x">the exponent</param>
			<param name="scale">a precision parameter as in <para></para>BigDecimal</param>
			<returns><i>e<sup>x</sup></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.exp(java.math.BigDecimal)">
			<summary>Compute <i>e<sup>x</sup></i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/exponential_function">Wikipedia: Exponential function</a></summary>
			<param name="x">the exponent</param>
			<returns><i>e<sup>x</sup></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.big.BigDecimalUtils.exp(java.math.BigDecimal,System.Int32)">
			<summary>Compute <i>e<sup>x</sup></i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/exponential_function">Wikipedia: Exponential function</a></summary>
			<param name="x">the exponent</param>
			<param name="scale">a precision parameter as in <para></para>BigDecimal</param>
			<returns><i>e<sup>x</sup></i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.complex.ElementaryFunction">
			<summary>This class contains some elementary functions for complex number, <para></para>Complex.
 The references for the formulae can be found in the following.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/square_root#square_roots_of_negative_and_complex_numbers">Wikipedia: Square roots of negative and complex numbers</a></item>
 <item><a href="http://en.wikipedia.org/wiki/logarithm">Wikipedia: Logarithm</a></item>
 <item><a href="http://en.wikipedia.org/wiki/exponentiation">Wikipedia: Exponentiation</a></item>
 <item><a href="http://en.wikipedia.org/wiki/trigonometric_function">Wikipedia: Trigonometric functions</a></item>
 <item><a href="http://en.wikipedia.org/wiki/hyperbolic_function">Wikipedia: Hyperbolic functions</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.sqrt(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Square root of a complex number.<para> See also: </para><a href="http://en.wikipedia.org/wiki/square_root#square_roots_of_negative_and_complex_numbers">Wikipedia: Square roots of negative and complex numbers</a></summary>
			<param name="z">a complex number</param>
			<returns>the square root of the number</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.log(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Natural logarithm of a complex number.
 <blockquote><i>
 ln(a + bi) = ln(r exp(i &#952;)) = ln(r) + i &#952;
 </i></blockquote></summary>
			<param name="z">a complex number</param>
			<returns><i>ln(z)</i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.exp(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Exponential of a complex number.
 <blockquote><code><i>
 exp(a + bi) = exp(a) * [cos(b) + i sin(b)]
             = exp(b)cos(b) + i exp(a)sin(b)
 </i></code></blockquote></summary>
			<param name="z">a complex number</param>
			<returns><i>e<sup>z</sup></i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.pow(com.numericalmethod.suanshu.number.complex.Complex,com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>z<sub>1</sub> to the power z<sub>2</sub>.
 <blockquote><i>
 (r exp(i &#952;)) ^ (a + bi)
 = r^a exp(-b &#952;) (cos(b ln(r) + a &#952;) + i sin(b ln(r) + a &#952;))
 </i></blockquote></summary>
			<param name="z1">a complex number</param>
			<param name="z2">a complex number</param>
			<returns><i>z1<sup>z2</sup></i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.sin(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Sine of a complex number.
 <blockquote><i>
 sin(a + bi) = sin(a)cosh(b) + i cos(a)sinh(b)
 </i></blockquote></summary>
			<param name="z">a complex number</param>
			<returns><i>sin(z)</i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.cos(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Cosine of a complex number.
 <blockquote><i>
 cos(a + bi) = cos(a)cosh(b) - i sin(a)sinh(b)
 </i></blockquote></summary>
			<param name="z">a complex number</param>
			<returns><i>cos(z)</i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.tan(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Tangent of a complex number.
 <blockquote><code><i>
 tan(a + bi) = [sin(2a) + i sinh(2a)] / [cos(2a) + cosh(2b)]
 </i></code></blockquote></summary>
			<param name="z">a complex number</param>
			<returns><i>tan(z)</i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.asin(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Inverse of sine.
 <blockquote><i>
 arcsin(z) = -i ln(iz + sqrt(1 - z<sup>2</sup>))
 </i></blockquote><para> See also: </para><a href="http://mathworld.wolfram.com/inversesine.html">Inverse Sine from Wolfram MathWorld</a></summary>
			<param name="z">a complex number</param>
			<returns><i>sin<sup>-1</sup>(z)</i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.acos(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Inverse of cosine.
 <blockquote><i>
 arccos(z) = pi / 2 + i ln(iz + sqrt(1 - z<sup>2</sup>))
 = pi / 2 - arcsin(z)
 </i></blockquote><para> See also: </para><a href="http://mathworld.wolfram.com/inversecosine.html">Inverse Cosine from Wolfram MathWorld</a></summary>
			<param name="z">a complex number</param>
			<returns><i>cos<sup>-1</sup>(z)</i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.atan(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Inverse of tangent.
 <blockquote><i>
 arctan(z) = i * ( ln ( 1 - iz ) - ln ( 1 + iz) ) / 2
 </i></blockquote><para> See also: </para><a href="http://mathworld.wolfram.com/inversetangent.html">Inverse Tangent from Wolfram MathWorld</a></summary>
			<param name="z">a complex number</param>
			<returns><i>tan<sup>-1</sup>(z)</i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.sinh(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Hyperbolic sine of a complex number.
 <blockquote><i>
 sinh(a + bi) = sinh(a)cos(b) + i cosh(a)sin(b)
 </i></blockquote></summary>
			<param name="z">a complex number</param>
			<returns><i>sinh(z)</i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.cosh(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Hyperbolic cosine of a complex number.
 <blockquote><i>
 cosh(a + bi) = cosh(a)cos(b) + i sinh(a)sin(b)
 </i></blockquote></summary>
			<param name="z">a complex number</param>
			<returns><i>cosh(z)</i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.ElementaryFunction.tanh(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Hyperbolic tangent of a complex number.
 <blockquote><i>
 tanh(a + bi) = [sinh(2a) + i sin(2b)] / [cosh(2a) + cos(2b)]
 </i></blockquote></summary>
			<param name="z">a complex number</param>
			<returns><i>tanh(z)</i></returns>
			<exception cref="T:java.lang.IllegalArgumentException">if <c>z</c> is a <c>NaN</c> or <i>&#8734;</i></exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.complex.Complex">
			<summary>A complex number is a number consisting of a real number part and an imaginary number part.
 It is normally written in the form <i>a + bi</i>, where <i>a</i> and <i>b</i> are real numbers,
 and <i>i</i> is the square root of minus one.
 <para/>
 This class is immutable.<para> See also: </para><a href="http://en.wikipedia.org/wiki/complex_number">Wikipedia: Complex number</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.complex.Complex.I">
			<summary>a number representing <i>0.0 + 1.0i</i>, the square root of <i>-1</i></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.complex.Complex.ZERO">
			<summary>a number representing <i>0.0 + 0.0i</i></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.complex.Complex.ONE">
			<summary>a number representing <i>1.0 + 0.0i</i></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.complex.Complex.POSITIVE_INFINITY">
			<summary>a number representing <i>+&#8734; + &#8734;i</i></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.complex.Complex.NEGATIVE_INFINITY">
			<summary>a number representing <i>-&#8734; + -&#8734;i</i></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.complex.Complex.NaN">
			<summary>a number representing the complex Not-a-Number (<c>NaN</c>)</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.#ctor(System.Double,System.Double)">
			<summary>Construct a complex number from the real and imaginary parts.</summary>
			<param name="a">the real part</param>
			<param name="b">the imaginary part</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.#ctor(System.Double)">
			<summary>Construct a complex number from a real number.</summary>
			<param name="a">a real number</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.fromPolar(System.Double,System.Double)">
			<summary>Factory method to construct a complex number from the polar form: <i>(r, &#952;)</i>.</summary>
			<param name="r">a radius</param>
			<param name="theta">an angle</param>
			<returns>a complex number equivalent to the polar form <i>(r, &#952;)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.real">
			<summary>Get the real part of this complex number.</summary>
			<returns>the real part</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.imaginary">
			<summary>Get the imaginary part of this complex number.</summary>
			<returns>the imaginary part</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.isReal(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Check if this complex number is a real number;
 i.e., the imaginary part is 0.</summary>
			<param name="z">a complex number</param>
			<returns><c>true</c> if the imaginary part is 0</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.isNaN(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Check if a complex number is an <c>NaN</c>;
 i.e., either the real or the imaginary part is an <c>NaN</c>.</summary>
			<param name="z">a complex number</param>
			<returns><c>true</c> if either the real or the imaginary part is a <c>NaN</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.isInfinite(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Check if a complex number is an infinity;
 i.e., either the real or the imaginary part is infinite, c.f., <para></para>Double#isInfinite(),
 <em>and</em> the number is not a <c>NaN</c>.</summary>
			<param name="z">a complex number</param>
			<returns><c>true</c> if either the real or the imaginary part is infinite</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.modulus">
			<summary>Get the modulus.
 The modulus is the square root of itself multiplied by its conjugate, namely
 <blockquote><i>
 this.modulus() * this.modulus() = this.multiply(this.conjugate())
 </i></blockquote><para> See also: </para>java.lang.Math#hypot(double, double)</summary>
			<returns>the modulus</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.arg">
			<summary>Get the <i>&#952;</i> of the complex number in polar representation.</summary>
			<returns>&#952; as in the polar form <i>(r, &#952;)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.toDouble">
			<summary>Cast the complex number to a <para></para>Double if it is a real number.</summary>
			<returns>the real part if this complex number is a real number</returns>
			<exception cref="T:java.lang.IllegalArgumentException">if this complex number is not a real number</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.conjugate">
			<summary>Get the conjugate of the complex number, namely, <i>(a - bi)</i>.</summary>
			<returns>the conjugate</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.intValue">
			<summary><para><c>DEPRECATED:</c> Invalid operation.</para>
</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.longValue">
			<summary><para><c>DEPRECATED:</c> Invalid operation.</para>
</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.floatValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.doubleValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.add(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.minus(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.inverse">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.divide(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Compute the quotient of this complex number divided by another complex number.
 \[
 \frac{a + bi}{c + di} = \frac{ac + bd + (bc - ad)i}{c^2 + d^2}
 \]
 <para/>
 ABSTRACT
 <blockquote>
 We develop a simple method for scaling to avoid overflow and harmful underflow in complex
 division.
 The method guarantees that no overflow will occur unless at least one component of the
 quotient must overflow,
 otherwise the normwise error in the computed result is at most a few units in the last place.
 Moreover, the scaling requires only four floating point multiplications
 and a small amount of integer arithmetic to compute the scale factor.
 Thus, on many modern CPUs, our method is both safer and faster than Smith&apos;s widely used
 algorithm.
 </blockquote><para> See also: </para>&quot;Douglas M. Priest Sun Microsystems, Menlo Park, CA, &quot;Efficient scaling for complex
 division,&quot; ACM Transactions on Mathematical Software (TOMS) archive, Volume 30, Issue 4
 (December 2004) Pages: 389 - 401.&quot;</summary>
			<returns><i>this / that</i></returns>
			<exception cref="T:java.lang.ArithmeticException">if division by zero happens</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.multiply(com.numericalmethod.suanshu.number.complex.Complex)">
			<summary>Compute the product of this complex number and that complex number.
 <blockquote><i>
 (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 </i></blockquote>
 This implementation is more efficient by doing 1 less multiplication:
 <blockquote><i>
 (a + bi)(c + di) = (ac - bd) + ((a + b)(c + d) - ac - bd)i
 </i></blockquote></summary>
			<returns><i>this * that</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.ZERO">
			<summary>Get zero - the number representing <i>0.0 + 0.0i</i>.</summary>
			<returns>ZERO</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.ONE">
			<summary>Get one - the number representing <i>1.0 + 0.0i</i>.</summary>
			<returns>ONE</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.compare(java.lang.Number,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.complex.Complex.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.doublearray.SimpleDoubleArrayOperation">
			<summary>This is a simple, single-threaded implementation of the array math operations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.SimpleDoubleArrayOperation.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.SimpleDoubleArrayOperation.add(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.SimpleDoubleArrayOperation.minus(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.SimpleDoubleArrayOperation.multiply(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.SimpleDoubleArrayOperation.divide(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.SimpleDoubleArrayOperation.scaled(System.Double[],System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.doublearray.ParallelDoubleArrayOperation">
			<summary>This is a multi-threaded implementation of the array math operations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.ParallelDoubleArrayOperation.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.ParallelDoubleArrayOperation.add(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.ParallelDoubleArrayOperation.minus(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.ParallelDoubleArrayOperation.multiply(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.ParallelDoubleArrayOperation.divide(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.ParallelDoubleArrayOperation.scaled(System.Double[],System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.doublearray.DoubleArrayOperation">
			<summary>It is possible to provide different implementations for different platforms, hardware, etc.
 For example, there are single vs. multiple threads, single vs. multiple cores, single vs.
 multiple machines, GPU or not, etc.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayOperation.add(System.Double[],System.Double[])">
			<summary>Add two <c>double</c> arrays, entry-by-entry.</summary>
			<param name="arr1">an array <c>double[]</c></param>
			<param name="arr2">an array <c>double[]</c></param>
			<returns>the sum of the two arrays</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayOperation.minus(System.Double[],System.Double[])">
			<summary>Subtract one <c>double</c> array from another, entry-by-entry.</summary>
			<param name="arr1">an array <c>double[]</c></param>
			<param name="arr2">an array <c>double[]</c></param>
			<returns>the difference of the two arrays</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayOperation.multiply(System.Double[],System.Double[])">
			<summary>Multiply one <c>double</c> array to another, entry-by-entry.</summary>
			<param name="arr1">an array <c>double[]</c></param>
			<param name="arr2">an array <c>double[]</c></param>
			<returns>the product of the two arrays</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayOperation.divide(System.Double[],System.Double[])">
			<summary>Divide one <c>double</c> array by another, entry-by-entry.</summary>
			<param name="arr1">an array <c>double[]</c></param>
			<param name="arr2">an array <c>double[]</c></param>
			<returns>the quotient array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayOperation.scaled(System.Double[],System.Double)">
			<summary>Scale each entry of a <c>double</c> array.</summary>
			<param name="arr">an array <c>double[]</c></param>
			<param name="c">a scaling constant</param>
			<returns>the scaled array</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath">
			<summary>These are the math functions that operate on <c>double[]</c>.
 In other words, this provide an array version of <para></para>java.lang.Math.

 <para/>
 These functions are static and stateless.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.min(System.Double[])">
			<summary>Get the minimum of the values.</summary>
			<param name="doubles">an array of <tt>double</tt>s</param>
			<returns>the smallest of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.max(System.Double[])">
			<summary>Get the maximum of the values.</summary>
			<param name="doubles">an array of <tt>double</tt>s</param>
			<returns>the biggest of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.max(System.Int32[])">
			<summary>Get the maximum of the values.</summary>
			<param name="integers">an array of <tt>int</tt>s</param>
			<returns>the biggest of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.abs(System.Double[])">
			<summary>Get the absolute values.</summary>
			<param name="doubles">an array of <tt>double</tt>s</param>
			<returns>the absolute values of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.sum(System.Double[])">
			<summary>Get the sum of the values.</summary>
			<param name="doubles">an array of <tt>double</tt>s</param>
			<returns>the sum of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.sum(System.Int32[])">
			<summary>Get the sum of the values.</summary>
			<param name="integers">an array of <tt>int</tt>s</param>
			<returns>the sum of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.sum2(System.Double[])">
			<summary>Get the sum of squares of the values.</summary>
			<param name="doubles">an array of <tt>double</tt>s</param>
			<returns>the sum of squares of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.log(System.Double[])">
			<summary>Get the logs of values.</summary>
			<param name="doubles">an array of <tt>double</tt>s</param>
			<returns>the logs of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.exp(System.Double[])">
			<summary>Get the exponentials of values.</summary>
			<param name="doubles">an array of <tt>double</tt>s</param>
			<returns>the exponentials of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.expm1(System.Double[])">
			<summary>Get the exponential-minus-one (<i>e<sup>x</sup> - 1</i>) of values.</summary>
			<param name="doubles">an array of <tt>double</tt>s</param>
			<returns>the exponential-minus-one of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.signum(System.Double[])">
			<summary>Get the signs of values.</summary>
			<param name="doubles">an array of <tt>double</tt>s</param>
			<returns>the signs of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.sqrt(System.Double[])">
			<summary>Get the square roots of values.</summary>
			<param name="doubles">an array of <tt>double</tt>s</param>
			<returns>the square roots of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.reciprocal(System.Double[])">
			<summary>Get the reciprocals of values.</summary>
			<param name="doubles">an array of <tt>double</tt>s</param>
			<returns>the reciprocals of the inputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.add(System.Double[],System.Double)">
			<summary>Add a double value to each element in an array.</summary>
			<param name="doubles">the double array</param>
			<param name="value">the value to be added</param>
			<returns>the double array with the value added</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.scale(System.Double[],System.Double)">
			<summary>Scale each element in an array by a multiplier.</summary>
			<param name="doubles">the double array</param>
			<param name="multiplier">the multiplier</param>
			<returns>the double array with the value scaled</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.DoubleArrayMath.pow(System.Double[],System.Double)">
			<summary>Raise each element in an array to the power of the given exponent.</summary>
			<param name="doubles">the double array</param>
			<param name="exponent">the exponent</param>
			<returns>the double array with the value power raised</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.doublearray.CompositeDoubleArrayOperation">
			<summary>It is desirable to have multiple implementations and switch between them for, e.g., performance
 reason.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.CompositeDoubleArrayOperation.#ctor(com.numericalmethod.suanshu.number.doublearray.CompositeDoubleArrayOperation.ImplementationChooser)">
			<summary>Construct a <c>CompositeDoubleArrayOperation</c> by supplying the multiplexing criterion and
 the multiple <c>DoubleArrayOperation</c>s.</summary>
			<param name="chooser">an <para></para>ImplementationChooser</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.CompositeDoubleArrayOperation.#ctor(System.Int32,com.numericalmethod.suanshu.number.doublearray.DoubleArrayOperation,com.numericalmethod.suanshu.number.doublearray.DoubleArrayOperation)">
			<summary>Construct a <c>CompositeDoubleArrayOperation</c> that chooses an implementation by array
 length.</summary>
			<param name="arrayLengthThreshold">the array length threshold to switch implementation</param>
			<param name="impl1">implementation 1</param>
			<param name="impl2">implementation 2</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.CompositeDoubleArrayOperation.add(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.CompositeDoubleArrayOperation.minus(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.CompositeDoubleArrayOperation.multiply(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.CompositeDoubleArrayOperation.divide(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.CompositeDoubleArrayOperation.scaled(System.Double[],System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.doublearray.CompositeDoubleArrayOperation.ImplementationChooser">
			<summary>Specify which implementation to use.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.doublearray.CompositeDoubleArrayOperation.ImplementationChooser.getOperation(System.Double[],System.Double[])">
			<summary>Get an implementation based on the inputs.</summary>
			<param name="arr1">an array <c>double[]</c></param>
			<param name="arr2">an array <c>double[]</c></param>
			<returns>an implementation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.ScientificNotation">
			<summary>Scientific notation expresses a number in this form
 <blockquote><i>
 x = a * 10<sup>b</sup>
 </i></blockquote>
 <i>a</i> is called the significand or mantissa, and <i>1 &#8804; |a| &lt; 10</i>.
 <i>b</i> is called the exponent and is an integer.
 <para/>
 Strictly speaking, <i>0</i> cannot be represented in this notation.
 This implementation, however, expresses it as <i>0 = 0 * 10<sup>0</sup></i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/scientific_notation"> Wikipedia: Scientific notation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.#ctor(System.Double,System.Int32)">
			<summary>Construct the scientific notation of a number in this form: <i>x = a * 10<sup>b</sup></i>.</summary>
			<param name="significand">the significand</param>
			<param name="exponent">the exponent</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.#ctor(java.math.BigDecimal,System.Int32)">
			<summary>Construct the scientific notation of a number in this form: <i>x = a * 10<sup>b</sup></i>.</summary>
			<param name="significand">the significand</param>
			<param name="exponent">the exponent</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.#ctor(java.math.BigDecimal)">
			<summary>Construct the scientific notation of a number.</summary>
			<param name="x">a number</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.#ctor(java.math.BigInteger)">
			<summary>Construct the scientific notation of an integer.</summary>
			<param name="x">an integer</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.#ctor(System.Int64)">
			<summary>Construct the scientific notation of a <c>long</c>.</summary>
			<param name="x">a <c>long</c> integer</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.#ctor(System.Double)">
			<summary>Construct the scientific notation of a <c>double</c>.</summary>
			<param name="x">a <c>double</c> number</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.significand">
			<summary>Get the significand.</summary>
			<returns>the significand</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.exponent">
			<summary>Get the exponent.</summary>
			<returns>the exponent</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.bigDecimalValue">
			<summary>Convert the number to <para></para>BigDecimal.
 There is no rounding.</summary>
			<returns>the <c>BigDecimal</c> representation of the number</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.intValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.longValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.floatValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.ScientificNotation.doubleValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.Real">
			<summary>A real number is an arbitrary precision number.
 This implementation is simply a wrapper around <para></para>java.math.BigDecimal and implements the <para></para>Field interface.
 <para/>
 This class is immutable.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.Real.ZERO">
			<summary>a number representing <i>0</i></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.Real.ONE">
			<summary>a number representing <i>1</i></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.#ctor(System.Double)">
			<summary>Construct a <c>Real</c> from a <c>double</c>.</summary>
			<param name="value">a <c>double</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.#ctor(System.Int64)">
			<summary>Construct a <c>Real</c> from an integer.</summary>
			<param name="value">an integer</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.#ctor(java.math.BigDecimal)">
			<summary>Construct a <c>Real</c> from a <c>BigDecimal</c>.</summary>
			<param name="value">a <c>BigDecimal</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.#ctor(java.math.BigInteger)">
			<summary>Construct a <c>Real</c> from a <c>BigInteger</c>.</summary>
			<param name="value">a <c>BigInteger</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.#ctor(System.String)">
			<summary>Construct a <c>Real</c> from a <c>String</c>.</summary>
			<param name="value">a <c>String</c> representation of a number</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.toBigDecimal">
			<summary>Convert this number to a <c>BigDecimal</c>.</summary>
			<returns>the value in <c>BigDecimal</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.intValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.longValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.floatValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.doubleValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.add(com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.minus(com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.opposite">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.multiply(com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.divide(com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.divide(com.numericalmethod.suanshu.number.Real,System.Int32)">
			<summary><i>/ : R &#215; R &#8594; R</i>
 <para/>
 Divide this number by another one.
 Rounding is performed with the specified <c>scale</c>.</summary>
			<param name="that">another non-zero real number</param>
			<param name="scale">rounding scale as in <para></para>BigDecimal</param>
			<returns><i>this/that</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.inverse">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.ZERO">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.ONE">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.compareTo(com.numericalmethod.suanshu.number.Real)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.Real.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.NumberUtils">
			<summary>These are the utility functions to manipulate <para></para>Numbers.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.NumberUtils.equal(java.lang.Number,java.lang.Number,System.Double)">
			<summary>Check the equality of two <para></para>Numbers, up to a precision.</summary>
			<param name="num1">a number</param>
			<param name="num2">a number</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if the numbers are close enough, <c>false</c> otherwise</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.NumberUtils.compare(java.lang.Number,java.lang.Number,System.Double)">
			<summary>Compare two numbers. The two numbers must be of (possibly different) subclasses of
 <para></para>Number.
 <list type="bullet">
 <item>If both can be cast to <c>double</c>, they are compared as <c>double</c>s; e.g., 2 vs.
 new Double(3);</item>
 <item>If one is a <c>double</c> but the other is not, the <c>double</c> is cast into the same
 field as the other number for comparison; e.g., 4 vs. 3 + 0i;</item>
 <item>If neither is a <c>double</c>, the two numbers must be of the same class for comparison;
 e.g., both are <para></para>Complex.</item>
 </list></summary>
			<param name="num1">a number</param>
			<param name="num2">a number</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0;
                e.g., <i>1e-9</i></param>
			<returns>0 if <c>num1</c> is close enough to <c>num2</c>; 1 if <c>num1 &amp;gt; num2</c>; -1 if
         <c>num1 &amp;lt; num2</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.NumberUtils.isReal(java.lang.Number)">
			<summary>Check if a number is a real number.
 <para/>
 <em>
 TODO: this function needs to be extended or modified when a new <para></para>Number subclass is
 implemented.
 </em></summary>
			<param name="number">a number</param>
			<returns><c>true</c> if the number is real, i.e., in R<sup>n</sup></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.NumberUtils.parse(System.String)">
			<summary>Construct a number from a String. For example, some valid strings are:
 <blockquote><code>
 &quot;2&quot;
 &quot;2.&quot;
 &quot;3 + 5i&quot;
 &quot;1.23 - 4.56i&quot;
 &quot;-1.23 - 4.56i&quot;
 &quot;-1.23 - 4.56e-7i&quot;
 &quot;-1.23 - 4.56+e7i&quot;
 &quot;i&quot;
 </code></blockquote>
 Note: having spaces in the real part between sign and number is illegal, e.g.,
 <blockquote><code>
 - 1.23+4.56i
 + 1.23+4.56i
 </code></blockquote>
 <em>
 TODO: this function needs to be extended or modified when a new <para></para>Number subclass is
 implemented.
 </em></summary>
			<param name="str">a number in <para></para>String</param>
			<returns>a number of type subclass-ing from <para></para>Number, such as
         <para></para>Double, <para></para>Complex</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.NumberUtils.parseArray(System.String[])">
			<summary>Convert an array of numbers in <para></para>String to an array of numbers in <para></para>Number.</summary>
			<param name="strs">an array of numbers in <para></para>String</param>
			<returns>an array of <para></para>Numbers</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.NumberUtils.Comparable">
			<summary>We need a precision parameter to determine whether two numbers are close enough to be treated
 as equal.
 All subclasses of <para></para>Number must implement this interface to work with
 <para></para>NumberUtils#compare(java.lang.Number, java.lang.Number, double).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.NumberUtils.Comparable.compare(java.lang.Number,System.Double)">
			<summary>Compare <c>this</c> and <c>that</c> numbers up to a precision.</summary>
			<param name="that">a <para></para>Number.
                As a number can be represented in multiple ways, e.g., <i>0 = 0 + 0i</i>, the
                implementation may need to check <para></para>Object type.</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered
                0</param>
			<returns>0 if both numbers are close enough; +1 if <c>this</c> is bigger; -1 if
         <c>that</c> is bigger</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.DoubleUtils">
			<summary>These are the utility functions to manipulate <c>double</c> and <c>int</c>.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.DoubleUtils.CSV_SEPARATOR">
			<summary>The default separator for CSV file parsing.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.compare(System.Double,System.Double,System.Double)">
			<summary>Compares two <c>double</c>s up to a precision.
 This implementation is preferred to <para></para>Double#compare(double, double) because
 our implementation returns 0 (equality), i.e.,
 <c>DoubleUtils.compare(0.0, -0.0)</c> returns <c>0</c>;
 <c>Double.compare(0.0, -0.0)</c> returns <c>1</c>.</summary>
			<param name="d1">a <c>double</c></param>
			<param name="d2">a <c>double</c></param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns>0 if <c>d1</c> is close enough to <c>d2</c>; 1 if <i>d1 &gt; d2</i>; -1 if <i>d1
         &#8804; d2</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.isZero(System.Double,System.Double)">
			<summary>Check if <c>d</c> is zero.</summary>
			<param name="d">a <c>double</c></param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <c>d</c> is close enough to 0</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.isPositive(System.Double,System.Double)">
			<summary>Check if <c>d</c> is positive.</summary>
			<param name="d">a <c>double</c></param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <c>d</c> is bigger than 0 by <c>epsilon</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.isNegative(System.Double,System.Double)">
			<summary>Check if <c>d</c> is negative.</summary>
			<param name="d">a <c>double</c></param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <c>d</c> is smaller than 0 by <c>epsilon</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.equal(System.Double,System.Double,System.Double)">
			<summary>Check if two <c>double</c>s are close enough, hence equal.</summary>
			<param name="d1">a <c>double</c></param>
			<param name="d2">a <c>double</c></param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if <c>d1</c> is close enough to <c>d2</c>, <c>false</c> otherwise</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.equal(System.Double[],System.Double[],System.Double)">
			<summary>Check if two <c>double</c> arrays are close enough, hence equal, entry-by-entry.</summary>
			<param name="d1">a <c>double[]</c></param>
			<param name="d2">a <c>double[]</c></param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if all entries in <c>d1</c> are close enough to all entries in
         <c>d2</c>, <c>false</c> otherwise</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.equal(System.Double[][],System.Double[][],System.Double)">
			<summary>Check if two 2D arrays, <c>double[][]</c>, are close enough, hence equal, entry-by-entry.</summary>
			<param name="d1">a <c>double[][]</c></param>
			<param name="d2">a <c>double[][]</c></param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if all entries in <c>d1</c> are close enough to all entries in
         <c>d2</c>, <c>false</c> otherwise</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.equal(System.Int32[],System.Int32[])">
			<summary>Check if two <c>int</c> arrays, <c>int[]</c>, are equal, entry-by-entry.</summary>
			<param name="d1">an <c>int</c> array</param>
			<param name="d2">an <c>int</c> array</param>
			<returns><c>true</c> if all entries in <c>d1</c> are the same as all entries in
         <c>d2</c>, <c>false</c> otherwise</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.maxIndex(System.Boolean,System.Int32,System.Int32,System.Double[])">
			<summary>Get the index of the maximum of the values, skipping <para></para>Double#NaN.</summary>
			<param name="moveOnTies"><c>true</c> if prefer the later one on ties</param>
			<param name="from">the initial index of the range to be considered</param>
			<param name="to">1 after the last index of the range to be considered</param>
			<param name="doubles">an array, <c>double[]</c></param>
			<returns>the index of the biggest number</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.maxIndex(System.Double[])">
			<summary>Get the index of the maximum of the values, skipping <para></para>Double#NaN.</summary>
			<param name="doubles">an array, <c>double[]</c></param>
			<returns>the index of the biggest number</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.minIndex(System.Boolean,System.Int32,System.Int32,System.Double[])">
			<summary>Get the index of the minimum of the values, skipping <para></para>Double#NaN.</summary>
			<param name="moveOnTies"><c>true</c> if prefer the later one on ties</param>
			<param name="from">the initial index of the range to be considered</param>
			<param name="to">1 after the last index of the range to be considered</param>
			<param name="doubles">an array, <c>double[]</c></param>
			<returns>the index of the smallest number</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.minIndex(System.Double[])">
			<summary>Get the index of the minimum of the values, skipping <para></para>Double#NaN.</summary>
			<param name="doubles">an array, <c>double[]</c></param>
			<returns>the index of the smallest number</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.foreach(System.Double[],com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Apply a function <i>f</i> to each element in an array.</summary>
			<param name="doubles">an array, <c>double[]</c></param>
			<param name="f">a function to be applied to each element</param>
			<returns>the function outputs</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.concat(System.Double[][])">
			<summary>Concatenate an array of arrays into one array.
 The concatenated array is not sorted.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<returns>the concatenated array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.reverse(System.Double[])">
			<summary>Reverse a <c>double</c> array.</summary>
			<param name="arr">an array, <c>double[]</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.reverseCopy(System.Double[])">
			<summary>Get a reversed copy of a <c>double</c> array.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<returns>the reversed copy</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.reverse(System.Int32[])">
			<summary>Reverse an <c>int</c> array.</summary>
			<param name="arr">an array, <c>int[]</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.reverseCopy(System.Int32[])">
			<summary>Get a reversed copy of a <c>int</c> array.</summary>
			<param name="arr">an array, <c>int[]</c></param>
			<returns>the reversed copy</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.leftShiftCopy(System.Double[])">
			<summary>Get a left shifted (by 1 cell) copy of an array. The rightmost element is filled by a 0.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<returns>a left shifted array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.leftShiftCopy(System.Double[],System.Int32)">
			<summary>Get a left shifted (by <c>k</c> cells) copy of an array. The rightmost elements are filled
 by zeros.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<param name="k">the number of cells to be shifted</param>
			<returns>a left shifted array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.leftShift(System.Double[])">
			<summary>Perform a in-memory left-shift (by 1 cell} to an array. The leftmost element is filled by a
 zero. No temporary array will be created during the operation.</summary>
			<param name="arr">an array, <c>double[]</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.leftShift(System.Double[],System.Int32)">
			<summary>Perform a in-memory right-shift (by <c>k</c> cells} to an array. The leftmost elements are
 filled by zeros. No temporary array will be created during the operation.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<param name="k">the number of cells to be shifted</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.rightShiftCopy(System.Double[])">
			<summary>Get a right shifted (by 1 cell) copy of an array. The leftmost element is filled by a 0.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<returns>a right shifted array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.rightShiftCopy(System.Double[],System.Int32)">
			<summary>Get a right shifted (by <c>k</c> cells) copy of an array. The leftmost elements are filled
 by zeros.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<param name="k">the number of cells to be shifted</param>
			<returns>a right shifted array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.rightShift(System.Double[])">
			<summary>Perform a in-memory right-shift (by 1 cell} to an array. The leftmost element is filled by a
 zero. No temporary array will be created during the operation.</summary>
			<param name="arr">an array, <c>double[]</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.rightShift(System.Double[],System.Int32)">
			<summary>Perform a in-memory right-shift (by <c>k</c> cells} to an array. The leftmost elements are
 filled by zeros. No temporary array will be created during the operation.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<param name="k">the number of cells to be shifted</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.shellsort(System.Double[])">
			<summary>Sort an array using Shell sort.<para> See also: </para><a href="http://en.wikipedia.org/wiki/shell_sort">Wikipedia: Shell sort</a></summary>
			<param name="arr">an array, <c>double[]</c></param>
			<returns>the order of the original array; <em>side effect: the input <c>arr</c> is sorted in
         ascending order</em></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.isAllZeros(System.Double[],System.Double)">
			<summary>Check if a <c>double</c> array contains only 0s, entry-by-entry.</summary>
			<param name="d">a <c>double</c> array</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if all entries in <c>d</c> are close enough to 0, <c>false</c>
         otherwise</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.hasZero(System.Double[],System.Double)">
			<summary>Check if a <c>double</c> array has any 0.</summary>
			<param name="d">a <c>double</c> array</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if an entry in <c>d</c> are close enough to 0, <c>false</c> otherwise</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.isNumber(System.Double)">
			<summary>Check if a <c>double</c> is a number, i.e., it is not <c>&amp;infin;</c> or <c>NaN</c>.</summary>
			<param name="x">a <c>double</c></param>
			<returns><c>true</c> if <i>x</i> is not <c>&amp;infin;</c> or <c>NaN</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.isPow2(System.Int32)">
			<summary>Check if an integer is a power of 2.</summary>
			<param name="n">an integer</param>
			<returns><c>true</c> if <i>n</i> is a power of 2.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.hasDuplicate(System.Double[],System.Double)">
			<summary>Check if a <c>double</c> array contains any duplicates.</summary>
			<param name="arr">a <c>double</c> array</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if there is a duplicate</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.doubleArray2intArray(System.Double[])">
			<summary>Convert a <c>double</c> array to an <c>int</c> array, rounding down if necessary.</summary>
			<param name="arr">a <c>double</c> array</param>
			<returns>an <c>int</c> array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.intArray2doubleArray(System.Int32[])">
			<summary>Convert an <c>int</c> array to a <c>double</c> array.</summary>
			<param name="arr">an <c>int</c> array</param>
			<returns>a <c>double</c> array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.collection2DoubleArray(java.util.Collection)">
			<summary>Convert a collection of numbers to a <c>double</c> array.</summary>
			<param name="numbers">the collection of numbers</param>
			<returns>a <c>double</c> array containing the numbers in the input collection</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.doubleArray2List(System.Double[])">
			<summary>Convert a <c>double</c> array to a list.</summary>
			<param name="arr">a <c>double</c> array</param>
			<returns>a list of the numbers</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.collection2IntArray(java.util.Collection)">
			<summary>Convert a collection of <c>Integer</c>s to an <c>int</c> array.</summary>
			<param name="integers">a collection of integers</param>
			<returns>an <c>int</c> array of the integers</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.collection2LongArray(java.util.Collection)">
			<summary>Convert a collection of <c>Long</c>s to a <c>long</c> array.</summary>
			<param name="integers">a collection of long integers</param>
			<returns>a <c>long</c> array of the long integers</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.intArray2List(System.Int32[])">
			<summary>Convert an <c>int</c> array to a list.</summary>
			<param name="arr">an <c>int</c> array</param>
			<returns>a list of the integers</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.toPrimitive(java.lang.Double[])">
			<summary>Convert a <c>Double</c> array to a primitive <c>double</c> array.
 <c>Double.NaN</c> is used when an input <c>Double</c> instance is
 <c>null</c>.</summary>
			<param name="arr">a <c>Double</c> array</param>
			<returns>the primitive array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.round(System.Double,com.numericalmethod.suanshu.number.DoubleUtils.RoundingScheme)">
			<summary>Round up or down a number to an integer.</summary>
			<param name="d">a number</param>
			<param name="scheme">the rounding scheme</param>
			<returns>a near integer in <c>double</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.round(System.Double,System.Int32)">
			<summary>Round a number to the precision specified.</summary>
			<param name="d">a number</param>
			<param name="scale">the number of decimal points</param>
			<returns>an approximation of the number</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.absoluteError(System.Double,System.Double)">
			<summary>Compute the absolute difference between <c>x1</c> and <c>x0</c>. This function is
 symmetric.
 <blockquote><i>
 &#949; = | x1 - x0 |
 </i></blockquote></summary>
			<param name="x1"><c>x1</c></param>
			<param name="x0"><c>x0</c></param>
			<returns>the absolute error</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.relativeError(System.Double,System.Double)">
			<summary>Compute the relative error for <i>{x1, x0}</i>.
 This function is asymmetric.
 <blockquote><i>
 &#949; = | (x1 - x0) / x0 | = | x1/x0 - 1 |
 </i></blockquote></summary>
			<param name="x1"><c>x1</c></param>
			<param name="x0"><c>x0</c></param>
			<returns>the relative error</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.toString(System.Double[])">
			<summary>Print out numbers to a string.</summary>
			<param name="arr">a <c>double</c> array</param>
			<returns>a <c>String</c> representation of the numbers</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.toString(System.Double[][])">
			<summary>Print out a 2D array, <c>double[][]</c> to a string.</summary>
			<param name="arr">a <c>double[][]</c></param>
			<returns>the string representation of the array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.rep(System.Double,System.Int32)">
			<summary>Generates an array of <c>double</c>s of repeated values.</summary>
			<param name="value">the repeated value</param>
			<param name="times">the length of the array</param>
			<returns>an array of repetitions of value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.rep(System.Int32,System.Int32)">
			<summary>Generates an array of <c>int</c>s of repeated values.</summary>
			<param name="value">the repeated value</param>
			<param name="times">the length of the array</param>
			<returns>an array of repetitions of value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.seq(System.Int32,System.Double,System.Double)">
			<summary>Generate a sequence of <c>double</c> values with a given start value and a given constant
 increment.</summary>
			<param name="n">the total number of values</param>
			<param name="start">the first value</param>
			<param name="inc">the increment</param>
			<returns>the sequence</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.seq(System.Double,System.Double,System.Double)">
			<summary>Generates a sequence of <c>double</c>s from <c>from</c> up to <c>to</c> with increments
 <c>inc</c>.
 The last number in the sequence is smaller than or equal to <c>to</c> for positive
 <c>inc</c>.
 The last number in the sequence is bigger than or equal to <c>to</c> for negative
 <c>inc</c>.</summary>
			<param name="from">the first number in the sequence</param>
			<param name="to">the bound of the sequence</param>
			<param name="inc">the increment</param>
			<returns>a sequence of <c>double</c>s</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.seq(System.Double,System.Double,System.Int32)">
			<summary>Generate a sequence of <c>n</c> equi-spaced <c>double</c> values, from <c>start</c> to
 <c>end</c> (inclusive).</summary>
			<param name="from">the first value</param>
			<param name="to">the last value</param>
			<param name="n">the total number of values</param>
			<returns>an array of <c>n</c> equi-spaced values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.seq(System.Int32,System.Int32,System.Int32)">
			<summary>Generates a sequence of <c>int</c>s from <c>from</c> up to <c>to</c> with increments
 <c>inc</c>.
 The last number in the sequence is smaller than or equal to <c>to</c> for positive
 <c>inc</c>.
 The last number in the sequence is bigger than or equal to <c>to</c> for negative
 <c>inc</c>.</summary>
			<param name="from">the first number in the sequence</param>
			<param name="to">the bound of the sequence</param>
			<param name="inc">the increment</param>
			<returns>a sequence of <c>int</c>s</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.seq(System.Int32,System.Int32)">
			<summary>Generates a sequence of <c>int</c>s from <c>from</c> up to <c>to</c> with increments 1.
 That is, <i>[from, to]</i>, inclusively.</summary>
			<param name="from">the first number in the sequence</param>
			<param name="to">the bound of the sequence</param>
			<returns>a sequence of <c>int</c>s</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.diff(System.Double[],System.Int32,System.Int32)">
			<summary>Gets the lagged and iterated differences.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<param name="lag">an integer indicating which lag to use</param>
			<param name="order">an integer indicating the order of the difference.
              This is the number of times <c>diff</c> is applied to the data.
              E.g., <c>diff(x, 1, 2) = diff(diff(x, 1, 1), 1, 1)</c>.</param>
			<returns>the lagged and iterated differences</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.diff(System.Double[])">
			<summary>Gets the first differences of an array.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<returns>the first differences</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.diff(System.Double[][],System.Int32,System.Int32)">
			<summary>Gets the lagged and iterated differences of vectors.</summary>
			<param name="arr">a <c>double[][]</c>; row view; must not be jagged</param>
			<param name="lag">an integer indicating which lag to use</param>
			<param name="order">an integer indicating the order of the difference.
              This is the number of times <c>diff</c> is applied to the data.
              E.g., <c>diff(x, 1, 2) = diff(diff(x, 1, 1), 1, 1)</c>.</param>
			<returns>the lagged and iterated differences</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.diff(System.Double[][])">
			<summary>Gets the first differences of an array of vectors.</summary>
			<param name="arr">a <c>double[][]</c>; row view; must not be jagged</param>
			<returns>the first differences</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.cumsum(System.Double[])">
			<summary>Gets the cumulative sums of the elements in an array.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<returns><c>cumsum</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.cumsum(System.Int32[])">
			<summary>Gets the cumulative sums of the elements in an array.</summary>
			<param name="arr">an array, <c>int[]</c></param>
			<returns><c>cumsum</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.ifelse(System.Double[],com.numericalmethod.suanshu.number.DoubleUtils.ifelse)">
			<summary>Return a value with the same shape as <c>test</c>
 which is filled with elements selected from either <c>yes</c> or <c>no</c>
 depending on whether the element of test is <c>true</c> or <c>false</c>.</summary>
			<param name="arr">an array</param>
			<param name="selection">the <c>boolean</c> test to decide <c>true</c> or <c>false</c> and return
                  values</param>
			<returns>&quot;yes&quot; or &quot;no&quot; return values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.which(System.Double[],com.numericalmethod.suanshu.number.DoubleUtils.which)">
			<summary>Get the indices of the array elements which satisfy the <c>boolean</c> test.</summary>
			<param name="arr">an array. <c>double[]</c></param>
			<param name="test">the <c>boolean</c> test to decide <c>true</c> or <c>false</c> (which to
             select)</param>
			<returns>the indices of the satisfying elements</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.which(System.Int32[],com.numericalmethod.suanshu.number.DoubleUtils.which)">
			<summary>Get the indices of the array elements which satisfy the <c>boolean</c> test.</summary>
			<param name="arr">an array. <c>int[]</c></param>
			<param name="test">the <c>boolean</c> test to decide <c>true</c> or <c>false</c> (which to
             select)</param>
			<returns>the indices of the satisfying elements</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.select(System.Double[],com.numericalmethod.suanshu.number.DoubleUtils.which)">
			<summary>Select the array elements which satisfy the <c>boolean</c> test.
 R does not have a &apos;select&apos; function. The R-equivalent is <c>arr[which(...</c>]}.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<param name="test">the <c>boolean</c> test to determine which elements to be selected</param>
			<returns>the satisfying elements</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.select(System.Int32[],com.numericalmethod.suanshu.number.DoubleUtils.which)">
			<summary>Select the array elements which satisfy the <c>boolean</c> test.
 R does not have a &apos;select&apos; function. The R-equivalent is <c>arr[which(...</c>]}.</summary>
			<param name="arr">an array, <c>int[]</c></param>
			<param name="test">the <c>boolean</c> test to determine which elements to be selected</param>
			<returns>the satisfying elements</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.subarray(System.Double[],System.Int32[])">
			<summary>Get a sub-array of the original array with the given indices.
 The R-equivalent is <c>arr[indices]</c>.</summary>
			<param name="arr">an array, <c>double[]</c></param>
			<param name="indices">an array of indices to select</param>
			<returns><c>arr[indices]</c>.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.subarray(System.Int32[],System.Int32[])">
			<summary>Get a sub-array of the original array with the given indices.
 The R-equivalent is <c>arr[indices]</c>.</summary>
			<param name="arr">an array, <c>int[]</c></param>
			<param name="indices">an array of indices to select</param>
			<returns><c>arr[indices]</c>.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.order(System.Double[],System.Boolean)">
			<summary>Sort an array either in ascending or descending order.</summary>
			<param name="arr">an array, <c>int[]</c></param>
			<param name="ascending"><c>true</c> if arranging elements in ascending order; false if descending
                  order</param>
			<returns>a sorted array</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.order(System.Double[])">
			<summary>Sort an array in ascending order.</summary>
			<param name="arr">an array, <c>int[]</c></param>
			<returns>a sorted array in ascending order</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.readCSV2d(System.String)">
			<summary>Read a multi-column CSV file (output by <c>write.csv</c> from R) into a 2-D <c>double</c>
 array. By default, the CSV file contains both the index column (as the first column) and the
 heading row (as the first row), and use the <para></para>#CSV_SEPARATOR default separator.</summary>
			<param name="fileName">the name of the CSV file</param>
			<returns>the numbers in the CSV file as a <c>double[][]</c></returns>
			<exception cref="T:java.io.IOException">when error has occurred while reading the file</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.readCSV2d(System.String,System.Boolean,System.Boolean)">
			<summary>Read a multi-column CSV file (output by <c>write.csv</c> from R) into a 2-D <c>double</c>
 array. The <para></para>#CSV_SEPARATOR default separator is used.</summary>
			<param name="fileName">the name of the CSV file</param>
			<param name="hasIndex">whether or not the file contains an index column</param>
			<param name="hasHeading">whether or not the file contains a heading row</param>
			<returns>the numbers in the CSV file as a <c>double[][]</c></returns>
			<exception cref="T:java.io.IOException">when error has occurred while reading the file</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.readCSV2d(System.String,System.Boolean,System.Boolean,System.String)">
			<summary>Read a multi-column CSV file (output by <c>write.csv</c> from R) into a 2-D <c>double</c>
 array, with a given separator which overrides the <para></para>#CSV_SEPARATOR default separator.</summary>
			<param name="fileName">the name of the CSV file</param>
			<param name="hasIndex">whether or not the file contains an index column</param>
			<param name="hasHeading">whether or not the file contains a heading row</param>
			<param name="separator">the separator</param>
			<returns>the numbers in the CSV file as a <c>double[][]</c></returns>
			<exception cref="T:java.io.IOException">when error has occurred while reading the file</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.readCSV2d(java.io.InputStream)">
			<summary>Read a multi-column CSV stream (output by <c>write.csv</c> from R) into a 2-D <c>double</c>
 array. By default, the CSV file contains both the index column (as the first column) and the
 heading row (as the first row), and use the <para></para>#CSV_SEPARATOR default separator.</summary>
			<param name="stream">the CSV input stream</param>
			<returns>the numbers in the CSV file as a <c>double[][]</c></returns>
			<exception cref="T:java.io.IOException">when error has occurred while reading the file</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.readCSV2d(java.io.InputStream,System.Boolean,System.Boolean)">
			<summary>Read a multi-column CSV stream (output by <c>write.csv</c> from R) into a 2-D <c>double</c>
 array. The <para></para>#CSV_SEPARATOR default separator is used.</summary>
			<param name="stream">the CSV input stream</param>
			<param name="hasIndex">whether or not the file contains an index column</param>
			<param name="hasHeading">whether or not the file contains a heading row</param>
			<returns>the numbers in the CSV file as a <c>double[][]</c></returns>
			<exception cref="T:java.io.IOException">when error has occurred while reading the file</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.readCSV2d(java.io.InputStream,System.Boolean,System.Boolean,System.String)">
			<summary>Read a multi-column CSV stream (output by <c>write.csv</c> from R) into a 2-D <c>double</c>
 array, with a given separator which overrides the <para></para>#CSV_SEPARATOR default separator.</summary>
			<param name="stream">the CSV input stream</param>
			<param name="hasIndex">whether or not the file contains an index column</param>
			<param name="hasHeading">whether or not the file contains a heading row</param>
			<param name="separator">the separator</param>
			<returns>the numbers in the CSV file as a <c>double[][]</c></returns>
			<exception cref="T:java.io.IOException">when error has occurred while reading the file</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.readCSV1d(System.String)">
			<summary>Read a single-column CSV file (output by <c>write.csv</c> from R) into a 1-D <c>double</c>
 array. By default, the CSV file contains both the index column (as the first column) and the
 heading row (as the first row), and use the <para></para>#CSV_SEPARATOR default separator.</summary>
			<param name="fileName">the name of the CSV file</param>
			<returns>the numbers in the CSV file as a <c>double[]</c></returns>
			<exception cref="T:java.io.IOException">when error has occurred while reading the file</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.readCSV1d(System.String,System.Boolean,System.Boolean)">
			<summary>Read a single-column CSV file (output by <c>write.csv</c> from R) into a 1-D <c>double</c>
 array. The <para></para>#CSV_SEPARATOR default separator is used.</summary>
			<param name="fileName">the name of the CSV file</param>
			<param name="hasIndex">whether or not the file contains an index column</param>
			<param name="hasHeading">whether or not the file contains a heading row</param>
			<returns>the numbers in the CSV file as a <c>double[]</c></returns>
			<exception cref="T:java.io.IOException">when error has occurred while reading the file</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.readCSV1d(System.String,System.Boolean,System.Boolean,System.String)">
			<summary>Read a single-column CSV file (output by <c>write.csv</c> from R) into a 1-D <c>double</c>
 array, with a given separator which overrides the <para></para>#CSV_SEPARATOR default separator.</summary>
			<param name="fileName">the name of the CSV file</param>
			<param name="hasIndex">whether or not the file contains an index column</param>
			<param name="hasHeading">whether or not the file contains a heading row</param>
			<param name="separator">the separator</param>
			<returns>the numbers in the CSV file as a <c>double[]</c></returns>
			<exception cref="T:java.io.IOException">when error has occurred while reading the file</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.readCSV1d(java.io.InputStream)">
			<summary>Read a single-column CSV file (output by <c>write.csv</c> from R) into a 1-D <c>double</c>
 array. By default, the CSV file contains both the index column (as the first column) and the
 heading row (as the first row), and use the <para></para>#CSV_SEPARATOR default separator.</summary>
			<param name="stream">the CSV input stream</param>
			<returns>the numbers in the CSV file as a <c>double[]</c></returns>
			<exception cref="T:java.io.IOException">when error has occurred while reading the file</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.readCSV1d(java.io.InputStream,System.Boolean,System.Boolean)">
			<summary>Read a single-column CSV file (output by <c>write.csv</c> from R) into a 1-D <c>double</c>
 array. The <para></para>#CSV_SEPARATOR default separator is used.</summary>
			<param name="stream">the CSV input stream</param>
			<param name="hasIndex">whether or not the file contains an index column</param>
			<param name="hasHeading">whether or not the file contains a heading row</param>
			<returns>the numbers in the CSV file as a <c>double[]</c></returns>
			<exception cref="T:java.io.IOException">when error has occurred while reading the file</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.readCSV1d(java.io.InputStream,System.Boolean,System.Boolean,System.String)">
			<summary>Read a single-column CSV file (output by <c>write.csv</c> from R) into a 1-D <c>double</c>
 array, with a given separator which overrides the <para></para>#CSV_SEPARATOR default separator.</summary>
			<param name="stream">the CSV input stream</param>
			<param name="hasIndex">whether or not the file contains an index column</param>
			<param name="hasHeading">whether or not the file contains a heading row</param>
			<param name="separator">the separator</param>
			<returns>the numbers in the CSV file as a <c>double[]</c></returns>
			<exception cref="T:java.io.IOException">when error has occurred while reading the file</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.copy2D(System.Double[][])">
			<summary>Copies a 2D array.</summary>
			<param name="raw">a 2D array</param>
			<returns>a copy of the a 2D array</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.DoubleUtils.RoundingScheme">
			<summary>the available schemes to round a number</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.DoubleUtils.RoundingScheme.DEFAULT">
			<summary>This rounding scheme is the same as in <para></para>java.lang.Math#round. That is,
 returning the closest long to the input.
 The input is rounded to an integer by adding 1/2, taking the floor,
 and casting it to <c>long</c>.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.DoubleUtils.RoundingScheme.UP">
			<summary>Always round up.
 This is done by taking the ceiling of the input after subtracting a very tiny number.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.number.DoubleUtils.RoundingScheme.DOWN">
			<summary>Always round down.
 This is done by taking the floor of the input after adding a very tiny number.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.RoundingScheme.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.RoundingScheme.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.DoubleUtils.ifelse">
			<summary>Return a value with the same shape as <c>test</c>
 which is filled with elements selected from either <c>yes</c> or <c>no</c>
 depending on whether the element of test is <c>true</c> or <c>false</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.ifelse.test(System.Double)">
			<summary>Decide whether <i>x</i> satisfies the <c>boolean</c> test.</summary>
			<param name="x">a number</param>
			<returns><c>true</c> if <i>x</i> satisfies the <c>boolean</c> test</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.ifelse.yes(System.Double)">
			<summary>Return value for a <c>true</c> element of test.</summary>
			<param name="x">a number</param>
			<returns>a &quot;yes&quot; value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.ifelse.no(System.Double)">
			<summary>Return value for a <c>false</c> element of test.</summary>
			<param name="x">a number</param>
			<returns>a &quot;no&quot; value</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.number.DoubleUtils.which">
			<summary>Decide whether <i>x</i> satisfies the <c>boolean</c> test.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.number.DoubleUtils.which.isTrue(System.Double,System.Int32)">
			<summary>Decide whether <i>x</i> is to be selected.</summary>
			<param name="x">a number</param>
			<param name="index">to index of <i>x</i>. Ignore <c>index</c> if you care only the value of
 <i>x</i> and not its position.</param>
			<returns><c>true</c> if <c>which({x}, ...) = {x}</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.Optimizer">
			<summary>Optimization, or mathematical programming, refers to choosing the best element from some set of available alternatives.
 In the simplest case,
 this means solving problems in which one seeks to minimize (or maximize) a real function by systematically choosing the values of real or integer variables from within an allowed set.
 The generalization of optimization theory and techniques to other formulations comprises a large area of applied mathematics.
 More generally, it means finding &quot;best available&quot; values of some objective function given a defined domain,
 including a variety of different types of objective functions and different types of domains.
 <para/>
 This interface defines the input (the optimization problem) and output (the optimization solution) of an optimization algorithm.<para> See also: </para><a href="http://en.wikipedia.org/wiki/mathematical_programming">Wikipedia: Mathematical optimization</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.Optimizer.solve(System.Object)">
			<summary>Solve an optimization problem, e.g., <para></para>OptimProblem.</summary>
			<param name="problem">an optimization problem</param>
			<returns>a solution to the optimization problem</returns>
			<exception cref="T:java.lang.Exception">when there is an error solving the problem</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.Minimizer">
			<summary>This interface represents an optimization algorithm that minimizes a real valued objective function, one or multi dimension.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.ConstrainedMinimizer">
			<summary>A constrained minimizer solves a constrained optimization problem, namely, <para></para>ConstrainedOptimProblem.<para> See also: </para><a href="http://en.wikipedia.org/wiki/constrained_optimization">Wikipedia: Constraint optimization</a></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.LessThanConstraints">
			<summary>The domain of an optimization problem may be restricted by less-than or equal-to constraints.
 For example,
 \[
 \min_x f(x)
 \]
 s.t.,
 \[
 g_i(x) \leq 0, i = 1, 2, ...
 \]<para> See also: </para>&quot;Edwin K. P. Chong, Stanislaw H. Zak. &quot;Chapter 20. Problems with Inequality GeneralConstraints,&quot; An Introduction to Optimization. Wiley-Interscience. 2001.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.LessThanConstraints.toGreaterThanConstraints">
			<summary>Convert the less-than or equal-to constraints to greater-than or equal-to constraints.</summary>
			<returns>the equivalent greater-than or equal-to constraints</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.GreaterThanConstraints">
			<summary>The domain of an optimization problem may be restricted by greater-than or equal-to constraints.
 For example,
 \[
 \min_x f(x)
 \]
 s.t.,
 \[
 g_i(x) \geq 0, i = 1, 2, ...
 \]<para> See also: </para>&quot;Edwin K. P. Chong, Stanislaw H. Zak. &quot;Chapter 20. Problems with Inequality GeneralConstraints,&quot; An Introduction to Optimization. Wiley-Interscience. 2001.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.GreaterThanConstraints.toLessThanConstraints">
			<summary>Convert the greater-than or equal-to constraints to less-than or equal-to constraints.</summary>
			<returns>the equivalent less-than or equal-to constraints</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints">
			<summary>The domain of an optimization problem may be restricted by equality constraints.
 For example,
 \[
 \min_x f(x)
 \]
 s.t.,
 \[
 h_i(x) = 0, i = 1, 2, ...
 \]</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.ConstraintsUtils">
			<summary>These are the utility functions for manipulating <para></para>Constraints.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.ConstraintsUtils.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.ConstraintsUtils.isSatisfied(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.Constraints,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Check if the constraints are satisfied.</summary>
			<param name="constraints">the constraints</param>
			<param name="x">the value to evaluate the constraints at</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns><c>true</c> if the constraints are satisfied</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.ConstraintsUtils.isSatisfied(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.Constraints,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Check if the constraints are satisfied.</summary>
			<param name="constraints">the constraints</param>
			<param name="x">the value to evaluate the constraints at</param>
			<returns><c>true</c> if the constraints are satisfied</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.ConstraintsUtils.evaluate(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.Constraints,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Evaluate the constraints.</summary>
			<param name="constraints">the constraints</param>
			<param name="x">the value to evaluate the constraints at</param>
			<returns>the constraint values</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.Constraints">
			<summary>A set of constraints for a (real-valued) optimization problem is a set of functions.
 They can be &#8805;, =, &#8804; 0.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.Constraints.getConstraints">
			<summary>Get the list of constraint functions.</summary>
			<returns>the list of constraint functions</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.Constraints.dimension">
			<summary>Get the number of variables.</summary>
			<returns>the number of variables</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.Constraints.size">
			<summary>Get the number of constraints.</summary>
			<returns>the number of constraints</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralLessThanConstraints">
			<summary>This is the collection of less-than or equal-to constraints for an optimization problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralLessThanConstraints.#ctor(java.util.Collection)">
			<summary>Construct an instance of less-than or equal-to inequality constraints from a collection of real-valued functions.</summary>
			<param name="constraints">the less-than or equal-to inequality constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralLessThanConstraints.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction[])">
			<summary>Construct an instance of less-than or equal-to inequality constraints from an array of real-valued functions.</summary>
			<param name="constraints">the less-than or equal-to inequality constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralLessThanConstraints.toGreaterThanConstraints">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralGreaterThanConstraints">
			<summary>This is the collection of greater-than-or-equal-to constraints for an optimization problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralGreaterThanConstraints.#ctor(java.util.Collection)">
			<summary>Construct an instance of greater-than-or-equal-to inequality constraints from a collection of
 real-valued functions.</summary>
			<param name="constraints">the greater-than-or-equal-to inequality constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralGreaterThanConstraints.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction[])">
			<summary>Construct an instance of greater-than-or-equal-to inequality constraints from an array of
 real-valued functions.</summary>
			<param name="constraints">the greater-than-or-equal-to inequality constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralGreaterThanConstraints.toLessThanConstraints">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralEqualityConstraints">
			<summary>This is the collection of equality constraints for an optimization problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralEqualityConstraints.#ctor(java.util.Collection)">
			<summary>Construct an instance of equality constraints from a collection of real-valued functions.</summary>
			<param name="constraints">the equality constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralEqualityConstraints.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction[])">
			<summary>Construct an instance of equality constraints from an array of real-valued functions.</summary>
			<param name="constraints">the equality constraints</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralConstraints">
			<summary>The real-valued constraints define the domain (feasible regions) for a real-valued objective
 function in a constrained optimization problem. The type of constraints can be equality (=),
 greater-than-or-equal-to (&#8805;), and less-than or equal-to (&#8804;).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralConstraints.#ctor(java.util.Collection)">
			<summary>Construct an instance of constraints from a collection of real-valued functions.</summary>
			<param name="constraints">the constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralConstraints.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction[])">
			<summary>Construct an instance of constraints from an array of real-valued functions.</summary>
			<param name="constraints">the constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralConstraints.getConstraints">
			<summary>Get the constraints.</summary>
			<returns>the constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralConstraints.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.general.GeneralConstraints.size">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.UpperBoundConstraints">
			<summary>This is an upper bound constraints such that for all x<sub>i</sub>&apos;s,
 <blockquote><i>
 x<sub>i</sub> &#8804; b
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.UpperBoundConstraints.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,System.Double)">
			<summary>Construct an upper bound constraints for all variables in a function.</summary>
			<param name="f">a function</param>
			<param name="lower">the upper bound</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.NonNegativityConstraints">
			<summary>These constraints ensures that for all variables are non-negative.
 <blockquote><i>
 x<sub>i</sub> &#8805; 0
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.NonNegativityConstraints.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary>Construct a lower bound constraints for all variables in a function.</summary>
			<param name="f">a function</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LowerBoundConstraints">
			<summary>This is a lower bound constraints such that for all x<sub>i</sub>&apos;s,
 <blockquote><i>
 x<sub>i</sub> &#8805; b
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LowerBoundConstraints.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,System.Double)">
			<summary>Construct a lower bound constraints for all variables in a function.</summary>
			<param name="f">a function</param>
			<param name="lower">the lower bound</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints">
			<summary>This is a collection of linear less-than-or-equal-to constraints.
 <blockquote><code><i>
 A * x &#8804; b
 </i></code></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a collection of linear less-than or equal-to constraints.</summary>
			<param name="A">the less-than inequality constraints</param>
			<param name="b">the less-than inequality values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints.toGreaterThanConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints.getFeasibleInitialPoint(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints)">
			<summary>Given a collection of linear less-than-or-equal-to constraints as well as a collection of equality constraints,
 find a feasible initial point that satisfy the constraints.
 This implementation solves eq. 11.25 in the reference.
 The first (n-1) entries consist of a feasible initial point.
 The last entry is the single point perturbation.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Eq 11.25, Quadratic and Convex Programming,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
			<param name="equal">a collection of linear equality constraints</param>
			<returns>a feasible initial point, and the single point perturbation (in one vector)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints.getFeasibleInitialPoint">
			<summary>Given a collection of linear less-than-or-equal-to constraints,
 find a feasible initial point that satisfy the constraints.
 This implementation solves eq. 11.25 in the reference.
 The first (n-1) entries consist of a feasible initial point.
 The last entry is the single point perturbation.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Eq 11.25, Quadratic and Convex Programming,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
			<returns>a feasible initial point, and the single point perturbation (in one vector)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints">
			<summary>This is a collection of linear greater-than-or-equal-to constraints.
 <blockquote><code><i>
 A * x &#8805; b
 </i></code></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a collection of linear greater-than or equal-to constraints.</summary>
			<param name="A">the inequality coefficients</param>
			<param name="b">the inequality values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints.toLessThanConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints.getFeasibleInitialPoint(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints)">
			<summary>Given a collection of linear greater-than-or-equal-to constraints as well as a collection of
 equality constraints,
 find a feasible initial point that satisfy the constraints.
 This implementation solves eq. 11.25 in the reference.
 The first (n-1) entries consist of a feasible initial point.
 The last entry is the single point perturbation.<para> See also: </para><list type="bullet">
 <item>&quot;Jorge Nocedal, Stephen Wright, &quot;p. 473,&quot; Numerical Optimization.&quot;</item>
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Eq 11.25, Quadratic and Convex Programming,&quot; Practical
 Optimization: Algorithms and Engineering Applications.&quot;</item>
 <item>http://www.mathworks.com/help/toolbox/optim/ug/brnox7l.html (initialization)</item>
 </list></summary>
			<param name="equal">a collection of linear equality constraints</param>
			<returns>a feasible initial point, and the single point perturbation (in one vector)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints.getFeasibleInitialPoint">
			<summary>Given a collection of linear greater-than-or-equal-to constraints,
 find a feasible initial point that satisfy the constraints.
 This implementation solves eq. 11.25 in the reference.
 The first (n-1) entries consist of a feasible initial point.
 The last entry is the single point perturbation.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Eq 11.25, Quadratic and Convex Programming,&quot; Practical
 Optimization: Algorithms and Engineering Applications.&quot;</summary>
			<returns>a feasible initial point, and the single point perturbation (in one vector)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints">
			<summary>This is a collection of linear equality constraints.
 <blockquote><code><i>
 A * x = b
 </i></code></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a collection of linear equality constraints.</summary>
			<param name="A">the equality coefficients</param>
			<param name="b">the equality values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints.isReducible">
			<summary>Check if we can reduce the number of linear equalities. That is, they are linearly dependent.<para> See also: </para>&quot;Section 10.2.2, p. 268- 270. Practical Optimization: Algorithms and Engineering Applications. Andreas Antoniou, Wu-Sheng Lu.&quot;</summary>
			<returns><c>true</c> if <i>rank[A b] = rank[A]</i>, and <i>rank[A] &lt; #equalities</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints.getReducedLinearEqualityConstraints">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
Get the collection of linearly independent linear constraints.</summary>
			<returns>the collection of linearly independent linear constraints</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearConstraints">
			<summary>This is a collection of linear constraints for a real-valued optimization problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearConstraints.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a collection of linear constraints.</summary>
			<param name="A">the constraint coefficients</param>
			<param name="b">the constraint values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearConstraints.getConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearConstraints.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearConstraints.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearConstraints.A">
			<summary>Get the constraint coefficients.</summary>
			<returns>the constraint coefficients</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearConstraints.b">
			<summary>Get the constraint values.</summary>
			<returns>the constraint values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearConstraints.getActiveRows(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Get the active constraint indices.
 The active constraints are those with a_i(x) = 0.</summary>
			<param name="x">a point or a potential solution</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns>the active (row) indices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearConstraints.getActiveConstraints(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Get the active constraint.
 The active constraints are those with a_i(x) = 0.</summary>
			<param name="x">a point or a potential solution</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns>the active constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearConstraints.concat(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearConstraints[])">
			<summary>Concatenate collections of linear constraints into one collection.</summary>
			<param name="groups">collections of linear constraints</param>
			<returns>a collection of linear constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearConstraints.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints">
			<summary>This represents the lower and upper bounds for a variable.
 <blockquote><c><code>
 lb &#8804; x &#8804; ub
 </code></c></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.#ctor(System.Int32,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.Bound[])">
			<summary>Construct a set of bound constraints.</summary>
			<param name="bounds">the bounds</param>
			<param name="dim">the number of variables</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.getBounds">
			<summary>Get a deep copy of the bounds.</summary>
			<returns>a deep copy of the bounds</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.getUpperBounds">
			<summary>Split the equality constraints and get the less-than-the-upper-bounds part.</summary>
			<returns>the upper bound constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.getLowerBounds">
			<summary>Split the equality constraints and get the greater-than-the-lower-bounds part.</summary>
			<returns>the lower bound constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.toLessThanConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.toGreaterThanConstraints">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.Bound">
			<summary>A bound constraint for a variable.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.Bound.index">
			<summary>the index to the variable, counting from 1.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.Bound.#ctor(System.Int32,System.Double,System.Double)">
			<summary>Construct a bound constraint for a variable.</summary>
			<param name="index">the index to the variable, counting from 1</param>
			<param name="lower">the lower bound for the variable</param>
			<param name="upper">the upper bound for the variable</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.Bound.lower">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.Bound.upper">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints.Bound.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPUnbounded">
			<summary>This is the exception thrown when the LP problem is unbounded.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPUnbounded.s">
			<summary>This is the pricing column that does not have an eligible row that passes the ratio test,
 hence the problem is unbounded.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPUnbounded.#ctor(System.Int32)">
			<summary>Construct an instance of <c>LPUnbounded</c>.</summary>
			<param name="s">the pricing column that does not have an eligible row that passes the ratio test</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPRuntimeException">
			<summary>This is the exception thrown when there is any problem when constructing a linear programming problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPRuntimeException.#ctor">
			<summary>Construct an instance of <c>LPRuntimeException</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPRuntimeException.#ctor(System.String)">
			<summary>Construct an instance of <c>LPRuntimeException</c>.</summary>
			<param name="msg">an error message</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPNoConstraint">
			<summary>This is the exception thrown when there is no linear constraint found for the LP problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPNoConstraint.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPInfeasible">
			<summary>This is the exception thrown when the LP problem is infeasible, i.e., no solution.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPInfeasible.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPException">
			<summary>This is the exception thrown when there is any problem when solving a linear programming problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPException.#ctor">
			<summary>Construct an instance of <c>LPException</c>.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPEmptyCostVector">
			<summary>This is the exception thrown when there is no objective function in a linear programming problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPEmptyCostVector.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPDimensionNotMatched">
			<summary>This is the exception thrown when the dimensions of the objective function and constraints of a linear programming problem are inconsistent.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPDimensionNotMatched.#ctor(System.String)">
			<summary>Construct an instance of <c>LPDimensionNotMatched</c>.</summary>
			<param name="msg">the error message</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.LPSolver">
			<summary>An LP solver solves a Linear Programming (LP) problem.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.LPSolution">
			<summary>A solution to an LP problem contains all information about solving an LP problem such as
 whether the problem has a solution (bounded), how many minimizers it has, and the minimum.
 For an LP problem that has multiple minimizers, the solution produces all of them.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.LPMinimizer">
			<summary>An LP minimizer minimizes the objective of an LP problem, satisfying all the constraints.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPStandardProblem">
			<summary>This is a linear programming problem in the standard form:
 <blockquote><i>
 min c&apos;x
 </i></blockquote>
 s.t.
 <blockquote><code><i>
 A * x = b,
 x &#8805; 0
 </i></code></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPStandardProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints)">
			<summary>Construct a linear programming problem in the standard form.</summary>
			<param name="c">the objective function</param>
			<param name="equal">the equality constraints</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1">
			<summary>This is an implementation of a linear programming problem, <para></para>LPProblem.
 For convenient construction, this implementation allows all forms of linear constraints:
 <list type="bullet">
 <item>greater-than-or-equal-to constraints: Agr * x &#8805; bgr</item>
 <item>less-than-or-equal-to constraints: Ale * x &#8804; ble</item>
 <item>equality constraints: Aeq * x = beq</item>
 <item>box constraints (bounds): l &#8804; x &#8804; u</item>
 </list>
 <em>By convention, if no bound is mentioned for a variable, x &#8805; 0.</em></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints)">
			<summary>Construct a general linear programming problem.</summary>
			<param name="cost">the objective function</param>
			<param name="greater">the greater-than-or-equal-to inequality constraints</param>
			<param name="less">the less-than-or-equal-to inequality constraints</param>
			<param name="equal">the equality constraints</param>
			<param name="bounds">the bounds for variables</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints)">
			<summary>Construct a general linear programming problem with only greater-than-or-equal-to and equality constraints.</summary>
			<param name="cost">the objective function</param>
			<param name="greater">the greater-than-or-equal-to inequality constraints</param>
			<param name="equal">the equality constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.nGreaterThanInequalities">
			<summary>Get the number of greater-than-or-equal-to constraints.</summary>
			<returns>the number of greater-than-or-equal-to inequalities</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.nEqualities">
			<summary>Get the number of equality constraints.</summary>
			<returns>the number of equality constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.f">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.getLessThanConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.getEqualityConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.c">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.A">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.b">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.Aeq">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.beq">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.isFree(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblemImpl1.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblem">
			<summary>A linear programming (LP) problem minimizes a linear objective function subject to a collection of linear constraints.
 <blockquote><code><i>
 min c&apos;x
 </i></code></blockquote>
 s.t.
 <blockquote><code><i>
 A * x &#8805; b
 Aeq * x = beq
 </i></code></blockquote>
 some <i>x &#8805; 0</i>, some <i>x</i> are free.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblem.c">
			<summary>Get the objective function.</summary>
			<returns>the objective function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblem.A">
			<summary>Get the coefficients, <i>A</i>, of the greater-than-or-equal-to constraints <i>A * x &#8805; b</i>.</summary>
			<returns>the coefficients of the greater-than-or-equal-to constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblem.b">
			<summary>Get the values, <i>b</i>, of the greater-than-or-equal-to constraints <i>A * x &#8805; b</i>.</summary>
			<returns>the values of the greater-than-or-equal-to constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblem.Aeq">
			<summary>Get the coefficients, <i>Aeq</i>, of the equality constraints <i>Aeq * x &#8805; beq</i>.</summary>
			<returns>the coefficients of the equality constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblem.beq">
			<summary>Get the values, <i>beq</i>, of the equality constraints <i>Aeq * x &#8805; beq</i>.</summary>
			<returns>the values of the equality constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblem.isFree(System.Int32)">
			<summary>Check whether x<sub>i</sub> is a free variable <em>after</em> handling the box constraints.</summary>
			<param name="i">the index of a variable, counting from 1</param>
			<returns><c>true</c> if x<sub>i</sub> is free</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem2">
			<summary>This is a linear programming problem in the 2nd canonical form (following the convention in the wiki):
 <blockquote><i>
 min c&apos;x
 </i></blockquote>
 s.t.
 <blockquote><code><i>
 A * x &#8804; b,
 x &#8805; 0
 </i></code></blockquote>
 <i>b &#8805; 0</i> if the problem is feasible<para> See also: </para><a href="http://en.wikipedia.org/wiki/linear_programming#standard_form">Wikipedia: Standard form</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem2.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a linear programming problem in the canonical form.</summary>
			<param name="c"><c>c&apos;x</c> is the linear objective function to be minimized</param>
			<param name="A">the less-than inequality constraints <c>A * x &amp;le; b</c></param>
			<param name="b">the less-than inequality values <c>A * x &amp;le; b</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem2.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints)">
			<summary>Construct a linear programming problem in the canonical form.</summary>
			<param name="cost">the objective function</param>
			<param name="less">a collection of less-than-or-equal-to constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem2.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem1)">
			<summary>Convert a linear programming problem from the 1st canonical form to the 2nd canonical form.</summary>
			<param name="problem">a linear programming problem in the 1st canonical form</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem1">
			<summary>This is a linear programming problem in the 1st canonical form (following the convention in the reference):
 <blockquote><i>
 min c&apos;x
 </i></blockquote>
 s.t.
 <blockquote><code><i>
 A * x &#8805; b,
 x &#8805; 0
 </i></code></blockquote>
 <i>b &#8804; 0</i> if the problem is feasible<para> See also: </para>&quot;Michael C. Ferris, Olvi L. Mangasarian, Stephen J. Wright, &quot;Eq. 3.1, Chapter 3, The Simplex Method,&quot; Linear Programming with MATLAB.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem1.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a linear programming problem in the canonical form.</summary>
			<param name="c">the objective function</param>
			<param name="A">the coefficients, <i>A</i>, of the greater-than-or-equal-to constraints <i>A * x &#8805; b</i></param>
			<param name="b">the values, <i>b</i>, of the greater-than-or-equal-to constraints <i>A * x &#8805; b</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem1.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints)">
			<summary>Construct a linear programming problem in the canonical form.</summary>
			<param name="cost">the objective function</param>
			<param name="greater">a collection of greater-than-or-equal-to constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem1.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem2)">
			<summary>Convert a linear programming problem from the 2nd canonical form to the 1st canonical form.</summary>
			<param name="problem">a linear programming problem in the 2nd canonical form</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem1.getGreaterThanConstraints">
			<summary>Get the greater-than-or-equal-to constraints of the linear programming problem.</summary>
			<returns>the greater-than-or-equal-to constraints</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable">
			<summary>This is a simplex table used to solve a linear programming problem using a simplex method.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.COST">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.B">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.ARTIFICIAL_COST">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.ARTIFICIAL">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.UNDEFINED">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem1,System.Double)">
			<summary>Construct a simplex table from a canonical linear programming problem.</summary>
			<param name="problem">a canonical linear programming problem</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem1)">
			<summary>Construct a simplex table from a canonical linear programming problem.</summary>
			<param name="problem">a canonical linear programming problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblem,System.Double)">
			<summary>Construct a simplex table from a general linear programming problem.</summary>
			<param name="problem">a general linear programming problem</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblem)">
			<summary>Construct a simplex table from a general linear programming problem.</summary>
			<param name="problem">a general linear programming problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary>Copy constructor.</summary>
			<param name="table">a simplex table</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.getColLabel(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.getRowLabel(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.getCostRow(System.Int32)">
			<summary>Get the table entry at <i>[COST, j]</i>.</summary>
			<param name="j">a column index, counting from 1</param>
			<returns><i>T[COST, j]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.getBCol(System.Int32)">
			<summary>Get the table entry at <i>[i, B]</i>.</summary>
			<param name="i">a row index, counting from 1</param>
			<returns><i>T[i, B]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.getProblemSize">
			<summary>Get the number of variables in the problem or the cost/objective function.</summary>
			<returns>the number of variables</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.swap(System.Int32,System.Int32)">
			<summary>Perform a Jordan Exchange to swap row <c>r</c> with column <c>s</c>.</summary>
			<param name="r">the index to a entering variable (row)</param>
			<param name="s">the index to a leaving variable (column)</param>
			<returns>a swapped simplex table</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.isFeasible">
			<summary>Check if this table is feasible.</summary>
			<returns><c>true</c> if the table is feasible</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.minimum">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.minimizer">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType.NON_BASIC">
			<summary>the non-basic variables, i.e., original variables in the cost function</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType.B">
			<summary>the constraint values (the last column)</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType.BASIC">
			<summary>the basic variables, i.e., constraints</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType.COST">
			<summary>the cost function (the last row)</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType.EQUALITY">
			<summary>the equality constraints</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType.FREE">
			<summary>the free variables</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType.ARTIFICIAL">
			<summary>the artificial variable, x0, pp. 61</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType.ARTIFICIAL_COST">
			<summary>the artificial objective, z0, pp. 61</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType.DELETED">
			<summary>the deleted rows and columns</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType.UNDEFINED">
			<summary>an undefined label</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.Label">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.Label.type">
			<summary>the label type</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.Label.index">
			<summary>the index of a variable, an inequality, an equality, etc., counting from 1</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.Label.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.LabelType,System.Int32)">
			<summary>Construct a label for a row or column in the simplex table.</summary>
			<param name="type">the label type</param>
			<param name="index">the index of a variable, an inequality, an equality, etc., counting from 1</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable.Label.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.JordanExchange">
			<summary>Jordan Exchange swaps the r-th entering variable (row) with the s-th leaving variable (column) in a matrix <i>A</i>.<para> See also: </para>&quot;Michael C. Ferris, Olvi L. Mangasarian, Stephen J. Wright, &quot;Section 2.1,&quot; Linear Programming with MATLAB.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.JordanExchange.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.MatrixTable,System.Int32,System.Int32)">
			<summary>Construct a new table by exchanging the r-th row with the s-th column in <i>A</i> using Jordan Exchange.</summary>
			<param name="A">a table</param>
			<param name="r">the r-th entering variable (row)</param>
			<param name="s">the s-th leaving variable (column)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.JordanExchange.#ctor(com.numericalmethod.suanshu.misc.datastructure.FlexibleTable,System.Int32,System.Int32)">
			<summary>Construct a new table by exchanging the r-th row with the s-th column in <i>A</i> using Jordan Exchange.
 For a <para></para>FlexibleTable, we maintain the row and columns labels.</summary>
			<param name="A">a table</param>
			<param name="r">the r-th entering variable (row)</param>
			<param name="s">the s-th leaving variable (column)</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.FerrisMangasarianWrightScheme2">
			<summary>The scheme 2 procedure removes equalities and free variables.<para> See also: </para>&quot;Michael C. Ferris, Olvi L. Mangasarian, Stephen J. Wright. &quot;Section 3.6.3, Scheme II,&quot; Linear Programming with MATLAB&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.FerrisMangasarianWrightScheme2.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary>Construct the scheme 2 algorithm for a table with equalities and free variables.</summary>
			<param name="table">a table with equalities and free variables</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.FerrisMangasarianWrightScheme2.process">
			<summary>Remove equalities and free variables, if possible.
 The resultant table may be infeasible.</summary>
			<returns>a simplex table without equalities and free variables</returns>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPInfeasible">if the linear programming problem is infeasible</exception>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPUnbounded">if the linear programming problem is unbounded</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.FerrisMangasarianWrightPhase1">
			<summary>The phase 1 procedure finds a feasible table from an infeasible one by pivoting the simplex table of a related problem.<para> See also: </para>&quot;Michael C. Ferris, Olvi L. Mangasarian, Stephen J. Wright, &quot;Algorithm 3.2, Section 3.4, The Phase I Procedure,&quot; Linear Programming with MATLAB.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.FerrisMangasarianWrightPhase1.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary>Construct the phase 1 algorithm for an infeasible table corresponding to a non-standard linear programming problem, e.g., b &#8805; 0.</summary>
			<param name="table">an infeasible table</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.FerrisMangasarianWrightPhase1.process">
			<summary>Find a feasible table, if any.</summary>
			<returns>a feasible table. If the original table is already feasible, return itself.</returns>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPInfeasible">if the linear programming problem is infeasible</exception>
			<exception cref="T:java.lang.Exception">if any error</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.SmallestSubscriptRule">
			<summary>Bland&apos;s smallest-subscript rule is for anti-cycling in choosing a pivot.<para> See also: </para>&quot;Michael C. Ferris, Olvi L. Mangasarian, Stephen J. Wright. &quot;Section 3.5.3,&quot; Linear Programming with MATLAB.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.SmallestSubscriptRule.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.SmallestSubscriptRule.pricing(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary>
 The pivot column is the smallest non-basic variable index, <i>s</i>, such that
 column <i>s</i> has a negative element in the bottom row (reduced cost).</summary>
			<param name="table">a simplex table</param>
			<returns>the pivot column</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.SimplexPivoting">
			<summary>A simplex pivoting finds a row and column to exchange to reduce the cost function.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.SimplexPivoting.pricing(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary>This is pivot column selection (pricing) rule.</summary>
			<param name="table">a simplex table</param>
			<returns>the pivot column</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.SimplexPivoting.ratioTest(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable,System.Int32)">
			<summary>This is pivot row selection (Ratio test) rule.</summary>
			<param name="table">a simplex table</param>
			<param name="s">a column index</param>
			<returns>the pivot row</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.SimplexPivoting.getPivot(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary>Get the next pivot.</summary>
			<param name="table">a simplex table</param>
			<returns>a pivot to reduce the cost; <c>null</c> if the <c>table</c> already optimal</returns>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPUnbounded">if the table is unbounded</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.SimplexPivoting.Pivot">
			<summary>the pivot</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.SimplexPivoting.Pivot.r">
			<summary>the pivot row</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.SimplexPivoting.Pivot.s">
			<summary>the pivot column</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.SimplexPivoting.Pivot.#ctor(System.Int32,System.Int32)">
			<summary>Construct a pivot.</summary>
			<param name="r">the pivot row</param>
			<param name="s">the pivot column</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.NaiveRule">
			<summary>This pivoting rule chooses the column with the most negative reduced cost.
 This gives the biggest decrease in the cost per unit increase in the entering variable.
 However, since we cannot tell how much we can increase the entering variable until we perform the ratio test,
 it is not generally true that this choice leads to the best decrease in the cost in this step, among all possible pivot columns.
 Moreover, this naive rule does not prevent cycling, and should be used only for testing purpose.<para> See also: </para>&quot;Michael C. Ferris, Olvi L. Mangasarian, Stephen J. Wright, &quot;p.49,&quot; Linear Programming with MATLAB.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.NaiveRule.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.NaiveRule.pricing(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary>
 We choose the column with most negative reduced cost (last entry in the column).</summary>
			<param name="table">a simplex table</param>
			<returns>the pivot column</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.NaiveRule.ratioTest(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable,System.Int32)">
			<summary>
 The pivot row is the smallest basic variable index, <i>r</i>, such that row <i>r</i> satisfies
 <i>-h(r) / H(r,s) = min {-h(i) / H(i,s) | H(i,s) &lt; 0}</i></summary>
			<param name="table">a simplex table</param>
			<param name="s">a column</param>
			<returns>the pivot row</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.NaiveRule.getPivot(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPUnboundedMinimizerScheme2">
			<summary>This is the solution to an unbounded linear programming problem found in scheme 2.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPUnboundedMinimizerScheme2.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable,System.Int32)">
			<summary>Construct the solution for an unbounded linear programming problem as a result of applying scheme 2.</summary>
			<param name="table">the resultant simplex table</param>
			<param name="lambdaCol">the column indicating an unbounded solution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPUnboundedMinimizerScheme2.minimizer">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPUnboundedMinimizerScheme2.v">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPUnboundedMinimizer">
			<summary>This is the solution to an unbounded linear programming problem.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPUnboundedMinimizer.table">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPUnboundedMinimizer.lambdaCol">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPUnboundedMinimizer.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable,System.Int32)">
			<summary>Construct the solution for an unbounded linear programming problem.</summary>
			<param name="table">the table of the current (intermediate) solution of a linear programming
                  problem</param>
			<param name="lambdaCol">the column index for which there is no row that passes the ratio test (hence
                  the problem is unbounded); when the problem is bounded, <c>lambdaCol = 0</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPUnboundedMinimizer.getResultantTableau">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPUnboundedMinimizer.minimum">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPUnboundedMinimizer.minimizer">
			<summary>This is the same as the <i>u</i> vector, such that the direction of arbitrarily negative can
 be computed by adjusting <i>&#955;</i>.
 <blockquote><i>
 u + &#955;v
 </i></blockquote></summary>
			<returns>the <i>u</i> vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPUnboundedMinimizer.v">
			<summary>When the problem is unbounded, the direction of arbitrarily negative can be computed by
 adjusting <i>&#955;</i>.
 <blockquote><i>
 u + &#955;v
 </i></blockquote>
 where <c>u = minimizer()</c>.
 <para/>
 This is only meaningful in the case where the problem is unbounded.</summary>
			<returns>the <i>v</i> vector</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPSimplexSolution">
			<summary>The solution to a linear programming problem using a simplex method contains an <para></para>LPSimplexMinimizer.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPSimplexMinimizer">
			<summary>A simplex LP minimizer can be read off from the solution simplex table.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPSimplexMinimizer.getResultantTableau">
			<summary>Get the solution simplex table as a result of solving a linear programming problem.</summary>
			<returns>the solution simplex table as a result of solving a linear programming problem</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPBoundedMinimizer">
			<summary>This is the solution to a bounded linear programming problem.
 Note that there may be multiple solutions that give the same minimum.
 This implementation returns all possible optimal solutions.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPBoundedMinimizer.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary>Construct the solution for a bounded linear programming problem.</summary>
			<param name="table">the solution simplex table, e.g., as a result of phase 2</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPBoundedMinimizer.getResultantTableau">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPBoundedMinimizer.minimum">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPBoundedMinimizer.minimizer">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPBoundedMinimizer.minimizers">
			<summary>Get all optimal minimizers.</summary>
			<returns>all optimal minimizers</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solution.LPBoundedMinimizer.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPTwoPhaseSolver">
			<summary>This implementation solves a linear programming problem, <para></para>LPProblem, using a two-step approach.
 It first converts the LP problem into a canonical LP problem and then solve it using a canonical LP solver.<para> See also: </para>&quot;Michael C. Ferris, Olvi L. Mangasarian, Stephen J. Wright, &quot;Section 3.6.4,&quot; Linear Programming with MATLAB.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPTwoPhaseSolver.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPSimplexSolver)">
			<summary>Construct an LP solver to solve LP problems.</summary>
			<param name="solver">a canonical LP solver</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPTwoPhaseSolver.#ctor">
			<summary>Construct an LP solver to solve LP problems.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPTwoPhaseSolver.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPTwoPhaseSolver.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPSimplexSolver">
			<summary>A simplex solver works toward an LP solution by sequentially applying Jordan exchange to a simplex table.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPSimplexSolver.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary>Solve an LP problem by a simplex algorithm on a simplex table</summary>
			<param name="table">the initial simplex table corresponding to the LP problem</param>
			<returns>an LP solution</returns>
			<exception cref="T:java.lang.Exception">when there is an error</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPCanonicalSolver">
			<summary>This is an LP solver that solves a canonical LP problem in the following form.
 <blockquote><i>
 min c&apos;x
 </i></blockquote>
 s.t.
 <blockquote><code><i>
 A * x &#8805; b,
 x &#8805; 0
 </i></code></blockquote>
 <i>b &#8804; 0</i> if the problem is feasible<para> See also: </para>LPCanonicalProblem1<para> See also: </para>LPCanonicalProblem2<para> See also: </para>&quot;Michael C. Ferris, Olvi L. Mangasarian, Stephen J. Wright, Linear Programming with MATLAB.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPCanonicalSolver.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.FerrisMangasarianWrightPhase2">
			<summary>This implementation solves a canonical linear programming problem that does not need preprocessing its simplex table.<para> See also: </para>&quot;Michael C. Ferris, Olvi L. Mangasarian, Stephen J. Wright, &quot;Algorithm 3.1, Section 3, The Simplex Method,&quot; Linear Programming with MATLAB.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.FerrisMangasarianWrightPhase2.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.pivoting.SimplexPivoting)">
			<summary>Construct an LP solver to solve canonical LP problems using the Phase 2 algorithm in Ferris, Mangasarian &amp; Wright.</summary>
			<param name="pivoting">a pivoting rule</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.FerrisMangasarianWrightPhase2.#ctor">
			<summary>Construct an LP solver to solve canonical LP problems using the Phase 2 algorithm in Ferris, Mangasarian &amp; Wright.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.FerrisMangasarianWrightPhase2.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.FerrisMangasarianWrightPhase2.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.problem.LPCanonicalProblem1)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.activeset.QPPrimalActiveSetSolver">
			<summary>This implementation solves a Quadratic Programming problem using the Primal Active Set algorithm.
 In quadratic programming, as the solution is not necessarily on one of the edges of the bounding polygon,
 an estimation of the active set gives us a subset of inequalities to watch while searching the solution,
 which reduces the complexity of the search.
 A bottleneck is that only one constraint can be added or removed from the working set per iteration.<para> See also: </para><list type="bullet">
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 13.1, Quadratic and Convex Programming,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 <item>&quot;Jorge Nocedal, Stephen Wright, &quot;Algorithm 16.3,&quot; Numerical Optimization.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/active_set">Wikipedia: Active set</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.activeset.QPPrimalActiveSetSolver.#ctor(System.Double,System.Int32)">
			<summary>Construct a Primal Active Set minimizer to solve quadratic programming problems.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations, e.g., <c>Integer.MAX_VALUE</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.activeset.QPPrimalActiveSetSolver.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.activeset.QPPrimalActiveSetSolver.Solution">
			<summary>This is the solution to a Quadratic Programming problem using the Primal Active Set algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.activeset.QPPrimalActiveSetSolver.Solution.setInitials(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPSolution[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.activeset.QPPrimalActiveSetSolver.Solution.step">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.activeset.QPPrimalActiveSetSolver.Solution.search">
			<summary>Search for a minimizer for the quadratic programming problem.<para> See also: </para>&quot;Algorithms 16.3 and 13.1&quot;</summary>
			<returns>a quadratic programming solution</returns>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPInfeasible">if there is no solution to the quadratic programming problem</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.activeset.QPPrimalActiveSetSolver.Solution.search(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Search for a minimizer for the quadratic programming problem.<para> See also: </para>&quot;Algorithms 16.3 and 13.1&quot;</summary>
			<param name="initial">a <em>strictly</em> feasible initial point that satisfies the constraints</param>
			<returns>a quadratic programming solution</returns>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPInfeasible">if there is no solution to the quadratic programming problem</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.activeset.QPPrimalActiveSetSolver.Solution.search(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPSolution)">
			<summary>Search for a minimizer for the quadratic programming problem from the
 given starting points.</summary>
			<param name="initial">an initial guess</param>
			<returns>an (approximate) optimizer</returns>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPInfeasible">when the quadratic programming problem is infeasible</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.activeset.QPPrimalActiveSetSolver.Solution.search(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPSolution[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.activeset.QPPrimalActiveSetSolver.Solution.minimizer">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.activeset.QPPrimalActiveSetSolver.Solution.minimum">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblemOnlyEqualityConstraints">
			<summary>A quadratic programming problem with only equality constraints can be converted into
 a equivalent quadratic programming problem without constraints, hence a mere quadratic function.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblemOnlyEqualityConstraints.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints)">
			<summary>Construct a quadratic programming problem with only equality constraints.</summary>
			<param name="f">the quadratic objective function to be minimized</param>
			<param name="equal">the linear equality constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblemOnlyEqualityConstraints.getSolutionToOriginalProblem(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Back out the solution for the original (constrained) problem, if the modified (unconstrained) problem can be solved.<para> See also: </para>&quot;eq. 13.4a&quot;</summary>
			<param name="phi">the solution to the modified (unconstrained) problem</param>
			<returns>the solution to the original (constrained) problem, if the modified (unconstrained) problem can be solved</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem">
			<summary>Quadratic Programming is the problem of optimizing (minimizing) a quadratic function of several variables subject to linear constraints on these variables.
 The standard form, following the convention in the reference, is:
 \[
 \min_x \left \{ \frac{1}{2} \times x&apos;Hx + x&apos;p \right \} \\
 Ax \geq b, A_{eq}x = b_{eq}
 \]<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/quadratic_programming">Wikipedia: Quadratic programming</a></item>
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Chapter 13, Quadratic and Convex Programming,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints)">
			<summary>Construct a quadratic programming problem.</summary>
			<param name="f">the quadratic objective function to be minimized</param>
			<param name="equal">the linear equality constraints</param>
			<param name="greater">the linear greater-than-or-equal-to constraints</param>
			<param name="less">the linear less-than-or-equal-to constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints)">
			<summary>Construct a quadratic programming problem with linear inequality constraints.</summary>
			<param name="f">the quadratic objective function to be minimized</param>
			<param name="greater">the linear greater-than-or-equal-to constraints</param>
			<param name="less">the linear less-than-or-equal-to constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints)">
			<summary>Construct a quadratic programming problem with linear equality and greater-than-or-equal-to constraints.</summary>
			<param name="f">the quadratic objective function to be minimized</param>
			<param name="equal">the linear equality constraints</param>
			<param name="greater">the linear greater-than-or-equal-to constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints)">
			<summary>Construct a quadratic programming problem with linear greater-than-or-equal-to constraints.</summary>
			<param name="f">the quadratic objective function to be minimized</param>
			<param name="greater">the linear greater-than-or-equal-to constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints)">
			<summary>Construct a quadratic programming problem with linear equality and less-than-or-equal-to constraints.</summary>
			<param name="f">the quadratic objective function to be minimized</param>
			<param name="equal">the linear equality constraints</param>
			<param name="less">the linear less-than-or-equal-to constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints)">
			<summary>Construct a quadratic programming problem with linear less-than-or-equal-to constraints.</summary>
			<param name="f">the quadratic objective function to be minimized</param>
			<param name="less">the linear less-than-or-equal-to constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem)">
			<summary>Copy constructor.</summary>
			<param name="that">an quadratic programming problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.f">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.getGreaterThanConstraints">
			<summary>Get the set of linear greater-than-or-equal-to constraints.</summary>
			<returns>the set of linear greater-than-or-equal-to constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.getLessThanConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.getEqualityConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.A">
			<summary>Get the coefficients of the inequality constraints: <i>A</i> as in \(Ax \geq b\).</summary>
			<returns>the inequality constraint coefficients</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.b">
			<summary>Get the values of the inequality constraints: <i>b</i> as in \(Ax \geq b\).</summary>
			<returns>the inequality constraint values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.Aeq">
			<summary>Get the coefficients of the equality constraints: <i>A<sub>eq</sub></i> as in \(A_{eq}x = b_{eq}\).</summary>
			<returns>the equality constraint coefficients</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.problem.QPProblem.beq">
			<summary>Get the values of the equality constraints: <i>b<sub>eq</sub></i> as in \(A_{eq}x = b_{eq}\).</summary>
			<returns>the equality constraint values</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPSolution">
			<summary>This is a solution to a quadratic programming problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPSolution.isUnique">
			<summary>Return <c>true</c> if the quadratic programming problem has only one solution.</summary>
			<returns><c>true</c> if the quadratic programming problem has only one solution</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPSolution.minimizer">
			<summary>Get a minimizing vector.</summary>
			<returns>a minimizing vector as a solution to the quadratic programming problem</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPSimpleSolver">
			<summary>These are the utility functions to solve simple quadratic programming problems that admit analytical solutions.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Section 13.2, Convex QP Problems with Equality Constraints,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPSimpleSolver.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPSimpleSolver.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction,System.Double)">
			<summary>Solve an unconstrained quadratic programming problem of this form.
 \[
 \min_x \left \{ \frac{1}{2} \times x&apos;Hx + x&apos;p \right \}
 \]</summary>
			<param name="f">the objective function</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns>a quadratic programming solution</returns>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPInfeasible">when the quadratic programming problem is infeasible</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPSimpleSolver.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction)">
			<summary>Solve an unconstrained quadratic programming problem of this form.
 \[
 \min_x \left \{ \frac{1}{2} \times x&apos;Hx + x&apos;p \right \}
 \]</summary>
			<param name="f">the objective function</param>
			<returns>a quadratic programming solution</returns>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPInfeasible">when the quadratic programming problem is infeasible</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPSimpleSolver.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints,System.Double)">
			<summary>Solve a quadratic programming problem subject to equality constraints.
 \[
 \min_x \left \{ \frac{1}{2} \times x&apos;Hx + x&apos;p \right \}, Ax = b
 \]</summary>
			<param name="f">the objective function</param>
			<param name="equal">the equality constraints</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns>a quadratic programming solution</returns>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPInfeasible">when the quadratic programming problem is infeasible</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPSimpleSolver.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.QuadraticFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints)">
			<summary>Solve a quadratic programming problem subject to equality constraints.
 \[
 \min_x \left \{ \frac{1}{2} \times x&apos;Hx + x&apos;p \right \}, Ax = b
 \]</summary>
			<param name="f">the objective function</param>
			<param name="equal">the equality constraints</param>
			<returns>a quadratic programming solution</returns>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPInfeasible">when the quadratic programming problem is infeasible</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPInfeasible">
			<summary>This is the exception thrown by a quadratic programming solver when the quadratic programming problem is infeasible, i.e., no solution.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPInfeasible.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPException">
			<summary>This is the exception thrown when there is an error solving a quadratic programming problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.QPException.#ctor">
			<summary>Construct an instance of <c>QPException</c>.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.SDPT3v4">
			<summary>This implements Algorithm_IPC, the SOCP interior point algorithm in SDPT3 version 4.<para> See also: </para>&quot;K. C. Toh, M. J. Todd, R. H. Tütüncü, &quot;On the implementation and usage of SDPT3 - a MATLAB
 software package for semidefinite-quadratic-linear programming, version 4.0,&quot; in Handbook on
 Semidefinite, Cone and Polynomial Optimization: Theory, Algorithms, Software and Applications,
 Anjos, M. and Lasserre, J.B., ED. Springer, 2012, pp. 715--754.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.SDPT3v4.iterate(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualSolution,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualSolution">
			<summary>The vector set <i>{x, s, y}</i> is a solution to both the primal and dual SOCP problems.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualSolution.x">
			<summary>This is the minimizer for the primal problem.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualSolution.y">
			<summary>This is the maximizer for the dual problem.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualSolution.s">
			<summary>This is the auxiliary helper to solve the dual problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualSolution.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a solution to a primal and a dual SOCP problems.</summary>
			<param name="x">the minimizer for the primal problem</param>
			<param name="s">the auxiliary helper to solve the dual problem</param>
			<param name="y">the maximizer for the dual problem</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualInteriorPoint">
			<summary>Solves a Dual Second Order Conic Programming problem using the Primal Dual Interior Point
 algorithm.
 <para/>
 2014/1/9: This solver is tested up to 6000 variables and 26000 constraints. It took 5 minutes to
 return the result.<para> See also: </para><list type="bullet">
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 14.5, Section 14.8.2, A primal-dual interior-point
 algorithm,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 <item>&quot;K. C. Toh, M. J. Todd, R. H. Tütüncü, &quot;On the implementation and usage of SDPT3 - a MATLAB
 software package for semidefinite-quadratic-linear programming, version 4.0,&quot; in Handbook on
 Semidefinite, Cone and Polynomial Optimization: Theory, Algorithms, Software and Applications,
 Anjos, M. and Lasserre, J.B., ED. Springer, 2012, pp. 715--754.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualInteriorPoint.#ctor(System.Double,System.Int32)">
			<summary>Constructs a Primal Dual Interior Point minimizer to solve Dual Second Order Conic
 Programming problems.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualInteriorPoint.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualInteriorPoint.Solution">
			<summary>This is the solution to a Dual Second Order Conic Programming problem using the Primal Dual
 Interior Point algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualInteriorPoint.Solution.minimum">
			<summary>

 c*x is the value of the prime objective function, and b*y is the value of the dual
 objective function. In theory c*x=b*y. For an SOCP problem, the prime objective function
 is minimized, while the dual objective function is maximized. Therefore, the method
 &quot;minimum()&quot; return c*x.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualInteriorPoint.Solution.minimizer">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualInteriorPoint.Solution.setInitials(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualSolution[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualInteriorPoint.Solution.search(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualSolution[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualInteriorPoint.Solution.search(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualSolution)">
			<summary>Searches for a solution that optimizes the objective function from the given starting
 point.</summary>
			<param name="initial">an initial guess</param>
			<returns>an (approximate) optimizer</returns>
			<exception cref="T:java.lang.Exception">when an error occurs during the search</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualInteriorPoint.Solution.search">
			<summary>Searches for a solution that optimizes the objective function from the starting point
 given by K. C. Toh, SDPT3 Version 3.0, p. 6.</summary>
			<returns>an (approximate) optimizer</returns>
			<exception cref="T:java.lang.Exception">when an error occurs during the search</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualInteriorPoint.Solution.step">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.AntoniouLu2007">
			<summary>This implementation is based on Algorithm 14.5 in the reference.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 14.5, Section 14.8.2, A primal-dual
 interior-point algorithm,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.AntoniouLu2007.DEFAULT_SIGMA">
			<summary>the default value of the centering parameter</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.AntoniouLu2007.iterate(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.interiorpoint.PrimalDualSolution,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPRiskConstraint">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPRiskConstraint.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPRiskConstraint.Sigma">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioProblem">
			<summary>Constructs an SOCP problem for portfolio optimization.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioProblem.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioObjectiveFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint[])">
			<summary>Constructs an SOCP problem for portfolio optimization.</summary>
			<param name="f">the objective function</param>
			<param name="constraints">the portfolio constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioProblem.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioObjectiveFunction,java.util.Collection)">
			<summary>Constructs an SOCP problem for portfolio optimization.</summary>
			<param name="f">the objective function</param>
			<param name="constraints">the portfolio constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioProblem.getPortfolioConstraints">
			<summary>Gets the portfolio constraints.</summary>
			<returns>the portfolio constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioProblem.dimensionOfDomain">
			<summary>Gets the dimension of the original (unstacked) problem.</summary>
			<returns>the dimension of the original (unstacked) problem</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioProblem.getVariables">
			<summary>Get the list of all variables and their beginning indices starting from 0.</summary>
			<returns>the list of all variables and their beginning indices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioProblem.areAllConstraintsSatisfied(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Checks whether the constraints are satisfied with a solution vector x.</summary>
			<param name="x">a solution vector</param>
			<returns><c>true</c> if and only if all constraints are satisfied</returns>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.ConstraintViolationException"></exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioObjectiveFunction">
			<summary>Constructs the objective function for portfolio optimization. The general form is:
 \[
 b&apos;z = -\bar{r}^{\top}(w^0+x)+\lambda_r t_1+\lambda_c t_2
 \]
 , where \(t_{1}\in\mathbb{R}^{1}\) and \(t_{2}\in\mathbb{R}^{1}\) are usually the portfolio risk
 and market impact terms respectively. \(\bar{r}\) is the expected portfolio return.
 <para/>
 By letting \(y=x+w^{0}\), the objective function becomes:
 \[
 -\bar{r}^{\top}y+\lambda_rt_1+\lambda_ct_2
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioObjectiveFunction.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double[],com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPRiskConstraint,com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint)">
			<summary>Constructs the objective function for an SOCP portfolio optimization (minimization) problem.</summary>
			<param name="returns">the return matrix</param>
			<param name="lambda">the coefficients of the portfolio risk and market impact terms</param>
			<param name="risk">the portfolio risk term</param>
			<param name="impact">the market impact term</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioObjectiveFunction.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double[],com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPRiskConstraint,com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint)">
			<summary>Constructs the objective function for an SOCP portfolio optimization (minimization) problem.</summary>
			<param name="r_bar">the vector of average returns</param>
			<param name="lambda">the coefficients of the portfolio risk and market impact terms</param>
			<param name="risk">the portfolio risk term</param>
			<param name="impact">the market impact term</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioObjectiveFunction.getVariables">
			<summary>Gets the variables involved in the portfolio constraints implied by the objective function.</summary>
			<returns>the variables involved in the portfolio constraints implied by the objective function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioObjectiveFunction.getPortfolioConstraints">
			<summary>Gets the portfolio constraints represented in the objective function.</summary>
			<returns>the portfolio constraints represented in the objective function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioObjectiveFunction.b">
			<summary>Gets the objective vector, <i>b</i>, in the compact form.</summary>
			<returns>the objective vector, <i>b</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioObjectiveFunction.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Computes the final objective function value.</summary>
			<param name="y">the positions</param>
			<returns>the objective values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioObjectiveFunction.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioObjectiveFunction.dimensionOfRange">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint">
			<summary>An SOCP constraint for portfolio optimization, e.g., market impact, is represented by a set of
 constraints in this form.
 \[
 ||A^{T}x+c||_{2}\leq b^{T}x+d
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.newSOCPGeneralConstraints(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.Variable[])">
			<summary>Creates a new <c>SOCPGeneralConstraints</c> so we can add <c>SOCPGeneralConstraint</c> to
 it.</summary>
			<param name="vars">the variables involved in this <c>SOCPGeneralConstraints</c></param>
			<returns>the reference to the newly created <c>SOCPGeneralConstraints</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.iterator">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.getVariables(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraints)">
			<summary>Gets the variables involved in <c>SOCPGeneralConstraints</c>.</summary>
			<param name="constraints">the SOCP constraints</param>
			<returns>the variables involved in the SOCP constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.areAllConstraintsSatisfied(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Checks whether all SOCP constraints represented by this portfolio constraint are satisfied.</summary>
			<param name="x">a portfolio solution or allocation; the positions of the assets</param>
			<returns><c>true</c> if and only if all SOCP constraints are satisfied</returns>
			<exception cref="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.ConstraintViolationException"></exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.ConstraintViolationException">
			<summary>Exception thrown when a constraint is violated.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.ConstraintViolationException.#ctor">
			<summary>Constructs a <c>ConstraintViolationException</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.ConstraintViolationException.#ctor(System.String)">
			<summary>Constructs a <c>ConstraintViolationException</c> with an error message.</summary>
			<param name="err">an error message</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.Variable">
			<summary>the variables involved in <c>SOCPGeneralConstraints</c></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.Variable.name">
			<summary>the variable name</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.Variable.dim">
			<summary>the variable dimension</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.Variable.#ctor(System.String,System.Int32)">
			<summary>Constructs a named variable.</summary>
			<param name="name">the variable name</param>
			<param name="dim">the variable dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.Variable.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.Variable.hashCode">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.SOCPPortfolioConstraint.Variable.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma">
			<summary>Constructs the constraint coefficient arrays of the portfolio risk term in the compact form. The
 constraints are generated during the transformation of the objective function.
 <para/>
 
 The portfolio risk in the objective function is transformed into the following constraints:
 \[
 (x+w^{0})^{\top}\Sigma(x+w^{0})\leq t_1.
 \]
 By letting \(y=x+w^{0}\), it can be written as:
 \[
 y^{\top}\Sigma\;y\leq t_1
 \]
 When the exact covariance matrix \(\Sigma\) is used, then the portfolio risk constraint is
 equivalent to:
 \[
 y^{\top}\Sigma\;y\leq t_1 \Longleftrightarrow
 y^{\top}\Sigma\;y+(\frac{t_{1}-1}{2})^{2}\leq(\frac{t_{1}+1}{2})^{2}\Longleftrightarrow
 ||\left(\begin{array}{c}\Sigma^{\frac{1}{2}}y\\\frac{t_{1}-1}{2}\end{array}\right)||_{2}\leq
 \frac{t_{1}+1}{2}.
 \]
 And the standard SOCP form of the portfolio risk constraint in this case are:
 \[
 ||\left(\begin{array}{c}\Sigma^{\frac{1}{2}}y\\\frac{t_{1}-1}{2}\end{array}\right)||_{2}\leq
 \frac{t_{1}+1}{2}\Longleftrightarrow ||A_{1}^{\top}z+C_{1}||_{2}\leq b^{\top}_{1}z+d_{1}\\
 A_{1}^{\top}=\left(\begin{array}{cc}\Sigma^{\frac{1}{2}} &amp; 0_{n\times 1}\\0_{1\times n} &amp;
 1/2\end{array}\right)\nonumber,\;
 C_{1}=\left(\begin{array}{c}0_{n\times 1}\\-1/2\end{array}\right),\;
 b_{1}=\left(\begin{array}{c}0_{n\times 1}\\1/2\end{array}\right)\;
 d_{1}=\frac{1}{2},\;
 z=\left(\begin{array}{c}y\\t_{1}\end{array}\right).
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.MatrixRoot)">
			<summary>Transforms the portfolio risk term, \(y^{\top}\Sigma\;y\leq t_1\), into the standard SOCP
 form when the exact covariance matrix is used.</summary>
			<param name="Sigma">the covariance matrix</param>
			<param name="root">the method to compute the root of a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Transforms the portfolio risk term, \(y^{\top}\Sigma\;y\leq t_1\), into the standard SOCP
 form when the exact covariance matrix is used.</summary>
			<param name="Sigma">the covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.Sigma">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.areAllConstraintsSatisfied(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>
 The constraint generated by objective function to find the optimal solution. It cannot be
 &quot;violated&quot;.</summary>
			<returns><c>true</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.dimensionOfRange">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.MatrixRoot">
			<summary>Specifies the method to compute the root of a matrix.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.MatrixRoot.getRoot(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Gets the root of a matrix</summary>
			<param name="A">a matrix</param>
			<returns>the matrix root</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.DefaultRoot">
			<summary>Computes the matrix root by <para></para>Cholesky and on failure
 by <para></para>MatrixRootByDiagonalization.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.DefaultRoot.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.DefaultRoot.getRoot(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.Diagonalization">
			<summary>Computes the matrix root by <para></para>MatrixRootByDiagonalization.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.Diagonalization.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.PortfolioRiskExactSigma.Diagonalization.getRoot(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.MarketImpact">
			<summary>Constructs the constraint coefficient arrays of a market impact term in the compact form. The
 constraint is generated during the transformation of the objective function.
 <para/> 
 This market impact term in the objective function takes this form:
 \[
 \sum_{j=1}^n\left(m_j |x_j|^{\frac{3}{2}}\right)\leq t_2.
 \]
 Let \(\bar{x}=|x|\), the market impact term is transformed into:
 \[
 \sum_{j=1}^n\left(
 m_{j}\bar{x}_{j}^{\frac{3}{2}}\right)\leq t_2
 \]
 By introducing variables \(y=x+w^{0}\), \(\alpha\) and \(\beta\), the above inequality is
 equivalent to:
 \[
 \sum\beta_{j}\leq t_{2}\\
 |y_{j}-w_{j}^{0}|\leq\bar{x}_{j}\;j=1,\cdots,n\\
 m_{j}\bar{x}_{j}^{\frac{3}{2}}\leq
 \beta_{j}\;j=1,\cdots,n\\
 \]
 These constraints can be further transformed into:
 \[
 \sum_{j=1}^{n}\beta_{j}\leq t_{2}\\
 y_{j}-w_{j}^{0}\leq\bar{x}_{j},\; j =1,\cdots, n\\
 -y_{j}+w_{j}^{0}\leq \bar{x}_{j},\; j=1,\cdots,n\\
 \bar{x}_{j}^{\frac{3}{2}}\leq \frac{\beta_{j}}{m_{j}},\; j=1,\cdots,n\\
 \]
 Therefore we have:
 \[
 ||0||_{2}\leq t_{2}-\sum_{j=1}^{n}\beta_{j}\\
 ||0||_{2}\leq\bar{x}_{j}-(y_{j}-w_{j}^{0}),\; j =1,\cdots, n\\
 ||0||_{2}\leq \bar{x}_{j}-(-y_{j}+w_{j}^{0}),\; j=1,\cdots,n\\
 \bar{x}_{j}^{\frac{3}{2}}\leq \frac{\beta_{j}}{m_{j}},\;j=1,\cdots,n.
 \]
 The last term, \(\bar{x}_{j}^{\frac{3}{2}}\leq \frac{\beta_{j}}{m_{j}}\), is equivalent to:
 \[
 \bar{x}_{j}^{\frac{3}{2}}\leq \frac{\beta_{j}}{m_{j}},\;\bar{x}_{j}\geq 0\Longleftrightarrow
 \bar{x}_{j}^2\leq s_{j} \frac{\beta_{j}}{m_{j}},\; s_{j}\leq
 \sqrt{\bar{x}_{j}},\;\bar{x}_{j}\geq0,\;
 s_{j}\geq 0\;, \frac{\beta_{j}}{m_{j}}\geq0 \Longleftrightarrow\\
 \bar{x}_{j}^2\leq s_{j} \frac{\beta_{j}}{m_{j}},\; s_{j}^{2} \leq
 \bar{x}_{j},\;\bar{x}_{j}\geq0,\;
 s_{j}\geq 0\;, \frac{\beta_{j}}{m_{j}}\geq 0 \Longleftrightarrow\\
 \bar{x}_{j}^2+\left(\frac{\beta_{j}}{2m_{j}}-\frac{s_{j}}{2}\right)^2\leq
 \left(\frac{\beta_{j}}{2m_{j}}+\frac{s_{j}}{2}\right)^2,\;s_{j}^{2}+\left(\frac{1-\bar{x}_{j}}{2}\right)^2\leq
 \left(\frac{1+\bar{x}_{j}}{2}\right)^2,\;\bar{x}_{j}\geq0,\;s_{j}\geq 0\;,
 \frac{\beta_{j}}{m_{j}}\geq 0.
 \]
 Because \(\bar{x}_{j}\geq0,\;s_{j}\geq 0\;, \frac{\beta_{j}}{m_{j}}\geq 0\) can be deduced from
 other
 constraints, they can be deleted from the system of constraints. The constraints deduced from
 \(\bar{x}_{j}^{\frac{3}{2}}\leq \frac{\beta_{j}}{m_{j}}\) can be written as:
 \[
 ||\left(\begin{array}{c}\bar{x}_{j}\\\frac{\beta_{j}}{2m_{j}}-\frac{s_{j}}{2}\end{array}\right)||_{2}\leq\frac{\beta_{j}}{2m_{j}}+\frac{s_{j}}{2},j=1,\cdots,n,\\
 ||\left(\begin{array}{c}s_{j}\\\frac{1-\bar{x}_{j}}{2}\end{array}\right)||_{2}\leq\frac{1+\bar{x}_{j}}{2},j=1,\cdots,n.
 \]
 Combine all the constraints together, the system of constraints for market impact is:
 \[
 ||0||_{2}\leq t_{2}-\sum_{j=1}^{n}\beta_{j},\\
 ||0||_{2}\leq\bar{x}_{j}-(y_{j}-w_{j}^{0}), \;j =1,\cdots, n,\\
 ||0||_{2}\leq \bar{x}_{j}-(-y_{j}+w_{j}^{0}),\; j=1,\cdots,n,\\
 ||\left(\begin{array}{c}\bar{x}_{j}\\\frac{\beta_{j}}{m_{j}}-\frac{s_{j}}{2}\end{array}\right)||_{2}\leq\frac{\beta_{j}}{m_{j}}+\frac{s_{j}}{2},\;j=1,\cdots,n,\\
 ||\left(\begin{array}{c}s_{j}\\\frac{1-\bar{x}_{j}}{2}\end{array}\right)||_{2}\leq\frac{1+\bar{x}_{j}}{2},\;j=1,\cdots,n.
 \]
 The standard SOCP form of the constraints are:
 \[
 ||0||_{2}\leq t_{2}-\sum_{j=1}^{n}\beta_{j} \Longleftrightarrow ||A_{1}^{\top}z+C_{1}||_{1}\leq
 b^{\top}_{1}z+d_{1}\\
 A_{1}^{\top}=0_{1\times n},\;
 C_{1}=0,\;
 b_{1}=\left(\begin{array}{c}-1_{n\times 1}\\1\end{array}\right),\;
 d_{1}=0,\;
 z=\left(\begin{array}{c}\beta\\t_{2}\end{array}\right).
 \]
 \[
 ||0||_{2}\leq\bar{x}_{j}-(y_{j}-w_{j}^{0}) \Longleftrightarrow
 ||A_{2,j}^{\top}z+C_{2,j}||_{2}\leq b^{\top}_{2,j}z+d_{2,j},\quad j=1,\cdots,n\\
 A_{2,j}^{\top}=0_{1\times 2n},\;
 C_{2,j}=0,\;
 b_{2,j}=\left(\begin{array}{c}-e_{j}\\e_{j}\end{array}\right),\;
 d_{2,j}=w_{j}^{0},\;
 z=\left(\begin{array}{c}y\\\bar{x}\end{array}\right),
 \]
 where \(e_{j}\) is a \(n\) dimensional vector whose \(j\)-th entry is \(1\) and all the other
 entries are \(0\).
 \[
 ||0||_{2}\leq\bar{x}_{j}-(-y_{j}+w_{j}^{0}) \Longleftrightarrow
 ||A_{3,j}^{\top}z+C_{3,j}||_{2}\leq b^{\top}_{3,j}z+d_{3,j},\quad j=1,\cdots,n\\
 A_{3,j}^{\top}=0_{1\times 2n},\;
 C_{3,j}=0,\;
 b_{3,j}=\left(\begin{array}{c}e_{j}\\e_{j}\end{array}\right),\;
 d_{3,j}=-w_{j}^{0},\;
 z=\left(\begin{array}{c}y\\\bar{x}\end{array}\right).
 \]
 \[
 ||\left(\begin{array}{c}\bar{x}_{j}\\\frac{\beta_{j}}{2m_{j}}-\frac{s_{j}}{2}\end{array}\right)||_{2}\leq\frac{\beta_{j}}{2m_{j}}+\frac{s_{j}}{2}\Longleftrightarrow
 ||A_{4,j}^{\top}z+C_{4,j}||_{2}\leq b^{\top}_{4,j}z+d_{4,j},\quad j=1,\cdots,n\\
 A_{4,j}^{\top}=\left(\begin{array}{ccc}e_{j}^{\top}&amp;0_{1\times n}&amp;0_{1\times n}\\0_{1\times
 n}&amp;\frac{1}{2m_{j}}e_{j}^{\top}&amp; -\frac{1}{2}e_{j}^{\top}\end{array}\right),\;
 C_{4,j}=0_{2 \times 1},\;
 b_{4,j}=\left(\begin{array}{c}0_{n\times 1}
 \\\frac{1}{2m_{j}}e_{j}\\\frac{1}{2}e_{j}\end{array}\right),\;
 d_{4,j}=0,\;
 z=\left(\begin{array}{c}\bar{x}\\\beta_{j}\\s\end{array}\right).
 \]
 \[
 ||\left(\begin{array}{c}s_{j}\\\frac{1-\bar{x}_{j}}{2}\end{array}\right)||_{2}\leq\frac{1+\bar{x}_{j}}{2}\Longleftrightarrow
 ||A_{5,j}^{\top}z+C_{5,j}||_{2}\leq b^{\top}_{5,j}z+d_{5,j},\quad j=1,\cdots,n\\
 A_{5,j}^{\top}=\left(\begin{array}{ccc}0_{1\times
 n}&amp;e_{j}^{\top}\\-\frac{1}{2}e_{j}^{\top}&amp;0_{1\times n}\end{array}\right),\;
 C_{5,j}=\left(\begin{array}{c}0\\\frac{1}{2}\end{array}\right),\;
 b_{5,j}=\left(\begin{array}{c}\frac{1}{2}e_{j}\\0_{n\times 1}\end{array}\right),\;
 d_{5,j}=\frac{1}{2},\;
 z=\left(\begin{array}{c}\bar{x}\\s\end{array}\right).
 \]<para> See also: </para>&quot;Section 2.1, Modeling market impact, http://mosek.com/fileadmin/reports/tech/portfolio.pdf&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.MarketImpact.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Constructs a market impact term.</summary>
			<param name="w_0">the initial position</param>
			<param name="m">the market impact parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.MarketImpact.areAllConstraintsSatisfied(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>
 The constraint generated by objective function to find the optimal solution. It cannot be
 &quot;violated&quot;.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.MarketImpact.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.MarketImpact.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.portfoliooptimization.MarketImpact.dimensionOfRange">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralProblem">
			<summary>Many convex programming problems can be represented in the following form.
 Minimize
 \[
 f^&apos; x
 \]
 subject to
 \[
 \lVert A_i x + b_i \rVert_2 \leq c_i^T x + d_i,\quad i = 1,\dots,m
 \]
 where the problem parameters are
 \[
 x\in\mathbb{R}^n, f \in \mathbb{R}^n, \ A_i \in \mathbb{R}^{{n_i}\times n}, \ b_i \in
 \mathbb{R}^{n_i}, \ c_i \in \mathbb{R}^n, \ d_i \in \mathbb{R}
 \]<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/second-order_cone_programming">Wikipedia: Second-order
 cone programming</a></item>
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;eq 14.104, Section 14.7, Second-Order Cone Programming,&quot;
 Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralProblem.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralProblem)">
			<summary>Copy constructor.</summary>
			<param name="that">another <para></para>SOCPGeneralProblem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraint[])">
			<summary>Construct a general Second Order Conic Programming problem. Minimize
 \[
 f^&apos; x
 \]
 subject to the SOCP constraints
 \[
 \lVert A_i x + b_i \rVert_2 \leq c_i^T x + d_i,\quad i = 1,\dots,m
 \]</summary>
			<param name="f"><i>f</i></param>
			<param name="constraints">the SOCP constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,java.util.List)">
			<summary>Construct a general Second Order Conic Programming problem. Minimize
 \[
 f^&apos; x
 \]
 subject to the SOCP constraints
 \[
 \lVert A_i x + b_i \rVert_2 \leq c_i^T x + d_i,\quad i = 1,\dots,m
 \]</summary>
			<param name="f"><i>f</i></param>
			<param name="constraints">the SOCP constraints</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraints">
			<summary>This represents a set of SOCP general constraints of this form.
 \[
 ||A^{T}x+c||_{2}\leq b^{T}x+d
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraints.#ctor">
			<summary>Constructs a set of SOCP general constraints.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraints.#ctor(java.util.List)">
			<summary>Constructs a set of SOCP general constraints.</summary>
			<param name="constraints">a list of SOCP general constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraints.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraint[])">
			<summary>Constructs a set of SOCP general constraints.</summary>
			<param name="constraints">an array of SOCP general constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraints.add(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraint)">
			<summary>Add an SOCP constraint.</summary>
			<param name="constraint">an SOCP constraint</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraints.size">
			<summary>Gets the number of constraints.</summary>
			<returns>the number of constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraints.iterator">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraint">
			<summary>This represents the SOCP general constraint of this form.
 \[
 \lVert A_i x + b_i \rVert_2 \leq c_i^T x + d_i,\quad i = 1,\dots,m
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraint.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double)">
			<summary>Constructs a SOCP general constraint.</summary>
			<param name="A"><i>A</i></param>
			<param name="c"><i>c</i></param>
			<param name="b"><i>b</i></param>
			<param name="d"><i>d</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraint.A">
			<summary>Gets <i>A</i>.</summary>
			<returns><i>A</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraint.c">
			<summary>Gets <i>c</i>.</summary>
			<returns><i>c</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraint.b">
			<summary>Gets <i>b</i>.</summary>
			<returns><i>b</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPGeneralConstraint.d">
			<summary>Gets <i>d</i>.</summary>
			<returns><i>d</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem">
			<summary>This is the Dual Second Order Conic Programming problem.
 \[
 \max_y \mathbf{b&apos;y} \textrm{ s.t.,} \\
 \mathbf{\hat{A}_i&apos;y + s_i = \hat{c}_i} \\
 s_i \in K_i, i = 1, 2, ..., q
 \]<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;eq 14.102, Section 14.7, Second-Order Cone Programming,&quot;
 Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Constructs a dual SODP problem.
 \[
 \max_y \mathbf{b&apos;y} \textrm{ s.t.,} \\
 \mathbf{\hat{A}_i&apos;y + s_i = \hat{c}_i} \\
 s_i \in K_i, i = 1, 2, ..., q
 \]</summary>
			<param name="b">\(b\)</param>
			<param name="A">\(A_i\)&apos;s</param>
			<param name="c">\(c_i\)&apos;s</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem)">
			<summary>Copy constructor.</summary>
			<param name="that">another <para></para>SOCPDualProblem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.f">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.getLessThanConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.getEqualityConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.m">
			<summary>Gets the dimension of the system, i.e., <i>m</i> = the dimension of <i>y</i>.</summary>
			<returns>the dimension of the system</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.q">
			<summary>Gets the number of A matrices.</summary>
			<returns>the number of A matrices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.b">
			<summary>Gets <i>b</i>.</summary>
			<returns><i>b</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.c(System.Int32)">
			<summary>Gets <i>c<sub>i</sub></i>.</summary>
			<param name="i">an index to the c&apos;s, counting from 1</param>
			<returns><i>c<sub>i</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.A(System.Int32)">
			<summary>Gets <i>A<sub>i</sub></i>.</summary>
			<param name="i">an index to the A&apos;s, counting from 1</param>
			<returns><i>A<sub>i</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.n(System.Int32)">
			<summary>Gets the number of columns of <i>A<sub>i</sub></i>.</summary>
			<param name="i">an index to the A&apos;s, counting from 1</param>
			<returns>the number of columns of <i>A<sub>i</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.A">
			<summary>\[
 A = [A_1, A_2, ... A_q]
 \]<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Section 14.8.1, Assumptions and KKT conditions,&quot;
 Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
			<returns><i>A</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.c">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.EqualityConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.EqualityConstraints.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Constructs the equality constraints for a dual SOCP problem, \(\max_y \mathbf{b&apos;y}
 \textrm{ s.t.,} \\ \mathbf{\hat{A}_i&apos;y + s_i = \hat{c}_i} \\ s_i \in K_i, i = 1, 2, ...,
 q\).</summary>
			<param name="b">\(b\)</param>
			<param name="A">\(A_i\)&apos;s</param>
			<param name="c">\(c_i\)&apos;s</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.EqualityConstraints.getConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.EqualityConstraints.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.problem.SOCPDualProblem.EqualityConstraints.size">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing">
			<summary>The Primal-Dual Path-Following algorithm is an interior point method that solves Semi-Definite
 Programming problems. In theory, the algorithm assumes feasible starting points. In practice when
 there is no feasible starting point, the program utilizes an infeasible interior point method.
 Specifically, this implementation relaxes the feasible constraints and require only the initials
 <i>X<sub>0</sub></i> and <i>S<sub>0</sub></i> be positive definite. For example, let
 <i>X<sub>0</sub></i> and <i>S<sub>0</sub></i> be identity matrices, <i>y<sub>0</sub></i> be a
 zero vector. This implementation adds one more condition to the terminal condition of iterations.
 That is,
 <blockquote><i>
 phi = delta(duality gap) + norm(rd) + norm(rp)
 </i></blockquote>
 where <i>norm(rd) + norm(rp)</i> measures the feasibility of solution.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 14.1, Primal-dual path-following algorithm,&quot;
 Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.#ctor(System.Double,System.Double,System.Double)">
			<summary>Constructs a Primal-Dual Path-Following minimizer to solve semi-definite programming
 problems.</summary>
			<param name="gamma0">\(0 &lt; \gamma &lt; 1\). It ensures the next iterates are inside the feasible set;
                suggested values are between 0.9 and 0.99.</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.#ctor(System.Double,System.Double)">
			<summary>Constructs a Primal-Dual Path-Following minimizer to solve semi-definite programming
 problems.</summary>
			<param name="gamma0">\(0 &lt; \gamma &lt; 1\). It ensures the next iterates are inside the feasible set;
                suggested values are between 0.9 and 0.99.</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.#ctor(System.Double)">
			<summary>Constructs a Primal-Dual Path-Following minimizer to solve semi-definite programming
 problems.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.getMinEigenValue(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Gets the minimum of all the eigen values of a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<returns>the minimum of all the eigen values of a matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution">
			<summary>This is the solution to a Semi-Definite Programming problem using the Primal-Dual
 Path-Following algorithm.</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.path">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.sigma">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.gamma">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.delta">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.phi">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.iter">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.problem">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.A">
			<summary>This is either [A] or

 [ A]
 [-C]</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.n">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.I">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.setInitials(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.CentralPath[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.step">
			<summary>
 <para/>
 Algorithm 14.1.</summary>
			<returns>the residual norm</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.search(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.CentralPath[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.search(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.CentralPath)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.search">
			<summary>Search for a solution that optimizes the objective function from the given starting
 points.</summary>
			<returns>an (approximate) optimizer</returns>
			<exception cref="T:java.lang.Exception">when an error occurs during the search</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.minimum">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.minimizer">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing.Solution.svecA">
			<summary><para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu. &quot;eq. 14.41a,&quot; Practical Optimization: Algorithms and
 Engineering Applications.&quot;</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.Hp">
			<summary>This is the symmetrization operator as defined in eq. 6 in the reference.
 \[
 H_p: C^{n \times n} \rightarrow \textit{H}^n \\
 H_p(U) = \frac{1}{2}[PUP^{-1}]+P^{-*}U^*P^*
 \]<para> See also: </para>&quot;K. C. Toh, M. J. Todd, R. H. Tütüncü, &quot;SDPT3 -- a MATLAB software package for semidefinite programming, version 2.1,&quot; OPTIMIZATION METHODS AND SOFTWARE. 1999.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.Hp.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a symmetrization operator.</summary>
			<param name="P">a parameter matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.Hp.#ctor">
			<summary>Construct the symmetrization operator using an identity matrix.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.Hp.evaluate(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Compute \(H_p(U) = \frac{1}{2}[PUP^{-1}]+P^{-*}U^*P^*\).</summary>
			<param name="U">a matrix</param>
			<returns>\(H_p(U)\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.HomogeneousPathFollowing">
			<summary>This implementation solves a Semi-Definite Programming problem using the Homogeneous Self-Dual Path-Following algorithm.<para> See also: </para><list type="bullet">
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 14.1, Primal-dual path-following algorithm,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 <item>&quot;K. C. Toh, M. J. Todd, R. H. Tütüncü, &quot;SDPT3 -- a MATLAB software package for semidefinite programming, version 2.1,&quot; OPTIMIZATION METHODS AND SOFTWARE, 1999.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.HomogeneousPathFollowing.#ctor(System.Double,System.Double,System.Double)">
			<summary>Construct a Homogeneous Self-Dual Path-Following minimizer to solve semi-definite programming problems.</summary>
			<param name="gamma0">\(0 &lt; \gamma &lt; 1\). It ensures the next iterates are inside the feasible set; suggested values are between 0.9 and 0.99.</param>
			<param name="sigma0">\(0 \leq \sigma &lt; 1\), the centering parameter</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.HomogeneousPathFollowing.#ctor(System.Double)">
			<summary>Construct a Homogeneous Self-Dual Path-Following minimizer to solve semi-definite programming problems.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.HomogeneousPathFollowing.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.HomogeneousPathFollowing.Solution">
			<summary>This is the solution to a Semi-Definite Programming problem using the Homogeneous Self-Dual Path-Following algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.HomogeneousPathFollowing.Solution.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.PrimalDualPathFollowing,com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem,System.Double,System.Double)">
			<summary>solve the semi-definite programming problem using the Homogeneous Self-Dual Path-Following algorithm</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.HomogeneousPathFollowing.Solution.search(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.CentralPath)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.HomogeneousPathFollowing.Solution.step">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.HomogeneousPathFollowing.Solution.svecA">
			<summary>Toh, Todd, Tütüncü, Section 3.1, A^</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.CentralPath">
			<summary>A central path is a solution to both the primal and dual problems of a semi-definite programming problem.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 14.3.3, Central Path,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.CentralPath.X">
			<summary>This is the minimizer for the primal problem.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.CentralPath.y">
			<summary>This is the maximizer for the dual problem.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.CentralPath.S">
			<summary>This is the auxiliary helper to solve the dual problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.pathfollowing.CentralPath.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a central path.</summary>
			<param name="X">the minimizer for the primal problem</param>
			<param name="y">the maximizer for the dual problem</param>
			<param name="S">the auxiliary helper to solve the dual problem</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPPrimalProblem">
			<summary>A Primal SDP problem, as in eq. 14.1 in the reference, takes the following form.
 \[
 \min_x \mathbf{c&apos;x} \textrm{, s.t., } \\
 \mathbf{Ax} = \mathbf{b}, \mathbf{x} \geq \mathbf{0}
 \]<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Section 14.2, Primal and Dual SDP Problems,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPPrimalProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix[])">
			<summary>Construct a primal SDP problem.
 \[
 \min_x \mathbf{c&apos;x} \textrm{, s.t., } \\
 \mathbf{Ax} = \mathbf{b}, \mathbf{x} \geq \mathbf{0}
 \]</summary>
			<param name="C">\(C\)</param>
			<param name="A">\(A\)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPPrimalProblem.n">
			<summary>Get the dimension of the system, i.e., the dimension of <i>x</i>, the number of variables.</summary>
			<returns>the dimension of the system</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPPrimalProblem.p">
			<summary>Get the size of <i>b</i>.</summary>
			<returns>the size of <i>b</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPPrimalProblem.C">
			<summary>Get <i>C</i>.</summary>
			<returns><i>C</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPPrimalProblem.A(System.Int32)">
			<summary>Get <i>A<sub>i</sub></i>.</summary>
			<param name="i">an index to the A&apos;s, counting from 1</param>
			<returns><i>A<sub>i</sub></i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem">
			<summary>A dual SDP problem, as in eq. 14.4 in the reference, takes the following form.
 \[
 \max_y \mathbf{b&apos;y} \textrm{, s.t., } \\
 \sum_{i=1}^{p}y_i\mathbf{A_i}+\textbf{S} = \textbf{C}, \textbf{S} \succeq \textbf{0}
 \]<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Section 14.2, Primal and Dual SDP Problems,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix[])">
			<summary>Construct a dual SDP problem.
 \[
 \max_y \mathbf{b&apos;y} \textrm{, s.t., } \\
 \sum_{i=1}^{p}y_i\mathbf{A_i}+\textbf{S} = \textbf{C}, \textbf{S} \succeq \textbf{0}
 \]</summary>
			<param name="b">\(b\)</param>
			<param name="C">\(C\)</param>
			<param name="A">\(A\)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem.n">
			<summary>Get the dimension of the square matrices <i>C</i> and <i>A</i>s.</summary>
			<returns>the dimension of the matrices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem.p">
			<summary>Get the dimension of the system, i.e., <i>p</i> = the dimension of <i>y</i>, the number of variables.</summary>
			<returns>the dimension of the system</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem.b">
			<summary>Get <i>b</i>.</summary>
			<returns><i>b</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem.C">
			<summary>Get <i>C</i>.</summary>
			<returns><i>C</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem.A(System.Int32)">
			<summary>Get <i>A<sub>i</sub></i>.</summary>
			<param name="i">an index to the A&apos;s, counting from 1</param>
			<returns><i>A<sub>i</sub></i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem.EqualityConstraints">
			<summary>This is the collection of equality constraints:
 \[
 \sum_{i=1}^{p}y_i\mathbf{A_i}+\textbf{S} = \textbf{C}, \textbf{S} \succeq \textbf{0}
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem.EqualityConstraints.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.matrixtype.dense.triangle.SymmetricMatrix[])">
			<summary>Construct the equality constraints for a dual SDP problem, \(\sum_{i=1}^{p}y_i\mathbf{A_i}+\textbf{S} = \textbf{C}, \textbf{S} \succeq \textbf{0}\).</summary>
			<param name="b">\(b\)</param>
			<param name="C">\(C\)</param>
			<param name="A">\(A\)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem.EqualityConstraints.getConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem.EqualityConstraints.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.problem.SDPDualProblem.EqualityConstraints.size">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.ZeroPenalty">
			<summary>This is a dummy zero cost (no cost) penalty function.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.ZeroPenalty.#ctor(System.Int32)">
			<summary>Construct a no-cost penalty function.</summary>
			<param name="dimension">the problem dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.ZeroPenalty.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.ZeroPenalty.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.SumOfPenalties">
			<summary>This penalty function sums up the costs from a set of constituent penalty functions.
 This builds a new composite penalty function from existing simpler ones.
 It applies to any constrained optimization problems.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.SumOfPenalties.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyFunction[])">
			<summary>Construct a sum-of-penalties penalty function from a set of penalty functions.
 The penalties must have the same dimension.</summary>
			<param name="penalties">the constituent penalty functions</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.SumOfPenalties.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.SumOfPenalties.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyMethodMinimizer">
			<summary>The penalty method is an algorithm for solving a constrained minimization problem with general constraints.
 It replaces a constrained optimization problem by a series of unconstrained problems
 whose solutions ideally converge to the solution of the original constrained problem.
 The unconstrained problems are formed by adding a term to the objective function
 that consists of a penalty parameter and a measure of violation of the constraints.
 The measure of violation is zero in the feasible region and is positive when the constraints are violated.
 <para/>
 In this implementation, we use only one iteration.
 In this iteration, we multiply the penalties by ɣ, which is a very big number, to penalize a solution outside the feasible region.
 This is to mimic when ɣ approaches infinity.
 A classical unconstrained minimization algorithm is then applied to the modified problem.
 It can be shown that if the penalty is large enough, the original and modified problems have the same solution.<para> See also: </para><list type="bullet">
 <item>@see <a href="http://en.wikipedia.org/wiki/penalty_method">Wikipedia: Penalty method</a></item>
 <item>&quot;R. Fletcher, &quot;Section 22.4, Penalty Methods, Chapter 22, Non-differentiable Optimization,&quot; Practical Methods of Optimization. 2nd ed. Wiley. May 2000.&quot;</item>
 </list></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyMethodMinimizer.DEFAULT_PENALTY_FUNCTION_FACTORY">
			<summary>the default penalty function factory</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyMethodMinimizer.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyMethodMinimizer.PenaltyFunctionFactory,System.Double,com.numericalmethod.suanshu.optimization.multivariate.unconstrained.MultivariateMinimizer)">
			<summary>Construct a constrained minimizer using the penalty method.</summary>
			<param name="penaltyFunctionFactory">a factory to construct a penalty function from a constrained optimization problem</param>
			<param name="gamma">the ɣ as in R. Fletcher</param>
			<param name="minimizer">an unconstrained minimization solver</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyMethodMinimizer.#ctor(System.Double)">
			<summary>Construct a constrained minimizer using the penalty method.
 ɣ should be big enough to reflect the penalty, but it cannot be too big to overflow the computations (to produce NaNs).
 It is recommended to experiment different ɣ&apos;s to get better results.</summary>
			<param name="gamma">the ɣ as in R. Fletcher</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyMethodMinimizer.#ctor">
			<summary>Construct a constrained minimizer using the penalty method.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyMethodMinimizer.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyMethodMinimizer.PenaltyFunctionFactory">
			<summary>For each constrained optimization problem, the solver creates a new penalty function for it.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyMethodMinimizer.PenaltyFunctionFactory.getPenaltyFunction(com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblem)">
			<summary>Get an instance of the penalty function.</summary>
			<param name="problem">a constrained optimization problem</param>
			<returns>the penalty function</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyFunction">
			<summary>A function P: R<sup>n</sup> -&gt; R is a penalty function for a constrained optimization problem if it has these properties.
 <list type="bullet">
 <item>P is continuous;</item>
 <item>P(x) &gt;= 0;</item>
 <item>P(x) = 0 if x is feasible; i.e., all constraints are satisfied</item>
 </list><para> See also: </para>&quot;Edwin K. P. Chong, Stanislaw H. Zak. &quot;Definition 22.1. Chapter 22. Algorithms for Constrained Optimization,&quot; An Introduction to Optimization. Wiley-Interscience. 2001.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyFunction.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.PenaltyFunction.dimensionOfRange">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.MultiplierPenalty">
			<summary>A multiplier penalty function allows different weights to be assigned to the constraints.<para> See also: </para>&quot;R. Fletcher, &quot;Section 12.2. Multiplier PenaltyFunction Function,&quot; Practical Method of Optimization Vol. 2. Constrained Optimization. Wiley, 1981.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.MultiplierPenalty.weights">
			<summary>the weights for the constraints</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.MultiplierPenalty.constraints">
			<summary>the constraint/cost functions</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.MultiplierPenalty.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.Constraints,System.Double[])">
			<summary>Construct a multiplier penalty function from a collection of constraints.</summary>
			<param name="constraints">a collection of constraints</param>
			<param name="weights">the weights assigned to the constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.MultiplierPenalty.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.Constraints,System.Double)">
			<summary>Construct a multiplier penalty function from a collection of constraints.
 We assign the same weight to all constraints.</summary>
			<param name="constraints">a collection of equality constraints</param>
			<param name="weight">the same weight assigned to all constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.MultiplierPenalty.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.Constraints)">
			<summary>Construct a multiplier penalty function from a collection of constraints.
 We assign the same default weight, 1.0, to all constraints.</summary>
			<param name="constraints">a collection of constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.MultiplierPenalty.dimensionOfDomain">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.FletcherPenalty">
			<summary>This penalty function sums up the squared costs penalties.
 It applies to inequality constrained problems.<para> See also: </para>&quot;R. Fletcher, &quot;An ideal penalty function for constrained optimization,&quot; J. Inst. Maths Applns, 15, 319 - 342. 1975.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.FletcherPenalty.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.LessThanConstraints,System.Double[])">
			<summary>Construct a Fletcher penalty function from a collection of inequality constraints.</summary>
			<param name="constraints">a collection of inequality constraints</param>
			<param name="weights">the weights assigned to the constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.FletcherPenalty.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.LessThanConstraints,System.Double)">
			<summary>Construct a Fletcher penalty function from a collection of inequality constraints.
 We assign the same weight to all constraints.</summary>
			<param name="constraints">a collection of inequality constraints</param>
			<param name="weight">the same weight assigned to the constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.FletcherPenalty.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.LessThanConstraints)">
			<summary>Construct a Fletcher penalty function from a collection of inequality constraints.
 We assign the same default weight to all constraints.</summary>
			<param name="constraints">a collection of inequality constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.FletcherPenalty.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.CourantPenalty">
			<summary>This penalty function sums up the squared error penalties.
 It applies to equality constrained problems.<para> See also: </para>&quot;R. CourantPenalty, &quot;Variational methods for the solution of problems of equilibrium and vibration,&quot; Bull. Amer. Math. Soc., 49, 1- 23. 1943.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.CourantPenalty.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints,System.Double[])">
			<summary>Construct a CourantPenalty penalty function from a collection of equality constraints.</summary>
			<param name="constraints">a collection of equality constraints</param>
			<param name="weights">the weights assigned to the constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.CourantPenalty.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints,System.Double)">
			<summary>Construct a CourantPenalty penalty function from a collection of equality constraints.
 We assign the same weight to all constraints.</summary>
			<param name="constraints">a collection of equality constraints</param>
			<param name="weight">the same weight assigned to the constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.CourantPenalty.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints)">
			<summary>Construct a CourantPenalty penalty function from a collection of equality constraints.
 We assign the same default weight to all constraints.</summary>
			<param name="constraints">a collection of equality constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.CourantPenalty.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.AbsoluteErrorPenalty">
			<summary>This penalty function sums up the absolute error penalties.
 It applies to equality constrained problems.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.AbsoluteErrorPenalty.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints,System.Double[])">
			<summary>Construct an absolute error penalty function from a collection of equality constraints.</summary>
			<param name="constraints">a collection of equality constraints</param>
			<param name="weights">the weights assigned to the constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.AbsoluteErrorPenalty.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints,System.Double)">
			<summary>Construct an absolute error penalty function from a collection of equality constraints.
 This assigns the same weight to all constraints.</summary>
			<param name="constraints">a collection of equality constraints</param>
			<param name="weight">the same weight assigned to all constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.AbsoluteErrorPenalty.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints)">
			<summary>Construct an absolute error penalty function from a collection of equality constraints.
 We assign the same default weight to all constraints.</summary>
			<param name="constraints">a collection of equality constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.penaltymethod.AbsoluteErrorPenalty.evaluate(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation2">
			<summary>This implementation tries to find an exact positive definite Hessian whenever possible.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation2.#ctor(System.Double,System.Double,System.Int32)">
			<summary>Construct a variation.</summary>
			<param name="r">Han&apos;s exact penalty function coefficient, the bigger the better, e.g., eq. 15.20</param>
			<param name="lower">the lower bound of alpha; the smaller the better but cannot be zero</param>
			<param name="discretization">the number of points between <i>[lower, 1]</i> to search for alpha; the bigger the better</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation2.#ctor">
			<summary>Construct a variation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation2.updateHessian(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1">
			<summary>This implementation is a modified version of the algorithm in the reference to solve a general constrained minimization problem
 using Sequential Quadratic Programming.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Section 15.3.2, Algorithm 15.4b, SQP algorithm for nonlinear problems with equality and inequality constraints,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.f">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.a">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.p">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.r">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.lower">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.discretization">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.foundPositiveDefiniteHessian">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.epsilon">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.#ctor(System.Double,System.Double,System.Int32)">
			<summary>Construct a variation.</summary>
			<param name="r">Han&apos;s exact penalty function coefficient, the bigger the better, e.g., eq. 15.20</param>
			<param name="lower">the lower bound of alpha; the smaller the better but cannot be zero</param>
			<param name="discretization">the number of points between <i>[lower, 1]</i> to search for alpha; the bigger the better</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.#ctor">
			<summary>Construct a variation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.set(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints)">
			<summary>Associate this variation to a particular general constrained minimization problem with only equality constraints.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="equal">the equality constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.getInitialHessian(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.W(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Compute <i>W</i>.<para> See also: </para>&quot;15.4b&quot;</summary>
			<param name="x">the current minimizer</param>
			<param name="u">the Lagrange multipliers for inequality constraints (mu)</param>
			<returns><i>W</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.updateHessian(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation1.alpha(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation">
			<summary>This interface allows customization of certain operations in the Active Set algorithm to solve a general constrained minimization problem with only equality constraints
 using Sequential Quadratic Programming.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation.getInitialHessian(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Get the initial Hessian matrix.</summary>
			<param name="x0">the initial minimizer</param>
			<param name="u0">the initial Lagrange multipliers for inequality constraints (mu)</param>
			<returns>the initial Hessian matrix, e.g., identity</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation.updateHessian(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Update the Hessian matrix using the latest iterates.</summary>
			<param name="x1">the next minimizer</param>
			<param name="u1">the next Lagrange multipliers for inequality constraints (mu)</param>
			<param name="d">the minimizer increment</param>
			<param name="g0">the gradient</param>
			<param name="A0">the set of active equality constraints</param>
			<param name="W0">the current Hessian matrix</param>
			<returns>the next Hessian matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPASEVariation.alpha(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Get the percentage increment along the minimizer increment direction.</summary>
			<param name="x">the current minimizer</param>
			<param name="d">the minimizer increment</param>
			<param name="u">the Lagrange multipliers for inequality constraints (mu)</param>
			<returns>the percentage increment</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPActiveSetSolverForOnlyEqualityConstraint2">
			<summary>This particular implementation of <para></para>SQPActiveSetSolverForOnlyEqualityConstraint1 uses <para></para>SQPASEVariation2.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPActiveSetSolverForOnlyEqualityConstraint2.#ctor(System.Double,System.Int32)">
			<summary>Construct an SQP Active Set minimizer to solve general minimization problems with equality constraints.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPActiveSetSolverForOnlyEqualityConstraint2.#ctor(System.Double,System.Double,System.Int32,System.Double,System.Int32)">
			<summary>Construct an SQP Active Set minimizer to solve general minimization problems with equality constraints.</summary>
			<param name="r">Han&apos;s exact penalty function coefficient, the bigger the better, e.g., eq. 15.20</param>
			<param name="lower">the lower bound of alpha; the smaller the better but cannot be zero</param>
			<param name="discretization">the number of points between <i>[lower, 1]</i> to search for alpha; the bigger the better</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPActiveSetSolverForOnlyEqualityConstraint1">
			<summary>This implementation is a modified version of Algorithm 15.1 in the reference to solve a general constrained optimization problem with only equality constraints.
 \[
 \min_x f(x) \textrm{ s.t.,} \\
 a_i(x) = 0, i = 1, 2, ..., p\\
 \]<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu. &quot;Algorithm 15.1, SQP Problems with equality Constraints,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPActiveSetSolverForOnlyEqualityConstraint1.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPActiveSetSolverForOnlyEqualityConstraint1.VariationFactory,System.Double,System.Int32)">
			<summary>Construct an SQP Active Set minimizer to solve general minimization problems with equality constraints.</summary>
			<param name="variant">specify an implementation to use</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPActiveSetSolverForOnlyEqualityConstraint1.#ctor(System.Double,System.Int32)">
			<summary>Construct an SQP Active Set minimizer to solve general minimization problems with equality constraints.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPActiveSetSolverForOnlyEqualityConstraint1.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPActiveSetSolverForOnlyEqualityConstraint1.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints)">
			<summary>Minimize a function subject to only equality constraints.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="equal">the equality constraints</param>
			<returns>a solution to the minimization problem</returns>
			<exception cref="T:java.lang.Exception">when there is an error solving the problem</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPActiveSetSolverForOnlyEqualityConstraint1.VariationFactory">
			<summary>This factory constructs a new instance of <c>SQPASEVariation</c> for each SQP problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.equalityconstraint.SQPActiveSetSolverForOnlyEqualityConstraint1.VariationFactory.newVariation(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints)">
			<summary>Construct a new instance of <c>SQPASEVariation</c> for an SQP problem.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="equal">the equality constraints</param>
			<returns>a new instance of <c>SQPASEVariation</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPASVariation1">
			<summary>This implementation is a modified version of Algorithm 15.4 in the reference to solve a general constrained minimization problem
 using Sequential Quadratic Programming.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 15.4, SQP algorithm for nonlinear problems with equality and inequality constraints,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPASVariation1.#ctor(System.Double)">
			<summary>Construct a variation.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPASVariation1.set(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.GreaterThanConstraints)">
			<summary>Associate this variation to a particular general constrained minimization problem.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="equal">the equality constraints</param>
			<param name="greater">the greater-than-or-equal-to constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPASVariation1.getInitialHessian(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPASVariation1.updateHessian(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary><para> See also: </para>&quot;eqs. 15.41 - 15.44&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPASVariation1.alpha(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary><para> See also: </para>&quot;eq. 15.36&quot;</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPASVariation">
			<summary>This interface allows customization of certain operations in the Active Set algorithm to solve a general constrained minimization problem
 using Sequential Quadratic Programming.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPASVariation.getInitialHessian(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Get the initial Hessian matrix.</summary>
			<param name="x0">the initial minimizer</param>
			<param name="v0">the initial Lagrange multipliers for equality constraints (lambda)</param>
			<param name="u0">the initial Lagrange multipliers for inequality constraints (mu)</param>
			<returns>the initial Hessian matrix, e.g., identity</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPASVariation.updateHessian(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Update the Hessian matrix using the latest iterates.</summary>
			<param name="x1">the next minimizer</param>
			<param name="v1">the next Lagrange multipliers for equality constraints (lambda)</param>
			<param name="u1">the next Lagrange multipliers for inequality constraints (mu)</param>
			<param name="d">the minimizer increment</param>
			<param name="g0">the gradient</param>
			<param name="Ae0">the set of active equality constraints</param>
			<param name="Ai0">the set of active inequality constraints</param>
			<param name="W0">the current Hessian matrix</param>
			<returns>the next Hessian matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPASVariation.alpha(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Get the percentage increment along the minimizer increment direction.</summary>
			<param name="x">the current minimizer</param>
			<param name="d">the minimizer increment</param>
			<param name="v">the Lagrange multipliers for equality constraints (lambda)</param>
			<param name="u">the Lagrange multipliers for inequality constraints (mu)</param>
			<returns>the percentage increment</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolverForOnlyInequalityConstraint">
			<summary>This implementation is a modified version of Algorithm 15.2 in the reference to solve a general constrained optimization problem with only inequality constraints.
 \[
 \min_x f(x) \textrm{ s.t.,} \\
 c_j(x) = 0, j = 1, 2, ..., q\\
 \]<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 15.2, SQP algorithm for nonlinear problems with inequality constraint,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolverForOnlyInequalityConstraint.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.VariationFactory,System.Double,System.Double,System.Int32)">
			<summary>Construct an SQP Active Set minimizer to solve general minimization problems with only inequality constraints.</summary>
			<param name="variant">a factory that constructs a new instance of <c>SQPASVariation</c> for each problem</param>
			<param name="epsilon1">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0; for the SQP solver</param>
			<param name="epsilon2">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0; for the embedded QP solver; suggested value = 0.</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolverForOnlyInequalityConstraint.#ctor(System.Double,System.Double,System.Int32)">
			<summary>Construct an SQP Active Set minimizer to solve general minimization problems with only inequality constraints.</summary>
			<param name="epsilon1">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0; for the SQP solver</param>
			<param name="epsilon2">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0; for the embedded QP solver; suggested value = 0.</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolverForOnlyInequalityConstraint.#ctor(System.Double,System.Int32)">
			<summary>Construct an SQP Active Set minimizer to solve general minimization problems with only inequality constraints.</summary>
			<param name="epsilon1">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolverForOnlyInequalityConstraint.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.GreaterThanConstraints)">
			<summary>Minimize a function subject to only inequality constraints.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="greater">the greater-than-or-equal-to constraints</param>
			<returns>a solution to the minimization problem</returns>
			<exception cref="T:java.lang.Exception">when there is an error solving the problem</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolverForOnlyInequalityConstraint.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolverForOnlyInequalityConstraint.Solution">
			<summary>This is the solution to a general minimization problem with only inequality constraints using the SQP Active Set algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolverForOnlyInequalityConstraint.Solution.search(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver">
			<summary>Sequential quadratic programming (SQP) is an iterative method for nonlinear optimization.
 SQP methods are used on problems for which the objective function and the constraints are twice
 continuously differentiable.
 SQP methods solve a sequence of optimization subproblems,
 each which optimizes a quadratic model of the objective subject to a linearization of the
 constraints.
 If the problem is unconstrained, then the method reduces to Newton&apos;s method for finding a point
 where the gradient of the objective vanishes.
 If the problem has only equality constraints, then the method is equivalent to applying Newton&apos;s
 method to the first-order optimality conditions,
 or Karush-Kuhn-Tucker conditions, of the problem.
 SQP methods are the state of the art in nonlinear programming methods.
 Schittkowski has shown that SQP can outperform every other tested method in terms of efficiency,
 accuracy, and percentage of successful solutions,
 over a large number of test problems.
 The general minimization problem takes this form.
 \[
 \min_x f(x) \textrm{ s.t.,} \\
 a_i(x) = 0, i = 1, 2, ..., p\\
 c_j(x) \geq 0, j = 1, 2, ..., q
 \]<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/sequential_quadratic_programming">Wikipedia: Sequential
 quadratic programming</a></item>
 <item><a href="http://en.wikipedia.org/wiki/active_set">Wikipedia: Active set</a></item>
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 15.4, SQP algorithm for nonlinear problems with
 equality and inequality constraints,&quot; Practical Optimization: Algorithms and Engineering
 Applications.&quot;</item>
 </list></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.epsilon1">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.epsilon2">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.maxIterations">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.VariationFactory,System.Double,System.Double,System.Int32)">
			<summary>Construct an SQP Active Set minimizer to solve general minimization problems with inequality
 constraints.</summary>
			<param name="variant">a factory that constructs a new instance of <c>SQPASVariation</c> for
                      each problem</param>
			<param name="epsilon1">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0; for the SQP solver</param>
			<param name="epsilon2">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0; for the embedded QP solver; suggested value = 0.</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.#ctor(System.Double,System.Double,System.Int32)">
			<summary>Construct an SQP Active Set minimizer to solve general minimization problems with inequality
 constraints.</summary>
			<param name="epsilon1">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0; for the SQP solver</param>
			<param name="epsilon2">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0; for the embedded QP solver; suggested value = 0.</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.#ctor(System.Double,System.Int32)">
			<summary>Construct an SQP Active Set minimizer to solve general minimization problems with inequality
 constraints.</summary>
			<param name="epsilon1">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0; for the SQP solver</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.VariationFactory">
			<summary>This factory constructs a new instance of <c>SQPASVariation</c> for each SQP problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.VariationFactory.newVariation(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.GreaterThanConstraints)">
			<summary>Construct a new instance of <c>SQPASVariation</c> for an SQP problem.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="equal">the equality constraints</param>
			<param name="greater">the greater-than-or-equal-to constraints</param>
			<returns>a new instance of <c>SQPASVariation</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.Solution">
			<summary>This is the solution to a general minimization with only inequality constraints using the SQP
 Active Set algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.Solution.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.GreaterThanConstraints)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.Solution.setInitials(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
			<param name="initials"><i>x<sub>0</sub></i> s.t., \(c_j(x_0) \geq 0, j = 1, 2, ..., q\);
 <i>&#955;<sub>0</sub></i>, the Lagrange multipliers for equality constraints (lambda);
 <i>&#956;<sub>0</sub> &amp;ge 0</i>, the Lagrange multipliers for inequality constraints (mu)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.Solution.step">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.Solution.search(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
			<param name="initials"><i>x<sub>0</sub></i> s.t., \(c_j(x_0) \geq 0, j = 1, 2, ..., q\);
 <i>&#955;<sub>0</sub></i>, the Lagrange multipliers for equality constraints (lambda);
 <i>&#956;<sub>0</sub> &amp;ge 0</i>, the Lagrange multipliers for inequality constraints (mu)</param>
			<returns>an (approximate) optimizer</returns>
			<exception cref="T:java.lang.Exception"></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.Solution.search(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Search for a solution that minimizes the objective function from the
 given starting point.</summary>
			<param name="x0">an initial guess s.t., \(c_j(x_0) \geq 0, j = 1, 2, ..., q\)</param>
			<returns>an (approximate) optimizer</returns>
			<exception cref="T:java.lang.Exception">when an error occurs during the search</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.Solution.search(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Search for a solution that minimizes the objective function from the
 given starting point.
 Note that <i>f(x<sub>0</sub>) &#8805; 0</i> and <i>&#956;<sub>0</sub> &#8805; 0</i></summary>
			<param name="x0"><i>x<sub>0</sub></i> s.t., \(c_j(x_0) \geq 0, j = 1, 2, ..., q\)</param>
			<param name="lambda0"><i>&#955;<sub>0</sub></i>, the Lagrange multipliers for equality
                constraints (lambda)</param>
			<param name="mu0"><i>&#956;<sub>0</sub> &amp;ge 0</i>, the Lagrange multipliers for inequality
                constraints (mu)</param>
			<returns>an (approximate) minimizer</returns>
			<exception cref="T:java.lang.Exception">when an error occurs during the search</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.Solution.minimum">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.general.sqp.activeset.SQPActiveSetSolver.Solution.minimizer">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.NonNegativityConstraintOptimProblem">
			<summary>This is a constrained optimization problem for a function which has all non-negative variables.
 \[
 \min_x f(x)
 \]
 s.t.,
 <blockquote><code><i>
 x &#8805; 0
 </i></code></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.NonNegativityConstraintOptimProblem.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary>Construct a constrained optimization problem with only non-negative variables.</summary>
			<param name="f">the objective function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.NonNegativityConstraintOptimProblem.getLessThanConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.NonNegativityConstraintOptimProblem.getEqualityConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.NonNegativityConstraintOptimProblem.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.NonNegativityConstraintOptimProblem.f">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblemImpl1">
			<summary>This implements a constrained optimization problem for a function <i>f</i> subject to equality
 and less-than-or-equal-to constraints.
 \[
 \min_x f(x)
 \]
 s.t.,
 <blockquote><code><i>
 h<sub>i</sub>(x) = 0
 g<sub>i</sub>(x) &#8804; 0
 </i></code></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblemImpl1.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.LessThanConstraints)">
			<summary>Construct a constrained optimization problem.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="equal">the collection of equality constraints; if the collection is empty, use
              <c>null</c>.</param>
			<param name="less">the collection of less-than-or-equal-to constraints; if the collection is empty,
              use <c>null</c>.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblemImpl1.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblemImpl1)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>ConstrainedOptimProblemImpl1</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblemImpl1.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblemImpl1.f">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblemImpl1.getLessThanConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblemImpl1.getEqualityConstraints">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblem">
			<summary>A constrained optimization problem takes this form.
 \[
 \min_x f(x)
 \]
 s.t.,
 <blockquote><code><i>
 h<sub>i</sub>(x) = 0
 g<sub>i</sub>(x) &#8804; 0
 </i></code></blockquote><para> See also: </para>&quot;Edwin K. P. Chong, Stanislaw H. Zak, &quot;Chapter 20, Problems with Inequality Constraints,&quot; An Introduction to Optimization. Wiley-Interscience, 2001.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblem.getLessThanConstraints">
			<summary>Get the less-than-or-equal-to constraints, <i>g<sub>i</sub>(x) &#8804; 0</i></summary>
			<returns>the less-than-or-equal-to constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.problem.ConstrainedOptimProblem.getEqualityConstraints">
			<summary>Get the equality constraints, <i>h<sub>i</sub>(x) = 0</i></summary>
			<returns>the equality constraints</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem">
			<summary>This implementation is an integral constrained minimization problem that has enumerable integral domains.
 That is, the integral variables have known and bounded integral domains.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.LessThanConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem.IntegerDomain[],System.Double)">
			<summary>Construct an integral constrained minimization problem with explicit integral domains.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="equal">the set of equality constraints. Use <c>null</c> if the set is empty.</param>
			<param name="less">the set of less-than-or-equal-to inequality constraints. Use <c>null</c> if the set is empty.</param>
			<param name="integers">the integral constraints</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem.IntegerDomain[],System.Double)">
			<summary>Construct an integral constrained minimization problem with explicit integral domains.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="integers">the integral constraints</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem.getIntegralConstraint(System.Int32)">
			<summary>Get the integral domain of a particular integral variable.</summary>
			<param name="index">the index of the integral variable, counting from 1</param>
			<returns>the integral domain</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem.IntegerDomain">
			<summary>This specifies the integral domain for an integral variable,
 i.e., the integer values the variable can take.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem.IntegerDomain.index">
			<summary>the index of an integral variable</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem.IntegerDomain.domain">
			<summary>the integer values the variable can take</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem.IntegerDomain.#ctor(System.Int32,System.Int32[])">
			<summary>Construct the integral domain for an integral variable.</summary>
			<param name="index">the index of an integral variable</param>
			<param name="domain">the integer values the variable can take</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem.IntegerDomain.#ctor(System.Int32,System.Int32,System.Int32)">
			<summary>Construct the integral domain for an integral variable.</summary>
			<param name="index">the index of an integral variable</param>
			<param name="lower">the lower bound of the integral domain</param>
			<param name="upper">the upperbound of the integral domain</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem.IntegerDomain.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary>Construct the integral domain for an integral variable.</summary>
			<param name="index">the index of an integral variable</param>
			<param name="lower">the lower bound of the integral domain</param>
			<param name="upper">the upperbound of the integral domain</param>
			<param name="inc">the increment</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPMinimizer">
			<summary>This implementation solves an integral constrained minimization problem by brute force search for
 all possible integer combinations.
 For each element in the Cartesian product, it fixes the integral variables to the integers. The
 problem then becomes a real valued minimization problem,
 which can be solved by another constrained minimization algorithm, e.g., Nelder-Mead or BFGS.
 The drawbacks are that: (1) the integral domains must be enumerable, hence bounded and known; (2)
 the performance is very slow.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPMinimizer.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPMinimizer.ConstrainedMinimizerFactory)">
			<summary>Construct a brute force minimizer to solve integral constrained minimization problems.</summary>
			<param name="factory">a factory that constructs a new instance of
                <c>ConstrainedMinimizerFactory</c> to solve a real valued minimization
                problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a brute force minimizer to solve integral constrained minimization problems.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPMinimizer.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPMinimizer.ConstrainedMinimizerFactory">
			<summary>This factory constructs a new instance of <c>ConstrainedMinimizer</c> to solve a real valued
 minimization problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPMinimizer.ConstrainedMinimizerFactory.newInstance">
			<summary>Construct a new instance of <c>ConstrainedMinimizer</c> to solve a real valued
 minimization problem.</summary>
			<returns>a new instance of a constrained minimizer</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPMinimizer.Solution">
			<summary>This is the solution to an integral constrained minimization using the brute-force search.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPMinimizer.Solution.search(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Search for a solution that minimizes the objective function from the
 given starting points.</summary>
			<param name="initials">the initial guesses of the non fixed double variables</param>
			<returns>an (approximate) minimizer</returns>
			<exception cref="T:java.lang.Exception">when an error occurs during the search</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPMinimizer.Solution.minimum">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.bruteforce.BruteForceIPMinimizer.Solution.minimizer">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblemImpl1">
			<summary>This is an implementation of a general Integer Programming problem in which some variables take only integers.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblemImpl1.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.LessThanConstraints,System.Int32[],System.Double)">
			<summary>Construct a constrained optimization problem with integral constraints.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="equal">the set of equality constraints; Use <c>null</c> if the set is empty.</param>
			<param name="less">the set of less-than-or-equal-to inequality constraints; Use <c>null</c> if the set is empty.</param>
			<param name="integers">the set of indices of the integral variables, counting from 1</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblemImpl1.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.EqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.LessThanConstraints,System.Int32[])">
			<summary>Construct a constrained optimization problem with integral constraints.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="equal">the set of equality constraints; Use <c>null</c> if the set is empty.</param>
			<param name="less">the set of less-than-or-equal-to inequality constraints; Use <c>null</c> if the set is empty.</param>
			<param name="integers">the set of indices of the integral variables, counting from 1</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblemImpl1.getIntegerIndices">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblemImpl1.getNonIntegralIndices(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblemImpl1.getFirstNonIntegralIndices(System.Double[])">
			<summary>Get the index of the first integral variable whose value is not an integer, violating the integral constraints.
 The indices count from 1.</summary>
			<param name="x">an argument to the objective function</param>
			<returns>the index of the first integral variable whose value is not an integer.
 0 indicates that the values of all integral variables in <i>x</i> are integers.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblemImpl1.epsilon">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblemImpl1.getLessThanConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblemImpl1.getEqualityConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblemImpl1.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblemImpl1.f">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblem">
			<summary>An Integer Programming problem is a mathematical optimization or feasibility program in which some or all of the variables are restricted to be integers.
 \[
 \min_x f(x) \textrm{ s.t.,} \\
 h_i(x) = 0 \\
 g_i(x) \leq 0
 \]
 Some {x<sub>i</sub>} are integers.<para> See also: </para><a href="http://en.wikipedia.org/wiki/integer_programming">Wikipedia: Integer programming</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblem.getIntegerIndices">
			<summary>Get the indices of the integral variables.</summary>
			<returns>the integral variable indices</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblem.getNonIntegralIndices(System.Double[])">
			<summary>Check which elements in <i>x</i> do not satisfy the integral constraints.
 The indices count from 1.</summary>
			<param name="x">an argument to the objective function</param>
			<returns>the set of indices of values in <i>x</i> that do not satisfy the integral constraints.
 An <c>int[]</c> of length 0 indicates that all integral variables in <i>x</i> are integers.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblem.epsilon">
			<summary>Get the threshold to check whether a variable is an integer.</summary>
			<returns>the precision parameter: when a number |x| &#8804; &#949;, it is considered 0</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPMinimizer">
			<summary>An Integer Programming minimizer minimizes an objective function subject to equality/inequality constraints as well as integral constraints.
 That is, some variables in the objective function are integers.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode">
			<summary>This is the branch-and-bound node used in conjunction with <para></para>ILPBranchAndBound to solve an Integer Linear Programming problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblem)">
			<summary>Construct a BB node and associate it with an ILP problem.</summary>
			<param name="problem">an ILP problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode.solution">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode.isCandidate">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode.branching">
			<summary>

 <para/>
 This implementation assumes
 <list type="bullet">
 <item>the parent node has a solution;</item>
 <item>the parent solution has more than 1 non-satisfying integral variable.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode.getLessThanConstraint(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary>Construct a less-than constraint for the branching less-than subproblem.</summary>
			<param name="minimizer">the node&apos;s solution</param>
			<param name="i">the index of a non-satisfying integral variable (the branching variable), counting from 1</param>
			<returns>a less-than constraint for the branching less-than subproblem</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode.getGreaterThanConstraint(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary>Construct a greater-than constraint for the branching greater-than subproblem.</summary>
			<param name="minimizer">the node&apos;s solution</param>
			<param name="i">the index of a non-satisfying integral variable (the branching variable), counting from 1</param>
			<returns>a greater-than constraint for the branching greater-than subproblem</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode.getLessThanConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode.getEqualityConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode.f">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPNode.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPBranchAndBound">
			<summary>This is a Branch-and-Bound algorithm that solves Integer Linear Programming problems.<para> See also: </para>&quot;Der-San Chen, Robert G. Batson, Yu Dang, &quot;11.1.2 Branch-and-Bound Algorithm, &quot; Applied Integer Programming: Modeling and Solution.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPBranchAndBound.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPBranchAndBound.ActiveListFactory)">
			<summary>Construct a Branch-and-Bound minimizer to solve Integer Linear Programming problems.</summary>
			<param name="factory">a factory that constructs a new instance of <c>ActiveList</c> for each problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPBranchAndBound.#ctor">
			<summary>Construct a Branch-and-Bound minimizer to solve Integer Linear Programming problems.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPBranchAndBound.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPBranchAndBound.ActiveListFactory">
			<summary>This factory constructs a new instance of <c>ActiveList</c> for each Integer Linear Programming problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.bb.ILPBranchAndBound.ActiveListFactory.newActiveList">
			<summary>Construct a new instance of <c>ActiveList</c> for an Integer Linear Programming problem.</summary>
			<returns>a new instance of <c>ActiveList</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.SimplexCuttingPlane">
			<summary>The use of cutting planes to solve Mixed Integer Linear Programming (MILP) problems was introduced by Ralph E Gomory.
 Cutting plane methods for MILP work by solving a non-integer linear program,
 the linear relaxation of the given integer program.
 The theory of Linear Programming dictates that under mild assumptions
 (if the linear program has an optimal solution, and if the feasible region does not contain a line),
 one can always find an extreme point or a corner point that is optimal.
 The obtained optimum is tested for being an integer solution.
 If it is not, there is guaranteed to exist a linear inequality that separates the optimum from the convex hull of the true feasible set.
 Finding such an inequality is the separation problem, and such an inequality is a cut.
 A cut can be added to the relaxed linear program. Then, the current non-integer solution is no longer feasible to the relaxation.
 This process is repeated until an optimal integer solution is found.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/cutting-plane_method">Wikipedia: Cutting-plane method</a></item>
 <item>&quot;Der-San Chen, Robert G. Batson, Yu Dang, &quot;11.2.1 Dual Cutting Place Approach,&quot; Applied Integer Programming: Modeling and Solution.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.SimplexCuttingPlane.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPSimplexSolver,com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.SimplexCuttingPlane.CutterFactory)">
			<summary>Construct a cutting-plane minimizer to solve an MILP problem.</summary>
			<param name="solver">a simplex solver to solve an LP problem</param>
			<param name="cutterFactory">a factory that constructs a new <c>Cutter</c> for each problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.SimplexCuttingPlane.solve(com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.SimplexCuttingPlane.CutterFactory">
			<summary>This factory constructs a new <c>Cutter</c> for each MILP problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.SimplexCuttingPlane.CutterFactory.getCutter(com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblem)">
			<summary>Construct a new <c>Cutter</c> for a MILP problem.</summary>
			<param name="problem">a MILP problem</param>
			<returns>a <c>Cutter</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.SimplexCuttingPlane.CutterFactory.Cutter">
			<summary>A <c>Cutter</c> defines how to cut a simplex table, i.e., how to relax a linear program so that
 the current non-integer solution is no longer feasible to the relaxation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.SimplexCuttingPlane.CutterFactory.Cutter.cut(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary>Cut a simplex table.
 For efficiency reason, the input <c>table</c> is changed after this operation.</summary>
			<param name="table">a simple table</param>
			<returns>a cut simplex table</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.GomoryPureCut">
			<summary>This cutting-plane implementation uses Gomory&apos;s pure cut method for pure integer programming,
 in which all variables are integral.<para> See also: </para>&quot;K. C. Toh, &quot;4.3 Gomory&apos;s mixed integer cutting plane method,&quot; MA4252: Discrete Optimization, NUS, 2011&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.GomoryPureCut.#ctor">
			<summary>Construct a Gomory pure cutting-plane minimizer to solve pure ILP problems,
 in which all variables are integral.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.GomoryPureCut.MyCutter">
			<summary>This is Gomory&apos;s pure cut.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.GomoryPureCut.MyCutter.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.PureILPProblem)">
			<summary>Construct a Gomory pure cutter.</summary>
			<param name="problem">a pure ILP problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.GomoryPureCut.MyCutter.cut(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.GomoryMixedCut">
			<summary>This cutting-plane implementation uses Gomory&apos;s mixed cut method.<para> See also: </para>&quot;K. C. Toh, &quot;4.3 Gomory&apos;s mixed integer cutting plane method,&quot; MA4252: Discrete Optimization, NUS, 2011.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.GomoryMixedCut.#ctor">
			<summary>Construct a Gomory mixed cutting-plane minimizer to solve an MILP problem.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.GomoryMixedCut.MyCutter">
			<summary>This is Gomory&apos;s mixed cut.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.GomoryMixedCut.MyCutter.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblem)">
			<summary>Construct a Gomory mixed cutter.</summary>
			<param name="problem">an MILP problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.cuttingplane.GomoryMixedCut.MyCutter.cut(com.numericalmethod.suanshu.optimization.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.SimplexTable)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.PureILPProblem">
			<summary>This is a pure integer linear programming problem, in which all variables are integral.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.PureILPProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints,System.Double)">
			<summary>Construct a pure ILP problem.</summary>
			<param name="cost">the linear objective function</param>
			<param name="greater">the greater-than-or-equal-to constraints</param>
			<param name="less">the less-than-or-equal-to constraints</param>
			<param name="equal">the equality constraints</param>
			<param name="bounds">the box constraints</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1">
			<summary>This implementation is an ILP problem, in which the variables can be real or integral.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearGreaterThanConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearLessThanConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.LinearEqualityConstraints,com.numericalmethod.suanshu.optimization.multivariate.constrained.constraint.linear.BoxConstraints,System.Int32[],System.Double)">
			<summary>Construct an ILP problem, in which the variables can be real or integral.</summary>
			<param name="cost">the linear objective function</param>
			<param name="greater">the greater-than-or-equal-to constraints</param>
			<param name="less">the less-than-or-equal-to constraints</param>
			<param name="equal">the equality constraints</param>
			<param name="bounds">the box constraints</param>
			<param name="integers">the indices of the integral variables</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.epsilon">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.getIntegerIndices">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.getNonIntegralIndices(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.getLessThanConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.getEqualityConstraints">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.f">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.c">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.A">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.b">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.Aeq">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.beq">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblemImpl1.isFree(System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.linear.problem.ILPProblem">
			<summary>A linear program in real variables is said to be integral if it has at least one optimal solution which is integral.
 It is both an linear programming problem and an integer programming problem.<para> See also: </para><a href="http://en.wikipedia.org/wiki/integer_linear_programming#integral_linear_programs">Wikipedia: Integral linear programs</a></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.initialization.UniformDistributionOverBox2">
			<summary>This algorithm, by perturbing each grid point by a small random scale,
 generates a set of initials uniformly distributed over a box region,
 with some degree of irregularity or randomness.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.UniformDistributionOverBox2.#ctor(System.Double,com.numericalmethod.suanshu.interval.RealInterval[],System.Int32[],com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct a generator to uniformly sample points over a feasible region.</summary>
			<param name="scale">the small percentage of disturbance, e.g., 10%</param>
			<param name="bounds">the feasible box region</param>
			<param name="discretizations">the number of discretization levels in each dimension (bound)</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.UniformDistributionOverBox2.#ctor(System.Double,com.numericalmethod.suanshu.interval.RealInterval[],System.Int32[])">
			<summary>Construct a generator to uniformly sample points over a feasible region.</summary>
			<param name="scale">the small percentage of disturbance, e.g., 10%</param>
			<param name="bounds">the feasible box region</param>
			<param name="discretizations">the number of discretization in each dimension (bound)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.UniformDistributionOverBox2.#ctor(System.Double,com.numericalmethod.suanshu.interval.RealInterval[],System.Int32,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct a generator to uniformly sample points over a feasible region.</summary>
			<param name="scale">the small percentage of disturbance, e.g., 10%</param>
			<param name="bounds">the feasible box region</param>
			<param name="discretization">the number of discretization in each dimension (bound)</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.UniformDistributionOverBox2.#ctor(System.Double,com.numericalmethod.suanshu.interval.RealInterval[],System.Int32)">
			<summary>Construct a generator to uniformly sample points over a feasible region.</summary>
			<param name="scale">the small percentage of disturbance, e.g., 10%</param>
			<param name="bounds">the feasible box region</param>
			<param name="discretization">the number of discretization in all dimensions (bounds)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.UniformDistributionOverBox2.getInitials(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.UniformDistributionOverBox2.getInitials">
			<summary>Generate a set of initial points for optimization.</summary>
			<returns>a full set of initial points</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.initialization.UniformDistributionOverBox1">
			<summary>This algorithm, by sampling uniformly in each dimension,
 generates a set of initials uniformly distributed over a box region,
 with some degree of irregularity or randomness.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.UniformDistributionOverBox1.#ctor(System.Int32,com.numericalmethod.suanshu.interval.RealInterval[])">
			<summary>Construct a generator to uniformly sample points over a feasible region.</summary>
			<param name="N">the number of initials to generate</param>
			<param name="bounds">the feasible box region</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.UniformDistributionOverBox1.seed(System.Int64[])">
			<summary>Seed the random number generator to produce repeatable sequences.</summary>
			<param name="seeds">the seeds</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.UniformDistributionOverBox1.getInitials(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.UniformDistributionOverBox1.getInitials">
			<summary>Generate a set of initial points for optimization.</summary>
			<returns>a full set of initial points</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.initialization.InitialsFactory">
			<summary>Some optimization algorithms, e.g., Nelder-Mead, Differential-Evolution, require a set of initial points to work with.
 In case there are fewer initial points supplied, we need to generate more by, e.g., guessing.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.InitialsFactory.getInitials(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Generate a set of initial points for optimization from the fewer than required points.</summary>
			<param name="initials">initial points; <c>null</c> if no initial supplied</param>
			<returns>a full set of initial points</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.initialization.DefaultSimplex">
			<summary>A simplex optimization algorithm, e.g., Nelder-Mead, requires an initial simplex to start the search.
 To create a simplex from an initial point, we add an increment factor to each component/direction of the point.
 The increments are computed as a percentage of the maximal absolute value of the components of the initial point.
 For an initial point of 0, we set the increment to 1.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.DefaultSimplex.#ctor(System.Double)">
			<summary>Construct a simplex builder.</summary>
			<param name="scale">a percentage (of the maximal absolute value of the components of the initial point)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.DefaultSimplex.#ctor">
			<summary>Construct a simplex builder.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.initialization.DefaultSimplex.getInitials(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Build a simplex of <i>N+1</i> vertices from an initial point, where <i>N</i> is the dimension of the initial points.</summary>
			<param name="initials">the initial points</param>
			<returns>a simplex</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.minmax.MinMaxProblem">
			<summary>A minmax problem is a decision rule used in decision theory, game theory, statistics and philosophy for minimizing the possible loss while maximizing the potential gain.
 Alternatively, it can be thought of as maximizing the minimum gain (maxmin).
 Given a family of error functions, parameterized by <i>&#969;</i>, we try to minimize their maximum.<para> See also: </para><a href="http://en.wikipedia.org/wiki/minimax">Wikipedia: Minimax</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.minmax.MinMaxProblem.error(System.Object)">
			<summary><i>e(x, &#969;)</i> is the error function, or the minmax objective, for a given <i>&#969;</i>.</summary>
			<param name="omega">a parameterization of a real scalar function</param>
			<returns>the error function for a given &#969;,
 <i>e(x, &#969;)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.minmax.MinMaxProblem.gradient(System.Object)">
			<summary><i>g(x, &#969;) = &#8711;|e(x, &#969;)|</i> is the gradient function of the <em>absolute</em> error, <i>|e(x, &#969;)|</i>, for a given <i>&#969;</i>.</summary>
			<param name="omega">a parameterization of a real scalar function</param>
			<returns><i>g<sub>&#969;</sub>(x)</i>, the gradient of the absolute error for a given <i>&#969;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.minmax.MinMaxProblem.getOmega">
			<summary>Get the list of omegas, the domain.</summary>
			<returns>the set of omegas</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.minmax.MinMaxMinimizer">
			<summary>A minmax minimizer minimizes a minmax problem.<para> See also: </para>MinMaxProblem</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.minmax.LeastPth">
			<summary>The least p-th minmax algorithm minimizes the maximal error/loss (function):
 \[
 \min_x \max_{\omega \in S} e(x, \omega)
 \]
 \(e(x, \omega)\) is the error or loss function.
 <para/>
 This implementation assumes the set <i>S</i> is discrete and finite.
 To use this to solve a continuous <i>S</i> set, a sampling of <i>S</i> is required.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 8.1.,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.minmax.LeastPth.#ctor(System.Double,System.Int32)">
			<summary>Construct a minmax minimizer using the Least p-th method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.minmax.LeastPth.solve(com.numericalmethod.suanshu.optimization.multivariate.minmax.MinMaxProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.ZangwillMinimizer">
			<summary>Zangwill&apos;s algorithm is an improved version of Powell&apos;s algorithm.
 It enhances the algorithm to generate a set of conjugate directions that are always linearly
 independent.
 Despite the &quot;improvement&quot;, in practice however,
 Zangwill&apos;s algorithm seems to produce results that are less accurate than those of Powell&apos;s
 algorithm.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 6.5,&quot; Practical Optimization: Algorithms and
 Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.ZangwillMinimizer.#ctor(System.Double,System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using the Zangwill method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="epsilon2">a precision parameter to decide whether there is a linear dependence
                      among the conjugate directions</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.ZangwillMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.ZangwillMinimizer.ZangwillImpl">
			<summary>an implementation of Zangwill&apos;s algorithm</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.ZangwillMinimizer.ZangwillImpl.#ctor(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.ZangwillMinimizer.ZangwillImpl.getIncrement(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.ZangwillMinimizer.ZangwillImpl.getDirection(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.PowellMinimizer">
			<summary>Powell&apos;s algorithm, starting from an initial point, performs a series
 of line searches in one iteration.
 The line search directions, except the last one, are all linearly independent.
 The major advantage of Powell’s algorithm is that
 the Hessian needs not be supplied, stored or manipulated.
 However, this algorithm has a few drawbacks and is superseded by Zangwill’s algorithm.
 For example, in an iteration, linear dependence can sometimes arise,
 which may fail to find complete the set of linearly independent directions that span
 <i>E<sup>n</sup></i>,
 even in the case of a convex quadratic problem.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Theorem 6.5, Algorithm 6.4,&quot; Practical Optimization:
 Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.PowellMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using the Powell method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.PowellMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.PowellMinimizer.PowellImpl">
			<summary>an implementation of Powell&apos;s algorithm</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.PowellMinimizer.PowellImpl.#ctor(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.PowellMinimizer.PowellImpl.getIncrement(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.PowellMinimizer.PowellImpl.getDirection(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.FletcherReevesMinimizer">
			<summary>The Fletcher-Reeves method is a variant of the Conjugate-Gradient method.
 Instead of finding the minimizer along a direction using an analytical formula
 as in <para></para>ConjugateGradientMinimizer, it uses a line search.
 The advantages are:
 <list type="bullet">
 <item>The modification renders the method more amenable to
 the minimization of non-quadratic problems since a larger reduction can be achieved in <i>f(x)</i>
 along <i>d<sub>k</sub></i> at points outside the neighborhood of the solution.</item>
 <item>The modification does not compute the Hessian.</item>
 </list><para> See also: </para><list type="bullet">
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 6.3,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/fletcher-reeves#nonlinear_conjugate_gradient">Wikipedia: Conjugate gradient method</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.FletcherReevesMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using the Fletcher-Reeves method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.FletcherReevesMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.ConjugateGradientMinimizer">
			<summary>A conjugate direction optimization method is performed by using
 sequential line search along directions that bear a strict mathematical relationship to one another.
 In particular, this conjugate-gradient method generates a new search direction
 by adding a vector <i>&#946;<sub>k</sub>d<sub>k</sub></i> to the negative gradient <i>-g<sub>k+1</sub></i>.
 The algorithm was originally developed for quadratic problems.
 For convex quadratic problems, the algorithm converges in <i>n</i> iterations,
 where <i>n</i> is the number of variables.
 It still has good convergence properties when applied to non-quadratic problems.<para> See also: </para><list type="bullet">
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Theorem 6.4, Algorithm 6.2,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/conjugate_gradient">Wikipedia: Conjugate gradient method</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.ConjugateGradientMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using the Conjugate-Gradient method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.conjugatedirection.ConjugateGradientMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.linesearch.LineSearch">
			<summary>A line search is often used in another minimization algorithm to improve the current solution in one iteration step.
 It begins the search from the current solution along a minimization direction.
 A line search does not need to be very accurate but it needs to be quick.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.linesearch.LineSearch.Solution">
			<summary>This is the solution to a line search minimization.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.linesearch.LineSearch.Solution.linesearch(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Get the increment <i>&#945;</i> so that <i>f(x + &#945; * d)</i> is (approximately) minimized.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Section 2.6, Algorithm 4.6,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
			<param name="x">the initial position</param>
			<param name="d">the line search direction</param>
			<returns>the increment &#945;</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.linesearch.FletcherLineSearch">
			<summary>This is Fletcher&apos;s inexact line search method.
 An inexact line search is usually used in conjunction with a multi-dimensional optimization algorithm.
 It trades off the accuracy of the line search result with the amount of computation.
 A lot of optimization algorithms are shown to be quite tolerant to line search imprecision.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Section 2.6, Algorithms 4.6, 7.3,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.linesearch.FletcherLineSearch.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32)">
			<summary>Construct a line search minimizer using the Fletcher method.</summary>
			<param name="rho">a precision parameter; smaller &#961;, e.g., 0.1, gives better accuracy</param>
			<param name="sigma">a precision parameter; smaller &#963;, e.g., 0.1, gives better accuracy</param>
			<param name="tau">a control parameter to prevent the result from being too close to boundary</param>
			<param name="chi">a control parameter to prevent the result from being too close to boundary</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0. This affects the precision of the result.</param>
			<param name="maxIterations">the maximum number of iterations. This affects the precision of the result.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.linesearch.FletcherLineSearch.#ctor">
			<summary>Construct a line search minimizer using the Fletcher method with the default control parameters.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.linesearch.FletcherLineSearch.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.NelderMeadMinimizer">
			<summary>The Nelder-Mead method is a nonlinear optimization technique,
 which is well-defined for twice differentiable and unimodal problems.
 It starts with a simplex, and then uses operations
 reflection, expansion, contraction, and reduction to search for the minimum/maximum point.
 However, the Nelder-Mead technique is only a heuristic,
 since it can converge to non-stationary points on problems that can be solved by alternative
 methods.
 It does not always converge even for smooth problems.
 In practice, however, the performance is generally good.
 Note that one dimensional optimization by Nelder-Mead is unreliable.<para> See also: </para><a href="http://en.wikipedia.org/wiki/nelder-mead_method">Wikipedia: Nelder-Mead method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.NelderMeadMinimizer.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32)">
			<summary>Construct a Nelder-Mead multivariate minimizer.</summary>
			<param name="alpha">the reflection coefficient</param>
			<param name="gamma">the shrink/reduction coefficient</param>
			<param name="rho">the contraction coefficient</param>
			<param name="sigma">the shrink/reduction coefficient</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.NelderMeadMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a Nelder-Mead multivariate minimizer.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.NelderMeadMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.NelderMeadMinimizer.Solution">
			<summary>This is the solution to an optimization problem by the Nelder-Mead method.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.NelderMeadMinimizer.Solution.minimum">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.NelderMeadMinimizer.Solution.minimizer">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.NelderMeadMinimizer.Solution.search(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Perform a Nelder-Mead search from an initial simplex.</summary>
			<param name="simplex">the initial simplex for the search</param>
			<returns>the optimal point</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.NelderMeadMinimizer.Solution.setInitials(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.NelderMeadMinimizer.Solution.step">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.MultivariateMinimizer">
			<summary>This is a minimizer that minimizes a twice continuously differentiable, multivariate function.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.MultivariateMaximizer">
			<summary>A maximization problem is simply minimizing the negative of the objective function.
 This class is simply provided as a wrapper class to solve a maximization problem using a <para></para>MultivariateMinimizer.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.MultivariateMaximizer.#ctor(com.numericalmethod.suanshu.optimization.multivariate.unconstrained.MultivariateMinimizer)">
			<summary>Construct a multivariate maximizer to maximize an objective function.</summary>
			<param name="minimizer">a multivariate minimizer</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.MultivariateMaximizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a multivariate maximizer to maximize an objective function.
 By default, we use the NelderMead algorithm.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.MultivariateMaximizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.MultivariateMaximizer.Solution">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.MultivariateMaximizer.Solution.maximum">
			<summary>Get the maximum found.
 <para/>
 Caching the result is especially useful for an objective function that takes a long time to compute.</summary>
			<returns>the maximum found</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.MultivariateMaximizer.Solution.maximizer">
			<summary>Get the maximizer (solution) to the maximization problem.</summary>
			<returns>the maximizer</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.RankOneMinimizer">
			<summary>The Rank One method is a quasi-Newton method
 to solve unconstrained nonlinear optimization problems.
 It owes its name to the fact that correction matrix has a rank of unity.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Section 7.4, Algorithm 7.2, Table 7.1,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.RankOneMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using the Rank One method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.QuasiNewtonMinimizer">
			<summary>The Quasi-Newton methods in optimization are for finding local maxima and minima of functions.
 The Quasi-Newton methods are based on Newton&apos;s method to find the stationary point of a function,
 where the gradient is 0.
 Newton&apos;s method assumes that the function can be locally approximated as quadratic in the region
 around the optimum.
 It uses the first and second derivatives (gradient and Hessian) to find the stationary point.
 In the Quasi-Newton methods the Hessian matrix of the objective function needs not to be
 computed.
 The Hessian is updated by analyzing successive gradient vectors instead.<para> See also: </para><list type="bullet">
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 7.2, 7.3,&quot; Practical Optimization: Algorithms and
 Engineering Applications.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/quasi-newton_method">Wikipedia: Quasi-Newton
 method</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.QuasiNewtonMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using a Quasi-Newton method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.QuasiNewtonMinimizer.QuasiNewtonImpl">
			<summary>This is an implementation of the Quasi-Newton algorithm.
 A sub-class supplies the Hessian updating rule.</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.QuasiNewtonMinimizer.QuasiNewtonImpl.Sk">
			<summary>This is the approximate inverse of the Hessian matrix.
 An implementation of
 <para></para>#updateSk(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)
 modifies this incrementally.</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.QuasiNewtonMinimizer.QuasiNewtonImpl.gk">
			<summary>the gradient at the k-th iteration</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.QuasiNewtonMinimizer.QuasiNewtonImpl.dk">
			<summary>the line search direction at the k-th iteration</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.QuasiNewtonMinimizer.QuasiNewtonImpl.ak">
			<summary>the increment in the search direction</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.QuasiNewtonMinimizer.QuasiNewtonImpl.getDirection(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.QuasiNewtonMinimizer.QuasiNewtonImpl.getIncrement(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.PearsonMinimizer">
			<summary>This is the Pearson method.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Table 7.1,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.PearsonMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using the Pearson method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.McCormickMinimizer">
			<summary><para><c>DEPRECATED:</c> the McCormick algorithm does not seem to work well; need further investigation; don&apos;t use it. TODO. Use <para></para>BFGSMinimizer instead.</para>
This is the McCormick method.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Table 7.1,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.McCormickMinimizer.#ctor(System.Double,System.Int32)">
			<summary><para><c>DEPRECATED:</c> the McCormick algorithm does not seem to work well; need further investigation; don&apos;t use it. TODO. Use <para></para>BFGSMinimizer instead.</para>
Construct a multivariate minimizer using the McCormick method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.HuangMinimizer">
			<summary>Huang&apos;s updating formula is a family of formulas which encompasses
 the rank-one, DFP, BFGS as well as some other formulas.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Section 7.9, Table 7.1,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.HuangMinimizer.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using Huang&apos;s method.</summary>
			<param name="theta">&#952; in Huang&apos;s formula</param>
			<param name="phi">&#966; in Huang&apos;s formula</param>
			<param name="psi">&#968; in Huang&apos;s formula</param>
			<param name="omega">&#969; in Huang&apos;s formula</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.HuangMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.HuangMinimizer.HuangImpl">
			<summary>an implementation of Huang&apos;s formula.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.HuangMinimizer.HuangImpl.#ctor(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.DFPMinimizer">
			<summary>The Davidon-Fletcher-Powell method is a quasi-Newton method
 to solve unconstrained nonlinear optimization problems.
 This method maintains the symmetry and positive definiteness of the Hessian matrix.<para> See also: </para><list type="bullet">
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Section 7.5, Table 7.1,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/davidon%e2%80%93fletcher%e2%80%93powell_formula">Wikipedia: Davidon-Fletcher-Powell formula</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.DFPMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using the DFP method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.DFPMinimizer.updateHessianInverse(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>S<sub>k+1</sub> = S<sub>k</sub> + &#948;&#948;&apos; / &#947;&apos;&#948; - S&#947;&#947;&apos;S&apos; / &#947;&apos;S&#947;<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;eq. 7.29,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
			<param name="S">the inverse of a Hessian</param>
			<param name="gamma">&#947;</param>
			<param name="delta">&#948;</param>
			<returns>an updated Hessian matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.BFGSMinimizer">
			<summary>The Broyden-Fletcher-Goldfarb-Shanno method is a quasi-Newton method
 to solve unconstrained nonlinear optimization problems.
 The Hessian matrix of the objective function needs not to be computed at any stage.
 The Hessian is updated by analyzing successive gradient vectors instead.<para> See also: </para><list type="bullet">
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Eq. 7.57, Section 7.6,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/bfgs">Wikipedia: BFGS method</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.BFGSMinimizer.#ctor(System.Boolean,System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using the BFGS method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
			<param name="isFletcherSwitch">indicate whether to use the Fletcher switch</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.BFGSMinimizer.updateHessianInverse1(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>S<sub>k+1</sub> = S<sub>k</sub> + (1 + &#947;&apos;S&#947;/&#947;&apos;&#948;)/&#947;&apos;&#948; * &#948;&#948;&apos; -(&#948;&#947;&apos;S + S&#947;&#948;&apos;) / &#947;&apos;&#948;, where S = H<sup>-1</sup><para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;eq. 7.57,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</summary>
			<param name="S">the inverse of a Hessian</param>
			<param name="gamma">&#947;</param>
			<param name="delta">&#948;</param>
			<returns>an updated Hessian matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.BFGSMinimizer.updateHessianInverse2(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>P + &#947;&#947;&apos; / &#947;&apos;&#948; - P %*% &#947;&#947;&apos; %*% P / &#947;&apos;P&#948;, where P = S<sup>-1</sup> is the Hessian.</summary>
			<param name="S">the inverse of a Hessian</param>
			<param name="gamma">&#947;</param>
			<param name="delta">&#948;</param>
			<returns>an updated Hessian matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.BFGSMinimizer.dampedBFGSHessianUpdate(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Damped BFGS Hessian update.<para> See also: </para>&quot;Jorge Nocedal, Stephen Wright, &quot;Procedure 18.2, Damped BFGS Updating,&quot; Numerical Optimization.&quot;</summary>
			<param name="H">a Hessian matrix</param>
			<param name="gamma">&#947;</param>
			<param name="delta">&#948;</param>
			<returns>an updated Hessian matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.BFGSMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.BFGSMinimizer.BFGSImpl">
			<summary>an implementation of the BFGS algorithm</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.quasinewton.BFGSMinimizer.BFGSImpl.#ctor(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer">
			<summary>A steepest descent algorithm finds the minimum by moving along the negative of the steepest gradient direction.
 In each iteration, we compute a direction, e.g., <i>d<sub>k</sub> = -g</i> as in the first order approximation.
 We search along this direction for an improved minimizer by analytically computing
 <i>&#945;<sub>k</sub></i> that minimizes <i>f(x<sub>k</sub> + &#945;<sub>k</sub> * d<sub>k</sub>)</i>.
 The minimizer <i>x<sub>k+1</sub> = x<sub>k</sub> + &#945;<sub>k</sub> * d<sub>k</sub></i> is updated.
 This procedure is repeated until the increment <i>|&#945;<sub>k</sub> * d<sub>k</sub>|</i> becomes sufficiently small, hence convergence.<para> See also: </para><list type="bullet">
 <item>&quot;Andreas Antoniou and Wu-Sheng Lu, &quot;Algorithms 5.2, 5.3, 5.5,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/gradient_descent">Wikipedia: Gradient descent</a></item>
 </list></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.epsilon">
			<summary>a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.maxIterations">
			<summary>the maximum number of iterations</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.#ctor(com.numericalmethod.suanshu.optimization.multivariate.unconstrained.linesearch.LineSearch,System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using a steepest descent method.</summary>
			<param name="linesearch">the line search method used in each iteration</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using a steepest descent method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary>Solve a minimization problem with a C<sup>2</sup> objective function.</summary>
			<param name="problem">a minimization problem with a C<sup>2</sup> objective function</param>
			<returns>a minimizer</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.SteepestDescentImpl">
			<summary>This is an implementation of the steepest descent method.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.SteepestDescentImpl.problem">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.SteepestDescentImpl.linesearch">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.SteepestDescentImpl.#ctor(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.SteepestDescentImpl.getDirection(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Get the next search direction.</summary>
			<param name="xk">the current minimizer</param>
			<returns>the next search direction</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.SteepestDescentImpl.getIncrement(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Get the increment fraction, <i>&#945;<sub>k</sub></i>.</summary>
			<param name="xk">the current minimizer</param>
			<param name="dk">the search direction</param>
			<returns><i>&#945;<sub>k</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.SteepestDescentImpl.minimum">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.SteepestDescentImpl.minimizer">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.SteepestDescentImpl.search(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.SteepestDescentImpl.setInitials(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.SteepestDescentMinimizer.SteepestDescentImpl.step">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.NewtonRaphsonMinimizer">
			<summary>The Newton-Raphson method is a second order steepest descent method that is based on
 the quadratic approximation of the Taylor series.<para> See also: </para><a href="http://en.wikipedia.org/wiki/newton's_method_in_optimization">Wikipedia: Newton&apos;s method in optimization</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.NewtonRaphsonMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using the Newton-Raphson method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.NewtonRaphsonMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.NewtonRaphsonMinimizer.NewtonRaphsonImpl">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.NewtonRaphsonMinimizer.NewtonRaphsonImpl.#ctor(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.NewtonRaphsonMinimizer.NewtonRaphsonImpl.getDirection(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.GaussNewtonMinimizer">
			<summary>The Gauss-Newton method is a steepest descent method to minimize a real vector function in the form:
 /[
 f(x) = [f_1(x), f_2(x), ..., f_m(x)]&apos;
 /]
 The objective function is
 /[
 F(x) = f&apos; %*% f
 ]/<para> See also: </para><list type="bullet">
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 5.5,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/gauss%e2%80%93newton_algorithm">Wikipedia: Gauss-Newton algorithm</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.GaussNewtonMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using the Gauss-Newton method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.GaussNewtonMinimizer.solve(com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction,com.numericalmethod.suanshu.analysis.function.matrix.RntoMatrix)">
			<summary>Solve the minimization problem to minimize <i>F = vf&apos; * vf</i>.</summary>
			<param name="vf">a real vector function to be minimized</param>
			<param name="J">a function that computes the Jacobian of <i>f</i> for a given <i>x</i></param>
			<returns>a minimizer</returns>
			<exception cref="T:java.lang.Exception"></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.GaussNewtonMinimizer.solve(com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction)">
			<summary>Solve the minimization problem to minimize <i>F = vf&apos; * vf</i>.</summary>
			<param name="vf">a real vector function to be minimized</param>
			<returns>a minimizer</returns>
			<exception cref="T:java.lang.Exception"></exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.GaussNewtonMinimizer.MySteepestDescent">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.GaussNewtonMinimizer.MySteepestDescent.#ctor(System.Double,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.GaussNewtonMinimizer.MySteepestDescent.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.GaussNewtonMinimizer.MySteepestDescent.GaussNewtonImpl">
			<summary>an implementation of the Gauss-Newton algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.GaussNewtonMinimizer.MySteepestDescent.GaussNewtonImpl.#ctor(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem,com.numericalmethod.suanshu.analysis.function.matrix.RntoMatrix)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.GaussNewtonMinimizer.MySteepestDescent.GaussNewtonImpl.getDirection(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.FirstOrderMinimizer">
			<summary>This implements the steepest descent line search using the first order expansion of the Taylor&apos;s series.
 Specifically, we search along the negative gradient direction.<para> See also: </para><list type="bullet">
 <item>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 5.2,&quot; Practical Optimization: Algorithms and Engineering Applications.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/gradient_descent">Wikipedia: Gradient descent</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.FirstOrderMinimizer.#ctor(com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.FirstOrderMinimizer.Method,System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using the First-Order method.</summary>
			<param name="method">the method to do line search</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.FirstOrderMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a multivariate minimizer using the First-Order method.
 This line search is using Fletcher&apos;s inexact line search method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.FirstOrderMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.FirstOrderMinimizer.Method">
			<summary>the available methods to do line search</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.FirstOrderMinimizer.Method.IN_EXACT_LINE_SEARCH">
			<summary>The line search is done using Fletcher&apos;s inexact line search method, <para></para>FletcherLineSearch.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.FirstOrderMinimizer.Method.ANALYTIC">
			<summary>The line search is done analytically.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.FirstOrderMinimizer.Method.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.unconstrained.steepestdescent.FirstOrderMinimizer.Method.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm">
			<summary>A genetic algorithm (GA) is a search heuristic that mimics the process of natural evolution.
 A population of strings (called chromosomes or the genotype of the genome),
 which encode candidate solutions to an optimization problem, evolves toward better solutions.
 The evolution usually starts from a population of randomly generated individuals and happens in
 generations.
 In each generation, the fitness of every individual in the population is evaluated,
 multiple individuals are stochastically selected from the current population (based on their
 fitness),
 and modified (recombined and possibly randomly mutated) to form a new population.
 The new population is then used in the next iteration of the algorithm.
 Commonly, the algorithm terminates when either a maximum number of generations has been produced,
 or a satisfactory fitness level has been reached for the population.
 If the algorithm has terminated due to a maximum number of generations, a satisfactory solution
 may or may not have been reached.
 <para/>
 This implementation is the meta evolutionary algorithm in the reference.
 It provides a framework for implementing multiple classes of evolutionary algorithms, e.g.,
 Genetic Algorithm, Differential Evolution.
 All methods are <c>protected</c> so any can be overridden to allow customization.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/differential_evolution">Wikipedia: Differential
 evolution</a></item>
 <item>&quot;Kenneth Price, Rainer M. Storn, Jouni A. Lampinen, &quot;Fig. 1.15, Meta-algorithm for evolution
 strategies (ESs),&quot; Differential Evolution: A Practical Approach to Global Optimization,
 2005.&quot;</item>
 </list></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.parallel">
			<summary>This indicate if the algorithm is to run in parallel (multi-core).</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.uniform">
			<summary>This is a uniform random number generator.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.population">
			<summary>This is the (current) population pool.
 <para/>
 An implementation must guarantee that this is sorted in descending order.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.#ctor(System.Boolean,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct an instance of this implementation of genetic algorithm.</summary>
			<param name="parallel"><c>true</c> if the algorithm is to run in parallel</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.getFirstGeneration">
			<summary>Initialize the first population.</summary>
			<returns>the first population</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.isConverged">
			<summary>This is the convergence criterion.</summary>
			<returns><c>true</c> if the search has converged</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.run">
			<summary>Run the genetic algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.step">
			<summary>Run a step in genetic algorithm: produce the next generation of chromosome pool.</summary>
			<returns>true</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.getChild(System.Int32)">
			<summary>Produce a child chromosome.
 <para/>
 This implementation first applies the crossover and then the mutation operators.</summary>
			<param name="i">an index that ranges from 0 to (population size - 1)</param>
			<returns>a child chromosome</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.getOne">
			<summary>Pick a chromosome for mutation/crossover.
 <para/>
 This implementation uniformly and randomly chooses from the population.</summary>
			<returns>a chromosome</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.getNextGeneration(java.util.List,java.util.List)">
			<summary>Populate the next generation using the parent and children chromosome pools.
 <para/>
 This implementation chooses the best chromosomes among the parents and children.</summary>
			<param name="parents">the parent chromosome pool</param>
			<param name="children">the children chromosome pool</param>
			<returns>the next generation population</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.nPopulation">
			<summary>Get the size of the population pool, that is the number of chromosomes.</summary>
			<returns>the population size</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.nChildren">
			<summary>Get the number of children before populating the next generation.
 <para/>
 In this implementation, it is the same as the population size (same as the number of
 parents).</summary>
			<returns>the number of children</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.getBest(System.Int32)">
			<summary>Get the <i>i</i>-th best chromosome.</summary>
			<param name="i">an index</param>
			<returns>the <i>i</i>-th best chromosome</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.GeneticAlgorithm.getNewPool(System.Int32)">
			<summary>Allocate space for a population pool.</summary>
			<param name="size">the population size</param>
			<returns>a population pool</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.Chromosome">
			<summary>A chromosome is a representation of a solution to an optimization problem.
 A genetic algorithm creates new chromosomes from existing ones by taking parts and combine them in new ways.
 As a genetic algorithm usually runs in a multi-core environment for performance,
 it is important to ensure that an implementation of the chromosome operations are thread-safe and can run in parallel.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.Chromosome.fitness">
			<summary>This is the fitness to determine how good this chromosome is.</summary>
			<returns>the fitness</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.Chromosome.mutate">
			<summary>Construct a <c>Chromosome</c> by mutation.</summary>
			<returns>a mutated chromosome</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.Chromosome.crossover(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.Chromosome)">
			<summary>Construct a <c>Chromosome</c> by crossing over a pair of chromosomes.</summary>
			<param name="that">another chromosome</param>
			<returns>a crossed over chromosome</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Rand1Bin">
			<summary>The Rand-1-Bin rule is defined by:
 <list type="bullet">
 <item>mutation by adding a scaled, randomly sampled vector difference to a third vector (differential mutation);</item>
 <item>crossover by performing a uniform crossover (discrete recombination).</item>
 </list><para> See also: </para>&quot;Kenneth Price, Rainer M. Storn, Jouni A. Lampinen, &quot;Section 2.1.3 Mutation, Section 2.1.4 Crossover, Section 2.1.8 Notation,&quot; Differential Evolution: A Practical Approach to Global Optimization, Springer, 2005.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Rand1Bin.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct an instance of <c>Rand1Bin</c>.</summary>
			<param name="Cr">the crossover probability</param>
			<param name="F">the scaling factor</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Rand1Bin.#ctor(System.Double,System.Double)">
			<summary>Construct an instance of <c>Rand1Bin</c>.</summary>
			<param name="Cr">the crossover probability</param>
			<param name="F">the scaling factor</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Rand1Bin.getSimpleCell(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Rand1Bin.DeRand1BinCell">
			<summary>This chromosome defines the Rand-1-Bin rule.
 The two genetic operations of this chromosome are:
 <list type="bullet">
 <item>mutation by adding a scaled, randomly sampled vector difference to a third vector (differential mutation);</item>
 <item>crossover by performing a uniform crossover (discrete recombination).</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Rand1Bin.DeRand1BinCell.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Rand1Bin.DeRand1BinCell.mutate">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Rand1Bin.DeRand1BinCell.crossover(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.Chromosome)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory">
			<summary>A <c>DEOptimCellFactory</c> produces <c>DeOptimCell</c>s.
 A <c>DeOptimCell</c> is a chromosome for a real valued function (an optimization problem) and a candidate solution.
 They together define the two genetic operations of an Differential Evolution implementation.
 <list type="bullet">
 <item>Mutation by perturbing the vector population by vector differences;</item>
 <item>Crossover by performing a uniform crossover (discrete recombination).</item>
 </list></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.Cr">
			<summary>the crossover probability</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.F">
			<summary>the scaling factor</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct an instance of a <c>DEOptimCellFactory</c>.</summary>
			<param name="Cr">the crossover probability</param>
			<param name="F">the scaling factor</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.#ctor(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>DEOptimCellFactory</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.Fmin(System.Double,System.Int32)">
			<summary>Compute the <i>F</i> critical value.<para> See also: </para>&quot;eq. 2.32&quot;</summary>
			<param name="Cr">the crossover probability</param>
			<param name="nPopulation">the population size</param>
			<returns>the minimum value for <i>F</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.setPopulation(java.util.List)">
			<summary>Set the current generation.</summary>
			<param name="population">the current population pool</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.getPopulation">
			<summary>Get the current generation.</summary>
			<returns>the current generation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.getBase">
			<summary>Pick a base chromosome from the population.</summary>
			<returns>the base chromosome</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.getOne">
			<summary>Pick a random chromosome from the population.</summary>
			<returns>a random chromosome</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.DeOptimCell">
			<summary>A <c>DeOptimCell</c> is a chromosome for a real valued function (an optimization problem) and a candidate solution.
 It is an <c>abstract</c> class so the subclasses must implement the two genetic operations.
 The specific Differential Evolution rules are implemented by these two genetic operations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.DeOptimCell.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.DeOptimCell.mutate">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory.DeOptimCell.crossover(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.Chromosome)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptim">
			<summary>Differential Evolution (DE) is a global optimization method.
 It is a genetic algorithm that iteratively tries to improve a candidate solution with regard to a given measure of quality.
 DE is used for multidimensional real-valued functions but does not use the gradient of the problem being optimized,
 which means DE does not require for the optimization problem to be differentiable as is required by classic optimization methods
 such as gradient descent and quasi-newton methods.
 DE can therefore also be used on optimization problems that are not even continuous, are noisy, change over time, etc.
 Comparing to other genetic algorithm optimization methods, the breakthrough of DE is the idea of using vector differences for perturbing the vector population.

 <para/>
 The R equivalent function is <c>DEoptim</c> in package <c>DEoptim</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/differential_evolution">Wikipedia: Differential evolution</a></item>
 <item><a href="http://www.icsi.berkeley.edu/~storn/code.html">Differential Evolution (DE)</a></item>
 <item>&quot;Kenneth Price, Rainer M. Storn, Jouni A. Lampinen. Differential Evolution: A Practical Approach to Global Optimization. Springer. 2005.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptim.#ctor(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptim.NewCellFactory,System.Boolean,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator,System.Double,System.Int32,System.Int32)">
			<summary>Construct a <c>DEOptim</c> to solve unconstrained minimization problems.</summary>
			<param name="factoryCtor">a factory that constructs a new instance of <c>SimpleCellFactory</c> for each problem</param>
			<param name="parallel"><c>true</c> if the algorithm is to run in parallel (multi-core)</param>
			<param name="uniform">a uniform random number generator</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
			<param name="nStableIterations">The solution is considered converged if the minimum does not change over this many iterations.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptim.#ctor(System.Double,System.Double,System.Boolean,System.Double,System.Int32,System.Int32)">
			<summary>Construct a <c>DEOptim</c> to solve unconstrained minimization problems.<para> See also: </para>&quot;Kenneth Price, Rainer M. Storn, Jouni A. Lampinen, &quot;Section 2.1.8 Notation,&quot; Differential Evolution: A Practical Approach to Global Optimization, Springer, 2005.&quot;</summary>
			<param name="Cr">the crossover probability</param>
			<param name="F">the scaling factor</param>
			<param name="parallel"><c>true</c> if the algorithm is to run in parallel (multi-core)</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
			<param name="nStableIterations">The solution is considered converged if the minimum does not change over this many iterations.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptim.solve(com.numericalmethod.suanshu.optimization.problem.OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptim.NewCellFactory">
			<summary>This factory constructs a new <c>DEOptimCellFactory</c> for each minimization problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptim.NewCellFactory.newCellFactory">
			<summary>Construct a new instance of <c>DEOptimCellFactory</c> for a minimization problem.</summary>
			<returns>a new instance of <c>DEOptimCellFactory</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptim.Solution">
			<summary>This is the solution to a minimization problem using <c>DEOptim</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptim.Solution.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptim.Solution.getNextGeneration(java.util.List,java.util.List)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptim.Solution.getChild(System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Best2Bin">
			<summary>The Best-1-Bin rule always picks the best chromosome as the base.
 The two genetic operations are:
 <list type="bullet">
 <item>mutation by adding TWO scaled, randomly sampled vector difference to a third vector (differential mutation);</item>
 <item>crossover by performing a uniform crossover (discrete recombination).</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Best2Bin.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct an instance of <c>Best2Bin</c>.</summary>
			<param name="Cr">the crossover probability</param>
			<param name="F">the scaling factor</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Best2Bin.#ctor(System.Double,System.Double)">
			<summary>Construct an instance of <c>Best2Bin</c>.</summary>
			<param name="Cr">the crossover probability</param>
			<param name="F">the scaling factor</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Best2Bin.getSimpleCell(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Best2Bin.DeBest2BinCell">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Best2Bin.DeBest2BinCell.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Best2Bin.DeBest2BinCell.mutate">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Best1Bin">
			<summary>The Best-1-Bin rule is the same as the <para></para>Rand1Bin Rand-1-Bin rule,
 except that it always pick the best candidate in the population to be the base.<para> See also: </para>&quot;Kenneth Price, Rainer M. Storn, Jouni A. Lampinen, &quot;Section 2.1.3 Mutation, Section 2.1.4 Crossover, Section 2.1.8 Notation,&quot; Differential Evolution: A Practical Approach to Global Optimization, Springer, 2005.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Best1Bin.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct an instance of <c>Best1Bin</c>.</summary>
			<param name="Cr">the crossover probability</param>
			<param name="F">the scaling factor</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Best1Bin.#ctor(System.Double,System.Double)">
			<summary>Construct an instance of <c>Best1Bin</c>.</summary>
			<param name="Cr">the crossover probability</param>
			<param name="F">the scaling factor</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.Best1Bin.getBase">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.IntegralConstrainedCellFactory">
			<summary>This implementation defines the constrained Differential Evolution operators that solve an Integer Programming problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.IntegralConstrainedCellFactory.#ctor(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory,com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.IntegralConstrainedCellFactory.IntegerConstraint)">
			<summary>Construct an instance of <c>IntegralConstrainedCellFactory</c>.</summary>
			<param name="factory">the Differential Operators for unconstrained optimization</param>
			<param name="constraint">the integral constraints</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.IntegralConstrainedCellFactory.getSimpleCell(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.IntegralConstrainedCellFactory.IntegerConstraint">
			<summary>The integral constraints are defined by implementing this <c>interface</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.IntegralConstrainedCellFactory.IntegerConstraint.round(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.IntegralConstrainedCellFactory.AllIntegers">
			<summary>This integral constraint makes all variables in the objective function integral variables.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.IntegralConstrainedCellFactory.AllIntegers.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.IntegralConstrainedCellFactory.AllIntegers.round(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.IntegralConstrainedCellFactory.SomeIntegers">
			<summary>This integral constraint makes some variables in the objective function integral variables.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.IntegralConstrainedCellFactory.SomeIntegers.#ctor(com.numericalmethod.suanshu.optimization.multivariate.constrained.integer.IPProblem)">
			<summary>Construct the integral constraint from an Integer Programming problem.</summary>
			<param name="problem">an Integer Programming problemI</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.IntegralConstrainedCellFactory.SomeIntegers.round(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.ConstrainedCellFactory">
			<summary>This defines a Differential Evolution operator that takes in account constraints.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.ConstrainedCellFactory.unconstrainedFactory">
			<summary>a factory that defines the unconstrained Differential Evolution operators</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.ConstrainedCellFactory.#ctor(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.DEOptimCellFactory)">
			<summary>Construct an instance of a <c>ConstrainedCellFactory</c> that define the constrained Differential Evolution operators.</summary>
			<param name="unconstrainedFactory">a factory that defines the unconstrained Differential Evolution operators</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.ConstrainedCellFactory.setPopulation(java.util.List)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.ConstrainedCellFactory.getSimpleCell(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Override this method to put in whatever constraints in the minimization problem.</summary>
			<param name="f">the original objective function</param>
			<param name="x">the original, unprocessed, unconstrained candidate solution</param>
			<returns>a constrained cell/chromosome</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.ConstrainedCellFactory.ConstrainedCell">
			<summary>A <c>ConstrainedCell</c> is a chromosome for a constrained optimization problem.
 It encodes the real valued objective function, a candidate solution, as well as the constraints.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.ConstrainedCellFactory.ConstrainedCell.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.ConstrainedCellFactory.ConstrainedCell.mutate">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.deoptim.constrained.ConstrainedCellFactory.ConstrainedCell.crossover(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.Chromosome)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.LocalSearchCellFactory">
			<summary>A <c>LocalSearchCellFactory</c> produces <c>LocalSearchCellFactory.LocalSearchCell</c>s.
 A <c>LocalSearchCellFactory.LocalSearchCell</c> is a chromosome for a real valued function (an optimization problem) and a candidate solution.
 Its mutation operation is by a local minimization method, Nelder-Mead, BFGS, searching the neighborhood of the current solution.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.LocalSearchCellFactory.#ctor(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.LocalSearchCellFactory.MinimizerFactory,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct an instance of a <c>LocalSearchCellFactory</c>.</summary>
			<param name="factory">a factory that generates a new instance of a <para></para>Minimizer for local search</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.LocalSearchCellFactory.getSimpleCell(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.LocalSearchCellFactory.MinimizerFactory">
			<summary>This factory constructs a new <c>Minimizer</c> for each mutation operation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.LocalSearchCellFactory.MinimizerFactory.newInstance">
			<summary>Construct a new instance of <c>Minimizer</c> for a mutation operation.</summary>
			<returns>a new instance of <c>Minimizer</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.LocalSearchCellFactory.LocalSearchCell">
			<summary>A <c>LocalSearchCell</c> implements the two genetic operations.
 <list type="bullet">
 <item>Mutation by a local search in the neighborhood;</item>
 <item>Crossover by taking the midpoint (average) of two cells.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.LocalSearchCellFactory.LocalSearchCell.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.LocalSearchCellFactory.LocalSearchCell.mutate">
			<summary>Mutate by a local search in the neighborhood.</summary>
			<returns>a mutant chromosome</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.GlobalSearchByLocalMinimizer">
			<summary>This minimizer is a global optimization method.
 It puts a mesh over the feasible region and then locally searches (optimizes) the neighborhood around each mesh point.
 The algorithm tries to escape the local minimums by crossing over other local minimums using a genetic algorithm.
 The local search (mutation) is performed by a typical local minimization method, such as Nelder-Mead, BFGS.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.GlobalSearchByLocalMinimizer.#ctor(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.LocalSearchCellFactory.MinimizerFactory,System.Boolean,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator,System.Double,System.Int32,System.Int32)">
			<summary>Construct a <c>GlobalSearchByLocalMinimizer</c> to solve unconstrained minimization problems.</summary>
			<param name="factory">a factory that constructs a new instance of <c>Minimizer</c> for each problem</param>
			<param name="parallel"><c>true</c> if the algorithm is to run in parallel (multi-core)</param>
			<param name="uniform">a uniform random number generator</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
			<param name="nStableIterations">The solution is considered converged if the minimum does not change over this many iterations.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.GlobalSearchByLocalMinimizer.#ctor(System.Boolean,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator,System.Double,System.Int32)">
			<summary>Construct a <c>GlobalSearchByLocalMinimizer</c> to solve unconstrained minimization problems.</summary>
			<param name="parallel"><c>true</c> if the algorithm is to run in parallel (multi-core)</param>
			<param name="uniform">a uniform random number generator</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.local.GlobalSearchByLocalMinimizer.#ctor(System.Boolean)">
			<summary>Construct a <c>GlobalSearchByLocalMinimizer</c> to solve unconstrained minimization problems.</summary>
			<param name="parallel"><c>true</c> if the algorithm is to run in parallel (multi-core)</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.firstgeneration.UniformMeshOverRegion">
			<summary>The initial population is generated by putting a uniform mesh/grid/net over the entire region.
 The population size is proportional to the number of available cores.
 The region bounds are determined from the initial guesses.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.firstgeneration.UniformMeshOverRegion.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleCellFactory,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator,System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[],System.Double)">
			<summary>Generate an initial pool of chromosomes by putting a uniform mesh/grid/net over the entire
 region.</summary>
			<param name="f">the objective function</param>
			<param name="factory">a cell factory</param>
			<param name="uniform">a uniform random number generator</param>
			<param name="minDiscretization">minimum level of discretization</param>
			<param name="initials0">the initial search points</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                          considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.firstgeneration.UniformMeshOverRegion.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleCellFactory,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[],System.Double)">
			<summary>Generate an initial pool of chromosomes by putting a uniform mesh/grid/net over the entire
 region.</summary>
			<param name="f">the objective function</param>
			<param name="factory">a cell factory</param>
			<param name="initials0">the initial search points</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.firstgeneration.UniformMeshOverRegion.getFirstGeneration">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.firstgeneration.PerturbationAroundPoint">
			<summary>The initial population is generated by adding a variance around a given initial.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.firstgeneration.PerturbationAroundPoint.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleCellFactory,System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int64)">
			<summary>Generate an initial pool of chromosomes by adding a variance around a given initial.</summary>
			<param name="f">the objective function</param>
			<param name="factory">a cell factory</param>
			<param name="poolSize">the number of chromosomes to generate</param>
			<param name="var">the variance in each dimension</param>
			<param name="initial0">the initial search point</param>
			<param name="seed">the seed</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.firstgeneration.PerturbationAroundPoint.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleCellFactory,System.Int32,System.Double,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Generate an initial pool of chromosomes by adding a variance around a given initial.</summary>
			<param name="f">the objective function</param>
			<param name="factory">a cell factory</param>
			<param name="poolSize">the number of chromosomes to generate</param>
			<param name="var">the variance in each dimension</param>
			<param name="initial0">the initial search point</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.firstgeneration.PerturbationAroundPoint.getFirstGeneration">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.firstgeneration.FirstGeneration">
			<summary>This interface allows customization of how the first pool of chromosomes is generated.
 The grid points are the chromosomes in the first population.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.firstgeneration.FirstGeneration.getFirstGeneration">
			<summary>Generate the initial pool of chromosomes.</summary>
			<returns>the initial pool of chromosomes</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer">
			<summary>This minimizer is a simple global optimization method.
 It puts a mesh over the feasible region and then locally searches (optimizes) the neighborhood
 around each mesh point.
 The algorithm tries to escape the local minimums by crossing over other local minimums using a
 genetic algorithm.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.DEFAULT_STABLE_ITERATION_COUNT">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.parallel">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.uniform">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.factoryCtor">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.epsilon">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.maxIterations">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.nStableIterations">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.#ctor(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.NewCellFactoryCtor,System.Boolean,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator,System.Double,System.Int32,System.Int32)">
			<summary>Construct a <c>SimpleGridMinimizer</c> to solve unconstrained minimization problems.</summary>
			<param name="factoryCtor">a factory that constructs a new instance of
                          <c>SimpleCellFactory</c> for each problem</param>
			<param name="parallel"><c>true</c> if the algorithm is to run in parallel (multi-core)</param>
			<param name="uniform">a uniform random number generator</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                          considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
			<param name="nStableIterations">the solution is considered converged if the minimum does not change
                          over this many iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.#ctor(System.Boolean,System.Double,System.Int32)">
			<summary>Construct a <c>SimpleGridMinimizer</c> to solve unconstrained minimization problems.</summary>
			<param name="parallel"><c>true</c> if the algorithm is to run in parallel (multi-core)</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.NewCellFactoryCtor">
			<summary>This factory constructs a new <c>SimpleCellFactory</c> for each minimization problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.NewCellFactoryCtor.newCellFactory">
			<summary>Construct a new instance of <c>SimpleCellFactory</c> for a minimization problem.</summary>
			<returns>a new instance of <c>SimpleCellFactory</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution">
			<summary>This is the solution to a minimization problem using <c>SimpleGridMinimizer</c>.</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.initials">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.iteration">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.nNoChanges">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.fminLast">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.fmin">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.xmin">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.f">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.factory">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.getFirstGeneration">
			<summary>The initial population is generated by putting a uniform mesh/grid/net over the entire
 region.
 The grid points are the chromosomes in the first population.
 The population size is proportional to the number of available cores.
 The region bounds are determined from the initial guesses.</summary>
			<returns>the first population</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.isConverged">
			<summary>This genetic algorithm terminates if
 <list type="bullet">
 <item>the minimum does not improve for a fixed number of iterations, or</item>
 <item>the maximum number of iterations is exceeded.</item>
 </list></summary>
			<returns><c>true</c> if a convergence is found</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.setInitials(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.step">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.search(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.minimum">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleGridMinimizer.Solution.minimizer">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleCellFactory">
			<summary>A <c>SimpleCellFactory</c> produces <c>SimpleCell</c>s.
 A <c>SimpleCell</c> is a chromosome for a real valued function (an optimization problem) and a candidate solution.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleCellFactory.uniform">
			<summary>the uniform random number generator</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleCellFactory.#ctor(System.Double,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct an instance of a <c>SimpleCellFactory</c>.</summary>
			<param name="rate">the convergence rate</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleCellFactory.getSimpleCell(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct an instance of a <c>SimpleCell</c>.</summary>
			<param name="f">a real-valued function</param>
			<param name="x">a candidate solution</param>
			<returns>a <c>SimpleCell</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleCellFactory.SimpleCell">
			<summary>A <c>SimpleCell</c> implements the two genetic operations.
 <list type="bullet">
 <item>Mutation by disturbing (scaling) the fitness by a percentage;</item>
 <item>Crossover by taking the midpoint (average) of two cells.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleCellFactory.SimpleCell.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleCellFactory.SimpleCell.mutate">
			<summary>Mutate by random disturbs in a neighborhood.</summary>
			<returns>a mutant chromosome</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.SimpleCellFactory.SimpleCell.crossover(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.Chromosome)">
			<summary>Crossover by taking the midpoint.</summary>
			<param name="other">another chromosome</param>
			<returns>a hybrid chromosome</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.RealScalarFunctionChromosome">
			<summary>This chromosome encodes a real valued function.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.RealScalarFunctionChromosome.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct an instance of <c>RealScalarFunctionChromosome</c>.</summary>
			<param name="f">the objective function</param>
			<param name="x">a candidate solution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.RealScalarFunctionChromosome.f">
			<summary>Get the objective function.</summary>
			<returns>the objective function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.RealScalarFunctionChromosome.x">
			<summary>Get the candidate solution.</summary>
			<returns>the candidate solution</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.RealScalarFunctionChromosome.fitness">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.RealScalarFunctionChromosome.compareTo(com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.Chromosome)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.multivariate.geneticalgorithm.minimizer.simplegrid.RealScalarFunctionChromosome.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.problem.OptimProblem">
			<summary>This is an optimization problem that minimizes a real valued objective function, one or multi dimension.
 Optimization, or mathematical programming, refers to choosing the best element from some set of available alternatives.
 In the simplest case,
 this means solving problems in which one seeks to minimize (or maximize) a real function by systematically choosing the values of real or integer variables from within an allowed set.
 The generalization of optimization theory and techniques to other formulations comprises a large area of applied mathematics.
 More generally, it means finding &quot;best available&quot; values of some objective function given a defined domain,
 including a variety of different types of objective functions and different types of domains.<para> See also: </para><a href="http://en.wikipedia.org/wiki/mathematical_programming">Wikipedia: Optimization (mathematics)</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.problem.OptimProblem.dimension">
			<summary>Get the number of variables.</summary>
			<returns>the number of variables.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.problem.OptimProblem.f">
			<summary>Get the objective function.</summary>
			<returns>the objective function</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.problem.MinimizationSolution">
			<summary>This is the solution to a minimization problem, <para></para>OptimProblem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.problem.MinimizationSolution.minimum">
			<summary>Get the (approximate) minimum found.</summary>
			<returns>the (approximate) minimum found</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.problem.MinimizationSolution.minimizer">
			<summary>Get the minimizer (solution) to the minimization problem.</summary>
			<returns>the minimizer</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.problem.IterativeMinimizer">
			<summary>Many minimization algorithms work by starting from some given initials and iteratively moving toward an approximate solution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/mathematical_optimization#iterative_methods">Wikipedia: Iterative methods</a></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.problem.C2OptimProblemImpl">
			<summary>This is an optimization problem of a real valued function: \(\max_x f(x)\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.problem.C2OptimProblemImpl.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction,com.numericalmethod.suanshu.analysis.function.matrix.RntoMatrix)">
			<summary>Construct an optimization problem with an objective function.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="g">the gradient of the objective function</param>
			<param name="H">the Hessian of the objective function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.problem.C2OptimProblemImpl.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction,com.numericalmethod.suanshu.analysis.function.rn2rm.RealVectorFunction)">
			<summary>Construct an optimization problem with an objective function.
 This uses a numerical Hessian, if needed.</summary>
			<param name="f">the objective function to be minimized</param>
			<param name="g">the gradient of the objective function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.problem.C2OptimProblemImpl.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary>Construct an optimization problem with an objective function.
 This uses a numerical gradient and a numerical Hessian, if needed.</summary>
			<param name="f">the objective function to be minimized</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.problem.C2OptimProblemImpl.#ctor(com.numericalmethod.suanshu.optimization.problem.C2OptimProblemImpl)">
			<summary>Copy Ctor.</summary>
			<param name="that">a <c>C2OptimProblemImpl</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.problem.C2OptimProblemImpl.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.problem.C2OptimProblemImpl.f">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.problem.C2OptimProblemImpl.g">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.problem.C2OptimProblemImpl.H">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.problem.C2OptimProblem">
			<summary>This is an optimization problem of a real valued function that is twice differentiable.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.GoldenMinimizer">
			<summary>This is the golden section univariate minimization algorithm.
 On each iteration, it compares the distances to the lower and upper ends of the bracketing interval.
 The bigger sub-interval is divided by the golden section (about 0.3189660...) at the new <c>next</c> point.
 The value of the function at this new point is calculated and compared to the current minimum.
 A new bracketing interval is then chosen in the usual manner as in <para></para>BracketSearchMinimizer.
 Choosing the golden section as the bisection ratio gives the fastest convergence among the algorithms that converge linearly.
 This implementation guarantees that the next guess lies inside the bracketing interval.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.GoldenMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a univariate minimizer using the Golden method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.GoldenMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.GoldenMinimizer.Solution">
			<summary>This is the solution to a Golden section univariate optimization.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.GoldenMinimizer.Solution.search(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.GoldenMinimizer.Solution.isMinFound">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.GoldenMinimizer.Solution.xnext">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.FibonaccMinimizer">
			<summary>The Fibonacci search is a dichotomous search where a bracketing interval is sub-divided by the Fibonacci ratio.
 This implementation runs the risk that the next guess may lie outside the bracketing interval.<para> See also: </para>&quot;Andreas Antoniou, Wu-Sheng Lu, &quot;Algorithm 4.1,&quot; Practical Optimization: Algorithms and Engineering Applications. Springer.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.FibonaccMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a univariate minimizer using the Fibonacci method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.FibonaccMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.FibonaccMinimizer.Solution">
			<summary>This is the solution to a Fibonacci&apos;s univariate optimization.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.FibonaccMinimizer.Solution.search(System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.FibonaccMinimizer.Solution.search(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.FibonaccMinimizer.Solution.isMinFound">
			<summary>This algorithm stops only after a pre-specified number of iterations.
 This is to guarantee the search interval is reduced to certain size, or a fraction of the input interval.</summary>
			<returns>false</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.FibonaccMinimizer.Solution.xnext">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BrentMinimizer">
			<summary>Brent&apos;s algorithm is the preferred method for finding the minimum of a univariate function.
 It is able to recognize behavior of the function to switch between the golden ratio and parabolic
 approach.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BrentMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a univariate minimizer using Brent&apos;s algorithm.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BrentMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BrentMinimizer.Solution">
			<summary>This is the solution to a Brent&apos;s univariate optimization.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BrentMinimizer.Solution.search(System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BrentMinimizer.Solution.search(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BrentMinimizer.Solution.isMinFound">
			<summary>

 The search stops when
 <list type="bullet">
 \((x_u - x_l) &lt; 2 \left | x \right | \varepsilon \)
 \(\left | \rm xmin - \rm mid \right | &lt; \left | x \right | \varepsilon\)
 </list>
 <para/>
 \((x_u - x_l) / 2 + \left | \rm xmin - \rm mid \right | &lt; 2 \left | x \right | \varepsilon \approx \rm tol_2\)<para> See also: </para>&quot;Chapter 10.3, Numerical Recipes.&quot;</summary>
			<returns><c>true</c> if the minimum is found</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BrentMinimizer.Solution.xnext">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BrentMinimizer.Solution.updateStates">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer">
			<summary>This class provides implementation support for those univariate optimization algorithms that are based on bracketing.
 Examples are Bisection method, Fibonacci search, and Golden-section search.
 Starting with a 3-point bracketing interval of a minimum, i.e., <i>x<sup>l</sup>, x<sup>a</sup>, x<sup>u</sup>,</i>
 the search iteratively reduce the length of the interval.
 It computes a 4th point, <i>x<sup>b</sup></i>, according to an interval dividing schedule, to form two overlapping sub-intervals, e.g.,
 <i>[x<sup>l</sup>, x<sup>a</sup>]</i>, and
 <i>[x<sup>b</sup>, x<sup>u</sup>]</i>.
 The sub-interval that contains the new minimum is chosen. Repeat the procedure until convergence.
 This algorithm is most effective for a uni-modal function in interval
 <i>[x<sup>l</sup>, x<sup>u</sup>]</i>.<para> See also: </para>&quot;Andreas Antoniou and Wu-Sheng Lu, &quot;Chapter 4,&quot; Practical Optimization: Algorithms and Engineering Applications. Springer.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.epsilon">
			<summary>the convergence tolerance</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.maxIterations">
			<summary>the maximum number of iterations</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a univariate minimizer using a bracket search method.</summary>
			<param name="epsilon">the convergence tolerance; It should be no less than the square root of the machine precision.</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Minimize a univariate function.</summary>
			<param name="f">the objective function</param>
			<returns>the minimizer</returns>
			<exception cref="T:java.lang.Exception"></exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.f">
			<summary></summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.fmin">
			<summary>the best minimum found so far</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.fnext">
			<summary>the next guess of the minimum</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.xl">
			<summary>the lower bound of the bracketing interval</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.xu">
			<summary>the upper bound of the bracketing interval</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.xmin">
			<summary>the best minimizer found so far</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.xnext">
			<summary>the next best guess of the minimizer</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.iter">
			<summary>the current iteration count</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.isMinFound">
			<summary>the convergence criterion</summary>
			<returns><c>true</c> if the current min value is considered to have converged within a threshold</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.xnext">
			<summary>Compute the next best estimate within the bracketing interval.
 A particular univariate minimization algorithm implements the logic in this method.</summary>
			<returns>the next best guess of the minimizer</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.search(System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.updateStates">
			<summary>Update the bracketing interval and the best min found so far.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.isBracketing(System.Double,System.Double,System.Double)">
			<summary>Check whether <i>[xl, xu]</i> is bracketing <i>x</i>.</summary>
			<param name="xl">the lower bound of the bracketing interval</param>
			<param name="x">a guess of the minimizer</param>
			<param name="xu">the upper bound of the bracketing interval</param>
			<returns><c>true</c> if <i>fx &lt; fl &amp;&amp; fx &lt; fu</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.minimum">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.bracketsearch.BracketSearchMinimizer.Solution.minimizer">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.univariate.UnivariateMinimizer">
			<summary>A univariate minimizer minimizes a univariate function.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.univariate.UnivariateMinimizer.Solution">
			<summary>This is the solution to a univariate minimization problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.UnivariateMinimizer.Solution.search(System.Double,System.Double,System.Double)">
			<summary>Search for a minimum within the interval <i>[lower, upper]</i>.</summary>
			<param name="lower">the lower bound for the bracketing interval which contains a minimum</param>
			<param name="initial">an initial guess</param>
			<param name="upper">the upper bound for the bracketing interval which contains a minimum</param>
			<returns>an approximate minimizer</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.UnivariateMinimizer.Solution.search(System.Double,System.Double)">
			<summary>Search for a minimum within the interval <i>[lower, upper]</i>.</summary>
			<param name="lower">the lower bound for the bracketing interval which contains a minimum</param>
			<param name="upper">the upper bound for the bracketing interval which contains a minimum</param>
			<returns>an approximate minimizer</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.univariate.GridSearchMinimizer">
			<summary>This performs a grid search to find the minimum of a univariate function.
 This procedure may be appropriate when the bracketing interval is difficult to determine.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.univariate.GridSearchMinimizer.epsilon">
			<summary>a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.optimization.univariate.GridSearchMinimizer.maxIterations">
			<summary>the maximum number of iterations</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.GridSearchMinimizer.#ctor(System.Double,System.Int32)">
			<summary>Construct a univariate minimizer using the grid search method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.GridSearchMinimizer.solve(com.numericalmethod.suanshu.optimization.problem.C2OptimProblem)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.GridSearchMinimizer.solve(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Minimize a univariate function.</summary>
			<param name="f">the objective function</param>
			<returns>the minimizer</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.optimization.univariate.GridSearchMinimizer.Solution">
			<summary>This is the solution to the <c>GridSearchMinimizer</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.GridSearchMinimizer.Solution.search(System.Double,System.Double,System.Double)">
			<summary></summary>
			<param name="lower">the lower bound</param>
			<param name="initial"><em>not used</em></param>
			<param name="upper">the upper bound</param>
			<returns>the minimizer found</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.GridSearchMinimizer.Solution.search(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.GridSearchMinimizer.Solution.minimum">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.optimization.univariate.GridSearchMinimizer.Solution.minimizer">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.correlation.SpearmanRankCorrelation">
			<summary>Spearman&apos;s rank correlation coefficient or Spearman&apos;s rho is a non-parametric measure of
 statistical dependence between two variables.
 It assesses how well the relationship between two variables can be described using a monotonic
 function.
 If there are no repeated data values,
 a perfect Spearman correlation of +1 or -1 occurs when each of the variables is a perfect
 monotone function of the other.
 <para/>
 For a set of
 observations \((X_i, Y_i)\) we first compute the ranks \(x_i\) and \(y_i\) of the \(X\) and \(Y\)
 values
 for each observation. Spearman&apos;s rho is defined as the Pearson correlation coefficient between
 the ranked variables:
 \[
 \rho
 = \frac{\sum_i(x_i-\bar{x})(y_i-\bar{y})}{\sqrt{\sum_i (x_i-\bar{x})^2 \sum_i(y_i-\bar{y})^2}}
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/spearman's_rank_correlation_coefficient">Wikipedia:
 Spearman&apos;s rank correlation coefficient</a><para> See also: </para>Covariance#correlation()</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.correlation.SpearmanRankCorrelation.#ctor(System.Double[],System.Double[])">
			<summary>Construct a Spearman rank calculator initialized with two samples. The size of the two sample
 must be equal.</summary>
			<param name="data1">the first sample</param>
			<param name="data2">the second sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.correlation.SpearmanRankCorrelation.addData(System.Double[])">
			<summary>Update the statistic with more data. Since this signature takes only a single array
 <c>double[]</c>, we concatenate the two arrays into one.
 <para/>
 For example, suppose we want to do
 <code>
 <c>addData(new double[][]{
     {1, 2, 3},
     {4, 5, 6}
 });
 </c>
 </code>
 We can also write
 <code>
 <c>addData(new double[]{
     {1, 2, 3, 4, 5, 6}
 });
 </c>
 </code>
 In the latter case, there must be an even number of data points.</summary>
			<param name="data">a data array concatenating two samples</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.correlation.SpearmanRankCorrelation.addData(System.Double[],System.Double[])">
			<summary>Add the given two samples. The size of the two samples must be equal.</summary>
			<param name="data1">the first sample</param>
			<param name="data2">the second sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.correlation.SpearmanRankCorrelation.N">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.correlation.SpearmanRankCorrelation.value">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.correlation.KendallRankCorrelation">
			<summary>The Kendall rank correlation coefficient, commonly referred to as Kendall&apos;s tau (&#964;)
 coefficient, is a statistic used to measure the association between two measured quantities.
 A tau test is a non-parametric hypothesis test which uses the coefficient to test for statistical
 dependence. Specifically, it is a measure of rank correlation, that is, the similarity of the
 orderings of the data when ranked by each of the quantities.
 <para/>
 Specifically, for each pair of observations \((x_i, y_i), (x_j, y_j)\) we say that they are
 concordant if either \(x_i &gt; x_j\) and \(y_i &gt; y_j\) or \(x_i &lt; x_j\) and
 \(y_i &lt; y_j\). Otherwise, they are said to be discordant.
 <para/>
 Kendall&apos;s tau is defined as:
 \[
 \tau =
 \frac{(\text{no. of concordant pairs}) - (\text{no. of discordant pairs})}{\frac{1}{2} n (n-1) }
 \]
 <para/>
 If the values in \(x\) and \(y\) are not unique, (&#964; - b) is computed.
 <para/>
 This class implements the O(n log n) algorithm from
 Knight, W. (1966). &quot;A Computer Method for Calculating Kendall&apos;s Tau with Ungrouped Data&quot;.
 <para/>
 The R equivalent function is <c>Kendall</c> in package <c>Kendall</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/kendall_tau_rank_correlation_coefficient">
 Wikipedia: Kendall tau rank correlation coefficient</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.correlation.KendallRankCorrelation.#ctor(System.Double[],System.Double[])">
			<summary>Construct a Kendall rank calculator initialized with two samples.
 The size of the two sample must be equal.</summary>
			<param name="data1">the first sample</param>
			<param name="data2">the second sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.correlation.KendallRankCorrelation.addData(System.Double[])">
			<summary>Update the statistic with more data. Since this signature takes only a single array
 <c>double[]</c>, we concatenate the two arrays into one.
 <para/>
 For example, suppose we want to do
 <code>
 <c>addData(new double[][]{
     {1, 2, 3},
     {4, 5, 6}
 });
 </c>
 </code>
 We can also write
 <code>
 <c>addData(new double[]{
     {1, 2, 3, 4, 5, 6}
 });
 </c>
 </code>
 In the latter case, there must be an even number of data points.</summary>
			<param name="data">a data array concatenating two samples</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.correlation.KendallRankCorrelation.N">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.correlation.KendallRankCorrelation.addData(System.Double[],System.Double[])">
			<summary>Add the given two samples. The size of the two samples must be equal.</summary>
			<param name="data1">the first sample</param>
			<param name="data2">the second sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.correlation.KendallRankCorrelation.value">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.correlation.CorrelationMatrix">
			<summary>The correlation matrix of <i>n</i> random variables <i>X<sub>1</sub>, ..., X<sub>n</sub></i> is
 the <i>n &#215; n</i> matrix whose <i>i,j</i> entry is <i>corr(X<sub>i</sub>,
 X<sub>j</sub></i>),
 the correlation between <i>X<sub>1</sub></i> and <i>X<sub>n</sub></i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/correlation_and_dependence#correlation_matrices">
 Wikipedia: Correlation matrices</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.correlation.CorrelationMatrix.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a correlation matrix from a covariance matrix.</summary>
			<param name="cov">a covariance matrix</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.covariance.SampleCovariance">
			<summary>This class computes the Covariance matrix of a matrix, where the <i>(i, j)</i> entry is the
 covariance of the <i>i</i>-th column and <i>j</i>-th column of the matrix.
 <para/>
 The R equivalent function is <c>cov</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.SampleCovariance.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct the covariance matrix of a matrix. By default, the sample covariance matrix is
 unbiased.</summary>
			<param name="A">a matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.SampleCovariance.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean)">
			<summary>Construct the covariance matrix of a matrix.</summary>
			<param name="A">a matrix</param>
			<param name="unbiased"><c>true</c> if the estimate is unbiased</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.covariance.LedoitWolf2004">
			<summary>To estimate the covariance matrix, Ledoit and Wolf (2004) suggests using the matrix obtained from
 the sample covariance matrix through a transformation called <em>shrinkage</em>. This tends to
 pull the most extreme coefficients towards more central values, thereby systematically reducing
 estimation error where it matters most. Statistically, the challenge is to know the optimal
 shrinkage intensity, and they also give the formula for that.
 <para/>
 Note: The input matrix here is <i>T-by-N</i>, while the description in the referenced paper
 assumes the matrix of stock returns is <i>N-by-T</i>.<para> See also: </para><list type="bullet">
 <item>Olivier Ledoit and Michael Wolf, &quot;Honey, I Shrunk the Sample Covariance Matrix,&quot; in Journal
 of Portfolio Management, Volume 31, Number 1, 2004.</item>
 <item>Olivier Ledoit and Michael Wolf, &quot;Improved Estimation of the Covariance Matrix of Stock
 Returns With an Application to Portfolio Selection,&quot; in Journal of Empirical Finance, Volume 10,
 Issue 5, December 2003, pages 603-621.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.LedoitWolf2004.#ctor">
			<summary>Creates the algorithm instance, using an unbiased sample covariance matrix by default.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.LedoitWolf2004.#ctor(System.Boolean)">
			<summary>Creates the algorithm instance, with the option to use an unbiased or biased sample
 covariance matrix.</summary>
			<param name="unbiased"><c>true</c> to use unbiased covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.LedoitWolf2004.compute(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Estimates the covariance matrix for a given matrix <i>Y</i> (each column in <i>Y</i> is a
 time-series), with the optimal shrinkage parameter computed by the algorithm.</summary>
			<param name="Y">the input matrix</param>
			<returns>the estimator</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.LedoitWolf2004.compute(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Estimates the covariance matrix for a given matrix <i>Y</i> (each column in <i>Y</i> is a
 time-series), with the given shrinkage parameter.</summary>
			<param name="Y">the input matrix</param>
			<param name="shrinkage">the shrinkage parameter</param>
			<returns>the estimator</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.covariance.LedoitWolf2004.Result">
			<summary>The estimator and some intermediate values computed by the algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.LedoitWolf2004.Result.getCovarianceMatrix">
			<summary>Gets the &quot;shrunk&quot; covariance matrix.</summary>
			<returns>the estimated covariance matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.LedoitWolf2004.Result.F">
			<summary>Gets the sample constant correlation matrix <i>F</i>.</summary>
			<returns><i>F</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.LedoitWolf2004.Result.S">
			<summary>Gets the sample covariance matrix <i>S</i>.</summary>
			<returns><i>S</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.LedoitWolf2004.Result.delta">
			<summary>Gets the shrinkage parameter <i>&#948;</i>.</summary>
			<returns><i>&#948;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.LedoitWolf2004.Result.rBar">
			<summary>Gets the average correlation \(\bar{r}\).</summary>
			<returns>\(\bar{r}\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.covariance.Covariance">
			<summary>Covariance is a measure of how much two variables change together.
 This implementation uses the Pearson method. That is,
 <blockquote><i>
 Cov(X, Y) = E[(X - E(X)) * (Y - E(Y))]
 </i></blockquote>
 Note that this implementation uses <i>N - 1</i> as the denominator to give an unbiased estimator
 of the covariance for i.i.d. observations.
 This implementation uses Pébay&apos;s update formula to incrementally compute the new statistic.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/covariance">Wikipedia: Covariance</a></item>
 <item><a href="http://en.wikipedia.org/wiki/correlation">Wikipedia: Correlation</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.Covariance.#ctor">
			<summary>Construct an empty <c>Covariance</c> calculator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.Covariance.#ctor(System.Double[],System.Double[])">
			<summary>Construct a <c>Covariance</c> calculator, initialized with two samples.
 The size of the two samples must be equal.</summary>
			<param name="data1">the first sample</param>
			<param name="data2">the second sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.Covariance.#ctor(com.numericalmethod.suanshu.stats.descriptive.covariance.Covariance)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>Covariance</c> instance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.Covariance.correlation">
			<summary>Get the correlation, i.e., Pearson&apos;s correlation coefficient.</summary>
			<returns>the correlation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.Covariance.addData(System.Double[])">
			<summary>Update the covariance statistic with more data.
 Since this signature takes only a single array <c>double[]</c>,
 we concatenate the two arrays into one.
 <para/>
 For example, suppose we want to do
 <code>
 <c>addData(new double[][]{
     {1, 2, 3},
     {4, 5, 6}
 });
 </c>
 </code>
 We can also write
 <code>
 <c>addData(new double[]{
     {1, 2, 3, 4, 5, 6}
 });
 </c>
 </code>
 In the latter case, there must be an even number of data points.</summary>
			<param name="data">a data array concatenating two samples</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.Covariance.addData(System.Double[],System.Double[])">
			<summary>Update the covariance statistic with more data.<para> See also: </para>&quot;Pébay, Philippe, &quot;Formulas for Robust, One-Pass Parallel Computation of Covariances and
 Arbitrary-Order Statistical Moments,&quot; Technical Report SAND2008-6212, Sandia National
 Laboratories, 2008.&quot;</summary>
			<param name="data1">the first new sample</param>
			<param name="data2">the second new sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.Covariance.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.Covariance.N">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.covariance.Covariance.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.moment.Variance">
			<summary>The variance of a sample is the average squared deviations from the sample mean.
 It measures the amount of variation the sample values have. That is,
 <blockquote><i>
 Var(X, Y) = E[(X - E(X))<sup>2</sup>]
 </i></blockquote>
 This implementation uses Chan&apos;s update formula to incrementally compute the new statistic.
 <para/>
 The R equivalent function is <c>var</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/variance">Wikipedia: Variance</a></item>
 <item><a href="http://en.wikipedia.org/wiki/algorithms_for_calculating_variance">Wikipedia: Algorithms for calculating variance</a></item>
 <item>&quot;Tony F. Chan, Gene H. Golub, Randall J. LeVeque, &quot;Updating Formulae and a Pairwise Algorithm for Computing Sample Variances,&quot; Technical Report STAN-CS-79-773, Department of Computer Science, Stanford University, 1979.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Variance.#ctor">
			<summary>Construct an empty <c>Variance</c> calculator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Variance.#ctor(System.Double[],System.Boolean)">
			<summary>Construct a <c>Variance</c> calculator,
 initialized with a sample.</summary>
			<param name="data">a sample</param>
			<param name="unbiased"><c>true</c> if the variance calculation uses the unbiased formula</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Variance.#ctor(System.Double[])">
			<summary>Construct an unbiased <c>Variance</c> calculator.</summary>
			<param name="data">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Variance.#ctor(com.numericalmethod.suanshu.stats.descriptive.moment.Variance)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>Variance</c> calculator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Variance.standardDeviation">
			<summary>Get the standard deviation of the sample,
 which is the square root of the variance.</summary>
			<returns>the standard deviation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Variance.addData(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Variance.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Variance.N">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Variance.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.moment.Skewness">
			<summary>Skewness is a measure of the asymmetry of the probability distribution.
 A distribution may either be positively or negatively skewed.
 For positive skew (or right-skewed), the right tail is longer.
 The mass of the distribution is concentrated on the left.
 For negative skew (or left-skewed), the left tail is longer.
 The mass of the distribution is concentrated on the right.
 The definition is:
 <blockquote><i>
 &#947; = E[((X - E(X)) / &#963;)<sup>3</sup>]
 </i></blockquote>
 This implementation uses Chan&apos;s update formula to incrementally compute the new statistic.
 <para/>
 The R equivalent function is <c>skewness</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/skewness">Wikipedia: Skewness</a></item>
 <item><a href="http://en.wikipedia.org/wiki/algorithms_for_calculating_variance">Wikipedia: Algorithms for calculating variance</a></item>
 <item>&quot;Chan, Tony F.; Golub, Gene H.; LeVeque, Randall J. (1979), &quot;Updating Formulae and a Pairwise Algorithm for Computing Sample Variances,&quot; Technical Report STAN-CS-79-773, Department of Computer Science, Stanford University.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Skewness.#ctor">
			<summary>Construct an empty <c>Skewness</c> calculator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Skewness.#ctor(System.Double[])">
			<summary>Construct a <c>Skewness</c> calculator,
 initialized with a sample.</summary>
			<param name="data">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Skewness.#ctor(com.numericalmethod.suanshu.stats.descriptive.moment.Skewness)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>Skewness</c> calculator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Skewness.sample">
			<summary>Get the sample skewness (biased estimator).</summary>
			<returns>the sample skewness</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Skewness.addData(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Skewness.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Skewness.N">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Skewness.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.moment.Moments">
			<summary>Compute the central moment of a data set <em>incrementally</em>.
 The <i>n</i>-th moment is the expected value of the <i>n</i>-th power of the differences from the mean.
 That is,
 <blockquote><i>
 &#956;<sub>k</sub> = E[(X - E(X))<sup>k</sup>]
 </i></blockquote>
 This implementation uses Pébay&apos;s update formula to incrementally compute the new statistic.<para> See also: </para><list type="bullet">
 <item>&quot;Pébay, Philippe, &quot;Formulas for Robust, One-Pass Parallel Computation of Covariances and Arbitrary-Order Statistical Moments,&quot; Technical Report SAND2008-6212, Sandia National Laboratories, 2008.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/moment_%28mathematics%29">Wikipedia: Moment (mathematics)</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Moments.#ctor(System.Int32)">
			<summary>Construct an empty moment calculator, computing all moments up to and including the <c>order</c>-th moment.</summary>
			<param name="order">the number of the highest moment</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Moments.#ctor(System.Int32,System.Double[])">
			<summary>Construct a moment calculator, computing all moments up to and including the <c>order</c>-th moment.
 initialized with a sample.</summary>
			<param name="order">the order of the highest moment</param>
			<param name="data">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Moments.#ctor(com.numericalmethod.suanshu.stats.descriptive.moment.Moments)">
			<summary>Copy constructor.</summary>
			<param name="that">a moment calculator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Moments.centralMoment(System.Int32)">
			<summary>Get the value of the <i>k</i>-th central moment.
 This method can be used to compute the lower moments.
 For example,
 <c>centralMoment(1)</c> is the mean.
 Note that higher central moments do not correspond to variance, skew, kurtosis, etc.</summary>
			<param name="k">the order of the moment</param>
			<returns>the value of the <i>k</i>-th central moment</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Moments.addData(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Moments.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Moments.N">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Moments.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Moments.sumsOfPowersOfDifferences(System.Int32,System.Double,System.Double[])">
			<summary>Compute the <c>power</c>-th moment of an array of <c>data</c> with respect to a <c>mean</c>.</summary>
			<param name="power">the power to raise the difference to</param>
			<param name="mean">the reference/center of the data, e.g., 0 or the mean</param>
			<param name="data">the data array</param>
			<returns>the <c>power</c>-th moment of an array of <c>data</c> with respect to a <c>mean</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.moment.Mean">
			<summary>The mean of a sample is the sum of all numbers in the sample,
 divided by the sample size. That is,
 <blockquote><i>
 E(X) = &#931; (xi) / N
 </i></blockquote>
 This implementation supports incremental update of the statistic.
 <para/>
 The R equivalent function is <c>mean</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Mean.#ctor">
			<summary>Construct an empty <c>Mean</c> calculator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Mean.#ctor(System.Double[])">
			<summary>Construct a <c>Mean</c> calculator,
 initialized with a sample.</summary>
			<param name="data">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Mean.#ctor(com.numericalmethod.suanshu.stats.descriptive.moment.Mean)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>Mean</c> calculator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Mean.addData(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Mean.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Mean.N">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Mean.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.moment.Kurtosis">
			<summary>Kurtosis measures the &quot;peakedness&quot; of the probability distribution of a real-valued random variable.
 Higher kurtosis means that there are more infrequent extreme deviations than frequent modestly sized deviations, hence a fatter tail.
 This implementation computes the <em>excess</em> kurtosis. That is,
 <blockquote><i>
 &#947; = E[((X - E(X)) / &#963;)<sup>4</sup>]
 </i></blockquote>
 This implementation uses Chan&apos;s update formula to incrementally compute the new statistic.
 <para/>
 The R equivalent function is <c>kurtosis</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/kurtosis">Wikipedia: Kurtosis</a></item>
 <item><a href="http://en.wikipedia.org/wiki/algorithms_for_calculating_variance">Wikipedia: Algorithms for calculating variance</a></item>
 <item>&quot;Tony F, Chan, Gene H, Golub, Randall J, LeVeque, &quot;Updating Formulae and a Pairwise Algorithm for Computing Sample Variances,&quot; Technical Report STAN-CS-79-773, Department of Computer Science, Stanford University, 1979.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Kurtosis.#ctor">
			<summary>Construct an empty <c>Kurtosis</c> calculator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Kurtosis.#ctor(System.Double[])">
			<summary>Construct a <c>Kurtosis</c> calculator,
 initialized with a sample.</summary>
			<param name="data">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Kurtosis.#ctor(com.numericalmethod.suanshu.stats.descriptive.moment.Kurtosis)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>Kurtosis</c> calculator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Kurtosis.sample">
			<summary>Get the sample kurtosis (biased estimator).</summary>
			<returns>the sample kurtosis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Kurtosis.addData(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Kurtosis.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Kurtosis.N">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.Kurtosis.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedVariance">
			<summary>The weighted sample variance is defined as follows.
 The biased sample variance is:
 \[
 \sigma^2 = \frac{\sum_{i=1}^N w_i \left(x_i - \mu^*\right)^2 }{V_1}
 \]
 where \(V_1 = \sum_{i=1}^N w_i\) and \(\mu^*\) is the weighted mean.
 The unbiased sample variance is (assuming each \(x_i\) is drawn from a Gaussian distribution with
 variance \(1 / w_i\)):
 \[
 s^2\ = \frac {V_1} {V_1^2-V_2} \sum_{i=1}^N w_i \left(x_i - \mu^*\right)^2
 \]
 where \(V_2 = \sum_{i=1}^N {w_i^2}\).<para> See also: </para><a href="http://en.wikipedia.org/wiki/weighted_mean#weighted_sample_variance">Wikipedia:
 Weighted mean - Weighted sample variance</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedVariance.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedVariance.#ctor(System.Boolean)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedVariance.#ctor(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedVariance.#ctor(System.Double[],System.Double[],System.Boolean)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedVariance.addData(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedVariance.addData(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedVariance.N">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedVariance.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedVariance.stdev">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedMean">
			<summary>The weighted mean is defined as
 \[
 \bar{x} = \frac{ \sum_{i=1}^N w_i x_i}{\sum_{i=1}^N w_i}
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/weighted_mean">Wikipedia: Weighted mean</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedMean.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedMean.#ctor(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedMean.addData(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedMean.addData(System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedMean.N">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedMean.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.moment.weighted.WeightedMean.sumOfWeights">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.rank.Rank">
			<summary>Rank is a relationship between a set of items such that,
 for any two items, the first is either &quot;ranked higher than&quot;, &quot;ranked lower than&quot; or &quot;ranked equal to&quot; the second.
 This is known as a weak order or total preorder of objects.
 It is not necessarily a total order of objects because two different objects can have the same ranking.
 The rankings themselves are totally ordered.
 In statistics, &quot;ranking&quot; refers to the data transformation in which numerical or ordinal values are replaced by their rank when the data are sorted.
 It is important to note that ranks can sometimes have non-integer values for tied data values.
 Thus, in one way of treating tied data values, when there is an even number of copies of the same data value,
 the statistical rank (being the median rank of the tied data) can end in ½ or another fraction.
 <para/>
 The R equivalent function is <c>rank</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/ranking">Wikipedia: Ranking</a></item>
 <item><a href="http://en.wikipedia.org/wiki/ranking#ranking_in_statistics">Wikipedia: Ranking in statistics</a></item>
 <item>&quot;Algorithm AS 26: Ranking an Array of Numbers. P. R. Freeman. Journal of the Royal Statistical Society. Series C (Applied Statistics) Vol. 19, No. 1 (1970), p. 111-113.&quot;</item>
 <item>&quot;Remark AS R7: A Remark on Algorithm AS 26: Ranking an Array of Numbers. P. R. Freeman. Journal of the Royal Statistical Society. Series C (Applied Statistics), Vol. 22, No. 1 (1973), p. 133.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Rank.#ctor(System.Double[],System.Double)">
			<summary>Compute the sample ranks of the values.</summary>
			<param name="values">the values</param>
			<param name="threshold">the tie threshold.
 If successive elements of the sorted array differ by less than the threshold, they are treated as equal.
 We count the number of ties in each group.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Rank.#ctor(System.Double[])">
			<summary>Compute the sample ranks of the values.</summary>
			<param name="values">the values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Rank.rank(System.Int32)">
			<summary>Get the rank of the <i>i</i>-th element.</summary>
			<param name="i">the index to a value</param>
			<returns>the rank of the <i>i</i>-th element</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Rank.ranks">
			<summary>Get the ranks of the values.</summary>
			<returns>the ranks</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Rank.t">
			<summary>/[
 t = \sum(t_i^3 - t_i)
 \]</summary>
			<returns><i>t</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Rank.s">
			<summary>\[
 s = \sum(t_i^2 - t_i)
 \]</summary>
			<returns><i>s</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile">
			<summary>Quantiles are points taken at regular intervals from the cumulative distribution function (CDF) of a random variable.
 Dividing ordered data into <i>q</i> essentially equal-sized data subsets is the motivation for <i>q</i>-quantiles;
 the quantiles are the data values marking the boundaries between consecutive subsets.
 Put another way, the <i>k</i>-th <i>q</i>-quantile for a random variable is the value <i>x</i> such that
 the probability that the random variable will be less than <i>x</i> is at most <i>k/q</i> and
 the probability that the random variable will be more than <i>x</i> is at most <i>(q - k)/q</i>.
 There are <i>q-1</i> <i>q</i>-quantiles, with <i>k</i> an integer satisfying <i>0 &lt; k &lt; q</i>.
 The smallest observation corresponds to probability 0 and the largest probability 1.
 This class implements the 9 different quantile definitions in Hyndman 1996.
 <para/>
 The R equivalent function is <c>quantile</c>.<para> See also: </para><list type="bullet">
 <item>&quot;R. J. Hyndman, and Y. Fan, &quot;Sample quantiles in statistical packages,&quot; American Statistician, 50, 361-365, 1996.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/quantile">Wikipedia: Quantile</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.#ctor(System.Double[],com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType)">
			<summary>Construct a <c>Quantile</c> calculator.</summary>
			<param name="data">the data</param>
			<param name="type">the algorithm to compute <i>Q(q)</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.#ctor(System.Double[])">
			<summary>Construct a <c>Quantile</c> calculator using the default type:
 <para></para>QuantileType#APPROXIMATELY_MEDIAN_UNBIASED.</summary>
			<param name="data">the data</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.value(System.Double)">
			<summary>Compute the sample value corresponding to a quantile.</summary>
			<param name="q">a quantile</param>
			<returns>the value for the <c>q</c> quantile</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.addData(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.N">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType">
			<summary>the available quantile definitions<para> See also: </para>&quot;R. J. Hyndman, and Y. Fan, &quot;Sample quantiles in statistical packages,&quot; American Statistician, 50, 361-365, 1996.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType.INVERSE_OF_EMPIRICAL_CDF">
			<summary>the inverse of empirical distribution function</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType.INVERSE_OF_EMPIRICAL_CDF_WITH_AVERAGING_AT_DISCONTINUITIES">
			<summary>the inverse of empirical distribution function with averaging at discontinuities</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType.NEAREST_EVEN_ORDER_STATISTICS">
			<summary>the nearest even order statistic as in SAS</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType.LINEAR_INTERPOLATION_OF_EMPIRICAL_CDF">
			<summary>the linear interpolation of the empirical cdf</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType.MIDWAY_THROUGH_STEPS_OF_EMPIRICAL_CDF">
			<summary>a piecewise linear function where
 the knots are the values midway through the steps of the empirical cdf</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType.MINITAB_SPSS">
			<summary>the definition in Minitab and SPSS</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType.S">
			<summary>the definition in S</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType.APPROXIMATELY_MEDIAN_UNBIASED">
			<summary>default: the resulting quantile estimates are approximately median-unbiased
 regardless of the distribution of the sample</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType.APPROXIMATELY_UNBIASED_IF_DATA_IS_NORMAL">
			<summary>the resulting quantile estimates are approximately unbiased
 for the expected order statistics if the sample is normally distributed</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.rank.Min">
			<summary>The minimum of a sample is the smallest value in the sample.
 <para/>
 The R equivalent function is <c>min</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/minimum">Wikipedia: Minimum</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Min.#ctor">
			<summary>Construct an empty <c>Min</c> calculator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Min.#ctor(System.Double[])">
			<summary>Construct a <c>Min</c> calculator,
 initialized with a sample.</summary>
			<param name="data">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Min.#ctor(com.numericalmethod.suanshu.stats.descriptive.rank.Min)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>Min</c> calculator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Min.addData(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Min.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Min.N">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Min.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.rank.Max">
			<summary>The maximum of a sample is the biggest value in the sample.
 <para/>
 The R equivalent function is <c>max</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/maximum">Wikipedia: Maximum</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Max.#ctor">
			<summary>Construct an empty <c>Max</c> calculator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Max.#ctor(System.Double[])">
			<summary>Construct a <c>Max</c> calculator,
 initialized with a sample.</summary>
			<param name="data">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Max.#ctor(com.numericalmethod.suanshu.stats.descriptive.rank.Max)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>Max</c> calculator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Max.addData(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Max.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Max.N">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.rank.Max.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.SynchronizedStatistic">
			<summary>This is a thread-safe wrapper of <para></para>Statistic by synchronizing all public methods
 so that only one thread at a time can access the instance.
 This is essentially the same principle used by Java&apos;s synchronized collection class.<para> See also: </para>&quot;Brian Goetz, Tim Peierls, Joshua Bloch and Joseph Bowbeer, &quot;Chapter 5,&quot; Java Concurrency in Practice.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.SynchronizedStatistic.addData(System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.SynchronizedStatistic.value">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.SynchronizedStatistic.N">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.StatisticFactory">
			<summary>A factory to construct a new <para></para>Statistic.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.StatisticFactory.getStatistic">
			<summary>Get a <para></para>Statistic.</summary>
			<returns>a <para></para>Statistic</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.descriptive.Statistic">
			<summary>A statistic (singular) is a single measure of some attribute of a sample (e.g., its arithmetic mean value).
 It is calculated by applying a function (statistical algorithm) to a sample, i.e., a set of data.<para> See also: </para><a href="http://en.wikipedia.org/wiki/statistic">Wikipedia: Statistic</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.Statistic.addData(System.Double[])">
			<summary>Recompute the statistic with more data, incrementally if possible.</summary>
			<param name="data">an array of new items</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.Statistic.value">
			<summary>Get the value of the statistic.</summary>
			<returns>the statistic</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.descriptive.Statistic.N">
			<summary>Get the size of the sample.</summary>
			<returns>the sample size</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassSampler">
			<summary>A random sampler that is constructed ad-hoc from a list of values and their probabilities.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassSampler.#ctor(java.util.List,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Creates an instance with the probable values and an RNG.</summary>
			<param name="outcomes">the values this distribution can take and their associated probabilities</param>
			<param name="uniformRNG">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassSampler.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassSampler.next">
			<summary>Gets the next random element from the range of the probability distribution.</summary>
			<returns>the next random outcome</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassQuantile">
			<summary>As probability mass function is discrete, there are gaps between values in the domain of its cdf,
 The quantile function is:
 \[
 Q(p)\,=\,\inf\left\{ x\in R : p \le F(x) \right\}
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassQuantile.#ctor(java.lang.Iterable,System.Double)">
			<summary>Constructs the quantile function for a probability mass function.</summary>
			<param name="outcomes">an ordered list of outcomes and their probabilities</param>
			<param name="normalization">a normalizing constant if the probabilities do not sum to 1; setting it
                      to 1 speed up the initialization</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassQuantile.#ctor(java.lang.Iterable)">
			<summary>Constructs the quantile function for a probability mass function. If the sum of the
 probabilities is not 1, it normalizes all probabilities by dividing them by the sum, which is
 automatically computed. To speed up the initialization phase, specify the
 <c>normalizatoin</c> constant instead.</summary>
			<param name="outcomes">an ordered list of outcomes and their probabilities</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassQuantile.quantile(System.Double)">
			<summary>Gets the quantile at a cumulative probability mass.</summary>
			<param name="cm">cumulative probability mass</param>
			<returns>the quantile at <c>cm</c>; <c>null</c> if <c>cm</c> is smaller than the first
         sample</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassFunction">
			<summary>A probability mass function (pmf) is a function that gives the probability that a discrete random
 variable is exactly equal to some value.
 Suppose that <i>X: S &#8594; R</i> is a discrete random variable defined on a sample space
 <i>S</i>.
 The probability mass function <i>f<sub>X</sub>: R &#8594; [0, 1]</i> for <i>X</i> is defined as
 <blockquote><i>
 f<sub>X</sub>(x) = Pr(X = x) = Pr({s &#8712; S : X(s) = x})
 </i></blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/probability_mass_function">Wikipedia: Probability mass
 function</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassFunction.evaluate(System.Object)">
			<summary>Compute the probability mass for a discrete realization <i>x</i>.</summary>
			<param name="x">a realization</param>
			<returns><c>pmf(x)</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassFunction.Mass">
			<summary>Stores a possible outcome for a probability distribution and its associated probability.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassFunction.Mass.#ctor(System.Object,System.Double)">
			<summary>Creates an instance with an outcome and its associated probability.</summary>
			<param name="outcome">an outcome</param>
			<param name="probability">the probability that the given outcome will occur</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassFunction.Mass.outcome">
			<summary>Gets the outcome.</summary>
			<returns>the outcome</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.discrete.ProbabilityMassFunction.Mass.probability">
			<summary>Gets the probability of the outcome.</summary>
			<returns>the probability</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateProbabilityDistribution">
			<summary>A multivariate or joint probability distribution for <i>X, Y, ...</i> is a probability
 distribution that gives the probability that each of <i>X, Y, ...</i> falls in any particular
 range or discrete set of values specified for that variable.<para> See also: </para><a href="http://en.wikipedia.org/wiki/joint_probability_distribution">Wikipedia: Joint
 probability distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateProbabilityDistribution.cdf(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Gets the cumulative probability <i>F(x) = Pr(X &#8804; x)</i>.</summary>
			<param name="x"><i>x</i></param>
			<returns><i>F(x) = Pr(X &#8804; x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateProbabilityDistribution.density(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>The density function, which, if exists, is the derivative of <i>F</i>. It describes the
 density of probability at each point in the sample space.
 <blockquote><i>
 f(x) = dF(X) / dx
 </i></blockquote>
 <em>This may not always exist.</em>
 <para/>
 For the discrete cases, this is the probability mass function. It gives the probability that
 a discrete random variable is exactly equal to some value.</summary>
			<param name="x"><i>x</i></param>
			<returns><i>f(x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateProbabilityDistribution.mean">
			<summary>Gets the mean of this distribution.</summary>
			<returns>the mean</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateProbabilityDistribution.mode">
			<summary>Gets the mode of this distribution.</summary>
			<returns>the mean</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateProbabilityDistribution.covariance">
			<summary>Gets the covariance matrix of this distribution.</summary>
			<returns>the covariance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateProbabilityDistribution.entropy">
			<summary>Gets the entropy of this distribution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/information_entropy">Wikipedia: Entropy
 (information theory)</a></summary>
			<returns>the entropy</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateProbabilityDistribution.moment(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>The moment generating function is the expected value of <i>e<sup>tX</sup></i>. That is,
 <blockquote><i>
 E(e<sup>tX</sup>)
 </i></blockquote>
 <em>This may not always exist.</em><para> See also: </para><a href="http://en.wikipedia.org/wiki/moment_generating_function">Wikipedia:
 Moment-generating function</a></summary>
			<param name="t"><i>t</i></param>
			<returns><i>E(exp(tX))</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateNormalDistribution">
			<summary>The multivariate Normal distribution or multivariate Gaussian distribution, is a generalization
 of the one-dimensional (univariate) Normal distribution to higher dimensions.
 <para/>
 An equivalent function in R is <c>dmvnorm</c> from the package <c>mvtnorm</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/multivariate_normal_distribution">Wikipedia:
 Multivariate normal distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateNormalDistribution.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs an instance with the given mean and covariance matrix.</summary>
			<param name="mu">the mean</param>
			<param name="Sigma">the covariance matrix which must be positive definite</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateNormalDistribution.#ctor(System.Int32)">
			<summary>Constructs an instance of the standard Normal distribution.</summary>
			<param name="dim">the dimensionality of the distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateNormalDistribution.cdf(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateNormalDistribution.density(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateNormalDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateNormalDistribution.mode">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateNormalDistribution.covariance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateNormalDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.multivariate.MultivariateNormalDistribution.moment(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.WeibullDistribution">
			<summary>The Weibull distribution interpolates between the exponential distribution <i>k = 1</i> and the Rayleigh distribution (<i>k = 2</i>),
 where <i>k</i> is the shape parameter.
 <para/>
 The R equivalent functions are <c>dweibull, pweibull, qweibull, rweibull</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/weibull_distribution">Wikipedia: WeibullDistribution distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.WeibullDistribution.#ctor(System.Double,System.Double)">
			<summary>Construct a Weibull distribution.</summary>
			<param name="lambda">&#955;</param>
			<param name="k">the shape parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.WeibullDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.WeibullDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.WeibullDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.WeibullDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.WeibullDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.WeibullDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.WeibullDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.WeibullDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.WeibullDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.WeibullDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.TDistribution">
			<summary>The Student t distribution is the probability distribution of <i>t</i>, where
 \[
 t = \frac{\bar{x} - \mu}{s / \sqrt N}
 \]
 <list type="bullet">
 <item>\(\bar{x}\) is the sample mean;</item>
 <item><i>&#956;</i> is the population mean;</item>
 <item><i>s</i> is the square root of the sample variance;</item>
 <item><i>N</i> is the sample size;</item>
 </list>
 The importance of the Student&apos;s distribution is
 when (as in nearly all practical statistical work) the population standard deviation is unknown and has to be estimated from the data.
 This is especially true when the sample size is small.
 When the sample size is large, the Student&apos;s distribution converges to the Normal distribution.
 <para/>
 The R equivalent functions are <c>dt, pt, qt, rt</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/student_t">Wikipedia: Student&apos;s t-distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.TDistribution.#ctor(System.Double)">
			<summary>Construct a Student&apos;s t distribution.</summary>
			<param name="v">the degree of freedom</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.TDistribution.mean">
			<summary></summary>
			<exception cref="T:java.lang.UnsupportedOperationException">when <c>v &lt;= 1</c></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.TDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.TDistribution.variance">
			<summary></summary>
			<exception cref="T:java.lang.UnsupportedOperationException">when <c>v &lt; 2</c></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.TDistribution.skew">
			<summary></summary>
			<exception cref="T:java.lang.UnsupportedOperationException">when <c>v &lt;= 3</c></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.TDistribution.kurtosis">
			<summary></summary>
			<exception cref="T:java.lang.UnsupportedOperationException">when <c>v &lt;= 4</c></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.TDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.TDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.TDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.TDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.TDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.RayleighDistribution">
			<summary>The L2 norm of <i>(x1, x2)</i>, where <i>x<sub>i</sub></i>&apos;s are normal, uncorrelated, equal variance and
 have the Rayleigh distributions.<para> See also: </para><a href="http://en.wikipedia.org/wiki/rayleigh_distribution">Wikipedia: RayleighDistribution distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.RayleighDistribution.#ctor(System.Double)">
			<summary>Construct a Rayleigh distribution.</summary>
			<param name="sigma">the standard deviation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.RayleighDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.RayleighDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.RayleighDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.RayleighDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.RayleighDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.RayleighDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.RayleighDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.RayleighDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.RayleighDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.RayleighDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution">
			<summary>A univariate probability distribution completely characterizes a random variable by stipulating
 the probability of each value of a random variable (when the variable is discrete), or the
 probability of the value falling within a particular interval (when the variable is continuous).
 \[
 F(x) = Pr(X &lt; x)
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/probability_distribution">Wikipedia: Probability
 distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution.mean">
			<summary>Gets the mean of this distribution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/expected_value">Wikipedia: Expected value</a></summary>
			<returns>the mean</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution.median">
			<summary>Gets the median of this distribution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/median">Wikipedia: Median</a></summary>
			<returns>the median</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution.variance">
			<summary>Gets the variance of this distribution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/variance">Wikipedia: Variance</a></summary>
			<returns>the variance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution.skew">
			<summary>Gets the skewness of this distribution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/skewness">Wikipedia: Skewness</a></summary>
			<returns>the skewness</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution.kurtosis">
			<summary>Gets the excess kurtosis of this distribution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/kurtosis">Wikipedia: Kurtosis</a></summary>
			<returns>the excess kurtosis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution.entropy">
			<summary>Gets the entropy of this distribution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/information_entropy">Wikipedia: Entropy
 (information theory)</a></summary>
			<returns>the entropy</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution.cdf(System.Double)">
			<summary>Gets the cumulative probability <i>F(x) = Pr(X &#8804; x)</i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/cumulative_distribution_function">Wikipedia:
 Cumulative distribution function</a></summary>
			<param name="x"><i>x</i></param>
			<returns><i>F(x) = Pr(X &#8804; x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution.quantile(System.Double)">
			<summary>Gets the quantile, the inverse of the cumulative distribution function.
 It is the value below which random draws from the distribution would fall <i>u&#215;100</i>
 percent of the time.
 <blockquote><code><i>
 F<sup>-1</sup>(u) = x, such that
 Pr(X &#8804; x) = u
 </i></code></blockquote>
 <em>This may not always exist.</em><para> See also: </para><a href="http://en.wikipedia.org/wiki/quantile_function">Wikipedia: Quantile
 function</a></summary>
			<param name="u"><c>u</c>, a quantile</param>
			<returns><i>F<sup>-1</sup>(u)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution.density(System.Double)">
			<summary>The density function, which, if exists, is the derivative of <i>F</i>.
 It describes the density of probability at each point in the sample space.
 <blockquote><i>
 f(x) = dF(X) / dx
 </i></blockquote>
 <em>This may not always exist.</em>
 <para/>
 For the discrete cases, this is the probability mass function.
 It gives the probability that a discrete random variable is exactly equal to some value.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/probability_density_function">Wikipedia:
 Probability density function</a></item>
 <item><a href="http://en.wikipedia.org/wiki/probability_mass_function">Wikipedia: Probability
 mass function</a></item>
 </list></summary>
			<param name="x"><i>x</i></param>
			<returns><i>f(x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution.moment(System.Double)">
			<summary>The moment generating function is the expected value of <i>e<sup>tX</sup></i>. That is,
 <blockquote><i>
 E(e<sup>tX</sup>)
 </i></blockquote>
 <em>This may not always exist.</em><para> See also: </para><a href="http://en.wikipedia.org/wiki/moment_generating_function">Wikipedia:
 Moment-generating function</a></summary>
			<param name="t"><i>t</i></param>
			<returns><i>E(exp(tX))</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution">
			<summary>The Poisson distribution (or Poisson law of small numbers) is a discrete probability distribution
 that expresses the probability of a given number of events occurring in a fixed interval of time
 and/or space if these events occur with a known average rate and independently of the time since
 the last event.
 <para/>
 The R equivalent functions are <c>dpois, ppois, qpois, rpois</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/poisson_distribution">
 Wikipedia: Poisson distribution</a></item>
 <item><a
 href="http://www.boost.org/doc/libs/1_36_0/libs/math/doc/sf_and_dist/html/math_toolkit/policy/pol_tutorial/understand_dis_quant.html">
 Wikipedia: Understanding Quantiles of Discrete Distributions</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution.#ctor(System.Double)">
			<summary>Construct a Poisson distribution.</summary>
			<param name="lambda">the rate per interval</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution.ccdf(System.Double)">
			<summary>The complementary cumulative distribution function.</summary>
			<param name="x"><i>x</i></param>
			<returns><i>1 - F(x) = 1 - Pr(X &#8804; x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution">
			<summary>The Normal distribution has its density a Gaussian function.
 The Normal distribution is probably the most important single distribution.
 By the central limit theorem, under certain conditions,
 the sum of a number of random variables with finite means and variances approaches a Normal distribution as the number of variables increases.
 Laplace proved that the Normal distribution occurs as a limiting distribution of arithmetic means of independent,
 identically distributed random variables with finite second moment.
 <para/>
 The R equivalent functions are <c>dnorm, pnorm, qnorm, rnorm</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/normal_distribution">Wikipedia: Normal distribution</a></item>
 <item>Gaussian</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution.#ctor">
			<summary>Construct an instance of the standard Normal distribution with mean 0 and standard deviation 1.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution.#ctor(System.Double,System.Double)">
			<summary>Construct a Normal distribution with mean <c>mu</c> and standard deviation <c>sigma</c>.</summary>
			<param name="mu">the mean</param>
			<param name="sigma">the standard deviation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution">
			<summary>A log-normal distribution is a probability distribution of a random variable whose logarithm is normally distributed.
 A variable might be modeled as log-normal if it can be thought of as the multiplicative product of many independent random variables each of which is positive.<para> See also: </para><a href="http://en.wikipedia.org/wiki/log-normal_distribution">Wikipedia: Log-normal distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution.#ctor(System.Double,System.Double)">
			<summary>Construct a log-normal distribution.</summary>
			<param name="logMu">the log mean</param>
			<param name="logSigma">the log standard deviation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution">
			<summary>This gamma distribution, when <i>k</i> is an integer, is the distribution of
 the sum of <i>k</i> independent exponentially distributed random variables,
 each of which has a mean of <i>&#952;</i> (which is equivalent to a rate parameter of
 <i>&#952;<sup>-1</sup></i>).
 <para/>
 The R equivalent functions are <c>dgamma, pgamma, qgamma, rgamma</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/gamma_distribution">Wikipedia: Gamma distribution
 distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution.#ctor(System.Double,System.Double)">
			<summary>Construct a Gamma distribution.</summary>
			<param name="k">the shape parameter</param>
			<param name="theta">the scale parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution.entropy">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.FDistribution">
			<summary>The F distribution is the distribution of the ratio of two independent chi-squared variates.
 <para/>
 The R equivalent functions are <c>df, pf, qf, rf</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/f_distribution">
 Wikipedia: FDistribution-distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.FDistribution.#ctor(System.Double,System.Double)">
			<summary>Construct an F distribution.</summary>
			<param name="df1">the first degree of freedom</param>
			<param name="df2">the second degree of freedom</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.FDistribution.mean">
			<summary></summary>
			<exception cref="T:java.lang.UnsupportedOperationException">when <i>df2 &#8804; 2</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.FDistribution.median">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.FDistribution.variance">
			<summary></summary>
			<exception cref="T:java.lang.UnsupportedOperationException">when <i>df2 &#8804; 4</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.FDistribution.skew">
			<summary></summary>
			<exception cref="T:java.lang.UnsupportedOperationException">when <i>df2 &#8804; 6</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.FDistribution.kurtosis">
			<summary></summary>
			<exception cref="T:java.lang.UnsupportedOperationException">when <i>df2 &#8804; 8</i></exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.FDistribution.entropy">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.FDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.FDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.FDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.FDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution">
			<summary>The exponential distribution describes the times between events in a Poisson process,
 a process in which events occur continuously and independently at a constant average rate.
 <para/>
 The R equivalent functions are <c>dexp, pexp, qexp, rexp</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/exponential_distribution">Wikipedia: ExponentialDistribution distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution.#ctor">
			<summary>Construct an instance of the standard exponential distribution, where the rate/lambda is 1.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution.#ctor(System.Double)">
			<summary>Construct an exponential distribution.</summary>
			<param name="lambda">the rate</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution">
			<summary>An empirical cumulative probability distribution function
 is a cumulative probability distribution function that
 assigns probability <i>1/n</i> at each of the <i>n</i> numbers in a sample.
 <para/>
 The R equivalent function is <c>ecdf</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/empirical_distribution_function">Wikipedia: EmpiricalDistribution distribution function</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.#ctor(System.Double[],com.numericalmethod.suanshu.stats.descriptive.rank.Quantile.QuantileType)">
			<summary>Construct an empirical distribution from a sample.</summary>
			<param name="observations">a sample</param>
			<param name="quantileType">specify how the quantile function is computed</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.#ctor(System.Double[])">
			<summary>Construct an empirical distribution from a sample using the default
 quantile type <para></para>QuantileType#APPROXIMATELY_MEDIAN_UNBIASED.</summary>
			<param name="data">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.nSamples">
			<summary>Get the number of samples in the empirical distribution.</summary>
			<returns>the number of samples</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.toArray">
			<summary>Get the sorted sample.</summary>
			<returns>the sorted sample</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.entropy">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.quantile(System.Double)">
			<summary>
 <para/>
 For an empirical distribution, this implementation assumes the following.
 <blockquote><code><i>
 F<sup>-1</sup>(0) = the minimum x value
 F<sup>-1</sup>(1) = the maximum x value
 </i></code></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.density(System.Double)">
			<summary>This is the probability mass function for the discrete sample.</summary>
			<param name="x">an observation</param>
			<returns><c>pmf(x)</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.EmpiricalDistribution.moment(System.Double)">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.ChiSquareDistribution">
			<summary>The Chi-square distribution is the distribution of
 the sum of the squares of a set of statistically independent standard Gaussian random variables.
 <para/>
 The R equivalent functions are <c>dchisq, pchisq, qchisq, rchisq</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/chi_square">Wikipedia: Chi-square distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ChiSquareDistribution.#ctor(System.Double)">
			<summary>Construct a Chi-Square distribution.</summary>
			<param name="k">the degree of freedom</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ChiSquareDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ChiSquareDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ChiSquareDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ChiSquareDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ChiSquareDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ChiSquareDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ChiSquareDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ChiSquareDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ChiSquareDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.ChiSquareDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution">
			<summary>The binomial distribution is the discrete probability distribution of the number of successes in a sequence of <i>n</i> independent yes/no experiments,
 each of which yields success with probability <i>p</i>.
 The binomial distribution is frequently used to model the number of successes in a sample of size <i>n</i> drawn with replacement from a population of size <i>N</i>.
 For <i>N</i> much larger than <i>n</i>, the binomial distribution is a good approximation of hypergeometric distribution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/binomial_distribution">Wikipedia: Binomial distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution.#ctor(System.Int32,System.Double)">
			<summary>Construct a Binomial distribution.</summary>
			<param name="n">the number of trials, a natural number</param>
			<param name="p">the success probability in each trial, <i>[0, 1]</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution.median">
			<summary>
 <para/>
 The result is rounded rounded down to an integer.</summary>
			<returns>median</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution.cdf(System.Double)">
			<summary></summary>
			<param name="x">the number of success trials, an integer; rounded down to the closest integer if x is not an integer</param>
			<returns>cdf(x)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution.quantile(System.Double)">
			<summary>
 <para/>
 Uses the Cornish-Fisher Expansion to include a skewness
 correction to a normal approximation. This gives an
 initial value which never seems to be off by more than
 1 or 2. A search is then conducted of values close to
 this initial start point.<para> See also: </para><a href='http://svn.r-project.org/r/trunk/src/nmath/qbinom.c'>qbinom</a></summary>
			<param name="u">a quantile</param>
			<returns><c>qbinom(u)</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution.density(System.Double)">
			<summary>This is the probability mass function.</summary>
			<param name="x">the number of success trials, an integer; rounded down to the closest integer if x is not an integer</param>
			<returns><c>pmf(x)</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution">
			<summary>The beta distribution is the posterior distribution of the parameter <i>p</i> of a binomial
 distribution
 after observing <i>&#945; - 1</i> independent events with probability <i>p</i> and
 <i>&#946; - 1</i> with probability <i>1 - p</i>,
 if the prior distribution of <i>p</i> is uniform.
 <para/>
 The R equivalent functions are <c>dbeta, pbeta, qbeta, rbeta</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/beta_distribution">Wikipedia: BetaDistribution
 distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution.#ctor(System.Double,System.Double)">
			<summary>Construct a Beta distribution.</summary>
			<param name="alpha">&#945;: the shape parameter</param>
			<param name="beta">&#946;: the shape parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution.ccdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution.moment(System.Double)">
			<summary><para><c>DEPRECATED:</c> Not supported yet.</para>
</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRVG">
			<summary>This is a fast thread-safe wrapper for random vector generators. This class
 is backed by <para></para>ConcurrentCachedGenerator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRVG.#ctor(com.numericalmethod.suanshu.stats.random.multivariate.RandomVectorGenerator,System.Int32)">
			<summary>Constructs a new instance which wraps the given random vector generator
 and uses a cache of the specified size. A larger cache will make the
 simulation slightly faster at the expense of increased memory usage, but
 can lead to the computation of unnecessary values at the tail.<para> See also: </para>ConcurrentCachedGenerator#ConcurrentCachedGenerator(com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedGenerator.Generator, int)</summary>
			<param name="rvg">the underlying generator</param>
			<param name="cacheSize">the cache size</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRVG.#ctor(com.numericalmethod.suanshu.stats.random.multivariate.RandomVectorGenerator)">
			<summary>Constructs a new instance which wraps the given random vector generator
 and uses a cache which has 8 entries per available core.</summary>
			<param name="rvg">the underlying generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRVG.nextVector">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRVG.seed(System.Int64[])">
			<summary>Delegate to the underlying random vector generator.
 Note: <em>this method is NOT thread-safe.</em></summary>
			<param name="seeds">the seeds</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRNG">
			<summary>This is a fast thread-safe wrapper for random number generators. This class
 is backed by <para></para>ConcurrentCachedGenerator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRNG.#ctor(com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator,System.Int32)">
			<summary>Constructs a new instance which wraps the given random number generator
 and uses a cache of the specified size. A larger cache will make the
 simulation slightly faster at the expense of increased memory usage, but
 can lead to the computation of unnecessary values at the tail.<para> See also: </para>ConcurrentCachedGenerator#ConcurrentCachedGenerator(com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedGenerator.Generator, int)</summary>
			<param name="rng">the underlying generator</param>
			<param name="cacheSize">the cache size</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRNG.#ctor(com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Construct a new instance which wraps the given random number generator and
 uses a cache which has 8 entries per available core.</summary>
			<param name="rng">the underlying generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRNG.nextDouble">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRNG.seed(System.Int64[])">
			<summary>Delegate to the underlying random number generator.
 Note: <em>this method is NOT thread-safe.</em></summary>
			<param name="seeds">the seeds</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRLG">
			<summary>This is a fast thread-safe wrapper for random long generators. This class
 is backed by <para></para>ConcurrentCachedGenerator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRLG.#ctor(com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator,System.Int32)">
			<summary>Constructs a new instance which wraps the given random long generator and
 uses a cache of the specified size. A larger cache will make the
 simulation slightly faster at the expense of increased memory usage, but
 can lead to unnecessary computation of values at the tail.<para> See also: </para>ConcurrentCachedGenerator#ConcurrentCachedGenerator(com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedGenerator.Generator, int)</summary>
			<param name="rlg">the underlying generator</param>
			<param name="cacheSize">the cache size</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRLG.#ctor(com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct a new instance which wraps the given random long generator and
 uses a cache which has 1000 entries per available core.</summary>
			<param name="rlg">the underlying generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRLG.nextLong">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRLG.seed(System.Int64[])">
			<summary>Delegate to the underlying random long generator.
 Note: <em>this method is NOT thread-safe.</em></summary>
			<param name="seeds">the seeds</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRLG.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedGenerator">
			<summary>A generic wrapper that makes an underlying item generator thread-safe by
 caching generated items in a concurrently-accessible list. This is more
 efficient than plainly synchronizing all accessors of the generator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedGenerator.#ctor(com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedGenerator.Generator,System.Int32)">
			<summary>Creates a new instance which wraps the given item generator and uses a
 cache of the specified size. A larger cache will make the concurrency
 slightly faster at the expense of increased memory usage, but may lead to
 the computation of unnecessary values at the tail.</summary>
			<param name="generator">the underlying generator</param>
			<param name="cacheSize">the size of the cache</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedGenerator.next">
			<summary>Returns the next value in the generated sequence.</summary>
			<returns>the next generated value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedGenerator.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedGenerator.Generator">
			<summary>Defines a generic generator of type <c>T</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedGenerator.Generator.next">
			<summary>Returns the next value in the underlying generated sequence.</summary>
			<returns>the next generated value</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.Seedable">
			<summary>A seed-able experiment allow the same experiment to be repeated in exactly the same way.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.Seedable.seed(System.Int64[])">
			<summary>Seed the random number/vector/scenario generator to produce repeatable experiments.</summary>
			<param name="seeds">the seeds</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.RNGUtils">
			<summary>This class provides static methods that wraps random number generators to
 produce synchronized generators.
 For example,
 <blockquote><c>
 RandomNumberGenerator rng = RngUtils.synchronizedRNG(new Gaussian());
 </c></blockquote>
 or
 <blockquote><c>
 RandomLongGenerator rlg = RngUtils.synchronizedRLG(new MersenneTwister());
 </c></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.RNGUtils.synchronizedRNG(com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Return a synchronized (thread-safe) <para></para>RandomNumberGenerator
 backed by a specified generator.</summary>
			<param name="rng">the generator to be &quot;wrapped&quot; in a synchronized generator</param>
			<returns>a synchronized generator</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.RNGUtils.synchronizedRLG(com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Return a synchronized (thread-safe) <para></para>RandomLongGenerator
 backed by a specified generator.</summary>
			<param name="rlg">the generator to be &quot;wrapped&quot; in a synchronized generator</param>
			<returns>a synchronized generator</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.RNGUtils.synchronizedRVG(com.numericalmethod.suanshu.stats.random.multivariate.RandomVectorGenerator)">
			<summary>Return a synchronized (thread-safe) <para></para>RandomVectorGenerator
 backed by a specified generator.</summary>
			<param name="rng">the generator to be &quot;wrapped&quot; in a synchronized generator</param>
			<returns>a synchronized generator</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.RNGUtils.nextN(com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator,System.Int32)">
			<summary>Generate <c>n</c> random numbers from a given random number generator.</summary>
			<param name="rng">a random number generator</param>
			<param name="n">the number of random numbers to be generated</param>
			<returns>the generated <c>n</c> numbers</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.RNGUtils.nextN(com.numericalmethod.suanshu.stats.random.multivariate.RandomVectorGenerator,System.Int32)">
			<summary>Generate <c>n</c> random vectors from a given random vector generator.</summary>
			<param name="rvg">a random vector generator</param>
			<param name="n">the number of random vectors to be generated</param>
			<returns>the generated <c>n</c> vectors</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.ConstantSeeder">
			<summary>A wrapper that seeds each given seedable random number generator with the given seed(s).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.ConstantSeeder.#ctor(java.lang.Iterable,System.Int64[])">
			<summary>Creates a wrapper with the underlying RLGs and the seeds for seeding each RLG.</summary>
			<param name="underlying">the underlying RLGs</param>
			<param name="seeds">the seeds</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.ConstantSeeder.iterator">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.multivariate.UniformDistributionOverBox">
			<summary>This random vector generator uniformly samples points over a box region.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.UniformDistributionOverBox.#ctor(com.numericalmethod.suanshu.interval.RealInterval[])">
			<summary>Construct a random vector generator to uniformly sample points over a box region.</summary>
			<param name="bounds">the feasible box region</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.UniformDistributionOverBox.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.UniformDistributionOverBox.nextVector">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.multivariate.RandomVectorGenerator">
			<summary>A (pseudo) multivariate random number generator samples a random vector from a multivariate distribution.
 The elements in a vector can be correlated.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/random_vector">Wikipedia: Multivariate random variable</a></item>
 <item><a href="http://en.wikipedia.org/wiki/random_number_generation">Wikipedia: Random number generation</a></item>
 <item><a href="http://en.wikipedia.org/wiki/pseudorandom_number_generator">Wikipedia: Pseudorandom number generator</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.RandomVectorGenerator.nextVector">
			<summary>Get the next random vector.</summary>
			<returns>the next random vector</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.multivariate.NormalRVG">
			<summary>A multivariate Normal random vector is said to be p-variate normally distributed if every linear
 combination of its p components has a univariate normal distribution. This implementation uses
 the &quot;Best Approximation of Indefinite Matrices&quot; in the reference. In the case where the
 covariance matrix is not positive definite, we force the diagonal elements in the eigen
 decomposition to a small non-negative number, e.g., 0. Then, we re-construct a positive definite
 matrix from the new diagonal elements.
 <para/>
 The R equivalent function is <c>rmvnorm</c> in package <c>mvtnorm</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/multivariate_normal_distribution">
 Wikipedia: Multivariate normal distribution</a></item>
 <item>&quot;Jin Wang, Chunlei Liu. &quot;Generating Multivariate Mixture of Normal Distributions using a
 Modified Cholesky Decomposition,&quot; Simulation Conference, 2006. WSC 06. Proceedings of the Winter.
 p. 342 - 347. 3-6 Dec. 2006.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.NormalRVG.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Constructs a multivariate Normal random vector generator.</summary>
			<param name="mu">the mean</param>
			<param name="sigma">the covariance matrix</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.NormalRVG.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs a multivariate Normal random vector generator.</summary>
			<param name="mu">the mean</param>
			<param name="sigma">the covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.NormalRVG.#ctor(System.Int32)">
			<summary>Constructs a standard multivariate Normal random vector generator.</summary>
			<param name="dim">the dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.NormalRVG.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.NormalRVG.nextVector">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.multivariate.MultinomialRVG">
			<summary>A multinomial distribution puts <i>N</i> objects into <i>K</i> bins according to the bins&apos;
 probabilities. An output random vector counts the number of objects in each bin, making a total
 of <i>N</i>.
 <para/>
 The R equivalent function is <c>rmultinom</c> in package <c>normix</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.MultinomialRVG.#ctor(System.Int32,System.Double[])">
			<summary>Constructs a multinomial random vector generator.</summary>
			<param name="N">an integer, say <i>N</i>, specifying the total number of objects that are put
             into <i>K</i> boxes in a typical multinomial experiment</param>
			<param name="prob">a numeric non-negative vector of length <i>K</i>, specifying the probability for
             the <i>K</i> boxes</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.MultinomialRVG.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.MultinomialRVG.nextVector">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.multivariate.IID">
			<summary>An i.i.d. random vector has elements drawn from the same distribution.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.IID.#ctor(com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator,System.Int32)">
			<summary>Construct a rvg that outputs vectors that have i.i.d. elements drawn from the same distribution.</summary>
			<param name="rng">the underlying (univariate) random number generator</param>
			<param name="length">the length of the output vectors</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.IID.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.multivariate.IID.nextVector">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.WeibullRNG">
			<summary>This random number generator samples from the Weibull distribution using the inverse transform sampling method.<para> See also: </para><a href="http://en.wikipedia.org/wiki/weibull_distribution">Wikipedia: WeibullDistribution distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.WeibullRNG.#ctor(System.Double,System.Double)">
			<summary>Construct a random number generator to sample from the Weibull distribution.</summary>
			<param name="lambda">the scale parameter</param>
			<param name="k">the shape parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.WeibullRNG.#ctor">
			<summary>Construct a random number generator to sample from the Weibull distribution.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.RayleighRNG">
			<summary>This random number generator samples from the Rayleigh distribution using the inverse transform sampling method.<para> See also: </para><a href="http://en.wikipedia.org/wiki/rayleigh_distribution">Wikipedia: RayleighDistribution distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.RayleighRNG.#ctor(System.Double)">
			<summary>Construct a random number generator to sample from the Rayleigh distribution.</summary>
			<param name="sigma">the standard deviation</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator">
			<summary>A (pseudo) random number generator is an algorithm designed to generate a sequence of numbers that lack any pattern.
 However, it is very important to know that the sequence is not random at all and
 that it is completely determined by a relatively small set of initial values.
 Knowing the generation algorithm and the states can predict the next value, as the values are generated in a deterministic way.
 <para/>
 By default, an implementation of <c>RandomNumberGenerator</c> is
 <em>not thread-safe</em>, and thus should not be shared among multiple threads.
 If a <c>RandomNumberGenerator</c> instance is used in a multi-threaded
 program, for example, use
 <blockquote><c>
 RandomNumberGenerator rng = RandomNumberGenerators.synchronizedRNG(new Gaussian());
 </c></blockquote><para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/random_number_generation">Wikipedia: Random number generation</a></item>
 <item><a href="http://en.wikipedia.org/wiki/pseudorandom_number_generator">Wikipedia: Pseudorandom number generator</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator.nextDouble">
			<summary>Get the next random <c>double</c>.</summary>
			<returns>the next random number</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator">
			<summary>A (pseudo) random number generator that generates a sequence of <c>long</c>s that lack any pattern and are uniformly distributed.
 <para/>
 By default, an implementation of <c>RandomLongGenerator</c> is
 <em>not thread-safe</em>, and thus should not be shared among multiple threads.
 If a <c>RandomLongGenerator</c> instance is used in a multi-threaded
 program, for example, use
 <blockquote><c>
 RandomLongGenerator uniform = RandomNumberGenerators.synchronizedRLG(new MersenneTwister());
 </c></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator.nextLong">
			<summary>Get the next random <c>long</c>.</summary>
			<returns>the next random <c>long</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.LogNormalRNG">
			<summary>This random number generator samples from the log-normal distribution.
 <para/>
 The R equivalent class are <c>dlnorm, plnorm, qlnorm, rlnorm</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/log-normal_distribution">Wikipedia: Log-normal distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.LogNormalRNG.#ctor(com.numericalmethod.suanshu.stats.random.univariate.normal.NormalRNG)">
			<summary>Construct a random number generator to sample from the log-normal distribution.</summary>
			<param name="rnorm">a random number generator that samples from the normal distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.LogNormalRNG.#ctor(System.Double,System.Double)">
			<summary>Construct a random number generator to sample from the log-normal distribution.</summary>
			<param name="logMean">the log of mean</param>
			<param name="logSigma">the log of standard deviation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.LogNormalRNG.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.LogNormalRNG.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.InverseTransformSampling">
			<summary>Inverse transform sampling (also known as inversion sampling, the inverse probability integral transform, the inverse transformation method, Smirnov transform, golden rule, etc.)
 is a basic method for pseudo-random number sampling,
 i.e. for generating sample numbers at random from any probability distribution given its cumulative distribution function.
 This basic idea is this:
 to generate a random variable <i>X</i> with a cumulative distribution function <i>F(x)</i> for all <i>x</i>,
 we first sample <i>u</i> from the uniform distribution.
 Then, <i>x = F<sup>-1</sup>(u) = Q(u)</i>.
 This method requires that <i>F(x)</i> has a continuous density function,
 hence, strictly increasing and its inverse well defined.<para> See also: </para><list type="bullet">
 <item>&quot;Paul Glasserman. &quot;p. 44,&quot; Monte Carlo Methods in Financial Engineering, 2004.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/inverse_transform_method">Wikipedia: Inverse transform sampling</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.InverseTransformSampling.#ctor(com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution)">
			<summary>Construct a random number generator to sample from a distribution.</summary>
			<param name="distribution">the distribution to sample from</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.InverseTransformSampling.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.InverseTransformSampling.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.BinomialRNG">
			<summary>This random number generator samples from the binomial distribution.
 <para/>
 The R equivalent class are <c>dbinom, pbinom, qbinom, rbinom</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/binomial_distribution">Wikipedia: Binomial distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.BinomialRNG.#ctor(System.Int32,System.Double)">
			<summary>Construct a random number generator to sample from the binomial distribution.</summary>
			<param name="n">the number of trials, a natural number</param>
			<param name="p">the success probability in each trial, [0, 1]</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.BinomialRNG.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.BinomialRNG.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.BernoulliTrial">
			<summary>A Bernoulli trial (or binomial trial) is a random experiment with exactly two possible outcomes,
 &quot;success&quot; and &quot;failure&quot;, in which the probability of success, <i>p</i>, is the same every time
 the experiment is conducted.<para> See also: </para><a href="http://en.wikipedia.org/wiki/bernoulli_trial">Wikipedia: Bernoulli trial</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.BernoulliTrial.#ctor(com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator,System.Double)">
			<summary>Creates a new instance that uses the given <para></para>RandomNumberGenerator to do the trial.</summary>
			<param name="rng">the random number generator that is to be used</param>
			<param name="p">the success probability</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.BernoulliTrial.nextTrial(com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator,System.Double)">
			<summary>Performs a Bernoulli trial that succeeds with probability <i>p</i>.</summary>
			<param name="rng">a random number generator</param>
			<param name="p">a success probability</param>
			<returns><c>true</c> if the trial succeeded</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.BernoulliTrial.nextTrial">
			<summary>Performs a Bernoulli trial that succeeds with probability <i>p</i>.</summary>
			<returns><c>true</c> if the trial succeeded</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.BernoulliTrial.nextLogTrial(com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator,System.Double)">
			<summary>Performs a Bernoulli trial that succeeds with probability <i>e<sup>p</sup></i>.</summary>
			<param name="rng">a random number generator</param>
			<param name="p">the log of a success probability</param>
			<returns><c>true</c> if the trial succeeded</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.BernoulliTrial.nextLogTrial">
			<summary>Performs a Bernoulli trial that succeeds with probability <i>e<sup>p</sup></i>.</summary>
			<returns><c>true</c> if the trial succeeded</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.BernoulliTrial.nextDouble">
			<summary>Get the next random <c>double</c>, which is either 1 (success) or 0 (failure).</summary>
			<returns>the next random outcome (1 or 0)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.BernoulliTrial.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.beta.VanDerWaerden1969">
			<summary><para><c>DEPRECATED:</c> <para></para>Cheng1978 is a much better algorithm.</para>
If <i>X</i> and <i>Y</i> are independent, with <i>X ~ &#915;(&#945;,&#952;)</i> and <i>Y ~ &#915;(&#946;,&#952;)</i> then <i>X/(X+Y) ~ Beta(&#945;,&#946;)</i>,
 so one algorithm for generating beta variates is to generate <i>X/(X+Y)</i>,
 where <i>X</i> is a gamma variate with parameters <i>&#915;(&#945;,1)</i> and <i>Y</i> is an independent gamma variate with parameters <i>&#915;(&#946;,1)</i>.<para> See also: </para>&quot;van der Waerden, B. L., &quot;Mathematical Statistics&quot;, Springer, ISBN 978-3540045076.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.beta.VanDerWaerden1969.#ctor(com.numericalmethod.suanshu.stats.random.univariate.gamma.RandomGammaGenerator,com.numericalmethod.suanshu.stats.random.univariate.gamma.RandomGammaGenerator)">
			<summary>Construct a random number generator to sample from the beta distribution.</summary>
			<param name="X">a random gamma generator</param>
			<param name="Y">a random gamma generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.beta.VanDerWaerden1969.#ctor(System.Double,System.Double)">
			<summary>Construct a random number generator to sample from the beta distribution.</summary>
			<param name="alpha">the gamma distribution parameter, <i>&#945;</i>, for <i>X</i></param>
			<param name="beta">the gamma distribution parameter, <i>&#946;</i>, for <i>X</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.beta.VanDerWaerden1969.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.beta.VanDerWaerden1969.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.beta.RandomBetaGenerator">
			<summary>This is a random number generator that generates random deviates according to the Beta distribution.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.beta.Cheng1978">
			<summary>Cheng, 1978, is a new rejection method for generating beta variates.
 The method is compared with previously published methods both theoretically and through computer timings.
 It is suggested that the method has advantages in both speed and programming simplicity over previous methods,
 especially for &quot;difficult&quot; combinations of parameter values.<para> See also: </para><list type="bullet">
 <item>&quot;R. C. H. Cheng, &quot;Generating beta variates with nonintegral shape parameters,&quot; Communications of the ACM 21, 317-322. 1978.&quot;</item>
 <item>&quot;http://svn.r-project.org/R/trunk/src/nmath/rbeta.c&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.beta.Cheng1978.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct a random number generator to sample from the beta distribution.</summary>
			<param name="aa">the degree of freedom</param>
			<param name="bb">the degree of freedom</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.beta.Cheng1978.#ctor(System.Double,System.Double)">
			<summary>Construct a random number generator to sample from the beta distribution.</summary>
			<param name="aa">the degree of freedom</param>
			<param name="bb">the degree of freedom</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.beta.Cheng1978.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.beta.Cheng1978.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.exp.Ziggurat2000Exp">
			<summary>This implements the ziggurat algorithm to sample from the exponential distribution.<para> See also: </para><list type="bullet">
 <item>&quot;George Marsaglia, Wai Wan Tsang, &quot;The Ziggurat Method for Generating Random Variables,&quot;
 Journal of Statistical Software 5 (8), 2000.&quot;</item>
 <item><a href="http://www.jstatsoft.org/v05/i08/supp/1">a C implementation of the Ziggurat
 algorithm</a></item>
 <item><a href="http://people.sc.fsu.edu/~jburkardt/c_src/ziggurat/ziggurat.c">another C
 implementation of the Ziggurat algorithm</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.exp.Ziggurat2000Exp.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.exp.Ziggurat2000Exp.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.exp.Ziggurat2000Exp.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.exp.RandomExpGenerator">
			<summary>This is a random number generator that generates random deviates according to the exponential distribution.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.exp.InverseTransformSamplingExpRNG">
			<summary>This is a pseudo random number generator that samples from the exponential distribution using the inverse transform sampling method.<para> See also: </para><a href="http://en.wikipedia.org/wiki/exponential_distribution">Wikipedia: ExponentialDistribution distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.exp.InverseTransformSamplingExpRNG.#ctor(System.Double)">
			<summary>Construct a random number generator to sample from the exponential distribution using the inverse transform sampling method.</summary>
			<param name="lambda">the rate parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.exp.InverseTransformSamplingExpRNG.#ctor">
			<summary>Construct a random number generator to sample from the standard exponential distribution using the inverse transform sampling method.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.gamma.XiTanLiu2010b">
			<summary>Xi, Tan and Liu proposed two simple algorithms to generate gamma random numbers based on
 the ratio-of-uniforms method and logarithmic transformations of gamma random variable.
 This implementation is Algorithm 4.1 in the reference. It restricts the range of the shape parameter to be equal to or less than 1.
 It, however, assumes the scale parameter is always 1.
 Note that for when the shape parameter &lt; 0.01, it returns numbers in logarithmic scale.
 Take exp to convert.<para> See also: </para>&quot;B. Xi, K. M. Tan, and C. Liu, &quot;Two New Ratio-of-Uniforms Gamma Random Number Generators,&quot; Technical Report #10-03, Purdue University.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.XiTanLiu2010b.#ctor(System.Double,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct a random number generator to sample from the gamma distribution.</summary>
			<param name="k">the shape parameter</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.XiTanLiu2010b.#ctor(System.Double)">
			<summary>Construct a random number generator to sample from the gamma distribution.</summary>
			<param name="k">the shape parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.XiTanLiu2010b.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.XiTanLiu2010b.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.gamma.XiTanLiu2010a">
			<summary>Xi, Tan and Liu proposed two simple algorithms to generate gamma random numbers based on
 the ratio-of-uniforms method and logarithmic transformations of gamma random variable.
 This implementation is Algorithm 3.1 in the reference. It does not restrict the range of the shape parameter.
 It, however, assumes the scale parameter is always 1.
 Note that for when the shape parameter &lt; 0.01, it returns numbers in logarithmic scale.
 Take exp to convert.<para> See also: </para>&quot;B. Xi, K. M. Tan, and C. Liu, &quot;Two New Ratio-of-Uniforms Gamma Random Number Generators,&quot; Technical Report #10-03, Purdue University.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.XiTanLiu2010a.#ctor(System.Double,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct a random number generator to sample from the gamma distribution.</summary>
			<param name="k">the shape parameter</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.XiTanLiu2010a.#ctor(System.Double)">
			<summary>Construct a random number generator to sample from the gamma distribution.</summary>
			<param name="k">the shape parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.XiTanLiu2010a.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.XiTanLiu2010a.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.gamma.RandomGammaGenerator">
			<summary>This is a random number generator that generates random deviates according to the Gamma distribution.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.gamma.MarsagliaTsang2000">
			<summary>Marsaglia-Tsang is a procedure for generating a gamma variate as the cube of a suitably scaled normal variate.
 It is fast and simple, assuming one has a fast way to generate standard normal variables.
 This algorithm is (significantly) slowed down for when k &lt; 1 because an extra uniform rng needs to be generated.
 Consider using <para></para>KunduGupta2007 instead for k &lt; 1.<para> See also: </para>&quot;G. Marsaglia, W. W. Tsang, &quot;A simple method for generating gamma variables,&quot; ACM Transactions on Mathematical Software (TOMS), Vol 26, Issue 3, Sept., 2000.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.MarsagliaTsang2000.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.random.univariate.normal.RandomStandardNormalNumberGenerator,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct a random number generator to sample from the gamma distribution.</summary>
			<param name="k">the shape parameter</param>
			<param name="theta">the scale parameter</param>
			<param name="normal">a standard normal random number generator</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.MarsagliaTsang2000.#ctor(System.Double,System.Double)">
			<summary>Construct a random number generator to sample from the gamma distribution.</summary>
			<param name="k">the shape parameter</param>
			<param name="theta">the scale parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.MarsagliaTsang2000.#ctor">
			<summary>Construct a random number generator to sample from the standard gamma distribution.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.MarsagliaTsang2000.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.MarsagliaTsang2000.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.gamma.KunduGupta2007">
			<summary>Kundu-Gupta propose a very convenient way to generate gamma random variables using generalized
 exponential distribution,
 when the shape parameter lies between 0 and 1.
 This implementation is Algorithm 3 in the reference.<para> See also: </para>&quot;Debasis Kundu, Rameshwar D. Gupta, &quot;A convenient way of generating gamma random variables
 using generalized exponential distribution,&quot; Computational Statistics &amp; Data Analysis, Volume 51
 Issue 6, March, 2007.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.KunduGupta2007.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct a random number generator to sample from the gamma distribution.</summary>
			<param name="k">the shape parameter</param>
			<param name="theta">the scale parameter</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.KunduGupta2007.#ctor(System.Double,System.Double)">
			<summary>Construct a random number generator to sample from the gamma distribution.</summary>
			<param name="k">the shape parameter</param>
			<param name="theta">the scale parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.KunduGupta2007.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.KunduGupta2007.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.gamma.InverseTransformSamplingGammaRNG">
			<summary><para><c>DEPRECATED:</c> There exist much more efficient algorithms.</para>
This is a pseudo random number generator that samples from the gamma distribution using the inverse transform sampling method.
 This method is very slow and much better methods exist.<para> See also: </para><a href="http://en.wikipedia.org/wiki/gamma_distribution">Wikipedia: Gamma distribution distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.InverseTransformSamplingGammaRNG.#ctor(System.Double,System.Double)">
			<summary>Construct a random number generator to sample from the gamma distribution using the inverse transform sampling method.</summary>
			<param name="k">the shape parameter</param>
			<param name="theta">the scale parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.gamma.InverseTransformSamplingGammaRNG.#ctor">
			<summary>Construct a random number generator to sample from the standard gamma distribution using the inverse transform sampling method.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.normal.Zignor2005">
			<summary>This is an improved version of the Ziggurat algorithm as proposed in the reference.<para> See also: </para>&quot;J. A. Doornik, &quot;An Improved Ziggurat Method to Generate Normal Random Samples,&quot; Nuffield College, University of Oxford, 2005.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.Zignor2005.#ctor(com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct an improved Ziggurat random normal generator.</summary>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.Zignor2005.#ctor">
			<summary>Construct an improved Ziggurat random normal generator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.Zignor2005.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.Zignor2005.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.normal.Ziggurat2000">
			<summary>The Ziggurat algorithm is an algorithm for pseudo-random number sampling from the Normal distribution.
 This is considerably faster than the two more commonly used methods to generate normally distributed random numbers,
 the Marsaglia polar method or the Box-Muller transform, which require at least a logarithm and a square root.
 Empirically, however, the <para></para>MarsagliaBray1964 Marsaglia polar method and the <para></para>BoxMuller transform seem to have better distributional properties.
 There are implementation problems in the original uniform random number generator proposed in the paper.
 To improve the quality, we use <para></para>MWC8222 for the uniform random number generation.<para> See also: </para><list type="bullet">
 <item>&quot;George Marsaglia, Wai Wan Tsang, &quot;The Ziggurat Method for Generating Random Variables,&quot; Journal of Statistical Software 5 (8), 2000&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/ziggurat_algorithm">Wikipedia: Ziggurat algorithm</a></item>
 <item><a href="http://www.jstatsoft.org/v05/i08/supp/1">a C implementation of the Ziggurat algorithm</a></item>
 <item><a href="http://people.sc.fsu.edu/~jburkardt/c_src/ziggurat/ziggurat.c">another C implementation of the Ziggurat algorithm</a></item>
 <item><a href="http://arxiv.org/ps_cache/math/pdf/0603/0603058v1.pdf">Boaz Nadler. &quot;Design Flaws in the Implementation of the Ziggurat and Monty Python methods (and some remarks on Matlab randn),&quot; The Journal of Business. arXiv:math/0603058v1. 2 March 2006.</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.Ziggurat2000.#ctor(com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct a Ziggurat random normal generator.</summary>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.Ziggurat2000.#ctor">
			<summary>Construct a Ziggurat random normal generator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.Ziggurat2000.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.Ziggurat2000.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.normal.StandardNormalRNG">
			<summary>An alias for <para></para>Zignor2005 to provide a default implementation for sampling from the standard Normal distribution.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.StandardNormalRNG.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.normal.RandomStandardNormalNumberGenerator">
			<summary>This is a random number generator that generates random deviates according to the standard Normal distribution.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.normal.NormalRNG">
			<summary>This is a random number generator that generates random deviates according to the Normal distribution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/normal_distribution">Wikipedia: Normal distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.NormalRNG.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.random.univariate.normal.RandomStandardNormalNumberGenerator)">
			<summary>Construct a random number generator to sample from the Normal distribution.</summary>
			<param name="mean">the mean</param>
			<param name="sigma">the standard deviation</param>
			<param name="rnorm">a standard random normal number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.NormalRNG.#ctor(System.Double,System.Double)">
			<summary>Construct a random number generator to sample from the Normal distribution.</summary>
			<param name="mean">the mean</param>
			<param name="sigma">the standard deviation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.NormalRNG.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.NormalRNG.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.normal.MarsagliaBray1964">
			<summary>The polar method (attributed to George Marsaglia, 1964) is a pseudo-random number sampling method for generating a pair of independent <em>standard</em> normal random variables.
 This is an acceptance-rejection method so there is no upper-bound on the number of uniforms it may use to generate a sample.
 Hence, this method is not applicable to quasi-Monte Carlo simulation.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/marsaglia_polar_method">Wikipedia: Marsaglia polar method</a></item>
 <item>&quot;G. Marsaglia, and T. A. Bray, &quot;A convenient method for generating normal variates,&quot; SIAM Review 6:260-264, 1964.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.MarsagliaBray1964.#ctor(com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct a random number generator to sample from the standard Normal distribution.</summary>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.MarsagliaBray1964.#ctor">
			<summary>Construct a random number generator to sample from the standard Normal distribution.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.MarsagliaBray1964.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.MarsagliaBray1964.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.normal.BoxMuller">
			<summary>The Box-Muller transform (by George Edward Pelham Box and Mervin Edgar Muller 1958)
 is a pseudo-random number sampling method for generating pairs of independent <em>standard</em> normally distributed
 (zero expectation, unit variance) random numbers,
 given a source of uniformly distributed random numbers.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/box-muller_method">Wikipedia: Box-Muller transform</a></item>
 <item>&quot;G. E. P. Box, and M. E. Muller, &quot;A note on the generation of random normal deviates,&quot; Annals of Mathematical Statistics 29:610-611, 1958.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.BoxMuller.#ctor(com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct a random number generator to sample from the standard Normal distribution.</summary>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.BoxMuller.#ctor">
			<summary>Construct a random number generator to sample from the standard Normal distribution.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.BoxMuller.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.normal.BoxMuller.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.poisson.Knuth1969">
			<summary>This is a random number generator that generates random deviates according to the Poisson distribution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/poisson_distribution#generating_poisson-distributed_random_variables">Wikipedia: Generating Poisson-distributed random variables</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.poisson.Knuth1969.#ctor(System.Double,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Construct a random number generator to sample from the Poisson distribution.</summary>
			<param name="lambda">the shape parameter</param>
			<param name="uniform">a uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.poisson.Knuth1969.#ctor(System.Double)">
			<summary>Construct a random number generator to sample from the Poisson distribution.</summary>
			<param name="lambda">the shape parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.poisson.Knuth1969.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.poisson.Knuth1969.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.MRG">
			<summary>A Multiple Recursive Generator (MRG) is a linear congruential generator which takes this form:
 <blockquote><code><i>
 x<sub>i</sub> = (a<sub>1</sub> * x<sub>i-1</sub> + a<sub>2</sub> * x<sub>i-2</sub> + ... + a<sub>k</sub> * x<sub>i-k</sub>) mod m
 u<sub>i</sub> = x<sub>i</sub> / m
 </i></code></blockquote><para> See also: </para>&quot;Paul Glasserman, &quot;p. 44,&quot; Monte Carlo Methods in Financial Engineering, 2004.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.MRG.#ctor(System.Int64,System.Int64[])">
			<summary>Construct a Multiple Recursive Generator.</summary>
			<param name="m">the modulus</param>
			<param name="a">multipliers for the Lehmer rng (a <c>long</c>)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.MRG.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.MRG.order">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.MRG.modulus">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.MRG.nextLong">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.MRG.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.LinearCongruentialGenerator">
			<summary>A linear congruential generator (LCG) produces a sequence of pseudo-random numbers
 based on a linear recurrence relation.
 An LCG is simple to understand and implement,
 but it should <em>not</em> be used for applications where high-quality randomness is critical.
 The higher quality pseudo-random generators available are, for instances, <para></para>MersenneTwister and <para></para>MWC8222.
 If, however, only a small number of random numbers are needed, e.g,. a few thousands,
 then an LCG should be sufficient.<para> See also: </para><a href="http://en.wikipedia.org/wiki/linear_congruential_generator">Wikipedia: Linear congruential generator</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.LinearCongruentialGenerator.order">
			<summary>Get the order of recursion.</summary>
			<returns>the order of recursion</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.LinearCongruentialGenerator.modulus">
			<summary>Get the modulus of this linear congruential generator.</summary>
			<returns>the modulus</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.Lehmer">
			<summary>Lehmer proposed a general linear congruential generator that generates pseudo-random numbers in
 [0, 1].
 It has this form:
 <blockquote><code><i>
 x<sub>i+1</sub> = (a * x<sub>i</sub> + c) mod m
 u<sub>i+1</sub> = x<sub>i+1</sub> / m
 </i></code></blockquote>
 We take <i>c</i> to be 0 because Marsaglia shows that there is little additional generality when
 <i>c &#8800; 0</i>.
 There are restrictions placed on the selection of <i>(a, m)</i> and the seed.
 For example,
 <list type="bullet">
 <item>the seed must be co-prime to <i>m</i>;</item>
 <item>the modulus <i>m</i> is a prime number or a power of a prime number;</item>
 <item>the multiplier <i>a</i> is an element of high multiplicative order modulo <i>m</i></item>
 </list>
 This implementation is essentially doing what <c>Random.next(int)</c> is doing (for a specific
 pair <i>a</i> and <i>m</i>),
 but it computes <i>(ax mod m)</i> in integer arithmetic without overflow under certain
 conditions.
 In addition, it allows customized multiplier and modulus.
 This class is the most fundamental building block for <em>all linear</em> random number
 generation algorithms in this library.<para> See also: </para><list type="bullet">
 <item>&quot;Lehmer, D.H. (1951) Mathematical methods in large-scale computing units, p.141-146.
 Proceedings of the Second Symposium on Large Scale Digital Computing Machinery. Harvard
 University Press, Cambridge, Mass.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/lehmer_random_number_generator">
 Wikipedia: Lehmer random number generator</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.Lehmer.#ctor(System.Int64,System.Int64,System.Int64)">
			<summary>Construct a Lehmer (pure) linear congruential generator.
 Suggested values are:
 <list type="bullet">
 <item> m = 2<sup>31</sup> - 1 = 2147483647; a = 16807 (inferior to the other 3)</item>
 <item> m = 2<sup>31</sup> - 1 = 2147483647; a = 39373</item>
 <item> m = 2147483399; a = 40692</item>
 <item> m = 2147483563; a = 40014</item>
 </list>
 This implementation computes the next random number in <em>long</em> arithmetic without
 overflow.
 It is based on L&apos;Ecuyer, P. (1988).
 Note that <i>a</i> cannot be too big.<para> See also: </para><list type="bullet">
 <item>&quot;Paul Glasserman, Monte Carlo Methods in Financial Engineering, 2004.&quot;</item>
 <item>&quot;P. L&apos;Ecuyer, &quot;Efficient and portable combined random number generators,&quot; Communications
 of the ACM 31:742-749, 774, Correspondence 32:1019-1024, 1988.&quot;</item>
 </list></summary>
			<param name="a">the multiplier</param>
			<param name="m">the modulus</param>
			<param name="seed">the seed. It should <em>not</em> be zero.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.Lehmer.#ctor(System.Int64,System.Int64,System.Int64,System.Int64)">
			<summary>Construct a skipping ahead Lehmer (pure) linear congruential generator.
 The pseudo-random sequence is a subset of the original Lehmer sequence,
 taking every <i>k</i> value.
 Equivalently, this call is the same as
 <blockquote><c>
 Lehmer((a^k)%m, m, seed)
 </c></blockquote>
 This implementation computes <i>(a^k)%m</i> more efficiently.
 Note that <i>a</i> cannot be too big.</summary>
			<param name="a">the multiplier</param>
			<param name="m">the modulus</param>
			<param name="k">the exponent</param>
			<param name="seed">the seed. It should <em>not</em> be zero.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.Lehmer.#ctor">
			<summary>Construct a Lehmer (pure) linear congruential generator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.Lehmer.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.Lehmer.order">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.Lehmer.modulus">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.Lehmer.nextLong">
			<summary><em>All</em> built-in <em>linear</em> random number generators in this library
 ultimately call this function to generate random numbers.
 This particular function is thus made thread safe using non-blocking synchronization.
 This in turn ensures thread-safety for all these rngs.
 If you are to write your own rng, you should either call this function,
 or have your own synchronization mechanism.<para> See also: </para>&quot;Brian Goetz, Tim Peierls, Joshua Bloch and Joseph Bowbeer. Java Concurrency in
 Practice.&quot;</summary>
			<returns>a random a <c>long</c> number</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.Lehmer.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.LEcuyer">
			<summary>This is the uniform random number generator recommended by L&apos;Ecuyer in 1996.
 The generator combines two MRGs.
 It has a period of approximately 2<sup>185</sup>.
 The first MRG has a modulus <c>m = 2^31-1 = 2147483647</c>, and
 <c>a[] = {0, 63308, -183326}</c>.
 The second has a modulus <c>m = 2145483479</c>, and
 <c>a[] = {86098, 0, -539608}</c>.<para> See also: </para>&quot;P. L&apos;Ecuyer, &quot;Combined multiple recursive random number generators,&quot; Operations Research 44:816-822, 1996.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.LEcuyer.#ctor">
			<summary>Construct a LEcuyer pseudo uniform random generator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.LEcuyer.#ctor(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
			<summary>Construct a LEcuyer pseudo uniform random generator and then seed.</summary>
			<param name="seed11">a seed</param>
			<param name="seed12">a seed</param>
			<param name="seed13">a seed</param>
			<param name="seed21">a seed</param>
			<param name="seed22">a seed</param>
			<param name="seed23">a seed</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.LEcuyer.seed(System.Int64[])">
			<summary>
 <para/>
 If there are not enough, i.e., fewer than 6, seeds, we recycle them.
 If there are more, we take the first 6 and ignore the rest.</summary>
			<param name="seeds">an array of seeds</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.LEcuyer.order">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.LEcuyer.modulus">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.LEcuyer.nextLong">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.LEcuyer.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.CompositeLinearCongruentialGenerator">
			<summary>A composite generator combines a number of simple <para></para>LinearCongruentialGenerator, such as <para></para>Lehmer,
 to form one longer period generator by first summing values and then taking modulus.
 The resultant generator in general has a superior uniformity and a longer period,
 without overflowing the arithmetics.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.CompositeLinearCongruentialGenerator.#ctor(com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.LinearCongruentialGenerator[])">
			<summary>Construct a linear congruential generator from some simpler and shorter modulus generators.</summary>
			<param name="rng">simpler and shorter modulus linear congruential generators</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.CompositeLinearCongruentialGenerator.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.CompositeLinearCongruentialGenerator.order">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.CompositeLinearCongruentialGenerator.modulus">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.CompositeLinearCongruentialGenerator.nextLong">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.linear.CompositeLinearCongruentialGenerator.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneTwisterParamSearcher">
			<summary>Searches for Mersenne-Twister parameters.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneTwisterParamSearcher.DEFAULT_MERSENNE_EXPONENT">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneTwisterParamSearcher.#ctor(com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Creates a new instance which uses the given RNG to do the parameter search.
 <para></para>#DEFAULT_MERSENNE_EXPONENT is used.</summary>
			<param name="rng">the random number generator to use for the search</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneTwisterParamSearcher.#ctor(com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator,com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent)">
			<summary>Creates a new instance which uses the given RNG to do the parameter search, with the given
 period parameter.
 <para/>
 The actual period of the RNG will be <i>2^p</i>, where <i>p</i> is the given <em>period</em>
 parameter.
 <para/>
 Note that choosing a greater period rapidly increases the cost of running the algorithm and
 the smallest period should suffice for all but the most demanding application.</summary>
			<param name="rng">the random number generator to use for the search</param>
			<param name="p">the period parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneTwisterParamSearcher.search(System.Int32)">
			<summary>Performs a search for parameters for a given id.</summary>
			<param name="id">the id</param>
			<returns>the found parameters</returns>
			<exception cref="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.DynamicCreatorException">if the search failed</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneTwisterParamSearcher.search">
			<summary>Performs a search for parameters with no id.</summary>
			<returns>the found parameters</returns>
			<exception cref="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.DynamicCreatorException">if the search for parameters has failed</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent">
			<summary>The value of a Mersenne Exponent <i>p</i> is a parameter for creating a Mersenne-Twister random
 number generator with a period of <i>2<sup>p</sup></i>.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P521">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P607">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P1279">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P2203">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P2281">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P3217">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P4253">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P4423">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P9689">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P9941">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P11213">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P19937">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P21701">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P23209">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.P44497">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent.value">
			<summary>Gets the value of this Mersenne exponent.</summary>
			<returns>the value of this Mersenne exponent</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.DynamicCreatorException">
			<summary>Indicates that a problem has occurred in the dynamic creation process, usually because suitable
 parameters were not found.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.DynamicCreator">
			<summary>Performs the Dynamic Creation algorithm (DC) to generate parameters for <para></para>MersenneTwister.
 <para/>
 The algorithm, developed by the original authors of Mersenne-Twister, can generate up to
 2<sup>16</sup> sets of parameters, which are orthogonal in that the streams of random numbers are
 uncorrelated with each other. For example, if you want 100 independent random streams in 100
 parallel machines, then what you need to do is calling DC 100 times, with id numbers 0 to 99.
 Then DC returns 100 different parameters for generators. Now you have 100 independent sources.
 <para/>
 Iterators returned by this class are thread safe.<para> See also: </para><list type="bullet">
 <item><a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/mt/dc/dgene.pdf">The original
 paper</a></item>
 <item><a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/mt/dc/dc.html">The authors&apos;
 original source code in C</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.DynamicCreator.#ctor(com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent,System.Int64[])">
			<summary>Creates a new instance which aims to generate MT RNGs with the given period.
 <para/>
 The period of the RNG will be 2<sup>p</sup>, where <i>p</i> is the <para></para>MersenneExponent
 provided.
 <para/>
 Note that choosing a greater period rapidly increases the cost of running the algorithm and
 the smallest period should suffice for all but the most demanding application.</summary>
			<param name="p">the value of <i>p</i></param>
			<param name="seeds">a seed for the RNG that controls the randomized nature of the dynamic creation
              algorithm</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.DynamicCreator.iterator">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam">
			<summary>Immutable parameters for creating a <para></para>MersenneTwister RNG.
 <para/>
 An instance could be generated by Dynamic Creation (DC) algorithm.<para> See also: </para>DynamicCreator</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int64,System.Int64)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getAaa(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getMm">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getNn">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getRr">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getWw">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getWmask">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getUmask">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getLmask">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getShift0">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getShift1">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getShiftB">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getShiftC">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getMaskB">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam.getMaskC">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwister">
			<summary>Mersenne Twister is one of the best pseudo random number generators available. It was invented by
 Makoto Matsumoto and Takuji Nishimura in 1997. This implementation is the MT19937 version that
 produces uniformly 32-bit integers. It is by-and-large a Java translation of the 2002-01-26
 version of the C by Makoto Matsumoto and Takuji Nishimura.
 <para/>
 Here is <em>their</em> copyright notice.

 <code>
    A C-program for MT19937, with initialization improved 2002/1/26.
  Coded by Takuji Nishimura and Makoto Matsumoto.

  Before using, initialize the state by using init_genrand(seed)
  or init_by_array(init_key, key_length).

  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    1. Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. The names of its contributors may not be used to endorse or promote
       products derived from this software without specific prior written
       permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


  Any feedback is very welcome.
  http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
  email: m-mat@math.sci.hiroshima-u.ac.jp
 </code><para> See also: </para><list type="bullet">
 <item><a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/mt/mt2002/codes/mt19937ar.c">The
 original C code</a></item>
 <item><a href="http://en.wikipedia.org/wiki/mersenne_twister">Wikipedia: Mersenne twister</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwister.#ctor">
			<summary>Constructs a random number generator to sample uniformly from [0, 1].</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwister.#ctor(System.Int64[])">
			<summary>Constructs a random number generator to sample uniformly from [0, 1].</summary>
			<param name="seeds">the seeds</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwister.#ctor(com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam)">
			<summary>Constructs a new instance, which uses parameters and the state contained in the given
 <para></para>MersenneTwisterParam instance.</summary>
			<param name="param">the parameter for creating this instance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwister.#ctor(com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwisterParam,System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwister.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwister.nextLong">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.MersenneTwister.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG">
			<summary>A pseudo uniform random number generator samples numbers from the unit interval, <i>[0, 1]</i>,
 in such a way that there are equal probabilities of them falling in any same length sub-interval.
 Sampling from the unit interval is the most basic building block of most pseudo random number generation algorithms.<para> See also: </para><a href="http://en.wikipedia.org/wiki/uniform_distribution_%28continuous%29">Wikipedia: UniformRng distribution (continuous)</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG.#ctor(com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG.Method)">
			<summary>Construct a pseudo uniform random number generator.</summary>
			<param name="method">the uniform random number generation algorithm to use</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG.#ctor">
			<summary>Construct a pseudo uniform random number generator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG.nextDouble">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG.nextLong">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG.Method">
			<summary>the pseudo uniform random number generators available</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG.Method.MERSENNE_TWISTER">
			<summary>Mersenne Twister (recommended)</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG.Method.LEHMER">
			<summary>Lehmer</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG.Method.LECUYER">
			<summary>Lecuyer</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG.Method.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.UniformRNG.Method.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.SHR3">
			<summary>SHR3 is a 3-shift-register generator with period 2^32-1.
 It uses <i>y(n)=y(n-1)(I+L^17)(I+R^13)(I+L^5)</i>,
 with the <i>y</i>&apos;s viewed as binary vectors,
 <i>L</i> the 32x32 binary matrix that shifts a vector left 1,
 and <i>R</i> its transpose.
 SHR3 seems to pass all tests except those related to the binary rank test,
 since 32 successive values, as binary vectors, must be linearly independent,
 while 32 successive truly random 32-bit integers, viewed as binary vectors, will be linearly independent only about 29% of the time.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.SHR3.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.SHR3.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.SHR3.nextLong">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.SHR3.nextDouble">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.SHR3.nextInt">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.SHR0">
			<summary>SHR0 is a simple uniform random number generator.<para> See also: </para><a href="http://arxiv.org/ps_cache/math/pdf/0603/0603058v1.pdf">Boaz Nadler. &quot;Design Flaws in the Implementation of the Ziggurat and Monty Python methods (and some remarks on Matlab randn),&quot; The Journal of Business. arXiv:math/0603058v1. 2 March 2006.</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.SHR0.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.SHR0.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.SHR0.nextLong">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.SHR0.nextDouble">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.SHR0.nextInt">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.random.univariate.uniform.MWC8222">
			<summary>Marsaglia&apos;s MWC256 (also known as MWC8222) is a multiply-with-carry generator.
 It has a period of 2^8222 and fares well in tests of randomness.
 It is also extremely fast, between 2 and 3 times faster than the Mersenne Twister.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.MWC8222.#ctor">
			<summary>Construct a random number generator to sample uniformly from [0, 1].</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.MWC8222.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.MWC8222.nextLong">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.random.univariate.uniform.MWC8222.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.TimeSeries">
			<summary>A time series is a serially indexed collection of items.
 Time series data have a natural temporal ordering.
 This makes time series analysis distinct from other common data analysis problems that have no natural ordering of the observations.
 A time series model will generally reflect the fact that observations close together in time will be more closely related than observations further apart.
 In addition, a time series model will often make use of the natural one-way ordering of time so that
 values for a given period will be expressed as deriving in some way from past values, rather than from future values.
 <para/>
 This implementation represents each datum and its timestamp as a pair of value and index often called time.
 The entries (pairs) are sorted in ascending order by the timestamps, c.f., <para></para>TimeSeries.Entry.
 A <c>TimeSeries</c> is immutable.<para> See also: </para><a href="http://en.wikipedia.org/wiki/time_series">Wikipedia: Time series</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.TimeSeries.size">
			<summary>Get the length of the time series.</summary>
			<returns>the time series length</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.TimeSeries.Entry">
			<summary>A time series is composed of a sequence of <c>Entry</c>s.
 <para/>
 An <c>TimeSeries.Entry</c> is immutable.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.TimeSeries.Entry.getTime">
			<summary>Get the timestamp.</summary>
			<returns>the timestamp</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.TimeSeries.Entry.getValue">
			<summary>Get the entry value.</summary>
			<returns>the entry value</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.DateTimeGenericTimeSeries">
			<summary>This is a generic time series where time is indexed by <c>DateTime</c> and value can be any
 type.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.DateTimeGenericTimeSeries.#ctor(DateTime[],System.Object[])">
			<summary>Construct a time series.</summary>
			<param name="timestamps">the timestamps</param>
			<param name="values">the data values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.DateTimeGenericTimeSeries.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.DateTimeGenericTimeSeries.iterator">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.DateTimeGenericTimeSeries.Entry">
			<summary>This is the <c>TimeSeries.Entry</c> for a <c>DateTime</c> -indexed time series.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.DateTimeGenericTimeSeries.Entry.getTime">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.DateTimeGenericTimeSeries.Entry.getValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.DateTimeGenericTimeSeries.Entry.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.DateTimeGenericTimeSeries.Entry.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateTimeSeries">
			<summary>A multivariate time series is a sequence of vectors indexed by some notion of time.
 The entries are the pair: <i>{(timestamp, vector)}</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateTimeSeries.toMatrix">
			<summary>Convert this multivariate time series into an <i>m x n</i> matrix, where
 <i>m</i> is the dimension, and <i>n</i> the length.</summary>
			<returns>the matrix representation of this time series</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateTimeSeries.dimension">
			<summary>Get the dimension of the multivariate time series.</summary>
			<returns>the multivariate time series dimension</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateTimeSeries.Entry">
			<summary>This is the <c>TimeSeries.Entry</c> for a multivariate time series.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateTimeSeries.Entry.#ctor(System.Object,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct an instance of <c>TimeSeries.Entry</c>.</summary>
			<param name="time">the timestamp</param>
			<param name="value">the entry value</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateTimeSeries.Entry.getValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateTimeSeries.Entry.getTime">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateTimeSeries.Entry.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateTimeSeries.Entry.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries">
			<summary>This is a multivariate time series indexed by some notion of time.
 This implementation explicitly remembers all data in memory. It is appropriate for a short time
 series.<para> See also: </para><a href="http://en.wikipedia.org/wiki/time_series">Wikipedia: Time series</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.#ctor(java.lang.Comparable[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Construct a multivariate time series from timestamps and vectors.</summary>
			<param name="timestamps">the timestamps</param>
			<param name="values">the vector values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.#ctor(java.lang.Comparable[],System.Double[][])">
			<summary>Construct a multivariate time series from timestamps and vectors.</summary>
			<param name="timestamps">the timestamps</param>
			<param name="values">the vector values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.#ctor(java.lang.Comparable[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate time series from timestamps and vectors.</summary>
			<param name="timestamps">the timestamps</param>
			<param name="values">the vector values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.iterator">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.toMatrix">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.toArray">
			<summary>Convert this multivariate time series into an array of vectors.</summary>
			<returns>the array representation of this time series</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.get(System.Int32)">
			<summary>Get the <i>i</i>-th value.</summary>
			<param name="i">the position index</param>
			<returns>the <i>i</i>-th value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.time(System.Int32)">
			<summary>Get the <i>i</i>-th timestamp.</summary>
			<param name="i">the position index</param>
			<returns>the <i>i</i>-th timestamp</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.timestamps">
			<summary>Get all the timestamps.</summary>
			<returns>the timestamps</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.drop(System.Int32)">
			<summary>Construct an instance of <c>MultivariateGenericTimeTimeSeries</c> by dropping the leading
 <c>nItems</c> entries, those most backward in time entries.</summary>
			<param name="nItems">the number of leading entries to be dropped</param>
			<returns>an instance of <c>MultivariateGenericTimeTimeSeries</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.diff(System.Int32)">
			<summary>Construct an instance of <c>MultivariateGenericTimeTimeSeries</c> by taking the first
 difference <c>d</c> times.</summary>
			<param name="d">the number of differences</param>
			<returns><c>diff(x, lag = 1, differences = d)</c> as in DoubleUtils</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateGenericTimeTimeSeries.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries">
			<summary>This simple multivariate time series has its vectored values indexed by integers.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct an instance of <c>MultivariateSimpleTimeSeries</c>.</summary>
			<param name="values">a matrix representation of the time series</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.#ctor(System.Double[][])">
			<summary>Construct an instance of <c>MultivariateSimpleTimeSeries</c>.</summary>
			<param name="values">a double array representation of the time series</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[])">
			<summary>Construct an instance of <c>MultivariateSimpleTimeSeries</c>.</summary>
			<param name="values">a vector representation of the time series</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries)">
			<summary>Construct an instance of <c>MultivariateSimpleTimeSeries</c> from a univariate time series.</summary>
			<param name="ts">a univariate time series</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.toMatrix">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.iterator">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.get(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.drop(System.Int32)">
			<summary>Construct an instance of <c>MultivariateSimpleTimeSeries</c> by dropping the leading
 <c>nItems</c> entries.</summary>
			<param name="nItems">the number of leading entries to be dropped</param>
			<returns>a <c>MultivariateSimpleTimeSeries</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.diff(System.Int32)">
			<summary>Construct an instance of <c>MultivariateSimpleTimeSeries</c> by taking the first difference
 <c>d</c> times.</summary>
			<param name="d">the number of differences</param>
			<returns><c>diff(x, lag = 1, differences = d)</c> as in DoubleUtils</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.lag(System.Int32,System.Int32)">
			<summary>Construct an instance of <c>MultivariateSimpleTimeSeries</c> by lagging the time series.
 This operation makes sense only for equi-distant data points.</summary>
			<param name="nLags">the number of lags</param>
			<param name="length">the length of the lagged time series</param>
			<returns>a lagged time series</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.lag(System.Int32)">
			<summary>Construct an instance of <c>MultivariateSimpleTimeSeries</c> by lagging the time series.
 This operation makes sense only for equi-distant data points.</summary>
			<param name="nLags">the number of lags</param>
			<returns>a lagged time series</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateIntTimeTimeSeries">
			<summary>This is a multivariate time series indexed by integers.
 The entries are the pair: <i>{(n, vector)}</i>.
 This time series is often seen in classical time series analysis, where the data points are
 equally spaced.<para> See also: </para><a href="http://en.wikipedia.org/wiki/time_series">Wikipedia: Time series</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateIntTimeTimeSeries.get(System.Int32)">
			<summary>Get the value at time <c>t</c> (random access).</summary>
			<param name="t">the time index, counting from 1</param>
			<returns>the value at time <c>t</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateIntTimeTimeSeries.Entry">
			<summary>This is the <c>TimeSeries.Entry</c> for an integer -indexed multivariate time series.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateIntTimeTimeSeries.Entry.#ctor(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct an instance of <c>Entry</c>.</summary>
			<param name="time">the index</param>
			<param name="value">the entry value</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.MultivariateRealization">
			<summary>A multivariate realization is a multivariate time series indexed by real numbers, e.g., real time.
 The entries are the pairs: <i>{(t, vector)}</i>.
 This time series is often seen in the studies of stochastic process, where the set of times is a continuum.<para> See also: </para><a href="http://en.wikipedia.org/wiki/stochastic_process">Wikipedia: Stochastic process</a></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.MultivariateRealization.Entry">
			<summary>This is the <c>TimeSeries.Entry</c> for a real number -indexed multivariate time series.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.MultivariateRealization.Entry.#ctor(System.Double,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct an instance of <c>TimeSeries.Entry</c>.</summary>
			<param name="time">the timestamp</param>
			<param name="value">the entry value</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeriesUtils">
			<summary>These are the utility functions to manipulate
 <para></para>com.numericalmethod.suanshu.stats.timeseries.datastructure.TimeSeries a univariate time series.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeriesUtils.toVector(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeries)">
			<summary>Cast a time series into a vector, discarding the timestamps.</summary>
			<param name="ts">a time series</param>
			<returns>a vector of values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeriesUtils.toMatrix(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeries)">
			<summary>Cast a time series into a column matrix, discarding the timestamps.</summary>
			<param name="ts">a time series</param>
			<returns>a column matrix of values</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeries">
			<summary>This is a univariate time series indexed by some notion of time.
 The entries are the pair: <i>{(timestamp, double)}</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeries.toArray">
			<summary>Convert this time series into an array, discarding the timestamps.</summary>
			<returns>the array representation of the time series</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeries.Entry">
			<summary>This is the <c>TimeSeries.Entry</c> for a univariate time series.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeries.Entry.#ctor(System.Object,System.Double)">
			<summary>Construct an instance of <c>Entry</c>.</summary>
			<param name="time">the timestamp</param>
			<param name="value">the entry value</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeries.Entry.getValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeries.Entry.getTime">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeries.Entry.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeries.Entry.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries">
			<summary>This is a univariate time series indexed by some notion of time.
 This implementation explicitly remembers all data in memory. It is appropriate for a short time
 series.<para> See also: </para><a href="http://en.wikipedia.org/wiki/time_series">Wikipedia: Time series</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.#ctor(java.lang.Comparable[],System.Double[])">
			<summary>Construct a univariate time series from timestamps and values.</summary>
			<param name="timestamps">the timestamps</param>
			<param name="values">the values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.iterator">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.toArray">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.get(System.Int32)">
			<summary>Get the <i>i</i>-th value.</summary>
			<param name="i">the position index</param>
			<returns>the <i>i</i>-th value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.get(java.lang.Comparable)">
			<summary>Get the value at time <c>t</c>.</summary>
			<param name="t">a timestamp</param>
			<returns>the value at time <c>t</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.time(System.Int32)">
			<summary>Get the <i>i</i>-th time.</summary>
			<param name="index">the position index</param>
			<returns>the <i>i</i>-th timestamp</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.timestamps">
			<summary>Get all the timestamps.</summary>
			<returns>the timestamps</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.drop(System.Int32)">
			<summary>Construct an instance of <c>GenericTimeTimeSeries</c> by dropping the leading <c>nItems</c>
 entries.</summary>
			<param name="nItems">the number of leading entries to be dropped</param>
			<returns>a <c>GenericTimeTimeSeries</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.diff(System.Int32)">
			<summary>Construct an instance of <c>GenericTimeTimeSeries</c> by taking the first difference
 <c>d</c> times.</summary>
			<param name="d">the number of differences</param>
			<returns><c>diff(x, lag = 1, differences = d)</c> as in DoubleUtils</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.GenericTimeTimeSeries.hashCode">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.DateTimeTimeSeries">
			<summary>This is a time series has its <c>double</c> values indexed by <c>DateTime</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.DateTimeTimeSeries.#ctor(DateTime[],System.Double[])">
			<summary>Construct a time series from <c>DateTime</c> and <c>double</c>.</summary>
			<param name="timestamps">the timestamps</param>
			<param name="values">the entry values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.DateTimeTimeSeries.#ctor(java.util.ArrayList,java.util.ArrayList)">
			<summary>Construct a time series from <c>DateTime</c> and <c>double</c>.</summary>
			<param name="timestamps">the timestamps</param>
			<param name="values">the entry values</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries">
			<summary>This simple univariate time series simply wraps a <c>double[]</c> to form a time series.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries.#ctor(System.Double[])">
			<summary>Constructs an instance of <c>SimpleTimeSeries</c>.</summary>
			<param name="values">an array of values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries.iterator">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries.toArray">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries.get(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries.drop(System.Int32)">
			<summary>Constructs an instance of <c>SimpleTimeSeries</c> by dropping the leading <c>nItems</c>
 entries.</summary>
			<param name="nItems">the number of leading entries to be dropped</param>
			<returns>a <c>SimpleTimeSeries</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries.diff(System.Int32)">
			<summary>Constructs an instance of <c>SimpleTimeSeries</c> by taking the first difference <c>d</c>
 times.</summary>
			<param name="d">the number of differences</param>
			<returns><c>diff(x, lag = 1, differences = d)</c> as in DoubleUtils</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries.lag(System.Int32,System.Int32)">
			<summary>Constructs an instance of <c>SimpleTimeSeries</c> by lagging the time series.
 This operation makes sense only for equi-distant data points.</summary>
			<param name="nLags">the number of lags</param>
			<param name="length">the length of the lagged time series</param>
			<returns>a lagged time series</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries.lag(System.Int32)">
			<summary>Constructs an instance of <c>SimpleTimeSeries</c> by lagging the time series.
 This operation makes sense only for equi-distant data points.</summary>
			<param name="nLags">the number of lags</param>
			<returns>a lagged time series</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries.hashCode">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.SimpleTimeSeries.equals(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries">
			<summary>This is a univariate time series indexed by integers.
 The entries are the pair: <i>{(n, double)}</i>.
 This time series is often seen in classical time series analysis, where the data points are equally spaced.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries.get(System.Int32)">
			<summary>Get the value at time <c>t</c>.</summary>
			<param name="t">a time index, counting from 1</param>
			<returns>the value at time <c>t</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries.Entry">
			<summary>This is the <c>TimeSeries.Entry</c> for an integer number -indexed univariate time series.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries.Entry.#ctor(System.Int32,System.Double)">
			<summary>Construct an instance of <c>TimeSeries.Entry</c>.</summary>
			<param name="time">the timestamp</param>
			<param name="value">the entry value</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.DifferencedIntTimeTimeSeries">
			<summary>Differencing of a time series <i>x<sub>t</sub></i> in discrete time <i>t</i> is the
 transformation of the series to a new time series <i>(1-B)x<sub>t</sub></i> where the new values
 are the differences between consecutive values of <i>x<sub>t</sub></i>. This procedure may be
 applied consecutively more than once, giving rise to the &quot;first differences&quot;, &quot;second
 differences&quot;,
 etc. An <i>d</i>-th order differencing gives arise to a new time series
 <i>(1-B)<sup>d</sup>x<sub>t</sub></i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.DifferencedIntTimeTimeSeries.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.DifferencedIntTimeTimeSeries.get(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.DifferencedIntTimeTimeSeries.toArray">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.DifferencedIntTimeTimeSeries.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.DifferencedIntTimeTimeSeries.iterator">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.Realization">
			<summary>This is a univariate time series indexed real numbers.
 The entries are in the pair: <i>{(t, double)}</i>.
 This time series is often seen in the studies of univariate stochastic process, where the set of times is a continuum.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.Realization.Entry">
			<summary>This is the <c>TimeSeries.Entry</c> for a real number -indexed univariate time series.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.Realization.Entry.#ctor(System.Double,System.Double)">
			<summary>Construct an instance of <c>TimeSeries.Entry</c>.</summary>
			<param name="time">the timestamp</param>
			<param name="value">the entry value</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.OneDimensionTimeSeries">
			<summary>This class constructs a univariate realization from a multivariate realization by taking one of its dimension (coordinate).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.OneDimensionTimeSeries.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateTimeSeries,System.Int32)">
			<summary>Construct a univariate realization from a multivariate realization by taking one of its dimension (coordinate).</summary>
			<param name="mts">a multivariate realization</param>
			<param name="dim">the dimension/coordinate to extract</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.OneDimensionTimeSeries.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.OneDimensionTimeSeries.iterator">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.OneDimensionTimeSeries.toArray">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel">
			<summary>The ARIMAX model (ARIMA model with eXogenous inputs) is a generalization of the ARIMA model by
 incorporating exogenous variables.
 Letting <i>L</i> be the lag operator, the <i>d</i>-th difference of a multivariate ARIMAX(p, d,
 q) process <i>Y<sub>t</sub></i> is
 \[
 X_t = (1 - L)^d Y_t
 \]
 where
 <i>X<sub>t</sub></i> is an ARMAX(p, q) process, for which
 \[
 X_t = \mu + \Sigma \phi_i X_{t-i} + \Sigma \theta_j \epsilon_{t-j} + \psi&apos; D_t + \epsilon_t,
 \]
 <i>X<sub>t</sub></i>, <i>&#956;</i> and <i>&#949;<sub>t</sub></i> are <i>n</i>-dimensional
 vectors.
 The <i>(n * n)</i> matrices \({\phi_i}\) and \({\theta_j}\) are the AR and MA coefficients
 respectively.
 <i>D<sub>t</sub></i> is an <i>(m * 1)</i> vector which contains all exogenous variables at time
 <i>t</i> (excluding the intercept term),
 and its coefficients are represented by an <i>(n * m)</i> matrix <i>&#968;</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate ARIMAX model.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="d">the order of integration</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate ARIMAX model with unit variance.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="d">the order of integration</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate ARIMAX model with zero-intercept (mu).</summary>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="d">the order of integration</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate ARIMAX model with unit variance and zero-intercept (mu).</summary>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="d">the order of integration</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a multivariate ARIMAX model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel)">
			<summary>Construct a multivariate ARIMAX model from a univariate ARIMAX model.</summary>
			<param name="model">a univariate ARIMAX model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.mu">
			<summary>Get the intercept (constant) vector.</summary>
			<returns>the intercept (constant) vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.AR(System.Int32)">
			<summary>Get the <i>i</i>-th AR coefficient; AR(0) = 1.</summary>
			<param name="i">an index</param>
			<returns>the <i>i</i>-th AR coefficient</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.phi">
			<summary>Get all the AR coefficients.</summary>
			<returns>all the AR coefficients</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.MA(System.Int32)">
			<summary>Get the <i>i</i>-th MA coefficient; MA(0) = 1.</summary>
			<param name="i">an index</param>
			<returns>the <i>i</i>-th MA coefficient</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.theta">
			<summary>Get all the MA coefficients.</summary>
			<returns>all the MA coefficients</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.psi">
			<summary>Get the coefficients of the deterministic terms.</summary>
			<returns>the coefficients of the deterministic terms; could be <c>null</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.d">
			<summary>Get the order of integration.</summary>
			<returns>the order of integration</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.dimension">
			<summary>Get the dimension of multivariate time series.</summary>
			<returns>the dimension of multivariate time series</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.p">
			<summary>Get the number of AR terms.</summary>
			<returns>the number of AR terms</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.q">
			<summary>Get the number of MA terms.</summary>
			<returns>the number of MA terms</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.maxPQ">
			<summary>Get the maximum of AR length or MA length.</summary>
			<returns>max(# AR terms, # MA terms)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.sigma">
			<summary>Get the white noise covariance matrix.</summary>
			<returns>the white noise covariance matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAXModel.getVARMAX">
			<summary>Get the ARMAX part of this ARIMAX model, essentially ignoring the differencing.</summary>
			<returns>the ARMAX part</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMASim">
			<summary>This class simulates a multivariate ARIMA process.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMASim.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAModel,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[],com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector[],com.numericalmethod.suanshu.stats.random.multivariate.RandomVectorGenerator)">
			<summary>Construct a multivariate ARIMA model.</summary>
			<param name="arima">a multivariate ARIMA model</param>
			<param name="lags">the lags of AR length; <c>lags[0]</c> is \(x_{t-1}\)</param>
			<param name="innovations">the innovations of MA length; <c>innovations[0]</c> is \(e_{t-1}\)</param>
			<param name="rvg">a random vector generator to generate innovations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMASim.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAModel,com.numericalmethod.suanshu.stats.random.multivariate.RandomVectorGenerator)">
			<summary>Construct a multivariate ARIMA model.
 The lags and innovations are initialized to 0.</summary>
			<param name="arima">a multivariate ARIMA model</param>
			<param name="rvg">a random vector generator to generate innovations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMASim.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAModel)">
			<summary>Construct a multivariate ARIMA model, using random standard Gaussian innovations.</summary>
			<param name="arima">an ARIMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMASim.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMASim.nextVector">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAModel">
			<summary>An ARIMA(p, d, q) process, <i>Y<sub>t</sub></i>, is such that
 \[
 X_t = (1 - L)^d Y_t
 \]
 where
 <i>L</i> is the lag operator, <i>d</i> the order of difference,
 <i>X<sub>t</sub></i> an ARMA(p, q) process, for which
 \[
 X_t = \mu + \Sigma \phi_i X_{t-i} + \Sigma \theta_j \epsilon_{t-j} + \epsilon_t,
 \]
 <i>X<sub>t</sub></i>, <i>&#956;</i> and <i>&#949;<sub>t</sub></i> are <i>n</i>-dimensional
 vectors.
 The <i>(n * n)</i> matrices \({\phi_i}\) and \({\theta_j}\) are the AR and MA coefficients
 respectively.<para> See also: </para><a href="http://en.wikipedia.org/wiki/autoregressive_integrated_moving_average">Wikipedia:
 Autoregressive integrated moving average</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate ARIMA model.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="d">the order of integration</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[])">
			<summary>Construct a multivariate ARIMA model with unit variance.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="d">the order of integration</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate ARIMA model with zero-intercept (mu).</summary>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="d">the order of integration</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[])">
			<summary>Construct a multivariate ARIMA model with unit variance and zero-intercept (mu).</summary>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="d">the order of integration</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel)">
			<summary>Construct a multivariate model from a univariate ARIMA model.</summary>
			<param name="model">a univariate ARIMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a multivariate ARIMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.arima.VARIMAModel.getVARMA">
			<summary>Get the ARMA part of this ARIMA model, essentially ignoring the differencing.</summary>
			<returns>the ARMA part</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.MultivariateAutoCovarianceFunction">
			<summary>This is the auto-covariance function of a multi-dimensional time series <i>{X<sub>t</sub>}</i>,
 \[
 K(i, j) = E((X_i - \mu_i) \times (X_j - \mu_j)&apos;)
 \]
 For a stationary process, the auto-covariance depends only on the lag, <i>|i - j|</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.MultivariateAutoCovarianceFunction.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.MultivariateAutoCovarianceFunction.get(System.Int32,System.Int32)">
			<summary>Get the auto-covariance matrix for <i>X<sub>i</sub></i> and <i>X<sub>j</sub></i>.</summary>
			<param name="i">i &gt; 0</param>
			<param name="j">j &gt; 0</param>
			<returns>the auto-covariance matrix indexed by <i>[i, j]</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.MultivariateAutoCorrelationFunction">
			<summary>This is the auto-correlation function of a multi-dimensional time series <i>{Xt}</i>.
 \[
 Y_{i,j} = E((X_i - \mu_i) \times (X_j - \mu_j)&apos;)
 \\
 \rho(i, j) = \frac{Y_{i,j}}{\sqrt{Y_{i,i}Y_{j,j}}}
 \]
 For a stationary process, the auto-correlation depends only on the lag, <i>|i - j|</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.MultivariateAutoCorrelationFunction.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.MultivariateAutoCorrelationFunction.get(System.Int32,System.Int32)">
			<summary>Get the auto-correlation of <i>X<sub>i</sub></i> and <i>X<sub>j</sub></i>.</summary>
			<param name="i">i &gt; 0</param>
			<param name="j">j &gt; 0</param>
			<returns>the auto-correlation Matrix indexed by <i>[i, j]</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAModel">
			<summary>This class represents a multivariate MA model.<para> See also: </para><a href="http://en.wikipedia.org/wiki/moving_average_model">Wikipedia: Moving average
 model</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate MA model.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[])">
			<summary>Construct a multivariate MA model with unit variance.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate MA model with zero-mean.</summary>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[])">
			<summary>Construct a multivariate MA model with unit variance and zero-mean.</summary>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.MAModel)">
			<summary>Construct a multivariate MA model from a univariate MA model.</summary>
			<param name="model">a univariate MA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a multivariate MA model</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAInvertibility">
			<summary>The inverse representation of an Autoregressive Moving Average (ARMA) model is a (truncated) infinite sum of the Moving Averages.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Eq. 11.3.13, Theorem 13.3.2, Chapter 11.3, Multivariate ARMA Processes,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAInvertibility.DEFAULT_NLAGS">
			<summary>the default number of lags</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAInvertibility.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel,System.Int32)">
			<summary>Construct the inverse representation of an ARMA model.</summary>
			<param name="model">an ARMA model</param>
			<param name="nLags">the number of lags</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAInvertibility.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel)">
			<summary>Construct the inverse representation of an ARMA model up to the default number of lags <para></para>#DEFAULT_NLAGS.</summary>
			<param name="model">an ARMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAInvertibility.PI">
			<summary>Get the coefficients of the linear representation of the time series.</summary>
			<returns>the coefficients of the linear representation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VMAInvertibility.getMAModel">
			<summary>Get the MA model of the inverse representation.</summary>
			<returns>the MA model of the inverse representation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMTransitory">
			<summary>A transitory Vector Error Correction Model (VECM(p)) takes this form.
 \[
 \Delta Y_t = \mu + \Pi Y_{t-1} + \Sigma \left ( \Gamma_i Y_{t-1} \right ) + \Psi D_t +
 \epsilon_t, i = 1, 2, ..., p-1
 \]
 <i>Y<sub>t</sub></i>, <i>&#956;</i> and <i>&#949;<sub>t</sub></i> are n-dimensional vectors.
 The impact matrix <i>&#928;</i> and the coefficients <i>{&#915;<sub>i</sub>}</i> of the lagged
 time series are n-by-n matrices;
 <i>D<sub>t</sub></i> is an m-by-1 vector which contains all exogenous variables at time <i>t</i>
 (excluding the intercept term),
 and its coefficients are represented by a n-by-m matrix <i>&#968;</i>.
 <para/>
 This implementation provides a conversion method between a transitory VECM(p) and a VARX(p)
 model.<para> See also: </para><list type="bullet">
 <item>S. Johansen, &quot;ch. 3-6, pp. 34-103,&quot; Likelihood-Based Inference in Cointegrated Vector
 Autoregressive Models, Oxford, Oxford University Press, 1995.</item>
 <item>S. Johansen, &quot;Estimation and Hypothesis Testing of Cointegration Vectors in Gaussian Vector
 Autoregressive Models,&quot; Econometrica, vol. 59, 1551-1580, 1991.</item>
 <item>A. Banerjee et al., Cointegration, Error Correction, and the Econometric Analysis of
 Non-Stationary Data, Oxford, Oxford University Press, 1993.</item>
 <item><a href="http://en.wikipedia.org/wiki/error_correction_model">Wikipedia: Error correction
 model</a></item>
 <item><a href="http://en.wikipedia.org/wiki/johansen_test">Wikipedia: Johansen test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMTransitory.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a transitory VECM(p) model.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="pi">the impact matrix</param>
			<param name="gamma">the AR coefficients of the lagged differences; <c>null</c> if <i>p = 1</i></param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMTransitory.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a transitory VECM(p) model with zero-intercept (mu).</summary>
			<param name="pi">the impact matrix</param>
			<param name="gamma">the AR coefficients of the lagged differences; <c>null</c> if <i>p = 1</i></param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMTransitory.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARXModel)">
			<summary>Construct a transitory VECM(p) from a VARX(p).</summary>
			<param name="varx">a VARX model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMTransitory.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMTransitory)">
			<summary>Copy constructor.</summary>
			<param name="that">a transitory VECM model</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMLongrun">
			<summary>The long-run Vector Error Correction Model (VECM(p)) takes this form.
 \[
 \Delta Y_t = \mu + \Pi Y_{t-p} + \sum \left ( \Gamma_i Y_{t-1} \right ) + \Psi D_t + \epsilon_t,
 i = 1, 2, ..., p-1
 \]
 <i>Y<sub>t</sub></i>, <i>&#956;</i> and <i>&#949;<sub>t</sub></i> are n-dimensional vectors.
 The impact matrix <i>&#928;</i> and the coefficients <i>{&#915;<sub>i</sub>}</i> of the lagged
 time series are n-by-n matrices;
 <i>D<sub>t</sub></i> is an m-by-1 vector which contains all exogenous variables at time <i>t</i>
 (excluding the intercept term),
 and its coefficients are represented by a n-by-m matrix <i>&#968;</i>.
 <para/>
 This implementation provides a conversion method between a long-run VECM(p) and a VARX(p) model.<para> See also: </para><list type="bullet">
 <item>S. Johansen, &quot;ch. 3-6, pp. 34-103,&quot; Likelihood-Based Inference in Cointegrated Vector
 Autoregressive Models, Oxford, Oxford University Press, 1995.</item>
 <item>S. Johansen, &quot;Estimation and Hypothesis Testing of Cointegration Vectors in Gaussian Vector
 Autoregressive Models,&quot; Econometrica, vol. 59, 1551-1580, 1991.</item>
 <item>A. Banerjee et al., Cointegration, Error Correction, and the Econometric Analysis of
 Non-Stationary Data, Oxford, Oxford University Press, 1993.</item>
 <item><a href="http://en.wikipedia.org/wiki/error_correction_model">Wikipedia: Error correction
 model</a></item>
 <item><a href="http://en.wikipedia.org/wiki/johansen_test">Wikipedia: Johansen test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMLongrun.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a long-run VECM(p) model.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="pi">the impact matrix</param>
			<param name="gamma">the AR coefficients of the lagged differences; <c>null</c> if <i>p = 1</i></param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMLongrun.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a long-run VECM(p) model with zero-intercept (mu).</summary>
			<param name="pi">the impact matrix</param>
			<param name="gamma">the AR coefficients of the lagged differences; <c>null</c> if <i>p = 1</i></param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMLongrun.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARXModel)">
			<summary>Construct a long-run VECM(p) from a VARX(p).</summary>
			<param name="varx">a VARX model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMLongrun.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMLongrun)">
			<summary>Copy constructor.</summary>
			<param name="that">a long-run VECM model</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECM">
			<summary>A Vector Error Correction Model (VECM(p)) has one of the following specifications:
 <para/>
 Transitory:
 \[
 \Delta Y_t = \mu + \Pi Y_{t-1} + \sum \left ( \Gamma_i Y_{t-1} \right ) + \Psi D_t + \epsilon_t, i = 1, 2, ..., p-1
 \]
 or
 <para/>
 Long-run:
 \[
 \Delta Y_t = \mu + \Pi Y_{t-p} + \sum \left ( \Gamma_i Y_{t-1} \right ) + \Psi D_t + \epsilon_t, i = 1, 2, ..., p-1
 \]
 <i>Y<sub>t</sub></i>, <i>&#956;</i> and <i>&#949;<sub>t</sub></i> are n-dimensional vectors.
 The impact matrix <i>&#928;</i> and the coefficients <i>{&#915;<sub>i</sub>}</i> of the lagged time series are n-by-n matrices;
 <i>D<sub>t</sub></i> is an m-by-1 vector which contains all exogenous variables at time <i>t</i> (excluding the intercept term),
 and its coefficients are represented by a n-by-m matrix <i>&#968;</i>.<para> See also: </para><list type="bullet">
 <item>S. Johansen, &quot;ch. 3-6, pp. 34-103,&quot; Likelihood-Based Inference in Cointegrated Vector Autoregressive Models, Oxford, Oxford University Press, 1995.</item>
 <item>S. Johansen, &quot;Estimation and Hypothesis Testing of Cointegration Vectors in Gaussian Vector Autoregressive Models,&quot; Econometrica, vol. 59, 1551-1580, 1991.</item>
 <item>A. Banerjee et al., Cointegration, Error Correction, and the Econometric Analysis of Non-Stationary Data, Oxford, Oxford University Press, 1993.</item>
 <item><a href="http://en.wikipedia.org/wiki/error_correction_model">Wikipedia: Error correction model</a></item>
 <item><a href="http://en.wikipedia.org/wiki/johansen_test">Wikipedia: Johansen test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECM.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a VECM(p) model.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="pi">the impact matrix</param>
			<param name="gamma">the AR coefficients of the lagged differences; <c>null</c> if <i>p = 1</i></param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECM.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECM)">
			<summary>Copy constructor.</summary>
			<param name="that">a VECM model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECM.mu">
			<summary>Get the intercept vector.</summary>
			<returns>the intercept (constant) vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECM.pi">
			<summary>Get the impact matrix.</summary>
			<returns>the impact matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECM.gamma(System.Int32)">
			<summary>Get the AR coefficient of the <i>i</i>-th lagged differences.</summary>
			<param name="i">an index, counting from 1</param>
			<returns>the AR coefficient of the <i>i</i>-th lagged differences</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECM.gamma">
			<summary>Get the AR coefficients of the lagged differences; <c>null</c> if <i>p = 1</i></summary>
			<returns>the AR coefficients of the lagged differences; <c>null</c> if <i>p = 1</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECM.psi">
			<summary>Get the coefficients of the deterministic terms.</summary>
			<returns>the coefficients of the deterministic terms; could be <c>null</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECM.sigma">
			<summary>Get the white noise covariance matrix.</summary>
			<returns>the white noise covariance matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECM.dimension">
			<summary>Get the dimension of the multivariate time series.</summary>
			<returns>the dimension of the multivariate time series</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECM.p">
			<summary>Get the order of the VECM model.</summary>
			<returns>the order of the VECM model</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARXModel">
			<summary>A VARX (Vector AutoRegressive model with eXogeneous inputs) model, <i>X<sub>t</sub></i>, takes
 this form.
 \[
 Y_t = \mu + \Sigma \phi_i * Y_{t-i} + \Psi * D_t + \epsilon_t
 \]
 where <i>Y<sub>t</sub></i>, <i>&#956;</i> and <i>&#949;<sub>t</sub></i> are <i>n</i>-dimensional
 vectors.
 The n-by-n matrices <i>{&#966;<sub>i</sub>}</i> (i = 1, 2, ..., p) denote the AR coefficients.
 <i>D<sub>t</sub></i> is an m-by-1 vector which contains all exogenous variables at time <i>t</i>
 (excluding the intercept term),
 and its coefficients are represented by an n-by-m matrix <i>&#968;</i>.
 <para/>
 This implementation provides conversion methods between a VARX(p) model and a VECM(p) model
 (long-run or transitory).<para> See also: </para><list type="bullet">
 <item>&quot;S. Johansen, &quot;ch. 2-4, pp. 11-88,&quot; Likelihood-Based Inference in Cointegrated Vector
 Autoregressive Models, Oxford, Oxford University Press, 1995.&quot;</item>
 <item>&quot;S. Johansen and K. Juselius, Maximum Likelihood Estimation and Inference on Cointegration -
 with Applications to the Demand for Money, Oxford Bull. of Econ. and Stat, vol. 52, 169-210,
 1990.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARXModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a VARX model.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="phi">the AR coefficients (excluding the initial 1)</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARXModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a VARX model with unit variance.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="phi">the AR coefficients (excluding the initial 1)</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARXModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a VARX model with zero-mean.</summary>
			<param name="phi">the AR coefficients (excluding the initial 1)</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARXModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a VARX model with unit variance and zero-mean.</summary>
			<param name="phi">the AR coefficients (excluding the initial 1)</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARXModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMTransitory)">
			<summary>Construct a VARX(p) from a transitory VECM(p).</summary>
			<param name="vecm">a transitory VECM(p)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARXModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VECMLongrun)">
			<summary>Construct a VARX(p) from a long-run VECM(p).</summary>
			<param name="vecm">a long-run VECM(p)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARXModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARXModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a VARX model</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARModel">
			<summary>This class represents a VAR model.<para> See also: </para><a href="http://en.wikipedia.org/wiki/vector_autoregression">Wikipedia: Vector
 autoregressive model</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a VAR model.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="phi">the AR coefficients (excluding the initial 1)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[])">
			<summary>Construct a VAR model with unit variance.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="phi">the AR coefficients (excluding the initial 1)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a VAR model with zero-intercept (mu).</summary>
			<param name="phi">the AR coefficients (excluding the initial 1)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[])">
			<summary>Construct a VAR model with unit variance and zero-intercept (mu).</summary>
			<param name="phi">the AR coefficients (excluding the initial 1)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARModel)">
			<summary>Construct a multivariate model from a univariate AR model.</summary>
			<param name="model">a univariate AR model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a VAR model</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAXModel">
			<summary>The ARMAX model (ARMA model with eXogenous inputs) is a generalization of the ARMA model by
 incorporating exogenous variables.
 <i>X<sub>t</sub></i> is an ARMAX(p, q) process, for which
 \[
 X_t = \mu + \sum \phi_i X_{t-i} + \sum \theta_j \epsilon_{t-j} + \psi&apos; D_t + \epsilon_t,
 \]
 <i>X<sub>t</sub></i>, <i>&#956;</i> and <i>&#949;<sub>t</sub></i> are <i>n</i>-dimensional
 vectors.
 The <i>(n * n)</i> matrices \({\phi_i}\) and \({\theta_j}\) are the AR and MA coefficients
 respectively.
 <i>D<sub>t</sub></i> is an <i>(m * 1)</i> vector which contains all exogenous variables at time
 <i>t</i> (excluding the intercept term),
 and its coefficients are represented by an <i>(n * m)</i> matrix <i>&#968;</i>.<para> See also: </para><a
 href="http://en.wikipedia.org/wiki/autoregressive_moving_average#generalizations">Wikipedia:
 Autoregressive moving average model - Generalizations</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAXModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate ARMAX model.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAXModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate ARMAX model with unit variance.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAXModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate ARMAX model with zero-intercept (mu).</summary>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAXModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate ARMAX model with unit variance and zero-intercept (mu).</summary>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAXModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAXModel)">
			<summary>Construct a multivariate model from a univariate ARMAX model.</summary>
			<param name="model">a univariate ARIMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAXModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAXModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a multivariate ARMAX model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAXModel.armaxMean(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Compute the multivariate ARMAX conditional mean.</summary>
			<param name="arLags">the AR lags</param>
			<param name="maLags">the MA lags</param>
			<param name="exVar">the exogenous variables</param>
			<returns>the conditional mean</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel">
			<summary>A multivariate ARMA model, <i>X<sub>t</sub></i>, takes this form.
 \[
 X_t = \mu + \Sigma \phi_i X_{t-i} + \Sigma \theta_j \epsilon_{t-j} + \epsilon_t,
 \]<para> See also: </para><list type="bullet">
 <item>&quot;P. J. Brockwell and R. A. Davis, Time Series: Theory and Methods, Springer, 2006.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/autoregressive_moving_average">Wikipedia:
 Autoregressive moving average model</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate ARMA model.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[])">
			<summary>Construct a multivariate ARMA model with unit variance.</summary>
			<param name="mu">the intercept (constant) vector</param>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multivariate ARMA model with zero-intercept (mu).</summary>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="sigma">the white noise covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix[])">
			<summary>Construct a multivariate ARMA model with unit variance and zero-intercept (mu).</summary>
			<param name="phi">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="theta">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel)">
			<summary>Construct a multivariate model from a univariate ARMA model.</summary>
			<param name="model">a univariate ARMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a multivariate ARMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel.conditionalMean(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Compute the multivariate ARMA conditional mean, given all the lags.</summary>
			<param name="arLags">the AR lags</param>
			<param name="maLags">the MA lags</param>
			<returns>the conditional mean</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel.unconditionalMean">
			<summary>Compute the multivariate ARMA unconditional mean.</summary>
			<returns>the unconditional mean</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel.getDemeanedModel">
			<summary>Get the demeaned version of the time series model.
 \[
 Y_t = (X_t - \mu) = \sum_{i=1}^p \phi_i (X_{t-i} - \mu) + \sum_{i=1}^q \theta_j
 \epsilon_{t-j} + \epsilon_t
 \]
 &#956; is the unconditional mean.</summary>
			<returns>the demeaned time series</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAForecastOneStep">
			<summary>This is an implementation, adapted for an ARMA process, of the innovation algorithm,
 which is an efficient way of obtaining a one step least square linear predictor.<para> See also: </para><list type="bullet">
 <item>&quot;P. J. Brockwell and R. A. Davis, &quot;Chapter 5.3, Recursive Prediction of an ARMA(p,q) Process,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</item>
 <item>&quot;P. J. Brockwell and R. A. Davis, &quot;Eqs. 11.4.26, 11.4.27, 11.4.28, Chapter 11.4, Recursive Prediction of an ARMA(p,q) Process, Best Linear Predictors of Second Order Random Vectors,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAForecastOneStep.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateIntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel)">
			<summary>Construct an instance of <c>InnovationAlgorithm</c> for a multivariate ARMA time series.</summary>
			<param name="Xt">an m-dimensional time series</param>
			<param name="model">the ARMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAForecastOneStep.xHat(System.Int32)">
			<summary>Get the one-step prediction \(\hat{X}_{n+1} = P_{\mathfrak{S_n}}X_{n+1}\), made at time <i>n</i>.</summary>
			<param name="n">time, ranging from 0 to <i>T</i>, the end of observation time</param>
			<returns>the one-step prediction \(\hat{X}_{n+1}\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAForecastOneStep.theta(System.Int32,System.Int32)">
			<summary>Get the coefficients of the linear predictor.</summary>
			<param name="i"><c>i</c>, ranging from 1 to <i>t</i></param>
			<param name="j"><c>j</c>, ranging from 1 to <i>t</i></param>
			<returns><i>&#920;[i][j]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAForecastOneStep.covariance(System.Int32)">
			<summary>Get the covariance matrix for prediction errors for \(\hat{x}_{n+1}\), made at time <i>n</i>.</summary>
			<param name="n">time, ranging from 0 to <i>T</i>, the end of observation time</param>
			<returns>the covariance matrix for prediction errors at time <i>n</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAAutoCovariance">
			<summary>Compute the Auto-CoVariance Function (ACVF) for a vector AutoRegressive Moving Average (ARMA) model, assuming that
 <i>EX<sub>t</sub> = 0</i>.
 <para/>
 This implementation solves the Yule-Walker equation.
 <para/>
 The R equivalent functions are <c>ARMAacf</c> and <c>TacvfAR</c> in package <c>FitAR</c>.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;p. 420, Eq. 11.3.15, The Covariance Matrix Function of a Causal ARMA Process, Chapter 11.3, Multivariate Time Series,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAAutoCovariance.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel,System.Int32)">
			<summary>Compute the auto-covariance function for a vector ARMA model.
 <para/>
 To solve Eq. 11.3.15, we &quot;expand&quot; the <i>(p+1)</i> matrix equations into <i>(p+1)*m*m</i> linear equations.
 <i>m</i> is the dimension of <i>&#915;</i> (ACVF).</summary>
			<param name="model">an ARIMA model</param>
			<param name="nLags">the number of lags</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAAutoCovariance.evaluate(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAAutoCovariance.evaluate(System.Double)">
			<summary>Get the <i>i</i>-th auto-covariance matrix.</summary>
			<param name="i">the lag order</param>
			<returns>the <i>i</i>-th auto-covariance matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAAutoCorrelation">
			<summary>Compute the Auto-Correlation Function (ACF) for a vector AutoRegressive Moving Average (ARMA) model, assuming that
 <i>EX<sub>t</sub> = 0</i>.
 <para/>
 This implementation solves the Yule-Walker equation.
 <para/>
 The R equivalent functions are <c>ARMAacf</c> and <c>TacvfAR</c> in package <c>FitAR</c>.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;p. 420, Eq. 11.3.15, The Covariance Matrix Function of a Causal ARMA Process, Chapter 11.3, Multivariate Time Series,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAAutoCorrelation.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel,System.Int32)">
			<summary>Compute the auto-correlation function for a vector ARMA model.</summary>
			<param name="model">an ARIMA model</param>
			<param name="nLags">the number of lags</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAAutoCorrelation.evaluate(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAAutoCorrelation.evaluate(System.Double)">
			<summary>Get the <i>i</i>-th auto-correlation matrix.</summary>
			<param name="i">the lag order</param>
			<returns>the <i>i</i>-th auto-correlation matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARLinearRepresentation">
			<summary>The linear representation of an Autoregressive Moving Average (ARMA) model is a (truncated)
 infinite sum of AR terms.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Eq. 11.3.12, Theorem 11.3.1, Chapter 11.3, Multivariate ARMA Processes,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARLinearRepresentation.DEFAULT_NUMBER_OF_LAGS">
			<summary>the default number of lags</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARLinearRepresentation.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel,System.Int32)">
			<summary>Construct the linear representation of an ARMA model.</summary>
			<param name="model">an ARMA model</param>
			<param name="nLags">the number of lags</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARLinearRepresentation.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARMAModel)">
			<summary>Construct the linear representation of an ARMA model up to the default number of lags <para></para>#DEFAULT_NUMBER_OF_LAGS.</summary>
			<param name="model">an ARMA model</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARFitting">
			<summary>This class construct a VAR model by estimating the coefficients using OLS regression.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.arma.VARFitting.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateIntTimeTimeSeries,System.Int32)">
			<summary>Estimate a VAR model from a multivariate time series.</summary>
			<param name="mts">a multivariate time series</param>
			<param name="p">the number of AR terms</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.MultivariateInnovationAlgorithm">
			<summary>This class implements the part of the innovation algorithm that computes the prediction error
 covariances, <i>V</i> and prediction coefficients <i>&#920;</i>.
 The coefficients depend only on the auto-covariance function and time horizon, <em>not</em> on
 any particular time series data.<para> See also: </para><list type="bullet">
 <item>&quot;P. J. Brockwell and R. A. Davis, &quot;Proposition 5.2.2, Chapter 5, Multivariate Time Series,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</item>
 <item>&quot;P. J. Brockwell and R. A. Davis, &quot;Proposition 11.4.2, Chapter 11.4, Best Linear Predictors of Second Order Random Vectors,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.MultivariateInnovationAlgorithm.#ctor(System.Int32,com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.MultivariateAutoCovarianceFunction)">
			<summary>Run the Innovation Algorithm to compute the prediction parameters,
 <i>V</i> and <i>&#920;</i>.</summary>
			<param name="T">time series length</param>
			<param name="K">the covariance structure of the time series</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.MultivariateInnovationAlgorithm.theta(System.Int32,System.Int32)">
			<summary>Get the coefficients of the linear predictor.</summary>
			<param name="i"><c>i</c>, ranging from 0 to <i>T</i></param>
			<param name="j"><c>j</c>, ranging from 0 to <i>T</i></param>
			<returns>&#920;[i][j]; &#920;[?][0] = 1</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.MultivariateInnovationAlgorithm.covariance(System.Int32)">
			<summary>Get the covariance matrix for prediction errors at time <i>t</i> for <i>x^<sub>t+1</sub></i>.</summary>
			<param name="n">time, ranging from 0 to <i>t</i>, the end of observation time</param>
			<returns>the covariance matrix for prediction errors at time <i>n</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.MultivariateForecastOneStep">
			<summary>The innovation algorithm is an efficient way to obtain
 a one step least square linear predictor for a multivariate linear time series
 with known auto-covariance and these properties (not limited to ARMA processes):
 <list type="bullet">
 <item><i>{x<sub>t</sub>}</i> can be non-stationary.</item>
 <item><i>E(x<sub>t</sub>) = 0</i> for all <i>t</i>.</item>
 </list><para> See also: </para><list type="bullet">
 <item>&quot;P. J. Brockwell and R. A. Davis, &quot;Proposition. 5.2.2. Chapter 5. Prediction of Stationary Processes,&quot; in <i>Time Series: Theory and Methods</i>, Springer, 2006.&quot;</item>
 <item>&quot;P. J. Brockwell and R. A. Davis, &quot;Proposition. 11.4.2. Chapter 11.4 Best Linear Predictors of Second Order Random Vectors,&quot; in <i>Time Series: Theory and Methods</i>, Springer, 2006.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.MultivariateForecastOneStep.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateIntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.MultivariateAutoCovarianceFunction)">
			<summary>Construct an instance of <tt>InnovationAlgorithm</tt> for a multivariate time series with known auto-covariance structure.</summary>
			<param name="Xt">an m-dimensional time series, length <i>t</i></param>
			<param name="K">auto-covariance function K(i, j) = E(Xi * Xj&apos;), a m x m matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.MultivariateForecastOneStep.xHat(System.Int32)">
			<summary>Get the one-step prediction \(\hat{X}_{n+1} = P_{\mathfrak{S_n}}X_{n+1}\), made at time <i>n</i>.</summary>
			<param name="n">time, ranging from 0 to <i>T</i>, the end of observation time</param>
			<returns>the one-step prediction \(\hat{X}_{n+1}\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.MultivariateForecastOneStep.theta(System.Int32,System.Int32)">
			<summary>Get the coefficients of the linear predictor.</summary>
			<param name="i"><c>i</c>, ranging from 1 to <i>t</i></param>
			<param name="j"><c>j</c>, ranging from 1 to <i>t</i></param>
			<returns><i>&#920;[i][j]</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.multivariate.stationaryprocess.MultivariateForecastOneStep.covariance(System.Int32)">
			<summary>Get the covariance matrix for prediction errors for \(\hat{x}_{n+1}\), made at time <i>n</i>.</summary>
			<param name="n">time, ranging from 0 to <i>T</i>, the end of observation time</param>
			<returns>the covariance matrix for prediction errors at time <i>n</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel">
			<summary>The ARIMAX model (ARIMA model with eXogenous inputs) is a generalization of the ARIMA model by incorporating exogenous variables.
 Letting <i>B</i> be the backward or lag operator, the <i>d</i>-th difference of an ARIMAX(p, d, q) process <i>X<sub>t</sub></i> is
 \[
 (1 - B)^d X_t = Y_t
 \]
 where
 <i>Y<sub>t</sub></i> is an ARMAX(p, q) process, for which
 \[
 Y_t = \mu + \sum_{i=1}^p \phi_i Y_{t-i} + \sum_{i=1}^q \theta_j \epsilon_{t-j} + \psi&apos; D_t + \epsilon_t,
 \]
 where <i>D<sub>t</sub></i> is an <i>(m * 1)</i> vector which contains all exogenous variables at time <i>t</i> (excluding the intercept term),
 and its coefficients are represented by an <i>m</i>-dimensional vector <i>&#968;</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.#ctor(System.Double,System.Double[],System.Int32,System.Double[],System.Double[],System.Double)">
			<summary>Construct a univariate ARIMAX model.</summary>
			<param name="mu">the intercept (constant) term</param>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="d">the order of integration</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise variance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.#ctor(System.Double,System.Double[],System.Int32,System.Double[],System.Double[])">
			<summary>Construct a univariate ARIMAX model with unit variance.</summary>
			<param name="mu">the intercept (constant) term</param>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="d">the order of integration</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.#ctor(System.Double[],System.Int32,System.Double[],System.Double[],System.Double)">
			<summary>Construct a univariate ARIMAX model with zero-intercept (mu).</summary>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="d">the order of integration</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise variance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.#ctor(System.Double[],System.Int32,System.Double[],System.Double[])">
			<summary>Construct a univariate ARIMAX model with unit variance and zero-intercept (mu).</summary>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficient</param>
			<param name="d">the order of integration</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficient</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a univariate ARIMAX model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.mu">
			<summary>Get the intercept (constant) term.</summary>
			<returns>the intercept (constant) term</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.AR(System.Int32)">
			<summary>Get the <i>i</i>-th AR coefficient; AR(0) = 1.</summary>
			<param name="i">an index</param>
			<returns>the <i>i</i>-th AR coefficient</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.phi">
			<summary>Get all the AR coefficients.</summary>
			<returns>all the AR coefficients</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.phiPolynomial">
			<summary>Get the polynomial <i>(1 - &#966;)</i>.
 The coefficients (except the initial 1) have the opposite signs to <para></para>#AR(int) and
 <para></para>#phi().</summary>
			<returns>the polynomial <i>(1 - &#966;)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.MA(System.Int32)">
			<summary>Get the <i>i</i>-th MA coefficient; MA(0) = 1.</summary>
			<param name="i">an index</param>
			<returns>the <i>i</i>-th MA coefficient</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.theta">
			<summary>Get all the MA coefficients.</summary>
			<returns>all the MA coefficients</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.thetaPolynomial">
			<summary>Get the polynomial <i>(1 + &#952;)</i>.</summary>
			<returns>the polynomial <i>(1 + &#952;)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.psi">
			<summary>Get the coefficients of the deterministic terms.</summary>
			<returns>the coefficients of the deterministic terms; could be <c>null</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.d">
			<summary>Get the order of integration.</summary>
			<returns>the order of integration</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.p">
			<summary>Get the number of AR terms.</summary>
			<returns>the number of AR terms</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.q">
			<summary>Get the number of MA terms.</summary>
			<returns>the number of MA terms</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.maxPQ">
			<summary>Get the maximum of AR length or MA length.</summary>
			<returns>max(# AR terms, # MA terms)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.sigma">
			<summary>Get the white noise variance.</summary>
			<returns>the white noise variance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.getARMAX">
			<summary>Get the ARMAX part of this ARIMAX model, essentially ignoring the differencing.</summary>
			<returns>the ARMAX part</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAXModel.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMASim">
			<summary>This class simulates an ARIMA (AutoRegressive Integrated Moving Average) process.
 It a generalization of an AutoRegressive Moving Average (ARMA) model.
 It is applied in some cases where data show evidence of non-stationarity,
 where an initial differencing step (corresponding to the &quot;integrated&quot; part of the model) can
 remove the non-stationarity.

 <para/>
 An ARMA model is a tool for understanding and, perhaps, predicting future values in this series.
 The model consists of two parts, an autoregressive (AR) part and a moving average (MA) part.
 It is usually denoted as ARMA(p, q) where <i>p</i> is the order of the autoregressive part
 and <i>q</i> the order of the moving average part.
 The notation AR(p) refers to the autoregressive model of order <i>p</i>. It is defined as
 the weighted sum of the lagged values, a constant, and a white noise.
 The notation MA(q) refers to the autoregressive model of order <i>q</i>. It is defined as
 the weighted sum of the lagged white noises and a drift.
 That is, a moving average model is conceptually a linear regression of the current value of the
 series
 against previous (unobserved) white noise error terms or random shocks.
 The random shocks are supposed to propagate to future values of the time series.<para> See also: </para><list type="bullet">
 <item>&quot;P. J. Brockwell and R. A. Davis, &quot;Chapter 9, Model Building and Forecasting with ARIMA
 Processes,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/autoregressive_integrated_moving_average">Wikipedia:
 Autoregressive integrated moving average</a></item>
 <item><a href="http://en.wikipedia.org/wiki/autoregressive_moving_average">Wikipedia:
 Autoregressive moving average model</a></item>
 <item><a href="http://en.wikipedia.org/wiki/autoregressive_model">Wikipedia: Autoregressive
 model</a></item>
 <item><a href="http://en.wikipedia.org/wiki/moving_average_model">Wikipedia: Moving average
 model</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMASim.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel,System.Double[],System.Double[],com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Construct an ARIMA model.</summary>
			<param name="arima">an ARIMA model</param>
			<param name="lags">the lags of AR length; <c>lags[0]</c> is \(x_{t-1}\)</param>
			<param name="innovations">the innovations of MA length; <c>innovations[0]</c> is \(e_{t-1}\)</param>
			<param name="rng">a random number generator to generate innovations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMASim.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Construct an ARIMA model.
 The lags and innovations are initialized to 0.</summary>
			<param name="arima">an ARIMA model</param>
			<param name="rng">a random number generator to generate innovations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMASim.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel)">
			<summary>Construct an ARIMA model, using random standard Gaussian innovations.</summary>
			<param name="arima">an ARIMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMASim.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMASim.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel">
			<summary>An ARIMA(p, d, q) process, <i>X<sub>t</sub></i>, is such that
 \[
 (1 - B)^d X_t = Y_t
 \]
 where
 <i>B</i> is the backward or lag operator, <i>d</i> the order of difference,
 <i>Y<sub>t</sub></i> an ARMA(p, q) process, for which
 \[
 Y_t = \mu + \Sigma \phi_i Y_{t-i} + \Sigma \theta_j \epsilon_{t-j} + \epsilon_t,
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/autoregressive_integrated_moving_average">Wikipedia: Autoregressive integrated moving average</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel.#ctor(System.Double,System.Double[],System.Int32,System.Double[],System.Double)">
			<summary>Construct a univariate ARIMA model.</summary>
			<param name="mu">the intercept (constant) term</param>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficients</param>
			<param name="d">the order of integration</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficients</param>
			<param name="sigma">the white noise variance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel.#ctor(System.Double,System.Double[],System.Int32,System.Double[])">
			<summary>Construct a univariate ARIMA model with unit variance.</summary>
			<param name="mu">the intercept (constant) term</param>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficients</param>
			<param name="d">the order of integration</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficients</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel.#ctor(System.Double[],System.Int32,System.Double[],System.Double)">
			<summary>Construct a univariate ARIMA model with zero-intercept (mu).</summary>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficients</param>
			<param name="d">the order of integration</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficients</param>
			<param name="sigma">the white noise variance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel.#ctor(System.Double[],System.Int32,System.Double[])">
			<summary>Construct a univariate ARIMA model with unit variance and zero-intercept (mu).</summary>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficients</param>
			<param name="d">the order of integration</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficients</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a univariate ARIMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel.getARMA">
			<summary>Get the ARMA part of this ARIMA model, essentially ignoring the differencing.</summary>
			<returns>the ARMA part</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecastMultiStep">
			<summary>Make a forecast for a time series assuming an ARIMA model using the innovative algorithm.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Section 9.5, Forecasting ARIMA Models,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecastMultiStep.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel,System.Int32)">
			<summary>Make the h-step ahead prediction for an ARIMA model.</summary>
			<param name="xt">the observations</param>
			<param name="arima">the ARIMA model</param>
			<param name="h">a time step</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecastMultiStep.y(System.Int32)">
			<summary>Get the stationary arma series.</summary>
			<param name="t">the time index, counting from 1</param>
			<returns><c>y[t]</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecastMultiStep.x_shifted(System.Int32)">
			<summary>Get the shifted time series of observations.</summary>
			<param name="t">the time index, counting from <i>-(d-1)</i></param>
			<returns><c>x[t]</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecastMultiStep.xHat">
			<summary>The next h-step ahead prediction.</summary>
			<returns>the h-step ahead prediction</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecastMultiStep.var">
			<summary>Get the mean squared error of the h-step ahead prediction.<para> See also: </para>&quot;eq. 9.5.6&quot;</summary>
			<returns>the mean squared error (variance)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecast">
			<summary>Forecast an ARIMA time series using the innovative algorithm.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Section 9.5, Forecasting ARIMA Models,&quot; Time Series:
 Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecast.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAModel)">
			<summary>Construct a forecaster for a time series assuming ARIMA model.</summary>
			<param name="xt">a time series</param>
			<param name="arima">the ARIMA specification</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecast.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,System.Int32,System.Int32,System.Int32,System.Double)">
			<summary>Construct a forecaster for a time series assuming ARIMA model.</summary>
			<param name="xt">a time series</param>
			<param name="p">the number of AR terms</param>
			<param name="d">the order of integration</param>
			<param name="q">the number of MA terms</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecast.next">
			<summary>Get the next forecast.</summary>
			<returns>the next forecast</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecast.Forecast">
			<summary>The forecast value and variance.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecast.Forecast.#ctor(System.Int32,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecast.Forecast.time">
			<summary>Get the forecast time.</summary>
			<returns>the forecast time</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecast.Forecast.xHat">
			<summary>Get the prediction at time <i>t</i>.</summary>
			<returns>the prediction</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecast.Forecast.var">
			<summary>Get the variance of the prediction.</summary>
			<returns>the variance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.arima.ARIMAForecast.Forecast.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.AutoCovarianceFunction">
			<summary>This is the auto-covariance function of a univariate time series <i>{x<sub>t</sub>}</i>.
 For a stationary process, the auto-covariance depends only on the lag, <i>|i - j|</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.AutoCovarianceFunction.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.AutoCovarianceFunction.get(System.Int32,System.Int32)">
			<summary>Get the auto-covariance of <i>x<sub>i</sub></i> and <i>x<sub>j</sub></i>.</summary>
			<param name="i">i &gt; 0</param>
			<param name="j">j &gt; 0</param>
			<returns>the auto-covariance of <i>x<sub>i</sub></i> and <i>x<sub>j</sub></i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.AutoCorrelationFunction">
			<summary>This is the auto-correlation function of a univariate time series <i>{x<sub>t</sub>}</i>.
 For a stationary process, the auto-correlation depends only on the lag, <i>|i - j|</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.AutoCorrelationFunction.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.AutoCorrelationFunction.get(System.Int32,System.Int32)">
			<summary>Get the auto-correlation of <i>x<sub>i</sub></i> and <i>x<sub>j</sub></i>.</summary>
			<param name="i">i &gt; 0</param>
			<param name="j">j &gt; 0</param>
			<returns>the correlation of <i>x<sub>i</sub></i> and <i>x<sub>j</sub></i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SamplePartialAutoCorrelation">
			<summary>This is the sample partial Auto-Correlation Function (PACF) for a univariate data set.<para> See also: </para>&quot;William W. S. Wei, &quot;Section 2.5.4, Sample Partial Auto-correlation function,&quot; Time Series Analysis : Univariate and Multivariate Methods (2nd Edition), July 17, 2005, Addison Wesley.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SamplePartialAutoCorrelation.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance.Type)">
			<summary>Construct the sample PACF for a time series.</summary>
			<param name="xt">a time series</param>
			<param name="type">the auto-covariance type</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SamplePartialAutoCorrelation.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries)">
			<summary>Construct the sample PACF for a time series.</summary>
			<param name="xt">a time series</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SamplePartialAutoCorrelation.evaluate(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SamplePartialAutoCorrelation.evaluate(System.Int32)">
			<summary>Compute the partial auto-correlation for lag <c>k</c>.</summary>
			<param name="lag">the lag order; it must be &gt; 1</param>
			<returns><i>&#961;(k)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance">
			<summary>This is the sample Auto-Covariance Function (ACVF) for a univariate data set.<para> See also: </para>&quot;William W. S. Wei, &quot;Section 2.5.2, Sample Auto-covariance function,&quot; Time Series Analysis : Univariate and Multivariate Methods (2nd Edition), July 17, 2005, Addison Wesley.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance.Type)">
			<summary>Construct the sample ACVF for a time series.</summary>
			<param name="xt">a time series</param>
			<param name="type">the auto-covariance type</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries)">
			<summary>Construct the sample ACVF for a time series.</summary>
			<param name="xt">a time series</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance.evaluate(System.Int32)">
			<summary>Compute the auto-covariance for lag <c>k</c>.</summary>
			<param name="k">the lag order</param>
			<returns><i>&#947;(k)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance.evaluate(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance.Type">
			<summary>the available auto-covariance types</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance.Type.TYPE_I">
			<summary>default: the denominator is the time series length</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance.Type.TYPE_II">
			<summary>the denominator is the time series length minus the lag</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance.Type.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance.Type.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCorrelation">
			<summary>This is the sample Auto-Correlation Function (ACF) for a univariate data set.<para> See also: </para>&quot;William W. S. Wei, &quot;Section 2.5.3, Sample Auto-correlation function,&quot; Time Series Analysis
 : Univariate and Multivariate Methods (2nd Edition), July 17, 2005, Addison Wesley.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCorrelation.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCovariance.Type)">
			<summary>Construct the sample ACF for a time series.</summary>
			<param name="xt">a time series</param>
			<param name="type">the auto-covariance type</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCorrelation.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries)">
			<summary>Construct the sample ACF for a time series.</summary>
			<param name="xt">a time series</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCorrelation.evaluate(System.Int32)">
			<summary>Compute the auto-correlation for lag <c>k</c>.</summary>
			<param name="k">the lag order</param>
			<returns><i>&#961;(k)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.sample.SampleAutoCorrelation.evaluate(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.MultiplicativeModel">
			<summary>The multiplicative model of a time series is a multiplicative composite of the trend, seasonality and irregular random components.
 <blockquote><i>
 Y[t] = T[t] * S[t] * e[t]
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.MultiplicativeModel.#ctor(System.Double[],System.Double[],System.Double[])">
			<summary>Construct a univariate time series by multiplying the components.</summary>
			<param name="trend">the trend component</param>
			<param name="seasonality">the seasonality component</param>
			<param name="randoms">the irregular random component</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.MultiplicativeModel.#ctor(System.Double[],System.Double[],com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Construct a univariate time series by multiplying the components.
 The irregular random component is generated using a custom random number generator.</summary>
			<param name="trend">the trend component</param>
			<param name="seasonality">the seasonality component</param>
			<param name="rng">a random number generator</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.MADecomposition">
			<summary>This class decomposes a time series into the trend, seasonal and stationary random components
 using the Moving Average Estimation method with symmetric window.
 That is,
 <blockquote><i>
 X<sub>t</sub> = m<sub>t</sub> + s<sub>t</sub> + Y<sub>t</sub>
 </i></blockquote>
 We have
 <list type="bullet">
 <item>EY<sub>t</sub> = 0</item>
 <item>s<sub>t+d</sub> = s<sub>t</sub></item>
 <item>&#931;(s<sub>j</sub>) = 0</item>
 </list>
 The R equivalent function is <c>decompose</c>.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;p. 23, Chapter 1.4, Elimination of both Trend and
 Seasonality,&quot; Time Series: Theory and Methods, 2nd ed, Springer, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.MADecomposition.#ctor(System.Double[],System.Double[],System.Int32)">
			<summary>Decompose a time series into the trend, seasonal and stationary random components using the
 Moving Average Estimation method.</summary>
			<param name="xt">a time series</param>
			<param name="MAFilter">the moving average filter to smooth the time series</param>
			<param name="period">the period of the time series; if aperiodic, use 1</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.MADecomposition.#ctor(System.Double[],System.Int32,System.Int32)">
			<summary>Decompose a time series into the trend, seasonal and stationary random components using the
 default filter.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Eq. 1.4.16, Chapter 1.4, Elimination of both Trend
 and Seasonality,&quot; Time Series: Theory and Methods, 2nd ed, Springer, 2006.&quot;</summary>
			<param name="xt">a time series</param>
			<param name="MAOrder">the length of the MA filter (automatically increased by 1 for even
                <c>MAOrder</c>)</param>
			<param name="period">the period of the time series; if aperiodic, use 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.MADecomposition.#ctor(System.Double[],System.Int32)">
			<summary>Decompose a periodic time series into the seasonal and stationary random components using no
 MA filter.</summary>
			<param name="xt">a time series</param>
			<param name="period">the period of the time series; if aperiodic, use 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.MADecomposition.getTrend">
			<summary>Get the estimated trend of the time series.</summary>
			<returns>the estimated trend</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.MADecomposition.getSeasonal">
			<summary>Get the stationary random component of the time series after the trend and seasonal
 components are removed.</summary>
			<returns>the stationary random component</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.MADecomposition.getRandom">
			<summary>Get the estimated seasonal effect of the time series.</summary>
			<returns>the estimated seasonal effect</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.InnovationAlgorithm">
			<summary>The innovation algorithm is an efficient way to obtain a one step least square linear predictor
 for a univariate linear time series with known auto-covariance and these properties (not limited
 to ARMA processes):
 <list type="bullet">
 <item><i>{x<sub>t</sub>}</i> can be non-stationary.</item>
 <item><i>E(x<sub>t</sub>) = 0</i> for all <i>t</i>.</item>
 </list>
 This class implements the part of the innovation algorithm that computes the prediction error
 variances, <i>v</i> and prediction coefficients <i>&#952;</i>. The coefficients depend only on
 the auto-covariance function and time horizon, <em>not</em> on any particular time series data.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Proposition. 5.2.2, Chapter 5, Multivariate Time Series,&quot;
 Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.InnovationAlgorithm.#ctor(System.Int32,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.AutoCovarianceFunction)">
			<summary>Constructs an instance of <c>InnovationAlgorithm</c> for a univariate time series with known
 auto-covariance structure.</summary>
			<param name="T">time series length</param>
			<param name="K">the auto-covariance function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.InnovationAlgorithm.theta(System.Int32,System.Int32)">
			<summary>Gets the coefficients of the linear predictor.</summary>
			<param name="i"><c>i</c>, ranging from 0 to <i>T</i></param>
			<param name="j"><c>j</c>, ranging from 0 to <i>T</i></param>
			<returns>&#952;[i][j]; &#952;[?][0] = 1</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.InnovationAlgorithm.var(System.Int32)">
			<summary>Gets the mean squared error for prediction errors at time <i>n</i> for \(\hat{x}_{n+1}\),
 i.e.,
 \(E(x_{n+1} - \hat{x}_{n+1})^2\).</summary>
			<param name="n">time, ranging from 0 to <i>T</i>, the end of observation time</param>
			<returns>the mean squared error (variance)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.AdditiveModel">
			<summary>The additive model of a time series is an additive composite of the trend, seasonality and irregular random components.
 <blockquote><i>
 Y[t] = T[t] + S[t] + e[t]
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.AdditiveModel.#ctor(System.Double[],System.Double[],System.Double[])">
			<summary>Construct a univariate time series by adding up the components.</summary>
			<param name="trend">the trend component</param>
			<param name="seasonality">the seasonality component</param>
			<param name="randoms">the irregular random component</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.AdditiveModel.#ctor(System.Double[],System.Double[],com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Construct a univariate time series by adding up the components.
 The irregular random component is generated using a custom random number generator.</summary>
			<param name="trend">the trend component</param>
			<param name="seasonality">the seasonality component</param>
			<param name="rng">a random number generator</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.MAModel">
			<summary>This class represents a univariate MA model.<para> See also: </para><a href="http://en.wikipedia.org/wiki/moving_average_model">Wikipedia: Moving average model</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.MAModel.#ctor(System.Double,System.Double[],System.Double)">
			<summary>Construct a univariate MA model.</summary>
			<param name="mu">the intercept (constant) term</param>
			<param name="MA">the MA coefficients (excluding the initial 1)</param>
			<param name="sigma">the white noise variance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.MAModel.#ctor(System.Double,System.Double[])">
			<summary>Construct a univariate MA model with unit variance.</summary>
			<param name="mu">the intercept (constant) term</param>
			<param name="MA">the MA coefficients (excluding the initial 1)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.MAModel.#ctor(System.Double[],System.Double)">
			<summary>Construct a univariate MA model with zero-mean.</summary>
			<param name="MA">the MA coefficients (excluding the initial 1)</param>
			<param name="sigma">the white noise variance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.MAModel.#ctor(System.Double[])">
			<summary>Construct a univariate MA model with unit variance and zero-mean.</summary>
			<param name="MA">the MA coefficients (excluding the initial 1)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.MAModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.MAModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a univariate MA model</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.LinearRepresentation">
			<summary>The linear representation of an Autoregressive Moving Average (ARMA) model is a (truncated) infinite sum of AR terms.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Eq. 3.3.3, 3.3.4, Theorem 3.1.1, Chapter 11.3, Multivariate ARMA Processes,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.LinearRepresentation.DEFAULT_NUMBER_OF_LAGS">
			<summary>the default number of lags</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.LinearRepresentation.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel,System.Int32)">
			<summary>Construct the linear representation of an ARMA model.</summary>
			<param name="arma">an ARMA model</param>
			<param name="nLags">the number of lags</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.LinearRepresentation.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel)">
			<summary>Construct the linear representation of an ARMA model up to the default number of lags <para></para>#DEFAULT_NUMBER_OF_LAGS.</summary>
			<param name="arma">an ARMA model</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ConditionalSumOfSquares">
			<summary>The method Conditional Sum of Squares (CSS) fits an ARIMA model by minimizing the conditional sum
 of squares. The CSS estimates are conditional on the assumption that the past unobserved errors
 are 0s. The estimation produced by CSS can be used as a starting point for a better algorithm,
 e.g., the maximum likelihood.
 <para/>
 Note that the order of integration is taken as an input, not estimated.
 <para/>
 The R equivalent function is <c>arima</c>.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Chapter 8.7, Model Building and Forecasting with ARIMA
 Processes,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ConditionalSumOfSquares.#ctor(System.Double[],System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary>Fit an ARIMA model for the observations using CSS. Note that the algorithm fits only an ARMA
 model. <c>d</c> is taken as an input. If the differenced input time series is not zero-mean,
 it is first de-mean-ed before running the algorithm as in Brockwell and Davis. When reporting
 the model, we compute the intercept to match the mean.</summary>
			<param name="x">the time series of observations</param>
			<param name="p">the number of AR terms</param>
			<param name="d">the order of integration</param>
			<param name="q">the number of MA terms</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ConditionalSumOfSquares.#ctor(System.Double[],System.Int32,System.Int32,System.Int32)">
			<summary>Fit an ARIMA model for the observations using CSS. Note that the algorithm fits only an ARMA
 model. <c>d</c> is taken as an input. If the differenced input time series is not zero-mean,
 it is first de-mean-ed before running the algorithm as in Brockwell and Davis. When reporting
 the model, we compute the intercept to match the mean.</summary>
			<param name="x">the time series of observations</param>
			<param name="p">the number of AR terms</param>
			<param name="d">the order of integration</param>
			<param name="q">the number of MA terms</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ConditionalSumOfSquares.nParams">
			<summary>Get the number of parameters for the estimation/fitting. They are the AR terms, MA terms, and
 variance (sigma^2).</summary>
			<returns>the number of parameters</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ConditionalSumOfSquares.getModel">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ConditionalSumOfSquares.getARMAModel">
			<summary>Get the fitted ARMA model.</summary>
			<returns>the fitted ARMA model</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ConditionalSumOfSquares.var">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ConditionalSumOfSquares.covariance">
			<summary>Get the asymptotic covariance matrix of the estimated parameters, <i>&#966;</i> and
 <i>&#952;</i>. The estimators are asymptotically normal.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Eq. 10.8.27, Thm. 10.8.2, Chapter 10.8, Model
 Building and Forecasting with ARIMA Processes,&quot; Time Series: Theory and Methods, Springer,
 2006.&quot;</summary>
			<returns>the asymptotic covariance matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ConditionalSumOfSquares.stderr">
			<summary>Get the asymptotic standard errors of the estimated parameters, <i>&#966;</i> and
 <i>&#952;</i>.
 The estimators are asymptotically normal.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Eq. 10.8.27, Thm. 10.8.2, Chapter 10.8, Model
 Building and Forecasting with ARIMA Processes,&quot; Time Series: Theory and Methods, Springer,
 2006.&quot;</summary>
			<returns>the asymptotic errors</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ConditionalSumOfSquares.AIC">
			<summary>Compute the AIC, a model selection criterion.<para> See also: </para><a href="http://en.wikipedia.org/wiki/akaike_information_criterion">Wikipedia: Akaike
 information criterion</a></summary>
			<returns>the AIC</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ConditionalSumOfSquares.AICC">
			<summary>Compute the AICC, a model selection criterion.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Eq. 9.2.1, Chapter 9.2, Model Building and
 Forecasting with ARIMA Processes,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
			<returns>the AICC</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ConditionalSumOfSquares.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.AutoCovariance">
			<summary>Computes the Auto-CoVariance Function (ACVF) for an AutoRegressive Moving Average (ARMA) model by
 recursion.
 <para/>
 The R equivalent functions are <c>ARMAacf</c> and <c>TacvfAR</c> in package <c>FitAR</c>.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Eqs. 3.3.8, 3.3.9, Chapter 3.3, Computing the
 Autocovariance Function of an ARMA(p, q) Process,&quot; Time Series: Theory and Methods, Springer,
 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.AutoCovariance.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel)">
			<summary>Computes the auto-covariance function for an ARMA model.</summary>
			<param name="model">an ARIMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.AutoCovariance.evaluate(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.AutoCovariance.evaluate(System.Double)">
			<summary>Gets the <i>i</i>-th auto-covariance.</summary>
			<param name="n">the lag order</param>
			<returns>the <i>i</i>-th auto-covariance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.AutoCovariance.psi(System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.AutoCorrelation">
			<summary>Compute the Auto-Correlation Function (ACF) for an AutoRegressive Moving Average (ARMA) model, assuming that
 <i>EX<sub>t</sub> = 0</i>.
 <para/>
 This implementation solves the Yule-Walker equation.
 <para/>
 The R equivalent functions are <c>ARMAacf</c> and <c>TacvfAR</c> in package <c>FitAR</c>.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;p. 420, Eq. 11.3.15, The Covariance Matrix Function of a Causal ARMA Process, Chapter 11.3, Multivariate Time Series,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.AutoCorrelation.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel,System.Int32)">
			<summary>Compute the auto-correlation function for an ARMA model.</summary>
			<param name="model">an ARIMA model</param>
			<param name="nLags">the number of lags</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.AutoCorrelation.evaluate(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.AutoCorrelation.evaluate(System.Double)">
			<summary>Get the <i>i</i>-th auto-correlation.</summary>
			<param name="i">the lag order</param>
			<returns>the <i>i</i>-th auto-correlation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARModel">
			<summary>This class represents an AR model.<para> See also: </para><a href="http://en.wikipedia.org/wiki/autoregressive_model">Wikipedia: Autoregressive model</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARModel.#ctor(System.Double,System.Double[],System.Double)">
			<summary>Construct a univariate AR model.</summary>
			<param name="mu">the intercept (constant) term</param>
			<param name="AR">the AR coefficients (excluding the initial 1)</param>
			<param name="sigma">the white noise variance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARModel.#ctor(System.Double,System.Double[])">
			<summary>Construct a univariate AR model with unit variance.</summary>
			<param name="mu">the intercept (constant) term</param>
			<param name="AR">the AR coefficients (excluding the initial 1)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARModel.#ctor(System.Double[],System.Double)">
			<summary>Construct a univariate AR model with zero-intercept (mu).</summary>
			<param name="AR">the AR coefficients (excluding the initial 1)</param>
			<param name="sigma">the white noise variance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARModel.#ctor(System.Double[])">
			<summary>Construct a univariate AR model with unit variance and zero-intercept (mu).</summary>
			<param name="AR">the AR coefficients (excluding the initial 1)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a univariate AR model</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAXModel">
			<summary>The ARMAX model (ARIMA model with eXogenous inputs) is a generalization of the ARMA model by incorporating exogenous variables.
 <i>X<sub>t</sub></i> is an ARMAX(p, q) process, for which
 \[
 X_t = \mu + \sum_{i=1}^p \phi_i X_{t-i} + \sum_{i=1}^q \theta_j \epsilon_{t-j} + \psi&apos; D_t + \epsilon_t,
 \]
 where <i>D<sub>t</sub></i> is an <i>(m * 1)</i> vector which contains all exogenous variables at time <i>t</i> (excluding the intercept term),
 and its coefficients are represented by an <i>m</i>-dimensional vector <i>&#968;</i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/autoregressive_moving_average#armax">Wikipedia: Autoregressive moving average model with exogenous inputs model (ARMAX model)</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAXModel.#ctor(System.Double,System.Double[],System.Double[],System.Double[],System.Double)">
			<summary>Construct a univariate ARMAX model.</summary>
			<param name="mu">the intercept (constant) term</param>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficients</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficients</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise variance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAXModel.#ctor(System.Double,System.Double[],System.Double[],System.Double[])">
			<summary>Construct a univariate ARMAX model with unit variance.</summary>
			<param name="mu">the intercept (constant) term</param>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficients</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficients</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAXModel.#ctor(System.Double[],System.Double[],System.Double[],System.Double)">
			<summary>Construct a univariate ARMAX model with zero-intercept (mu).</summary>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficients</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficients</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
			<param name="sigma">the white noise variance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAXModel.#ctor(System.Double[],System.Double[],System.Double[])">
			<summary>Construct a univariate ARMAX model with unit variance and zero-intercept (mu).</summary>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficients</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficients</param>
			<param name="psi">the coefficients of the deterministic terms (excluding the intercept term)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAXModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAXModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a univariate ARMAX model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAXModel.armaxMean(System.Double[],System.Double[],System.Double[])">
			<summary>Compute the univariate ARMAX conditional mean.</summary>
			<param name="arLags">the AR lags</param>
			<param name="maLags">the MA lags</param>
			<param name="exVar">the exogenous variables</param>
			<returns>the conditional mean</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel">
			<summary>A univariate ARMA model, <i>X<sub>t</sub></i>, takes this form.
 \[
 X_t = \mu + \sum_{i=1}^p \phi_i X_{t-i} + \sum_{i=1}^q \theta_j \epsilon_{t-j} + \epsilon_t
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/autoregressive_moving_average">Wikipedia: Autoregressive moving average model</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel.#ctor(System.Double,System.Double[],System.Double[],System.Double)">
			<summary>Construct a univariate ARMA model.</summary>
			<param name="mu">the intercept (constant) term</param>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficients</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficients</param>
			<param name="sigma">the white noise variance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel.#ctor(System.Double,System.Double[],System.Double[])">
			<summary>Construct a univariate ARMA model with unit variance.</summary>
			<param name="mu">the intercept (constant) term</param>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficients</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficients</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel.#ctor(System.Double[],System.Double[],System.Double)">
			<summary>Construct a univariate ARMA model with zero-intercept (mu).</summary>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficients</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficients</param>
			<param name="sigma">the white noise variance</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel.#ctor(System.Double[],System.Double[])">
			<summary>Construct a univariate ARMA model with unit variance and zero-intercept (mu).</summary>
			<param name="AR">the AR coefficients (excluding the initial 1); <c>null</c> if no AR coefficients</param>
			<param name="MA">the MA coefficients (excluding the initial 1); <c>null</c> if no MA coefficients</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a univariate ARMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel.conditionalMean(System.Double[],System.Double[])">
			<summary>Compute the univariate ARMA conditional mean, given all the lags.</summary>
			<param name="arLags">the AR lags</param>
			<param name="maLags">the MA lags</param>
			<returns>the conditional mean</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel.unconditionalMean">
			<summary>Compute the multivariate ARMA unconditional mean.</summary>
			<returns>the unconditional mean</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel.getDemeanedModel">
			<summary>Get the demeaned version of the time series model.
 \[
 Y_t = (X_t - \mu) = \sum_{i=1}^p \phi_i (X_{t-i} - \mu) + \sum_{i=1}^q \theta_j \epsilon_{t-j} + \epsilon_t
 \]
 &#956; is the unconditional mean.</summary>
			<returns>the demeaned time series</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastOneStep">
			<summary>Computes the one-step ahead prediction of a causal ARMA model, by the innovative algorithm.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Section 5.3, Chapter 5, Recursive Prediction of an
 ARMA(p, q) Process,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastOneStep.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.InnovationAlgorithm)">
			<summary>Makes the one-step ahead prediction for an ARMA model.</summary>
			<param name="xt">the observations</param>
			<param name="arma">the ARMA model</param>
			<param name="inn">the innovation algorithm to use</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastOneStep.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel)">
			<summary>Makes the one-step ahead prediction for an ARMA model.</summary>
			<param name="xt">the observations</param>
			<param name="arma">the ARMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastOneStep.#ctor(System.Double[],com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel)">
			<summary>Makes the one-step ahead prediction for an ARMA model.</summary>
			<param name="xt">the observations</param>
			<param name="arma">the ARMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastOneStep.K(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastOneStep.xHat(System.Int32)">
			<summary>Gets the one-step ahead prediction \(\hat{x}_{n+1}\).<para> See also: </para>&quot;eq. 5.3.9&quot;</summary>
			<param name="n">time, ranging from 0 to <i>T</i>, the end of observation time</param>
			<returns>the one-step prediction \(\hat{x}_{n+1}\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastOneStep.var(System.Int32)">
			<summary>Gets the mean squared error of the prediction at time <i>n</i> for \(\hat{x}_{n+1}\), i.e.,
 \(E(x_{n+1} - \hat{x}_{n+1})^2\).</summary>
			<param name="n">time, ranging from 0 to <i>T</i>, the end of observation time</param>
			<returns>the mean squared error (variance)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastOneStep.xHat">
			<summary>Gets the one-step ahead prediction of the time series.</summary>
			<returns>the one-step ahead prediction</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastOneStep.var">
			<summary>Gets the mean squared error of the one-step ahead prediction.</summary>
			<returns>the mean squared error (variance)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastMultiStep">
			<summary>Computes the h-step ahead prediction of a causal ARMA model, by the innovative algorithm.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Section 5.3, Chapter 5, Recursive Prediction of an
 ARMA(p, q) Process,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastMultiStep.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel,System.Int32,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.InnovationAlgorithm,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastOneStep)">
			<summary>Makes the h-step ahead prediction for an ARMA model.</summary>
			<param name="xt">the observations</param>
			<param name="arma">the ARMA model</param>
			<param name="h">a time step</param>
			<param name="inn">the innovation algorithm to use</param>
			<param name="forecast1">the auxiliary one-step ahead forecast of <c>xt</c> using <c>arma</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastMultiStep.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel,System.Int32)">
			<summary>Makes the h-step ahead prediction for an ARMA model.</summary>
			<param name="xt">the observations</param>
			<param name="arma">the ARMA model</param>
			<param name="h">a time step</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastMultiStep.#ctor(System.Double[],com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel,System.Int32)">
			<summary>Makes the h-step ahead prediction for an ARMA model.</summary>
			<param name="xt">the observations</param>
			<param name="arma">the ARMA model</param>
			<param name="h">a time step</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastMultiStep.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel)">
			<summary>Makes the one-step ahead prediction for an ARMA model.</summary>
			<param name="xt">the observations</param>
			<param name="arma">the ARMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastMultiStep.xHat(System.Int32)">
			<summary>Gets the h-step prediction \(P_{\mathfrak{S_n}}X_{n+h}\).<para> See also: </para>&quot;eq. 5.3.15&quot;</summary>
			<param name="n">time, ranging from 0 to <i>T</i>, the end of observation time</param>
			<returns>the h-step prediction \(P_{\mathfrak{S_n}}X_{n+h}\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastMultiStep.var(System.Int32)">
			<summary>Gets the mean squared error of the prediction at time <i>n</i> for \(\hat{x}_{n+h}\), i.e.,
 \(E(x_{n+h} - \hat{x}_{n+h})^2\).</summary>
			<param name="n">time, ranging from 0 to <i>T</i>, the end of observation time</param>
			<returns>the mean squared error (variance)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastMultiStep.xHat">
			<summary>Gets the h-step ahead prediction of the time series.</summary>
			<returns>the h-step ahead prediction</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastMultiStep.var">
			<summary>Gets the mean squared error of the h-step ahead prediction.</summary>
			<returns>the mean squared error (variance)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastMultiStep.getStandardError">
			<summary>Gets the the auxiliary coefficients, &#920; and V, in using the innovative algorithm.</summary>
			<returns>the the auxiliary coefficients, &#920; and V, in using the innovative algorithm</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecastMultiStep.getARMAForecastOneStep">
			<summary>Gets the auxiliary ARMA one-step ahead forecaster.</summary>
			<returns>the auxiliary ARMA one-step ahead forecaster</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecast">
			<summary>Forecast an ARMA time series using the innovative algorithm.<para> See also: </para>&quot;P. J. Brockwell and R. A. Davis, &quot;Section 5.3, Chapter 5, Recursive Prediction of an ARMA(p, q) Process,&quot; Time Series: Theory and Methods, Springer, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecast.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel)">
			<summary>Construct a forecaster for a time series assuming ARMA model.</summary>
			<param name="xt">a time series</param>
			<param name="arma">the ARMA specification</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecast.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.inttime.IntTimeTimeSeries,System.Int32,System.Int32)">
			<summary>Construct a forecaster for a time series assuming ARMA model.</summary>
			<param name="xt">a time series</param>
			<param name="p">the number of AR terms</param>
			<param name="q">the number of MA terms</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAForecast.next">
			<summary>Get the next forecast.</summary>
			<returns>the next forecast</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAFit">
			<summary>This interface represents a fitting method for estimating <i>&#966;, &#952;, &#956;, &#963;<sup>2</sup></i> in an ARMA model.<para> See also: </para>ConditionalSumOfSquares</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAFit.getModel">
			<summary>Get the fitted ARMA model.</summary>
			<returns>the fitted ARMA model</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAFit.var">
			<summary>Get the variance of the white noise.</summary>
			<returns><i>&#963;<sup>2</sup></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAFit.stderr">
			<summary>Get the asymptotic standard errors of the estimators.</summary>
			<returns>the asymptotic standard errors of the estimators</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAFit.covariance">
			<summary>Get the asymptotic covariance matrix of the estimators.</summary>
			<returns>the asymptotic covariance matrix of the estimators</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAFit.AIC">
			<summary>Compute the AIC of fitted model.</summary>
			<returns>the AIC</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAFit.AICC">
			<summary>Compute the AICC of fitted model.</summary>
			<returns>the AICC</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHModel">
			<summary>An ARMA-GARCH model takes this form:
 \[
 X_t = \mu + \sum_{i=1}^p \phi_i X_{t-i} + \sum_{i=1}^q \theta_j \epsilon_{t-j} + \epsilon_t,
 \\
 \epsilon_t = \sqrt{h_t\eta_t},
 \\
 h_t = \alpha_0 + \sum_{i=1}^{r} (\alpha_i e_{t-i}^2) + \sum_{i=1}^{s} (\beta_i h_{t-i})
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel)">
			<summary>Construct a univariate ARMA-GARCH model.</summary>
			<param name="arma">the ARMA part of the model</param>
			<param name="garch">the GARCH part of the model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHModel.getARMA">
			<summary>Get the ARMA part of this model.</summary>
			<returns>the ARMA part</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHModel.getGARCH">
			<summary>Get the GARCH part of this model.</summary>
			<returns>the GARCH part</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHFit">
			<summary>This implementation fits, for a data set, an ARMA-GARCH model by Quasi-Maximum Likelihood
 Estimation.
 &quot;QMLE&quot; stands for Quasi-Maximum Likelihood Estimation, which assumes Normal distribution and
 uses robust standard errors for inference. Hence, we currently support only Normal innovations.
 The parameters of both ARMA and GARCH models are jointly estimated by maximizing a likelihood
 function.
 <para/>
 Please refer to the reference for the standard assumptions.
 <para/>

 To reduce the number of parameters, hence more accuracy, we assume that the constant parameters
 \(\mu\) and \(\omega\) are expressed as:
 \[
 \mu=(1-\sum_{i=1}^p \phi_i) * MEAN(X), \\
 \omega=(1-\sum_{i=1}^r \alpha_i - \sum_{i=1}^r \beta_i) * MEAN(X).
 \]

 <para/>
 The R equivalent function is <c>garchFit</c> in <c>fGarch</c>.<para> See also: </para>&quot;Francq C. and Zakoian, J. M., &quot;Maximum likelihood estimation of pure GARCH and ARMA-GARCH
 processes&quot;, Bernoulli 10(4), 2004, 605-637.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHFit.DEFAULT_TOLERANCE">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHFit.DEFAULT_MAXIMUM_ITERATIONS">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHFit.#ctor(System.Double[],System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Int32)">
			<summary>Constructs a model.</summary>
			<param name="x">the input series</param>
			<param name="AR">the order for AR in ARMA model</param>
			<param name="MA">the order for MA in ARMA model</param>
			<param name="p">the order for GARCH in GARCH model</param>
			<param name="q">the order for ARCH in GARCH model</param>
			<param name="epsilon">the tolerance</param>
			<param name="maxIterations">the maximum number of optimization steps</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHFit.#ctor(System.Double[],System.Int32,System.Int32,System.Int32,System.Int32)">
			<summary>Constructs a model with the default <para></para>#DEFAULT_TOLERANCE tolerance and
 <para></para>#DEFAULT_MAXIMUM_ITERATIONS maximum number of iterations.</summary>
			<param name="x">the input series</param>
			<param name="AR">the order for AR in ARMA model</param>
			<param name="MA">the order for MA in ARMA model</param>
			<param name="p">the order for ARCH in GARCH model</param>
			<param name="q">the order for GARCH in GARCH model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHFit.getGARCHModel">
			<summary>Gets the fitted GARCH model.</summary>
			<returns>the GARCH model</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHFit.getARMAModel">
			<summary>Gets the fitted ARMA model.</summary>
			<returns>the ARMA model</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHFit.getMeanForecast(System.Int32)">
			<summary>Calculates the k-step ahead forecast of X in ARMA model.
 When <i>k &lt; max(p, q)</i>, <para></para>#getMeanForecastPQ() is called.
 When <i>k &gt; max(p, q)</i>, the first <i>max(p, q)</i> days forecasts are the same as
 those of <para></para>getMeanForecastPQ(). And the <i>(k - max(p, q))</i> days of forecasts
 are calculated by iteration.</summary>
			<param name="k">the number of forecasts</param>
			<returns>the ARMA forecast</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHFit.getVarForecast(System.Int32)">
			<summary>Calculates the k-step ahead of conditional variance <i>h</i> in GARCH model.
 When <i>k &lt; max(p, q)</i>, <para></para>#getVarForecastPQ() is called.
 When <i>k &gt; max(p, q)</i>, the first <i>max(p, q)</i> days forecasts are the same as
 those of <para></para>#getVarForecastPQ(). The <i>(k - max(p, q))</i> days of forecasts are
 calculated by iteration.</summary>
			<param name="k">the number of forecasts</param>
			<returns>the GARCH forecast</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHFit.getMeanResidual">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.armagarch.ARMAGARCHFit.getVarResidual">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHSim">
			<summary>This class simulates the GARCH models of this form.
 \[
 h_t = \alpha_0 + \sum_{i=1}^{q} (\alpha_i e_{t-i}^2) + \sum_{i=1}^{p} (\beta_i h_{t-i})
 \]
 <i>p</i> is the order of the GARCH terms <i>h<sub>t-i</sub></i>;
 <i>q</i> is the order of the ARCH terms <i>e<sub>t-i</sub><sup>2</sup></i>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/autoregressive_conditional_heteroskedasticity#garch">
 Wikipedia: GARCH</a></item>
 <item><a href="http://en.wikipedia.org/wiki/autoregressive_conditional_heteroskedasticity">
 Wikipedia: Autoregressive conditional heteroskedasticity</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHSim.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel,System.Double[],com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Simulate an GARCH model.</summary>
			<param name="model">a GARCH model</param>
			<param name="z">the innovations; size = q</param>
			<param name="rng">a random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHSim.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Simulate an GARCH model.
 The innovations are initialized to 0.</summary>
			<param name="model">a GARCH model</param>
			<param name="rng">a random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHSim.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel)">
			<summary>Simulate an GARCH model.
 The innovations are initialized to 0.</summary>
			<param name="model">a GARCH model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHSim.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHSim.nextDouble">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHSim.nextPair">
			<summary>Get the next random (e2_t, h_t).</summary>
			<returns>the next random (e2_t, h_t)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel">
			<summary>The GARCH(p, q) model takes this form.
 \[
 h_t = \alpha_0 + \sum_{i=1}^{q} (\alpha_i e_{t-i}^2) + \sum_{i=1}^{p} (\beta_i h_{t-i})
 \]
 <i>p</i> is the order of the GARCH terms <i>h<sub>t-i</sub></i>;
 <i>q</i> is the order of the ARCH terms <i>e<sub>t-i</sub><sup>2</sup></i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/autoregressive_conditional_heteroskedasticity#garch">
 Wikipedia: GARCH</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel.#ctor(System.Double,System.Double[],System.Double[])">
			<summary>Construct a GARCH model.</summary>
			<param name="a0">the constant term</param>
			<param name="a">the ARCH coefficients</param>
			<param name="b">the GARCH coefficients</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel.#ctor(System.Double,System.Double,System.Double)">
			<summary>Construct a GARCH(1,1) model.</summary>
			<param name="a0">the constant term</param>
			<param name="a1">the ARCH coefficient</param>
			<param name="b1">the GARCH coefficient</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel.#ctor(com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a GARCH model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel.a0">
			<summary>Get the constant term.</summary>
			<returns>the constant term</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel.alpha">
			<summary>Get the ARCH coefficients.</summary>
			<returns>the ARCH coefficients; could be <c>null</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel.beta">
			<summary>Get the GARCH coefficients.</summary>
			<returns>the GARCH coefficients; could be <c>null</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel.p">
			<summary>Get the number of GARCH terms.</summary>
			<returns>the number of GARCH terms</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel.q">
			<summary>Get the number of ARCH terms.</summary>
			<returns>the number of ARCH terms</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel.maxPQ">
			<summary>Get the maximum of the ARCH length or GARCH length.</summary>
			<returns>max(# ARCH terms, # GARCH terms)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel.var">
			<summary>Compute the unconditional variance of the GARCH model.</summary>
			<returns>the unconditional variance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel.sigma2(System.Double[],System.Double[])">
			<summary>Compute the conditional variance based on the past information.</summary>
			<param name="e2">the last <i>q</i> squared observations</param>
			<param name="sigma2_lag">the last <i>p</i> conditional variance</param>
			<returns>the conditional variance, <i>h(t | F<sub>t</sub>)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHModel.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHFit">
			<summary>This implementation fits, for a data set, a Generalized Autoregressive Conditional Heteroscedasticity (GARCH) model
 by maximizing the likelihood function using the gradient information.
 <para/>
 The R equivalent functions are <c>garch</c> in <c>tseries</c> and <c>garchFit</c> in <c>fGarch</c>.<para> See also: </para>&quot;Tim Bollerslev, &quot;Generalized autoregressive conditional heteroskedasticity,&quot; Journal of Econometrics, Issue 3, Vol. 31. 1986.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHFit.#ctor(System.Double[],System.Int32,System.Int32,System.Double,System.Int32,com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHFit.GRADIENT)">
			<summary>Fit a GARCH(p, q) model to a time series.</summary>
			<param name="e_t">a time series of the observations/residuals</param>
			<param name="p">the GARCH part order</param>
			<param name="q">the ARCH order</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
			<param name="grad">the method to compute the gradient</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHFit.#ctor(System.Double[],System.Int32,System.Int32)">
			<summary>Fit a GARCH(p, q) model to a time series.</summary>
			<param name="e_t">a time series of the observations/residuals</param>
			<param name="p">the GARCH part order</param>
			<param name="q">the ARCH order</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHFit.getModel">
			<summary>Get the fitted GARCH model.</summary>
			<returns>the fitted GARCH model, the estimators.</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHFit.GRADIENT">
			<summary>the available methods to compute the gradient to guild the optimization search</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHFit.GRADIENT.ANALYTICAL">
			<summary>use the analytical gradient formulae in the references, eqs. 19, 21</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHFit.GRADIENT.NUMERICAL">
			<summary>use the finite difference method</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHFit.GRADIENT.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.timeseries.linear.univariate.stationaryprocess.garch.GARCHFit.GRADIENT.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.cointegration.JohansenTest">
			<summary>The maximum number of cointegrating relations among a multivariate time series is the rank of the <i>&#928;</i> matrix.
 To determine the (most likely) number of cointegrating relations <i>r</i>,
 we need to check the likelihood of hypothesis of <i>r</i> being from 1 to the rank.
 Johansen provides two types of such hypothesis <para></para>JohansenAsymptoticDistribution.Test test statistics.<para> See also: </para>JohansenAsymptoticDistribution.Test</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.JohansenTest.#ctor(com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.Test,com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.TrendType,System.Int32,System.Int32,System.Int32)">
			<summary>Construct an instance of <c>JohansenTest</c>.</summary>
			<param name="test">the type of Johansen cointegration test</param>
			<param name="trend">the trend type</param>
			<param name="dim">the number of (real) eigenvalues</param>
			<param name="nSim">the number of simulations</param>
			<param name="nT">the number of discretization levels</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.JohansenTest.#ctor(com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.Test,com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.TrendType,System.Int32)">
			<summary>Construct an instance of <c>JohansenTest</c>.</summary>
			<param name="test">the type of Johansen cointegration test</param>
			<param name="trend">the trend type</param>
			<param name="dim">the number of (real) eigenvalues</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.JohansenTest.getStats(com.numericalmethod.suanshu.stats.cointegration.CointegrationMLE)">
			<summary>Get the set of likelihood ratio test statistics for testing <i>H(r)</i> in <i>H(r+1)</i>.</summary>
			<param name="coint">the results of Johansen cointegration</param>
			<returns>the likelihood ratio test statistics</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.JohansenTest.r(com.numericalmethod.suanshu.stats.cointegration.CointegrationMLE,System.Double)">
			<summary>Get the (most likely) order of cointegration.</summary>
			<param name="coint">the results of Johansen cointegration</param>
			<param name="level">the confidence level, i.e., 1 - quantile</param>
			<returns>the order of cointegration</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution">
			<summary>Johansen provides the asymptotic distributions of the two <para></para>Test hypothesis testings (Eigen and Trace tests),
 each for 5 different <para></para>TrendType trend types.<para> See also: </para>&quot;Kevin Sun, Notes on Cointegration, February 23, 2011.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.#ctor(com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.Test,com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.TrendType,System.Int32,System.Int32,System.Int32,System.Int64)">
			<summary>Construct the asymptotic distribution of a Johansen test.</summary>
			<param name="test">the type of Johansen cointegration test</param>
			<param name="trend">the trend type</param>
			<param name="dr">the dimension of the multivariate time series (<i>d</i>) minus the number of cointegrating vectors (<i>r</i>)</param>
			<param name="nSim">the number of simulations</param>
			<param name="nT">the number of grid points in interval <i>[0, 1]</i>. The bigger <c>nT</c> is, the finer the time discretization is, the smaller the discretization error is, and the more accurate the results are.</param>
			<param name="seed">a seed</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.#ctor(com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.Test,com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.TrendType,System.Int32)">
			<summary>Construct the asymptotic distribution of a Johansen test.</summary>
			<param name="test">the type of Johansen cointegration test</param>
			<param name="trend">the trend type</param>
			<param name="dr">the dimension of the multivariate time series (<i>d</i>) minus the number of cointegrating vectors (<i>r</i>)</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.Test">
			<summary>the available types of Johansen cointegration tests</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.Test.EIGEN">
			<summary>the EIGEN test</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.Test.TRACE">
			<summary>the TRACE test</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.Test.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.Test.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.TrendType">
			<summary>the available types of trends</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.TrendType.NO_CONSTANT">
			<summary>This is trend type I: no constant, no linear trend:
 <blockquote><code><i>
 &#956;0 = 0
 &#956;1 = 0
 </i></code></blockquote></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.TrendType.RESTRICTED_CONSTANT">
			<summary>This is trend type II: no restricted constant, no linear trend:
 <blockquote><code><i>
 &#956;0 = -&#928;&#956;
 &#956;1 = 0
 </i></code></blockquote></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.TrendType.CONSTANT">
			<summary>This is trend type III: constant, no linear trend:
 <blockquote><code><i>
 &#956;0 &#8800; 0
 &#956;1 = 0
 </i></code></blockquote></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.TrendType.CONSTANT_RESTRICTED_TIME">
			<summary>This is trend type IV: constant, restricted linear trend:
 <blockquote><code><i>
 &#956;0 &#8800; 0
 &#956;1 = -&#928;&#947;
 </i></code></blockquote></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.TrendType.CONSTANT_TIME">
			<summary>This is trend type V: constant, linear trend:
 <blockquote><code><i>
 &#956;0 &#8800; 0
 &#956;1 &#8800; 0
 </i></code></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.TrendType.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.TrendType.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.F">
			<summary>This is a filtration function.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.JohansenAsymptoticDistribution.F.evaluate(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.realtime.Realization[])">
			<summary><i>F(B)</i>.</summary>
			<param name="B">a multivariate Brownian motion</param>
			<returns><i>F(B)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.cointegration.CointegrationMLE">
			<summary>Two or more time series are cointegrated if they each share a common type of stochastic drift,
 that is, to a limited degree they share a certain type of behavior in terms of their long-term fluctuations,
 but they do not necessarily move together and may be otherwise unrelated.
 If two or more series are individually integrated (in the time series sense)
 but some linear combination of them has a lower order of integration,
 then the series are said to be cointegrated.
 A common example is where the individual series are first-order integrated (<i>I(1)</i>)
 but some (cointegrating) vector of coefficients exists to form a stationary linear combination of them.
 <para/>
 This implementation to estimate the cointegrating factors is the Johansen method, named after Søren Johansen.
 It is an MLE (maximum likelihood estimation) method.
 The Johansen test is a procedure for testing cointegration of several <i>I(1)</i> time series using MLE.
 This test permits more than one cointegrating relationship. It is more generally applicable than the Engle-Granger test.<para> See also: </para><list type="bullet">
 <item>Søren Johansen, &quot;Likelihood-Based Inference in Cointegrated Vector Autoregressive Models,&quot; Oxford University Press, USA. February 1, 1996.</item>
 <item>Kevin Sun, &quot;Notes on Cointegration,&quot; February 23, 2011.</item>
 <item><a href="http://en.wikipedia.org/wiki/cointegration">Wikipedia: Cointegration</a></item>
 <item><a href="http://en.wikipedia.org/wiki/johansen_test">Wikipedia: Johansen test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.CointegrationMLE.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries,System.Boolean,System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Perform the Johansen MLE procedure on a multivariate time series.</summary>
			<param name="ts">a multivariate time series</param>
			<param name="intercept">indicate whether an intercept is included in the estimation</param>
			<param name="p">the number of lags, e.g., 2</param>
			<param name="D">the exogenous factor matrix (excluding the intercept)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.CointegrationMLE.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries,System.Boolean,System.Int32)">
			<summary>Perform the Johansen MLE procedure on a multivariate time series, using the EIGEN test.</summary>
			<param name="ts">a multivariate time series</param>
			<param name="intercept">indicate whether an intercept is included in the estimation</param>
			<param name="p">the number of lags, e.g., 2</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.CointegrationMLE.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateSimpleTimeSeries,System.Boolean)">
			<summary>Perform the Johansen MLE procedure on a multivariate time series,
 using the EIGEN test, with the number of lags = 2.</summary>
			<param name="ts">a multivariate time series</param>
			<param name="intercept">indicate whether an intercept is included in the estimation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.CointegrationMLE.alpha">
			<summary>Get the set of adjusting coefficients, by columns.</summary>
			<returns><i>&#945;</i>, the adjusting coefficients</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.CointegrationMLE.beta">
			<summary>Get the set of cointegrating factors, by columns.</summary>
			<returns><i>&#946;</i>, the cointegrating factors</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.CointegrationMLE.beta(System.Int32)">
			<summary>Get the <i>r</i>-th cointegrating factor, counting from 1.</summary>
			<param name="r">an index</param>
			<returns><i>&#946;<sub>r</sub></i>, the <i>r</i>-th cointegrating factor</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.CointegrationMLE.getEigenvalues">
			<summary>Get the set of <em>real</em> eigenvalues.</summary>
			<returns>the real eigenvalues</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.CointegrationMLE.rank">
			<summary>Get the rank of the system, i.e., the number of (real) eigenvalues.</summary>
			<returns>the rank</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.cointegration.CointegrationMLE.n">
			<summary>Get the number of rows of the multivariate time series used in regression.</summary>
			<returns><c>ts.size - p</c></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionProblem">
			<summary>This class defines the covariance selection problem outlined in d&apos;Aspremont (2008).
 This technique is first used in Dempster (1972) and has some recent advancement, see for
 instance, Banerjee et al. (2007).<para> See also: </para><list type="bullet">
 <item>A. d&apos;Aspremont, &quot;Identifying small mean reverting portfolios,&quot; Working Paper, 2008.</item>
 <item>A. Dempster, &quot;Covariance selection,&quot; Biometrics, Volume: 28, 157 - 175, 1972.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Construct a covariance selection problem.</summary>
			<param name="S">a sample covariance (or correlation) matrix</param>
			<param name="t">the penalization parameter t for L1 regularization</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionProblem.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateTimeSeries,System.Double,System.Boolean)">
			<summary>Construct a covariance selection problem from a multivariate time series.</summary>
			<param name="ts">a multivariate time series</param>
			<param name="t">the penalization parameter t for L1 regularization</param>
			<param name="use_cor">indicator of whether sample correlation matrix is used instead of the
                covariance matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionProblem.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.MultivariateTimeSeries,System.Double)">
			<summary>Construct a covariance selection problem from a multivariate time series.
 By default, the correlation matrix is used in the calculation.</summary>
			<param name="ts">a multivariate time series</param>
			<param name="t">the penalization parameter t for L1 regularization</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionProblem.#ctor(com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionProblem)">
			<summary>Copy constructor.</summary>
			<param name="that">another <c>CovarianceSelectionProblem</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionProblem.S">
			<summary>Get the original sample covariance matrix.</summary>
			<returns>the original sample covariance matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionProblem.t">
			<summary>Get the penalization parameter t for L1 regularization.</summary>
			<returns>the penalization parameter t for L1 regularization</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionProblem.functionValueL1(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Get the value of an L1-penalized function.</summary>
			<param name="X">the inverse of a covariance matrix (to be estimated)</param>
			<returns>the value of an L1-penalized function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionProblem.functionValueCardinality(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Get the value of a cardinality-penalized function.</summary>
			<param name="X">the inverse of a covariance matrix (to be estimated)</param>
			<returns>the value of a cardinality-penalized function</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionLASSO">
			<summary>The LASSO approach of covariance selection.<para> See also: </para><list type="bullet">
 <item>A. d&apos;Aspremont, &quot;Identifying small mean reverting portfolios,&quot; Working Paper, 2008.</item>
 <item>Banerjee et al., 2007.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionLASSO.#ctor(com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionProblem,System.Double)">
			<summary>Estimate the covariance matrix directly by using LASSO.</summary>
			<param name="problem">the covariance selection problem</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionLASSO.#ctor(com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionProblem)">
			<summary>Estimate the covariance matrix directly by using LASSO.</summary>
			<param name="problem">the covariance selection problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionLASSO.getProblem">
			<summary>Get the original covariance selection problem.</summary>
			<returns>the original covariance selection problem</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionLASSO.getInverseEstimatedCovarianceMatrix">
			<summary>Get the inverse of the estimated covariance matrix.</summary>
			<returns>the inverse of the estimated covariance matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.covarianceselection.CovarianceSelectionLASSO.getEstimatedCovarianceMatrix">
			<summary>Get the estimated covariance matrix.</summary>
			<returns>the estimated covariance matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation">
			<summary>This is the state equation in a controlled dynamic linear model.
 <blockquote><i>
 x<sub>t</sub> = G<sub>t</sub> * x<sub>t-1</sub> + H<sub>t</sub> * u<sub>t</sub> + w<sub>t</sub>,
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.#ctor(com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix,com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix,com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix,com.numericalmethod.suanshu.stats.random.multivariate.NormalRVG)">
			<summary>Constructs a state equation.</summary>
			<param name="G">the coefficient matrix function of <i>x<sub>t - 1</sub></i></param>
			<param name="H">the coefficient matrix function of control variables <i>u<sub>t</sub></i>; use
                <c>null</c> if there isn&apos;t any</param>
			<param name="W">the covariance matrix function of <i>w<sub>t</sub></i></param>
			<param name="rmvnorm">a <i>p</i>-dimensional standard multivariate Gaussian random vector generator
                (for seeding); <i>p</i> = the dimension of <i>W</i> or <i>x<sub>t</sub></i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.#ctor(com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix,com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix,com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix)">
			<summary>Constructs a state equation.</summary>
			<param name="G">the coefficient matrix function of <i>x<sub>t - 1</sub></i></param>
			<param name="H">the coefficient matrix function of control variables <i>u<sub>t</sub></i>; use
          <c>null</c> if there isn&apos;t any</param>
			<param name="W">the covariance matrix function of <i>w<sub>t</sub></i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.#ctor(com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix,com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix)">
			<summary>Constructs a state equation without control variables.</summary>
			<param name="G">the coefficient matrix function of <i>x<sub>t - 1</sub></i></param>
			<param name="W">the covariance matrix function of <i>w<sub>t</sub></i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.stats.random.multivariate.NormalRVG)">
			<summary>Constructs a time-invariant state equation.</summary>
			<param name="G">the coefficient matrix function of <i>x<sub>t - 1</sub></i></param>
			<param name="H">the coefficient matrix function of control variables <i>u<sub>t</sub></i>; use
                <c>null</c> if there isn&apos;t any</param>
			<param name="W">the covariance matrix function of <i>w<sub>t</sub></i></param>
			<param name="rmvnorm">a <i>p</i>-dimensional standard multivariate Gaussian random vector generator;
 <i>p</i> = the dimension of <i>W</i> or <i>x<sub>t</sub></i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs a time-invariant state equation without control variables.</summary>
			<param name="G">the coefficient matrix function of <i>x<sub>t - 1</sub></i></param>
			<param name="W">the covariance matrix function of <i>w<sub>t</sub></i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.#ctor(com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation)">
			<summary>Constructs a multivariate state equation from a univariate state equation.</summary>
			<param name="states">a univariate state equation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.#ctor(com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>StateEquation</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.dimension">
			<summary>Gets the dimension of state <i>x<sub>t</sub></i>.</summary>
			<returns>the dimension of states</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.G(System.Int32)">
			<summary>Gets <i>G(t)</i>, the coefficient matrix of <i>x<sub>t - 1</sub></i>.</summary>
			<param name="t">time</param>
			<returns><i>G(t)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.H(System.Int32)">
			<summary>Gets <i>H(t)</i>, the covariance matrix of <i>u<sub>t</sub></i>.</summary>
			<param name="t">time</param>
			<returns><i>H(t)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.W(System.Int32)">
			<summary>Gets <i>W(t)</i>, the covariance matrix of <i>w<sub>t</sub></i>.</summary>
			<param name="t">time</param>
			<returns><i>W(t)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.xt_mean(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Predicts the next state.
 <blockquote><i>
 E(x_t) = G_t * x_{t - 1} + H_t * u_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="xt_1">x lag <i>x<sub>t - 1</sub></i></param>
			<param name="ut">the control variable <i>u<sub>t</sub></i></param>
			<returns><i>x<sub>t</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.xt_mean(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Predicts the next state without control variable.
 <blockquote><i>
 E(x_t) = G_t * x_{t - 1} + H_t * u_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="xt_1">x lag <i>x<sub>t - 1</sub></i></param>
			<returns><i>x<sub>t</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.xt_var(System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Gets the variance of the apriori prediction for the next state.
 <blockquote><i>
 Var(x_{t | t - 1}) = G_t * Var(x_{t - 1| t - 1}) * G_t&apos; + W_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="var_tlag_tlag"><i>Var(x_{t - 1 | t - 1})</i>, the covariance of the posterior update</param>
			<returns><i>Var(x_{t | t - 1})</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.xt(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Evaluates the state equation.
 <blockquote><i>
 x_t = G_t * x_{t - 1} + H_t * u_t + w_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="xt_1">x lag <i>x<sub>t - 1</sub></i></param>
			<param name="ut">the control variable <i>u<sub>t</sub></i></param>
			<returns><i>x<sub>t</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation.xt(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Evaluates the state equation without the control variable.
 <blockquote><i>
 x_t = G_t * x_{t - 1} + H_t * u_t + w_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="xt_1">x lag <i>x<sub>t - 1</sub></i></param>
			<returns><i>x<sub>t</sub></i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation">
			<summary>This is the observation equation in a controlled dynamic linear model.
 <blockquote><i>
 y<sub>t</sub> = F<sub>t</sub> * x<sub>t</sub> + v<sub>t</sub>
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation.#ctor(com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix,com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix,com.numericalmethod.suanshu.stats.random.multivariate.NormalRVG)">
			<summary>Constructs an observation equation.</summary>
			<param name="F">the coefficient matrix function of <i>x<sub>t</sub></i>, a function of time</param>
			<param name="V">the covariance matrix function of <i>v<sub>t</sub></i>, a function of time</param>
			<param name="rmvnorm">a <i>d</i>-dimensional standard multivariate Gaussian random vector generator
                (for seeding); <i>d</i> = the dimension of <i>V</i> or <i>y<sub>t</sub></i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation.#ctor(com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix,com.numericalmethod.suanshu.analysis.function.matrix.R1toMatrix)">
			<summary>Constructs an observation equation.</summary>
			<param name="F">the coefficient matrix function of <i>x<sub>t</sub></i>, a function of time</param>
			<param name="V">the covariance matrix function of <i>v<sub>t</sub></i>, a function of time</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.stats.random.multivariate.NormalRVG)">
			<summary>Constructs a time-invariant an observation equation.</summary>
			<param name="F">the coefficient matrix of <i>x<sub>t</sub></i></param>
			<param name="V">the covariance matrix of <i>v<sub>t</sub></i></param>
			<param name="rmvnorm">a <i>d</i>-dimensional standard multivariate Gaussian random vector generator
                (for seeding); <i>d</i> = the dimension of <i>V</i> or <i>y<sub>t</sub></i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs a time-invariant an observation equation.</summary>
			<param name="F">the coefficient matrix of <i>x<sub>t</sub></i></param>
			<param name="V">the covariance matrix of <i>v<sub>t</sub></i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation.#ctor(com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation)">
			<summary>Constructs a multivariate observation equation from a univariate observation equation.</summary>
			<param name="obs">a univariate observation equation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation.#ctor(com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>ObservationEquation</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation.dimension">
			<summary>Gets the dimension of observation <i>y<sub>t</sub></i>.</summary>
			<returns>the dimension of observations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation.F(System.Int32)">
			<summary>Gets <i>F(t)</i>, the coefficient matrix of <i>x<sub>t</sub></i>.</summary>
			<param name="t">time</param>
			<returns><i>F(t)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation.V(System.Int32)">
			<summary>Gets <i>V(t)</i>, the covariance matrix of <i>v<sub>t</sub></i>.</summary>
			<param name="t">time</param>
			<returns><i>V(t)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation.yt_mean(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Predicts the next observation.
 <blockquote><i>
 E(y_t) = F_t * x_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="xt">state <i>x<sub>t</sub></i></param>
			<returns>the mean observation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation.yt_var(System.Int32,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Gets the covariance of the apriori prediction for the next observation.
 <blockquote><i>
 Var(y_{t | t - 1}) = F_t * Var(x_{t | t - 1}) * F_t&apos; + V_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="var_t_tlag"><i>Var(y_{t | t - 1})</i>, the variance of the apriori prediction</param>
			<returns><i>Var(y_{t | t - 1})</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation.yt(System.Int32,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Evaluates the observation equation.
 <blockquote><i>
 y_t = F_t * x_t + v_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="xt">state <i>x<sub>t</sub></i></param>
			<returns>the mean observation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter">
			<summary>The Kalman filter, also known as linear quadratic estimation (LQE),
 is an algorithm which uses a series of measurements observed over time,
 containing noise (random variations) and other inaccuracies,
 and produces estimates of unknown variables that tend to be more precise than those that would be based on a single measurement alone.
 More formally, the Kalman filter operates recursively on streams of noisy input data to produce a statistically optimal estimate of the underlying system state.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.#ctor(com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM)">
			<summary>Construct a Kalman filter from a multivariate controlled dynamic linear model.</summary>
			<param name="model">a multivariate controlled DLM</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.filtering(com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateIntTimeTimeSeries,com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateIntTimeTimeSeries)">
			<summary>Filter the observations.</summary>
			<param name="Yt">the observations</param>
			<param name="Ut">the controls</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.filtering(com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateIntTimeTimeSeries)">
			<summary>Filter the observations without control variable.</summary>
			<param name="Yt">the observations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.dimension">
			<summary>Get the dimension of the system, i.e., the dimension of the state vector.</summary>
			<returns>the dimension of the system</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.size">
			<summary>Get <i>T</i>, the number of hidden states or observations.</summary>
			<returns><i>T</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.getFittedStates">
			<summary>Get the posterior expected states.</summary>
			<returns>the fitted states</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.getPredictedStates">
			<summary>Get the prior expected states.</summary>
			<returns>the predicted states</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.getPredictedObservations">
			<summary>Get the prior observation predictions.</summary>
			<returns>the predicted observations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.getFittedState(System.Int32)">
			<summary>Get the posterior expected state.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the fitted state</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.getFittedStateVariance(System.Int32)">
			<summary>Get the posterior expected state variance.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the fitted state variance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.getPredictedState(System.Int32)">
			<summary>Get the prior expected state.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the predicted state</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.getPredictedStateVariance(System.Int32)">
			<summary>Get the prior expected state variance.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the predicted state variance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.getPredictedObservation(System.Int32)">
			<summary>Get the prior observation prediction.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the predicted observation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.getPredictedObservationVariance(System.Int32)">
			<summary>Get the prior observation prediction variance.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the predicted observation variance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateLinearKalmanFilter.getKalmanGain(System.Int32)">
			<summary>Get the Kalman gain.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the Kalman gain</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSim">
			<summary>This is a simulator for a multivariate controlled dynamic linear model process. For <i>(t &#8805;
 1)</i>, a controlled DLM takes the following form:
 <para/>
 Observation Equation:
 <blockquote><i>
 y<sub>t</sub> = F<sub>t</sub> * x<sub>t</sub> + v<sub>t</sub>,
 </i></blockquote>
 State Equation:
 <blockquote><i>
 x<sub>t</sub> = G<sub>t</sub> * x<sub>t-1</sub> + H<sub>t</sub> * u<sub>t</sub> + w<sub>t</sub>,
 </i></blockquote>
 Given the model parameters, the time series of control variables <i>{<i>u<sub>t</sub></i>}</i>
 and an integer (length) <i>T</i>,
 This simulator generates both the states <i>{<i>x<sub>t</sub></i>}</i> and observations
 <i>{<i>y<sub>t</sub></i>}</i>.<para> See also: </para>&quot;G. Petris et al., &quot;ch. 2, pp. 31-84,&quot; Dynamic Linear Models with R, New York, Springer,
 2009.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSim.#ctor(com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM,com.numericalmethod.suanshu.stats.random.multivariate.NormalRVG)">
			<summary>Simulates a multivariate controlled dynamic linear model process.</summary>
			<param name="model">a multivariate controlled dynamic linear model</param>
			<param name="rmvnorm">a standard multivariate Gaussian random vector generator (for seeding)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSim.next(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Gets the next innovation.</summary>
			<param name="u">the control vector as of time <i>t - 1</i>; used not for the first innovation
          (initial state)</param>
			<returns>a simulated innovation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSim.Innovation">
			<summary>a simulated innovation</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSim.Innovation.state">
			<summary>the simulated state</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSim.Innovation.observation">
			<summary>the simulated observation</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSeries">
			<summary>This is a simulator for a multivariate controlled dynamic linear model process.
 For <i>(t &#8805; 1)</i>, a controlled DLM takes the following form:
 <para/>
 Observation Equation:
 <blockquote><i>
 y<sub>t</sub> = F<sub>t</sub> * x<sub>t</sub> + v<sub>t</sub>,
 </i></blockquote>
 State Equation:
 <blockquote><i>
 x<sub>t</sub> = G<sub>t</sub> * x<sub>t-1</sub> + H<sub>t</sub> * u<sub>t</sub> + w<sub>t</sub>,
 </i></blockquote>
 Given the model parameters, the time series of control variables <i>{<i>u<sub>t</sub></i>}</i> and an integer (length) <i>T</i>,
 This simulator generates both the states <i>{<i>x<sub>t</sub></i>}</i> and observations <i>{<i>y<sub>t</sub></i>}</i>.
 <para/>
 This implementation is appropriate for a short time series when the size is known;
 otherwise use instead <para></para>DLMSim.<para> See also: </para>&quot;G. Petris et al., &quot;ch. 2, pp. 31-84,&quot; Dynamic Linear Models with R, New York, Springer, 2009.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSeries.#ctor(System.Int32,com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM,com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateIntTimeTimeSeries,com.numericalmethod.suanshu.stats.random.multivariate.NormalRVG)">
			<summary>Simulate a multivariate controlled dynamic linear model process.</summary>
			<param name="T">the length of the multivariate time series (states and observations) to generate</param>
			<param name="model">a multivariate controlled dynamic linear model</param>
			<param name="Ut">an <i>m</i>-dimensional time series of control variables (length = <i>T</i>); use <c>null</c> if no control</param>
			<param name="rmvnorm">a standard multivariate Gaussian random vector generator (for seeding)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSeries.#ctor(System.Int32,com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM,com.numericalmethod.suanshu.stats.timeseries.datastructure.multivariate.realtime.inttime.MultivariateIntTimeTimeSeries)">
			<summary>Simulate a multivariate controlled dynamic linear model process.</summary>
			<param name="T">the length of the multivariate time series (states and observations) to generate</param>
			<param name="model">a multivariate controlled dynamic linear model</param>
			<param name="Ut">an <i>m</i>-dimensional time series of control variables (length = <i>T</i>); use <c>null</c> if no control</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSeries.#ctor(System.Int32,com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM)">
			<summary>Simulate a multivariate controlled dynamic linear model process.</summary>
			<param name="T">the length of the multivariate time series (states and observations) to generate</param>
			<param name="model">a multivariate controlled dynamic linear model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSeries.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSeries.iterator">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSeries.getStates">
			<summary>Get the states.</summary>
			<returns>the simulated states</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSeries.getObservations">
			<summary>Get the observations.</summary>
			<returns>the simulated observations</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSeries.Entry">
			<summary>This is the <c>TimeSeries.Entry</c> for a multivariate DLM time series.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSeries.Entry.getTime">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLMSeries.Entry.getValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM">
			<summary>This is the multivariate controlled DLM (controlled Dynamic Linear Model) specification.
 A controlled DLM, for <i>(t &#8805; 1)</i>, is described by two equations: the observation and state equations.
 <para/>
 Observation Equation:
 <blockquote><i>
 y<sub>t</sub> = F<sub>t</sub> * x<sub>t</sub> + v<sub>t</sub>,
 </i></blockquote>
 State Equation:
 <blockquote><i>
 x<sub>t</sub> = G<sub>t</sub> * x<sub>t-1</sub> + H<sub>t</sub> * u<sub>t</sub> + w<sub>t</sub>,
 </i></blockquote>
 <i>{y<sub>t</sub>}</i> are the observation vectors; <i>{x<sub>t</sub>}</i> are the state vectors.
 <i>F<sub>t</sub></i> and <i>G<sub>t</sub></i> are known matrices of dimension (number of observations * number of states) and (number of states * number of states) respectively.
 <i>{v<sub>t</sub>}</i> and <i>{w<sub>t</sub>}</i> are two independent sequences of independent normal random vectors
 with mean zero and known variance matrices <i>{V<sub>t</sub>}</i> and <i>{W<sub>t</sub>}</i>, respectively;
 Furthermore, it is assumed that <i>x<sub>0</sub></i> is independent of <i>{v<sub>t</sub>}</i> and <i>{w<sub>t</sub>}</i> and
 is normally distributed with mean <i>m<sub>0</sub></i> and covariance matrix <i>C<sub>0</sub></i>,
 where <i>m<sub>0</sub></i> is a vector of length the same as the number of states
 and <i>C<sub>0</sub></i> is a matrix of dimension (number of states * number of states);
 <i>u<sub>t</sub></i> is an <i>m</i>-dimensional vector of control variables, i.e., the variables whose values can be regulated by the user,
 in order to obtain a desired level of the state <i>x<sub>t</sub></i>.
 <i>H<sub>t</sub></i> is a known matrix of coefficients, with dimension of (number of states * m).<para> See also: </para><list type="bullet">
 <item>G. Petris et al., &quot;ch. 2, pp. 31-84,&quot; Dynamic Linear Models with R, New York, Springer, 2009.</item>
 <item><a href="http://en.wikipedia.org/wiki/kalman_filter#underlying_dynamic_system_model">Wikipedia: Kalman filter - Underlying dynamic system model</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateObservationEquation,com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateStateEquation)">
			<summary>Construct a (multivariate) controlled dynamic linear model.</summary>
			<param name="m0">the mean of <i>x<sub>0</sub></i></param>
			<param name="C0">the covariance matrix of <i>x<sub>0</sub></i></param>
			<param name="Yt">the observation equation for the model</param>
			<param name="Xt">the state equation for the model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM.#ctor(com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM)">
			<summary>Copy constructor.</summary>
			<param name="that">a (multivariate) controlled dynamic linear model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM.m0">
			<summary>Get the the mean of <i>x<sub>0</sub></i>.</summary>
			<returns>m0, the mean of <i>x<sub>0</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM.C0">
			<summary>Get the covariance matrix of <i>x<sub>0</sub></i>.</summary>
			<returns>C0, the covariance matrix of <i>x<sub>0</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM.getObsDimension">
			<summary>Get the dimension of the observations.</summary>
			<returns>the dimension of the observations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM.getStateDimension">
			<summary>Get the dimension of states.</summary>
			<returns>the dimension of states</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM.getObservationModel">
			<summary>Get the observation model.</summary>
			<returns>the observation model</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.multivariate.MultivariateDLM.getStateModel">
			<summary>Get the state model.</summary>
			<returns>the state model</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation">
			<summary>This is the state equation in a controlled dynamic linear model.
 <blockquote><i>
 x<sub>t</sub> = G<sub>t</sub> * x<sub>t-1</sub> + H<sub>t</sub> * u<sub>t</sub> + w<sub>t</sub>,
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.stats.random.univariate.normal.NormalRNG)">
			<summary>Construct a state equation.</summary>
			<param name="G">the coefficient function of <i>x<sub>t - 1</sub></i></param>
			<param name="H">the coefficient function of control variables <i>u<sub>t</sub></i></param>
			<param name="W">the variance function of <i>w<sub>t</sub></i></param>
			<param name="rnorm">a standard Gaussian random number generator (for seeding)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Construct a state equation.</summary>
			<param name="G">the coefficient function of <i>x<sub>t - 1</sub></i></param>
			<param name="H">the coefficient function of control variables <i>u<sub>t</sub></i></param>
			<param name="W">the variance function of <i>w<sub>t</sub></i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Construct a state equation without control variables.</summary>
			<param name="G">the coefficient function of <i>x<sub>t - 1</sub></i></param>
			<param name="W">the variance function of <i>w<sub>t</sub></i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.#ctor(System.Double,System.Double,System.Double,com.numericalmethod.suanshu.stats.random.univariate.normal.NormalRNG)">
			<summary>Construct a time-invariant state equation.</summary>
			<param name="G">the coefficient of <i>x<sub>t - 1</sub></i></param>
			<param name="H">the coefficient of control variables <i>u<sub>t</sub></i></param>
			<param name="W">the variance of <i>w<sub>t</sub></i></param>
			<param name="rnorm">a standard Gaussian random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.#ctor(System.Double,System.Double)">
			<summary>Construct a time-invariant state equation without control variables.</summary>
			<param name="G">the coefficient of <i>x<sub>t - 1</sub></i></param>
			<param name="W">the variance of <i>w<sub>t</sub></i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.#ctor(com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>StateEquation</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.dimension">
			<summary>Get the dimension of state <i>x<sub>t</sub></i>.</summary>
			<returns>the dimension of states</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.G(System.Int32)">
			<summary>Get <i>G(t)</i>, the coefficient of <i>x<sub>t - 1</sub></i>.</summary>
			<param name="t">time</param>
			<returns><i>G(t)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.H(System.Int32)">
			<summary>Get <i>H(t)</i>, the variance of <i>u<sub>t</sub></i>.</summary>
			<param name="t">time</param>
			<returns><i>H(t)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.W(System.Int32)">
			<summary>Get <i>W(t)</i>, the variance of <i>w<sub>t</sub></i>.</summary>
			<param name="t">time</param>
			<returns><i>W(t)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.xt_mean(System.Int32,System.Double,System.Double)">
			<summary>Predict the next state.
 <blockquote><i>
 E(x_t) = G_t * x_{t - 1} + H_t * u_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="xt_1">x lag <i>x<sub>t - 1</sub></i></param>
			<param name="ut">the control variable <i>u<sub>t</sub></i></param>
			<returns><i>x<sub>t</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.xt_mean(System.Int32,System.Double)">
			<summary>Predict the next state without control variable.
 <blockquote><i>
 E(x_t) = G_t * x_{t - 1} + H_t * u_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="xt_1">x lag <i>x<sub>t - 1</sub></i></param>
			<returns><i>x<sub>t</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.xt_var(System.Int32,System.Double)">
			<summary>Get the variance of the apriori prediction for the next state.
 <blockquote><i>
 Var(x_{t | t - 1}) = G_t * Var(x_{t - 1| t - 1}) * G_t&apos; + W_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="var_tlag_tlag"><i>Var(x_{t - 1 | t - 1})</i>, the variance of the posterior update</param>
			<returns><i>Var(x_{t | t - 1})</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.xt(System.Int32,System.Double,System.Double)">
			<summary>Evaluate the state equation.
 <blockquote><i>
 x_t = G_t * x_{t - 1} + H_t * u_t + w_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="xt_1">x lag <i>x<sub>t - 1</sub></i></param>
			<param name="ut">the control variable <i>u<sub>t</sub></i></param>
			<returns><i>x<sub>t</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation.xt(System.Int32,System.Double)">
			<summary>Evaluate the state equation without the control variable.
 <blockquote><i>
 x_t = G_t * x_{t - 1} + H_t * u_t + w_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="xt_1">x lag <i>x<sub>t - 1</sub></i></param>
			<returns><i>x<sub>t</sub></i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation">
			<summary>This is the observation equation in a controlled dynamic linear model.
 <blockquote><i>
 y<sub>t</sub> = F<sub>t</sub> * x<sub>t</sub> + v<sub>t</sub>
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.stats.random.univariate.normal.NormalRNG)">
			<summary>Construct an observation equation.</summary>
			<param name="F">the coefficient function of <i>x<sub>t</sub></i>, a function of time</param>
			<param name="V">the variance function of <i>v<sub>t</sub></i>, a function of time</param>
			<param name="rnorm">a standard Gaussian random number generator (for seeding)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction,com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Construct an observation equation.</summary>
			<param name="F">the coefficient function of <i>x<sub>t</sub></i>, a function of time</param>
			<param name="V">the variance function of <i>v<sub>t</sub></i>, a function of time</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.random.univariate.normal.NormalRNG)">
			<summary>Construct a time-invariant an observation equation.</summary>
			<param name="F">the coefficient of <i>x<sub>t</sub></i></param>
			<param name="V">the variance of <i>v<sub>t</sub></i></param>
			<param name="rnorm">a standard Gaussian random number generator (for seeding)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation.#ctor(System.Double,System.Double)">
			<summary>Construct a time-invariant an observation equation.</summary>
			<param name="F">the coefficient of <i>x<sub>t</sub></i></param>
			<param name="V">the variance of <i>v<sub>t</sub></i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation.#ctor(com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>ObservationEquation</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation.dimension">
			<summary>Get the dimension of observation <i>y<sub>t</sub></i>.</summary>
			<returns>the dimension of observations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation.F(System.Int32)">
			<summary>Get <i>F(t)</i>, the coefficient of <i>x<sub>t</sub></i>.</summary>
			<param name="t">time</param>
			<returns><i>F(t)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation.V(System.Int32)">
			<summary>Get <i>V(t)</i>, the variance of <i>v<sub>t</sub></i>.</summary>
			<param name="t">time</param>
			<returns><i>V(t)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation.yt_mean(System.Int32,System.Double)">
			<summary>Predict the next observation.
 <blockquote><i>
 E(y_t) = F_t * x_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="xt">state <i>x<sub>t</sub></i></param>
			<returns>the mean observation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation.yt_var(System.Int32,System.Double)">
			<summary>Get the variance of the apriori prediction for the next observation.
 <blockquote><i>
 Var(y_{t | t - 1}) = F_t * Var(x_{t | t - 1}) * F_t&apos; + V_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="var_t_tlag"><i>Var(y_{t | t - 1})</i>, the variance of the apriori prediction</param>
			<returns><i>Var(y_{t | t - 1})</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation.yt(System.Int32,System.Double)">
			<summary>Evaluate the observation equation.
 <blockquote><i>
 y_t = F_t * x_t + v_t
 </i></blockquote></summary>
			<param name="t">time</param>
			<param name="xt">state <i>x<sub>t</sub></i></param>
			<returns>the mean observation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter">
			<summary>The Kalman filter, also known as linear quadratic estimation (LQE),
 is an algorithm which uses a series of measurements observed over time,
 containing noise (random variations) and other inaccuracies,
 and produces estimates of unknown variables that tend to be more precise than those that would be
 based on a single measurement alone.
 More formally, the Kalman filter operates recursively on streams of noisy input data to produce a
 statistically optimal estimate of the underlying system state.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.#ctor(com.numericalmethod.suanshu.stats.dlm.univariate.DLM)">
			<summary>Construct a Kalman filter from a univariate controlled dynamic linear model.</summary>
			<param name="model">a univariate controlled DLM</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.filtering(System.Double[],System.Double[])">
			<summary>Filter the observations.</summary>
			<param name="Y">the observations</param>
			<param name="U">the controls</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.filtering(System.Double[])">
			<summary>Filter the observations without control variable.</summary>
			<param name="Y">the observations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.size">
			<summary>Get <i>T</i>, the number of hidden states or observations.</summary>
			<returns><i>T</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.getFittedStates">
			<summary>Get the posterior expected states.</summary>
			<returns>the fitted states</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.getPredictedStates">
			<summary>Get the prior expected states.</summary>
			<returns>the predicted states</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.getPredictedObservations">
			<summary>Get the prior observation predictions.</summary>
			<returns>the predicted observations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.getFittedState(System.Int32)">
			<summary>Get the posterior expected state.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the fitted state</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.getFittedStateVariance(System.Int32)">
			<summary>Get the posterior expected state variance.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the fitted state variance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.getPredictedState(System.Int32)">
			<summary>Get the prior expected state.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the predicted state</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.getPredictedStateVariance(System.Int32)">
			<summary>Get the prior expected state variance.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the predicted state variance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.getPredictedObservation(System.Int32)">
			<summary>Get the prior observation prediction.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the predicted observation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.getPredictedObservationVariance(System.Int32)">
			<summary>Get the prior observation prediction variance.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the predicted observation variance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.LinearKalmanFilter.getKalmanGain(System.Int32)">
			<summary>Get the Kalman gain.</summary>
			<param name="t">time, t &#8805; 1</param>
			<returns>the Kalman gain</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSim">
			<summary>This is a simulator for a univariate controlled dynamic linear model process.
 For <i>(t &#8805; 1)</i>, a controlled DLM takes the following form:
 <para/>
 Observation Equation:
 <blockquote><i>
 y<sub>t</sub> = F<sub>t</sub> * x<sub>t</sub> + v<sub>t</sub>,
 </i></blockquote>
 State Equation:
 <blockquote><i>
 x<sub>t</sub> = G<sub>t</sub> * x<sub>t-1</sub> + H<sub>t</sub> * u<sub>t</sub> + w<sub>t</sub>,
 </i></blockquote>
 Given the model parameters, the time series of control variables <i>{<i>u<sub>t</sub></i>}</i> and an integer (length) <i>T</i>,
 This simulator generates both the states <i>{<i>x<sub>t</sub></i>}</i> and observations <i>{<i>y<sub>t</sub></i>}</i>.<para> See also: </para>&quot;G. Petris et al., &quot;ch. 2, pp. 31-84,&quot; Dynamic Linear Models with R, New York, Springer, 2009.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSim.#ctor(com.numericalmethod.suanshu.stats.dlm.univariate.DLM,com.numericalmethod.suanshu.stats.random.univariate.normal.NormalRNG)">
			<summary>Simulate a univariate controlled dynamic linear model process.</summary>
			<param name="model">a univariate controlled dynamic linear model</param>
			<param name="rnorm">a standard Gaussian random number generator (for seeding)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSim.next(System.Double)">
			<summary>Get the next innovation.</summary>
			<param name="u">the control as of time <i>t - 1</i>; used not for the first innovation (initial state)</param>
			<returns>a simulated innovation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSim.Innovation">
			<summary>a simulated innovation</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSim.Innovation.state">
			<summary>the simulated state</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSim.Innovation.observation">
			<summary>the simulated observation</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSeries">
			<summary>This is a simulator for a multivariate controlled dynamic linear model process.
 For <i>(t &#8805; 1)</i>, a controlled DLM takes the following form:
 <para/>
 Observation Equation:
 <blockquote><i>
 y<sub>t</sub> = F<sub>t</sub> * x<sub>t</sub> + v<sub>t</sub>,
 </i></blockquote>
 State Equation:
 <blockquote><i>
 x<sub>t</sub> = G<sub>t</sub> * x<sub>t-1</sub> + H<sub>t</sub> * u<sub>t</sub> + w<sub>t</sub>,
 </i></blockquote>
 Given the model parameters, the time series of control variables <i>{<i>u<sub>t</sub></i>}</i>
 and an integer (length) <i>T</i>,
 This simulator generates both the states <i>{<i>x<sub>t</sub></i>}</i> and observations
 <i>{<i>y<sub>t</sub></i>}</i>.
 <para/>
 This implementation is appropriate for a short time series when the size is known;
 otherwise use instead <para></para>DLMSim.<para> See also: </para>&quot;G. Petris et al., &quot;ch. 2, pp. 31-84,&quot; Dynamic Linear Models with R, New York, Springer,
 2009.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSeries.#ctor(System.Int32,com.numericalmethod.suanshu.stats.dlm.univariate.DLM,System.Double[],com.numericalmethod.suanshu.stats.random.univariate.normal.NormalRNG)">
			<summary>Simulate a univariate controlled dynamic linear model process.</summary>
			<param name="T">the length of the univariate time series (states and observations) to generate</param>
			<param name="model">a univariate controlled dynamic linear model</param>
			<param name="u">a time series of control variables (length = <i>T</i>)</param>
			<param name="rnorm">a standard Gaussian random number generator (for seeding)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSeries.#ctor(System.Int32,com.numericalmethod.suanshu.stats.dlm.univariate.DLM,System.Double[])">
			<summary>Simulate a univariate controlled dynamic linear model process.</summary>
			<param name="T">the length of the univariate time series (states and observations) to generate</param>
			<param name="model">a univariate controlled dynamic linear model</param>
			<param name="u">a time series of control variables (length = <i>T</i>)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSeries.#ctor(System.Int32,com.numericalmethod.suanshu.stats.dlm.univariate.DLM)">
			<summary>Simulate a univariate controlled dynamic linear model process.</summary>
			<param name="T">the length of the univariate time series (states and observations) to generate</param>
			<param name="model">a univariate controlled dynamic linear model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSeries.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSeries.iterator">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSeries.getStates">
			<summary>Get the states.</summary>
			<returns>the simulated states</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSeries.getObservations">
			<summary>Get the observations.</summary>
			<returns>the simulated observations</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSeries.Entry">
			<summary>This is the <c>TimeSeries.Entry</c> for a univariate DLM time series.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSeries.Entry.getTime">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLMSeries.Entry.getValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.dlm.univariate.DLM">
			<summary>This is the multivariate controlled DLM (controlled Dynamic Linear Model) specification.
 A controlled DLM, for <i>(t &#8805; 1)</i>, is described by two equations: the observation and state equations.
 <para/>
 Observation Equation:
 <blockquote><i>
 y<sub>t</sub> = F<sub>t</sub> * x<sub>t</sub> + v<sub>t</sub>,
 </i></blockquote>
 State Equation:
 <blockquote><i>
 x<sub>t</sub> = G<sub>t</sub> * x<sub>t-1</sub> + H<sub>t</sub> * u<sub>t</sub> + w<sub>t</sub>,
 </i></blockquote>
 <i>{y<sub>t</sub>}</i> are the observation vectors; <i>{x<sub>t</sub>}</i> are the state vectors.
 <i>F<sub>t</sub></i> and <i>G<sub>t</sub></i> are known matrices of dimension (number of observations * number of states) and (number of states * number of states) respectively.
 <i>{v<sub>t</sub>}</i> and <i>{w<sub>t</sub>}</i> are two independent sequences of independent normal random vectors
 with mean zero and known variance matrices <i>{V<sub>t</sub>}</i> and <i>{W<sub>t</sub>}</i>, respectively;
 Furthermore, it is assumed that <i>x<sub>0</sub></i> is independent of <i>{v<sub>t</sub>}</i> and <i>{w<sub>t</sub>}</i> and
 is normally distributed with mean <i>m<sub>0</sub></i> and covariance matrix <i>C<sub>0</sub></i>,
 where <i>m<sub>0</sub></i> is a vector of length the same as the number of states
 and <i>C<sub>0</sub></i> is a matrix of dimension (number of states * number of states);

 <i>u<sub>t</sub></i> is an <i>m</i>-dimensional vector of control variables, i.e., the variables whose values can be regulated by the user,
 in order to obtain a desired level of the state <i>x<sub>t</sub></i>.
 <i>H<sub>t</sub></i> is a known matrix of coefficients, with dimension of (number of states * m).<para> See also: </para><list type="bullet">
 <item>G. Petris et al., &quot;ch. 2, pp. 31-84,&quot; Dynamic Linear Models with R, New York, Springer, 2009.</item>
 <item> <a href="http://en.wikipedia.org/wiki/kalman_filter#underlying_dynamic_system_model">Wikipedia: Kalman filter - Underlying dynamic system model</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLM.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.dlm.univariate.ObservationEquation,com.numericalmethod.suanshu.stats.dlm.univariate.StateEquation)">
			<summary>Construct a univariate controlled dynamic linear model.</summary>
			<param name="m0">the mean of <i>x<sub>0</sub></i></param>
			<param name="C0">the variance of <i>x<sub>0</sub></i></param>
			<param name="Yt">the observation equation for the model</param>
			<param name="Xt">the state equation for the model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLM.#ctor(com.numericalmethod.suanshu.stats.dlm.univariate.DLM)">
			<summary>Copy constructor.</summary>
			<param name="that">a univariate controlled dynamic linear model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLM.m0">
			<summary>Get the the mean of <i>x<sub>0</sub></i>.</summary>
			<returns>m0, the mean of <i>x<sub>0</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLM.C0">
			<summary>Get the variance of <i>x<sub>0</sub></i>.</summary>
			<returns>C0, the variance of <i>x<sub>0</sub></i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLM.getObsDimension">
			<summary>Get the dimension of observations.</summary>
			<returns>the dimension of observations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLM.getStateDimension">
			<summary>Get the dimension of states.</summary>
			<returns>the dimension of states</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLM.getObservationModel">
			<summary>Get the observation model.</summary>
			<returns>the observation model</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.dlm.univariate.DLM.getStateModel">
			<summary>Get the state model.</summary>
			<returns>the state model</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.factoranalysis.FAEstimator">
			<summary>These are the estimators
 (estimated psi, loading matrix, scores, degrees of freedom, test statistics, p-value, etc.)
 from the factor analysis MLE optimization.<para> See also: </para><list type="bullet">
 <item> M. S. Bartlett, &quot;The Statistical Conception of Mental Factors,&quot; The British Journal of Psychology, vol. 28, 97-104, 1937.</item>
 <item> M. S. Bartlett, &quot;A Note on Multiplying Factors for Various Chi-Squared Approximations,&quot; Journal of the Royal Statistical Society, Series B, vol. 16, 296-298, 1954.</item>
 <item> D. N. Lawley and A. E. Maxwell, &quot;Factor Analysis as a Statistical Method,&quot; Second Edition, Butterworths, 1971.</item>
 <item> G. H. Thomson, &quot;The Factorial Analysis of Human Ability,&quot; London University Press, 1951.</item>
 <item><a href="http://en.wikipedia.org/wiki/factor_analysis">Wikipedia: Factor analysis</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FAEstimator.psi">
			<summary>Get the estimated (optimal) psi, <i>E(ee&apos;)</i>, p. 6.</summary>
			<returns>the psi vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FAEstimator.loadings">
			<summary>Get the rotated loading matrix.</summary>
			<returns>the rotated matrix of loadings</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FAEstimator.dof">
			<summary>Get the degree of freedom in the factor analysis model.</summary>
			<returns>the degree of freedom</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FAEstimator.logLikelihood">
			<summary>Get the log-likelihood value.</summary>
			<returns>the log-likelihood</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FAEstimator.scores">
			<summary>Get the matrix of scores, computed using either Thompson&apos;s (1951) scores,
 or Bartlett&apos;s (1937) weighted least-squares scores.</summary>
			<returns>the matrix of scores</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FAEstimator.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FAEstimator.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FAEstimator.statistics">
			<summary>Get the test statistics of the factor analysis. Bartlett (1954) has shown
 that the chi-squared approximation to the distribution can be improved by
 using a multiplying factor of <i>(N - 1) - (2p + 4k + 5) / 6</i>, which is the
 same multiplying factor used here and often used in empirical studies. N.B.
 the same multiplying factor is used in Bartlett&apos;s test of sphericity.</summary>
			<returns>the test statistics</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FAEstimator.pValue">
			<summary>Calculate the p-value of the test statistics, given the degree of freedom.</summary>
			<returns>the p-value</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis">
			<summary>Factor analysis is a statistical method used to describe variability among observed variables in
 terms of a potentially lower number of unobserved variables called factors. Factor analysis
 searches for joint variations in response to unobserved latent variables. The observed variables
 are modeled as linear combinations of the potential factors, plus &quot;error&quot; terms. The information
 gained about the interdependencies between observed variables can be used later to reduce the set
 of variables in a dataset. Although factor analysis and principal component analysis (PCA) are
 both dimension reduction techniques, those two are not identical. Because PCA performs a
 variance-maximizing rotation of the variable space, it takes into account all variability in the
 variables. In contrast, factor analysis estimates how much of the variability is due to common
 factors. The two methods become essentially equivalent if the error terms in the factor analysis
 model can be assumed to all have the same variance.
 <para/>
 The R equivalent function is <c>factanal</c>.<para> See also: </para><list type="bullet">
 <item> M. S. Bartlett, &quot;The Statistical Conception of Mental Factors,&quot; The British Journal of
 Psychology, vol. 28, 97-104, 1937.</item>
 <item> M. S. Bartlett, &quot;A Note on Multiplying Factors for Various Chi-Squared Approximations,&quot;
 Journal of the Royal Statistical Society, Series B, vol. 16, 296-298, 1954.</item>
 <item> K. G. Jöreskog, &quot;Statistical Estimation in Factor Analysis: A New Technique and Its
 Foundation,&quot; Almqvist and Wicksell, 1963.</item>
 <item> D. N. Lawley and A. E. Maxwell, &quot;Factor Analysis as a Statistical Method,&quot; Second Edition,
 Butterworths, 1971.</item>
 <item> G. H. Thomson, &quot;The Factorial Analysis of Human Ability,&quot; London University Press,
 1951.</item>
 <item><a href="http://en.wikipedia.org/wiki/factor_analysis">Wikipedia: Factor analysis</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.ScoringRule,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Perform factor analysis on the data set with a user defined scoring rule and a user defined
 covariance (or correlation) matrix.
 <para/></summary>
			<param name="data">the data set</param>
			<param name="nFactors">the number of factors</param>
			<param name="rule">the scoring rule</param>
			<param name="S">a covariance (or correlation) matrix, usually taken to be the covariance (or
                 correlation) matrix of the <c>data</c> set. Using a correlation matrix amounts to scaling
                 the original data set.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.ScoringRule)">
			<summary>Perform factor analysis on the data set with a user defined scoring rule.
 <para/></summary>
			<param name="data">the data set</param>
			<param name="nFactors">the number of factors</param>
			<param name="rule">the scoring rule</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32)">
			<summary>Perform factor analysis on the data set, using Bartlett&apos;s weighted least-squares scores, and
 sample correlation matrix.
 <para/></summary>
			<param name="data">the data set</param>
			<param name="nFactors">the number of factors</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.S">
			<summary>Get the covariance (or correlation) matrix.
 <para/></summary>
			<returns>the covariance (or correlation) matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.nObs">
			<summary>Get the number of observations.
 <para/></summary>
			<returns>the number of observations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.nVariables">
			<summary>Get the number of variables in the original data set.
 <para/></summary>
			<returns>the number of variables in the original data set</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.nFactors">
			<summary>Get the number of factors.
 <para/></summary>
			<returns>the number of factors</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.scoringRule">
			<summary>Get the scoring rule.
 <para/></summary>
			<returns>the scoring rule</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.getEstimators(System.Int32)">
			<summary>Get the estimators (estimated psi, loading matrix, degree of freedom, test statistics,
 p-value, etc) obtained from the factor analysis, given the maximum number of iterations.</summary>
			<param name="maxIterations">the maximum number of iterations</param>
			<returns>the estimators from the factor analysis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.getEstimators(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary>Get the estimators (estimated psi, loading matrix, degree of freedom, test statistics,
 p-value, etc) obtained from the factor analysis, given the initial psi and the maximum number
 of iterations.</summary>
			<param name="initial">the initial values of psi</param>
			<param name="maxIterations">the maximum number of iterations</param>
			<returns>the estimators from the factor analysis</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.ScoringRule">
			<summary>These are the different ways to compute the factor analysis scores.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.ScoringRule.THOMSON">
			<summary>Thomson&apos;s (1951) scores</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.ScoringRule.BARTLETT">
			<summary>Bartlett&apos;s (1937) weighted least-squares scores</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.ScoringRule.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.factoranalysis.FactorAnalysis.ScoringRule.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.HmmInnovation">
			<summary>An HMM innovation consists of a state and an observation in the state.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.HmmInnovation.#ctor(System.Int32,System.Double)">
			<summary>Construct an HMM innovation.</summary>
			<param name="state">a hidden state</param>
			<param name="observation">an observation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.HmmInnovation.getState">
			<summary>Get the hidden state.</summary>
			<returns>the hidden state</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.HmmInnovation.getObservation">
			<summary>Get the observation associated with the hidden state.</summary>
			<returns>the observation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.HiddenMarkovModel">
			<summary>In a (discrete) hidden Markov model, the state is not directly visible, but output, dependent on the state, is visible.
 Each state has a probability distribution over the possible output tokens (could be continuous).
 Therefore the sequence of tokens generated by an HMM gives some information about the sequence of states.
 Note that the adjective &apos;hidden&apos; refers to the state sequence through which the model passes,
 not to the parameters of the model; even if the model parameters are known exactly, the model is still &apos;hidden&apos;.
 In other words, a hidden Markov model is a Markov chain of (hidden) states
 and for each state a conditional random number generator (distribution).<para> See also: </para><a href="http://en.wikipedia.org/wiki/hidden_markov_model">Wikipedia: Hidden Markov model</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.HiddenMarkovModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator[])">
			<summary>Construct a hidden Markov model.</summary>
			<param name="PI">the initial state probabilities</param>
			<param name="A">the state transition probabilities of the homogeneous hidden Markov chain</param>
			<param name="B">the conditional observation random number generators (distributions)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.HiddenMarkovModel.#ctor(com.numericalmethod.suanshu.stats.hmm.HiddenMarkovModel)">
			<summary>Copy constructor.</summary>
			<param name="that">a <c>HiddenMarkovModel</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.HiddenMarkovModel.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.HiddenMarkovModel.nextDouble">
			<summary>Get the next simulated observation.</summary>
			<returns>next observation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.HiddenMarkovModel.next">
			<summary>Get the next simulated innovation - state and observation.</summary>
			<returns>the next HMM innovation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixturePoissonDistribution">
			<summary>The HMM states use the Poisson distribution to model the observations.<para> See also: </para>com.numericalmethod.suanshu.stats.distribution.univariate.PoissonDistribution<para> See also: </para><a href="http://en.wikipedia.org/wiki/poisson_distribution">Wikipedia: Poisson distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixturePoissonDistribution.#ctor(java.lang.Double[])">
			<summary>Construct a Poisson distribution for each state in the HMM model.</summary>
			<param name="rates">the rates</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixturePoissonDistribution.getParams">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixturePoissonDistribution.getRandomNumberGenerators">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixturePoissonDistribution.getDistributions">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixturePoissonDistribution.getMStepParams(System.Double[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Object[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixturePoissonDistribution.newEMDistribution(System.Object[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution">
			<summary>The HMM states use the Normal distribution to model the observations.<para> See also: </para>com.numericalmethod.suanshu.stats.distribution.univariate.NormalDistribution<para> See also: </para><a href="http://en.wikipedia.org/wiki/normal_distribution">Wikipedia: Normal distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.#ctor(com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.Lambda[],System.Boolean,System.Boolean)">
			<summary>Construct a Normal distribution for each state in the HMM model.</summary>
			<param name="lambda">the distribution parameters</param>
			<param name="isMuEstimated">indicate whether parameter <c>mu</c> is to be estimated</param>
			<param name="isSigmaEstimated">indicate whether parameter <c>sigma</c> is to be estimated</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.#ctor(com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.Lambda[])">
			<summary>Construct a Normal distribution for each state in the HMM model.</summary>
			<param name="lambda">the distribution parameters</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.getParams">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.getRandomNumberGenerators">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.getDistributions">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.getMStepParams(System.Double[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Object[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.newEMDistribution(System.Object[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.Lambda">
			<summary>the Normal distribution parameters</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.Lambda.mu">
			<summary>the mean</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.Lambda.sigma">
			<summary>the standard deviation</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureNormalDistribution.Lambda.#ctor(System.Double,System.Double)">
			<summary>Construct a Normal distribution.</summary>
			<param name="mu">the mean</param>
			<param name="sigma">the standard deviation</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution">
			<summary>The HMM states use the Log-Normal distribution to model the observations.<para> See also: </para>com.numericalmethod.suanshu.stats.distribution.univariate.LogNormalDistribution<para> See also: </para><a href="http://en.wikipedia.org/wiki/log-normal_distribution">Wikipedia: Log-normal distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.#ctor(com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.Lambda[],System.Boolean,System.Boolean)">
			<summary>Construct a Log-Normal distribution for each state in the HMM model.</summary>
			<param name="lambda">the distribution parameters</param>
			<param name="isMuEstimated">indicate whether parameter <c>mu</c> is to be estimated</param>
			<param name="isSigmaEstimated">indicate whether parameter <c>sigma</c> is to be estimated</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.#ctor(com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.Lambda[])">
			<summary>Construct a Log-Normal distribution for each state in the HMM model.</summary>
			<param name="lambda">the distribution parameters</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.getParams">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.getRandomNumberGenerators">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.getDistributions">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.getMStepParams(System.Double[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Object[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.newEMDistribution(System.Object[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.Lambda">
			<summary>the Log-Normal distribution parameters</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.Lambda.logMu">
			<summary>the log-mean &#956; &#8712; R</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.Lambda.logSigma">
			<summary>the log-standard deviation; shape</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureLogNormalDistribution.Lambda.#ctor(System.Double,System.Double)">
			<summary>Construct a Log-Normal distribution.</summary>
			<param name="mu">the log-mean</param>
			<param name="sigma">the log-standard deviation</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution">
			<summary>The HMM states use the Gamma distribution to model the observations.<para> See also: </para>com.numericalmethod.suanshu.stats.distribution.univariate.GammaDistribution<para> See also: </para><a href="http://en.wikipedia.org/wiki/gamma_distribution">Wikipedia: Gamma distribution
 distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.#ctor(com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.Lambda[],System.Boolean,System.Boolean,System.Double,System.Int32)">
			<summary>Construct a Gamma distribution for each state in the HMM model.</summary>
			<param name="lambda">the distribution parameters</param>
			<param name="isShapeEstimated">indicate whether the shape parameter <c>k</c> is to be estimated</param>
			<param name="isScaleEstimated">indicate whether the scale parameter <c>theta</c> is to be estimated</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                         considered 0</param>
			<param name="maxIterations">the maximum number of iterations in each M-step</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.#ctor(com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.Lambda[],System.Int32)">
			<summary>Construct a Gamma distribution for each state in the HMM model.</summary>
			<param name="lambda">the distribution parameters</param>
			<param name="maxIterations">the maximum number of iterations in each M-step</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.getParams">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.getRandomNumberGenerators">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.getDistributions">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.getMStepParams(System.Double[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Object[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.newEMDistribution(System.Object[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.Lambda">
			<summary>the Gamma distribution parameters</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.Lambda.k">
			<summary>the shape parameter</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.Lambda.theta">
			<summary>the scale parameter</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureGammaDistribution.Lambda.#ctor(System.Double,System.Double)">
			<summary>Store the Gamma distribution parameters.</summary>
			<param name="k">the shape parameter</param>
			<param name="theta">the scale parameter</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureExponentialDistribution">
			<summary>The HMM states use the Exponential distribution to model the observations.<para> See also: </para>com.numericalmethod.suanshu.stats.distribution.univariate.ExponentialDistribution<para> See also: </para><a href="http://en.wikipedia.org/wiki/exponential_distribution">Wikipedia: ExponentialDistribution distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureExponentialDistribution.#ctor(java.lang.Double[])">
			<summary>Construct an Exponential distribution for each state in the HMM model.</summary>
			<param name="rates">the rates</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureExponentialDistribution.getParams">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureExponentialDistribution.getRandomNumberGenerators">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureExponentialDistribution.getDistributions">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureExponentialDistribution.getMStepParams(System.Double[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Object[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureExponentialDistribution.newEMDistribution(System.Object[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureDistribution">
			<summary>This is the conditional distribution of the observations in each state (possibly differently
 parameterized) of a mixture hidden Markov model. An EM algorithm, such as
 <para></para>MixtureBaumWelch the Baum-Welch algorihtm can fit the parameters.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureDistribution.getParams">
			<summary>Get the parameters, for each state, of the distribution.</summary>
			<returns>the parameters, for each state, of the distribution</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureDistribution.getDistributions">
			<summary>Get the distributions (possibly differently parameterized) for all states.</summary>
			<returns>the distributions</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureDistribution.getRandomNumberGenerators">
			<summary>Get the random number generators corresponding to the distributions (possibly differently
 parameterized) for all states.</summary>
			<returns>the random number generators corresponding to the distributions</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureDistribution.getMStepParams(System.Double[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Object[])">
			<summary>Maximize, for each state, the log-likelihood of the distribution with respect to the
 observations and current estimators.</summary>
			<param name="observations">the observations</param>
			<param name="u">this is a log-transformed version of eq. (4.13) of Zucchini and MacDonald
                     (2009), p. 65</param>
			<param name="param0">the current estimators of the distribution parameters</param>
			<returns>the MLE estimators</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureDistribution.newEMDistribution(System.Object[])">
			<summary>Construct a new distribution from a set of parameters, one set per state.</summary>
			<param name="lambda">the parameters of the distribution, one set per state</param>
			<returns>a new HMM distribution</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBinomialDistribution">
			<summary>The HMM states use the Binomial distribution to model the observations.<para> See also: </para>com.numericalmethod.suanshu.stats.distribution.univariate.BinomialDistribution<para> See also: </para><a href="http://en.wikipedia.org/wiki/binomial_distribution">Wikipedia: Binomial distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBinomialDistribution.#ctor(com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBinomialDistribution.Lambda[])">
			<summary>Construct a Binomial distribution for each state in the HMM model.</summary>
			<param name="lambda">the distribution parameters</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBinomialDistribution.getParams">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBinomialDistribution.getRandomNumberGenerators">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBinomialDistribution.getDistributions">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBinomialDistribution.getMStepParams(System.Double[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Object[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBinomialDistribution.newEMDistribution(System.Object[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBinomialDistribution.Lambda">
			<summary>the Binomial distribution parameters</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBinomialDistribution.Lambda.size">
			<summary>the size</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBinomialDistribution.Lambda.p">
			<summary>the success probability in each trial</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBinomialDistribution.Lambda.#ctor(System.Int32,System.Double)">
			<summary>Store the Binomial distribution parameters.</summary>
			<param name="size">the size</param>
			<param name="p">the success probability in each trial</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution">
			<summary>The HMM states use the Beta distribution to model the observations.<para> See also: </para>com.numericalmethod.suanshu.stats.distribution.univariate.BetaDistribution<para> See also: </para><a href="http://en.wikipedia.org/wiki/beta_distribution">Wikipedia: Beta distribution</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.#ctor(com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.Lambda[],System.Boolean,System.Boolean,System.Double,System.Int32)">
			<summary>Construct a Beta distribution for each state in the HMM model.</summary>
			<param name="lambda">the distribution parameters</param>
			<param name="isAlphaEstimated">indicate whether parameter <c>alpha</c> is to be estimated</param>
			<param name="isBetaEstimated">indicate whether parameter <c>beta</c> is to be estimated</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                         considered 0</param>
			<param name="maxIterations">the maximum number of iterations in each M-step</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.#ctor(com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.Lambda[],System.Int32)">
			<summary>Construct a Beta distribution for each state in the HMM model.</summary>
			<param name="lambda">the distribution parameters</param>
			<param name="maxIterations">the maximum number of iterations in each M-step</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.getParams">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.getRandomNumberGenerators">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.getDistributions">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.getMStepParams(System.Double[],com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Object[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.newEMDistribution(System.Object[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.Lambda">
			<summary>the Beta distribution parameters</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.Lambda.alpha">
			<summary>&#945;: the shape parameter</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.Lambda.beta">
			<summary>&#946;: the shape parameter</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureBetaDistribution.Lambda.#ctor(System.Double,System.Double)">
			<summary>Store the Beta distribution parameters.</summary>
			<param name="alpha">&#945;: the shape parameter</param>
			<param name="beta">&#946;: the shape parameter</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureViterbi">
			<summary>The Viterbi algorithm is a dynamic programming algorithm for finding the most likely sequence of hidden states
 - called the Viterbi path -
 that results in a sequence of observed events,
 especially in the context of Markov information sources and hidden Markov models.<para> See also: </para><list type="bullet">
 <item>Rabiner, L.R. &quot;A tutorial on hidden Markov models and selected applications in speech recognition,&quot; Proceedings of the IEEE. Volume 77, Issue 2, 257 - 286. Feb 1989.</item>
 <item>W. Zucchini and I. L. MacDonald, &quot;Hidden Markov Models for Time Series: An Introduction Using R,&quot; Boca Raton, Florida, CRC Press, 2009.</item>
 <item><a href="http://en.wikipedia.org/wiki/viterbi_algorithm">Wikipedia: Viterbi algorithm</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureViterbi.#ctor(com.numericalmethod.suanshu.stats.hmm.mixture.MixtureHiddenMarkovModel)">
			<summary>Construct an Viterbi algorithm for an HMM.</summary>
			<param name="model">the underlying hidden Markov model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureViterbi.getViterbiStates(System.Double[])">
			<summary>Generate the most likely sequence of states by using Viterbi algorithm (global decoding),
 given the observations and the parameters of the underlying hidden Markov model.</summary>
			<param name="observations">the observations</param>
			<returns>the most likely sequence of states</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureHiddenMarkovModel">
			<summary>This is the mixture hidden Markov model (HMM). The observations are continuous and follow a continuous distribution.<para> See also: </para><list type="bullet">
 <item>W. Zucchini and I. L. MacDonald, &quot;Hidden Markov Models for Time Series: An Introduction Using R,&quot; Boca Raton, Florida, CRC Press, 2009.</item>
 <item><a href="http://en.wikipedia.org/wiki/hidden_markov_model">Wikipedia: Hidden Markov model</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureHiddenMarkovModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.stats.hmm.mixture.distribution.MixtureDistribution)">
			<summary>Construct a mixture hidden Markov model.</summary>
			<param name="PI">the initial state probabilities</param>
			<param name="A">the state transition probabilities of the homogeneous hidden Markov chain</param>
			<param name="dist">the conditional distribution in the hidden Markov model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureHiddenMarkovModel.#ctor(com.numericalmethod.suanshu.stats.hmm.mixture.MixtureHiddenMarkovModel)">
			<summary>Copy constructor.</summary>
			<param name="model">a <c>HiddenMarkovModel</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureHiddenMarkovModel.getDistribution">
			<summary>Get the distribution in the hidden Markov model.</summary>
			<returns>the distribution in the hidden Markov model</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureHiddenMarkovModel.density(System.Int32,System.Double)">
			<summary>Get the probability density of making an observation in a particular state.</summary>
			<param name="observation">the observation value</param>
			<param name="state">the hidden state label, counting from 1</param>
			<returns>the probability density</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureForwardBackward">
			<summary>The implementation of the forward-backward algorithm computes the log of forward and backward
 probabilities,
 give a sequence of observations and the hmm model.<para> See also: </para><list type="bullet">
 <item>L. R. Rabiner, &quot;A tutorial on hidden Markov models and selected applications in speech
 recognition,&quot; Proceedings of the IEEE, Volume: 77, Issue:2, 257 - 286, Feb 1989.&quot;</item>
 <item>W. Zucchini and I. L. MacDonald, &quot;Hidden Markov Models for Time Series: An Introduction Using
 R,&quot; Boca Raton, Florida, CRC Press, 2009.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureForwardBackward.#ctor(com.numericalmethod.suanshu.stats.hmm.mixture.MixtureHiddenMarkovModel)">
			<summary>Construct an instance of <c>HmmForwardBackward</c> to compute
 the forward and backward probabilities and the log-likelihood.</summary>
			<param name="model">a mixture hidden Markov model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureForwardBackward.logForward(System.Double[])">
			<summary>Get the log-transformed forward probability matrix.</summary>
			<param name="observations">a sequence of observations</param>
			<returns>the log-transformed forward probabilities matrix (number of observations * number of
         states)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureForwardBackward.logBackward(System.Double[])">
			<summary>Get the log-transformed backward probability matrix.</summary>
			<param name="observations">a sequence of observations</param>
			<returns>the log-transformed backward probabilities matrix (number of observations * number of
         states)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureForwardBackward.logLikelihood(System.Double[])">
			<summary>Get the log-likelihood.</summary>
			<param name="observations">a sequence of observations</param>
			<returns>the log-likelihood</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureBaumWelch">
			<summary>The Baum-Welch algorithm is used to find the unknown parameters of a hidden Markov model (HMM)
 by making use of the forward-backward algorithm. It does the following.
 <list type="bullet">
 <item>the E step: Compute the conditional expectations given the observations and the current estimates of the parameters.</item>
 <item>the M step: Maximize, with respect to the estimated parameters and the data set, log-likelihood.</item>
 </list>
 These two steps are repeated until some convergence criterion has been satisfied.<para> See also: </para><list type="bullet">
 <item>L. R. Rabiner, &quot;A tutorial on hidden Markov models and selected applications in speech recognition,&quot; Proceedings of the IEEE, Volume: 77, Issue:2, 257 - 286, Feb 1989.&quot;</item>
 <item>W. Zucchini and I. L. MacDonald, &quot;Hidden Markov Models for Time Series: An Introduction Using R,&quot; Boca Raton, Florida, CRC Press, 2009.</item>
 <item>L. R. Welch, &quot;Hidden Markov models and the Baum-Welch algorithm,&quot; IEEE Information Theory Society Newsletter Volume 53, pp. 1, 10-13, Dec 2003.</item>
 <item><a href="http://en.wikipedia.org/wiki/baum%e2%80%93welch_algorithm">Wikipedia: Baum-Welch algorithm</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureBaumWelch.#ctor(System.Double[],com.numericalmethod.suanshu.stats.hmm.mixture.MixtureHiddenMarkovModel,System.Double,System.Int32)">
			<summary>Construct a mixture HMM model by training an initial model using the Baum-Welch algorithm.</summary>
			<param name="observations">the observations</param>
			<param name="model0">an initial model</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureBaumWelch.train(com.numericalmethod.suanshu.stats.hmm.mixture.MixtureHiddenMarkovModel,System.Double[])">
			<summary>Construct a trained mixture hidden Markov model, one iteration.</summary>
			<param name="model0">the initial hidden Markov model</param>
			<param name="observations">the observations</param>
			<returns>a trained mixture hidden Markov model</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureBaumWelch.TrainedModel">
			<summary>the result of the Baum-Welch algorithm</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureBaumWelch.TrainedModel.model">
			<summary>the newly trained model as a result of the Baum-Welch algorithm</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.hmm.mixture.MixtureBaumWelch.TrainedModel.logLikelihood">
			<summary>the log-likelihood</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerXi">
			<summary><i>&#958;</i> is the probability of the system being in state <i>s<sub>i</sub></i> at time <i>t</i>
 and state <i>s<sub>j</sub></i> at time <i>t+1</i>, given the model and observation sequence.
 <blockquote><i>
 &#958;<sub>t</sub>(i, j) =
 P(q<sub>t</sub> = s<sub>i</sub>, q<sub>t+1</sub> = s<sub>j</sub> | &#937;, &#955;)
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerXi.#ctor(com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerHiddenMarkovModel)">
			<summary>Construct the xi matrices generator.
 Generate the xi matrices of a (discrete) HMM, where for 1 &#8804; t &#8804; T - 1,
 the t-th entry of xi is an (N * N) matrix, for which the (i, j)-th entry is xi_t(i, j).</summary>
			<param name="model">a (discrete) hidden Markov model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerXi.xi(System.Int32[])">
			<summary>Get the <i>&#958;</i> matrices, where for <i>1 &#8804; t &#8804; T - 1</i>,
 the <i>t</i>-th entry of <i>&#958;</i> is an <i>(N * N)</i> matrix, for which the (i, j)-th
 entry is <i>&#958;<sub>t</sub>(i, j)</i>.</summary>
			<param name="observations">an integer array of observation symbols (length = <i>T</i>);
                     each symbol is a positive integer less than or equal to <i>M</i>
                     (the number of observation symbols per state)</param>
			<returns>the <i>&#958;</i> matrices</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerTrainByEM">
			<summary>This implementation trains an HMM model by observations using an EM algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerTrainByEM.#ctor(System.Int32[],com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerHiddenMarkovModel,System.Int32)">
			<summary>Construct an HMM model by training an initial model using an EM algorithm.</summary>
			<param name="observations">an integer array of observation symbols (length = <i>T</i>).
 Each symbol is a positive integer less than or equal to <i>M</i> (the number of observation symbols per state).</param>
			<param name="model0">an initial model</param>
			<param name="nIteraions">the number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerTrainByEM.train(com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerHiddenMarkovModel,System.Int32[])">
			<summary>Construct a trained (discrete) hidden Markov model, one iteration.</summary>
			<param name="model0">the initial hidden Markov model</param>
			<param name="observations">an integer array of observation symbols (length = <i>T</i>).
 Each symbol is a positive integer less than or equal to <i>M</i> (the number of observation symbols per state).</param>
			<returns>a trained (discrete) hidden Markov model</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerHiddenMarkovModel">
			<summary>This is the hidden Markov model as defined by Rabiner.<para> See also: </para>&quot;L. R. Rabiner, &quot;A tutorial on hidden Markov models and selected applications in speech recognition,&quot; Proceedings of the IEEE, Volume: 77, Issue:2, 257 - 286, Feb 1989.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerHiddenMarkovModel.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a Rabiner hidden Markov model.</summary>
			<param name="PI">the initial state probabilities</param>
			<param name="A">the state transition probabilities</param>
			<param name="B">the conditional probabilities of the observation symbols: rows correspond to
                state; columns corresponds symbols</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerHiddenMarkovModel.#ctor(com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerHiddenMarkovModel)">
			<summary>Copy constructor.</summary>
			<param name="model">a <c>HiddenMarkovModel</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerHiddenMarkovModel.B">
			<summary>Get the conditional probabilities of the observation symbols:
 rows correspond to state; columns corresponds symbols.</summary>
			<returns>the observation symbol probabilities</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerHiddenMarkovModel.nSymbols">
			<summary>Get the number of observation symbols per state.</summary>
			<returns>the number of observation symbols per state</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerGamma">
			<summary><i>&#947;</i> is the probability of the system in state <i>s<sub>i</sub></i>,
 given the model and observation sequence.
 <blockquote><i>
 &#947;<sub>t</sub>(i) = P(q<sub>t</sub> = s<sub>i</sub> | &#937;, &#955;)
 </i></blockquote></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerGamma.#ctor(com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerHiddenMarkovModel)">
			<summary>Construct the gamma matrix generator.</summary>
			<param name="model">a (discrete) hidden Markov model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerGamma.gamma(System.Int32[])">
			<summary>Get the <i>(T * N)</i> <i>&#947;</i> matrix,
 where the (t, i)-th entry is <i>&#947;<sub>t</sub>(i)</i>.</summary>
			<param name="observations">an integer array of observation symbols (length = <i>T</i>).
 Each symbol is a positive integer less than or equal to <i>M</i> (the number of observation symbols per state).</param>
			<returns>the gamma matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerForwardBackward">
			<summary>The forward-backward algorithm is an inference algorithm for hidden Markov models
 which computes the posterior marginals of all hidden state variables given a sequence of observations.
 This inference task is usually called smoothing.
 The algorithm makes use of the principle of dynamic programming to efficiently compute the values
 that are required to obtain the posterior marginal distributions in two passes.
 The first pass goes forward in time while the second goes backward in time; hence the name forward-backward algorithm.
 <para/>
 The forward probability, <i>&#945;</i>, is the probability of the partial observation sequence until time <i>t</i>
 and the system in state <i>s<sub>i</sub></i> and time <i>t</i>.
 <blockquote><i>
 &#945;<sub>t</sub>(i) = p(&#969;<sub>1</sub>, &#969;<sub>2</sub>, ... &#969;<sub>t</sub>, q<sub>t</sub> = s<sub>i</sub> | &#955;)
 </i></blockquote>
 The backward probability, <i>&#946;</i>, is the probability of the system in state <i>s<sub>i</sub></i> at time <i>t</i>,
 and the partial observations from then onward till time <i>t</i>.
 <blockquote><i>
 &#946;<sub>t</sub>(i) = p(&#969;<sub>t+1</sub>, &#969;<sub>t+2</sub>, ... &#969;<sub>T</sub> | q<sub>t</sub> = s<sub>i</sub>, &#955;)
 </i></blockquote><para> See also: </para><a href="http://en.wikipedia.org/wiki/forward%e2%80%93backward_algorithm">Wikipedia: Forward-backward algorithm</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerForwardBackward.#ctor(com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerHiddenMarkovModel)">
			<summary>Construct the forward and backward probability matrix generator for an HMM model.</summary>
			<param name="model">a (discrete) hidden Markov model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerForwardBackward.scaledAlpha(System.Int32[])">
			<summary>Get the scaled forward probability matrix, dimension <i>(T * N)</i>.</summary>
			<param name="observations">an integer array of observation symbols (length = <i>T</i>).
 Each symbol is a positive integer less than or equal to <i>M</i> (the number of observation symbols per state).</param>
			<returns>scaled alpha, the scaled forward probability matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.hmm.rabiner.RabinerForwardBackward.scaledBeta(System.Int32[])">
			<summary>Get the scaled backward probability matrix, dimension <i>(T * N)</i>.</summary>
			<param name="observations">an integer array of observation symbols (length = <i>T</i>).
 Each symbol is a positive integer less than or equal to <i>M</i> (the number of observation symbols per state).</param>
			<returns>scaled beta, the scaled backward probability matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.markovchain.SimpleMC">
			<summary>This is a time-homogeneous Markov chain with a finite state space. It is a mathematical system
 that undergoes transitions from one state to another, between a finite or countable number of
 possible states. It is a random process characterized as memoryless: the next state depends only
 on the current state and not on the sequence of events that preceded it. This specific kind of
 &quot;memorylessness&quot; is called the Markov property.<para> See also: </para><a href="http://en.wikipedia.org/wiki/markov_chain">Wikipedia: Markov chain</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.markovchain.SimpleMC.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs a time-homogeneous Markov chain with a finite state space.</summary>
			<param name="PI">the initial state probabilities</param>
			<param name="A">the state transition probabilities</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.markovchain.SimpleMC.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.markovchain.SimpleMC.nextDouble">
			<summary>Gets the next simulated state.</summary>
			<returns>next state</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.markovchain.SimpleMC.nextState">
			<summary>Gets the next simulated state.</summary>
			<returns>next state</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.markovchain.SimpleMC.PI">
			<summary>Gets the initial state probabilities.</summary>
			<returns>the initial state probabilities</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.markovchain.SimpleMC.A">
			<summary>Gets the state transition probabilities.</summary>
			<returns>the state transition probabilities</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.markovchain.SimpleMC.nStates">
			<summary>Gets the number of states.</summary>
			<returns>the number of states</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.markovchain.SimpleMC.getStationaryProbabilities(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Gets the stationary state probabilities of a Markov chain that is irreducible, aperiodic and
 strongly connected (positive recurrent). A stationary distribution vector <i>x</i> (if
 exists) satisfies
 \[
 x&apos; \times A = x&apos;
 \]
 where <i>x&apos;</i> denotes the transpose of <i>x</i>, and the sum of all elements of <i>x</i> is
 1.</summary>
			<param name="A">the transition matrix</param>
			<returns>the stationary state probabilities</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.markovchain.SimpleMC.bin(com.numericalmethod.suanshu.stats.random.multivariate.MultinomialRVG)">
			<summary>Picks the first non-empty bin.</summary>
			<param name="rvg">a <para></para>MultinomialRVG</param>
			<returns>the first non-empty bin</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.markovchain.MCUtils">
			<summary>These are the utility functions to examine a Markov chain.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.markovchain.MCUtils.getStateCounts(System.Int32[])">
			<summary>Count the numbers of occurrences of states.</summary>
			<param name="states">the Markov state labels, counting from 1</param>
			<returns>the numbers of occurrences</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.markovchain.MCUtils.getTransitionCounts(System.Int32[])">
			<summary>Count the numbers of times the state goes from one state to another.</summary>
			<param name="states">the Markov state labels, counting from 1</param>
			<returns>the counts of transitions</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.markovchain.MCUtils.getObservations(com.numericalmethod.suanshu.stats.hmm.HmmInnovation[],System.Int32)">
			<summary>Get all observations that occur in a particular state.</summary>
			<param name="innovations">the HMM innovations</param>
			<param name="state">a state</param>
			<returns>the observations in the state</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.pca.PCAbySVD">
			<summary>This class performs Principal Component Analysis (PCA) on a data matrix, using the preferred
 Singular Value Decomposition (SVD) method.
 <para/>
 PCA essentially rotates the set of points around their mean in order to align with the principal
 components. This moves as much of the variance as possible (using an orthogonal transformation)
 into the first few dimensions. The values in the remaining dimensions, therefore, tend to be
 small and may be dropped with minimal loss of information.
 <para/>
 The R equivalent function is <c>prcomp</c>.<para> See also: </para><list type="bullet">
 <item> K. V. Mardia, J. T. Kent and J. M. Bibby, &quot;Multivariate Analysis,&quot; London, Academic Press,
 1979.</item>
 <item> W. N. Venables and B. D. Ripley, &quot;Modern Applied Statistics with S,&quot; New York,
 Springer-Verlag, 2002.</item>
 <item> <a href="http://en.wikipedia.org/wiki/principal_component_analysis">Wikipedia: Principal
 component analysis</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbySVD.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Performs Principal Component Analysis, using the preferred SVD method, on a data matrix with
 (optional) mean vector and scaling vector provided.</summary>
			<param name="data">a matrix that represents the original data</param>
			<param name="mean">an optional mean vector (of length equal to <i>nFactors</i>) to be subtracted
              regardless of the flag <c>centered</c></param>
			<param name="scale">an optional scaling vector (of length equal to <i>nFactors</i>) to be divided
              regardless of the flag <c>scaled</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbySVD.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,System.Boolean)">
			<summary>Performs Principal Component Analysis, using the preferred SVD method, on a data matrix
 (possibly centered and/or scaled).</summary>
			<param name="data">a matrix that represents the original data</param>
			<param name="centered">a logical value indicating whether the variables should be shifted to be zero
                 centered</param>
			<param name="scaled">a logical value indicating whether the variables should be scaled to have
                 unit variance before the analysis takes place
                 (N.B. in general scaling is advisable; however, it should only be used if there is no
                 constant variable)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbySVD.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Performs Principal Component Analysis, using the preferred SVD method, on a centered and
 scaled data matrix.</summary>
			<param name="data">a matrix that represents the original data</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbySVD.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbySVD.scale">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbySVD.svd">
			<summary>Gets the Singular Value Decomposition (SVD) of matrix <i>X</i>.</summary>
			<returns>the Singular Value Decomposition (SVD) of matrix <i>X</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbySVD.sdPrincipalComponents">
			<summary>Gets the standard deviations of the principal components
 (i.e., the square roots of the eigenvalues of the correlation (or covariance) matrix,
 though the calculation is actually done with the singular values of the data matrix)</summary>
			<returns>the standard deviations of the principal components</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbySVD.loadings">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.pca.PCAbyEigen">
			<summary>This class performs Principal Component Analysis (PCA) on a data matrix, using eigen
 decomposition on the correlation or covariance matrix. Each eigenvalue is proportional to the
 portion of the &quot;variance&quot; (more correctly of the sum of the squared distances of the points from
 their multidimensional mean) that is correlated with each eigenvector. The sum of all the
 eigenvalues is equal to the sum of the squared distances of the points from their
 multidimensional mean.
 <para/>
 PCA essentially rotates the set of points around their mean in order to align with the principal
 components. This moves as much of the variance as possible (using an orthogonal transformation)
 into the first few dimensions. The values in the remaining dimensions, therefore, tend to be
 small and may be dropped with minimal loss of information.
 <para/>
 The R equivalent function is <c>princomp</c>. The main difference is that we use divisor
 <i>(nObs - 1)</i> instead of <i>nObs</i> for the sample covariance matrix.<para> See also: </para><list type="bullet">
 <item>K. V. Mardia, J. T. Kent and J. M. Bibby, &quot;Multivariate Analysis,&quot; London, Academic Press,
 1979.</item>
 <item>W. N. Venables and B. D. Ripley, &quot;Modern Applied Statistics with S,&quot; New York,
 Springer-Verlag, 2002.</item>
 <item><a href="http://en.wikipedia.org/wiki/principal_component_analysis">Wikipedia: Principal
 component analysis</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbyEigen.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Performs Principal Component Analysis, using the eigen method,
 on a data matrix with an optional correlation (or covariance) matrix provided.</summary>
			<param name="data">an <i>(nObs * nFactors)</i> numeric matrix that represents the original
                    data</param>
			<param name="correlation">a logical value indicating whether the correlation matrix (preferred) or
                    the covariance matrix should be used (N.B. the correlation matrix can only
                    be used if there is no constant variable)</param>
			<param name="V">an optional correlation (or covariance) matrix; if supplied, this is used
                    rather than the correlation (or covariance) matrix of the centered (and
                    possibly scaled) data</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbyEigen.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean)">
			<summary>Performs Principal Component Analysis, using the eigen method, on a data matrix.</summary>
			<param name="data">a matrix that represents the original data</param>
			<param name="correlation">a logical value indicating whether the correlation matrix (preferred) or
                    the covariance matrix should be used
                    (N.B. the correlation matrix can only be used if there is no constant variable)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbyEigen.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Performs Principal Component Analysis, using the eigen method and the user supplied
 correlation matrix,
 on a data matrix.</summary>
			<param name="data">matrix that represents the original data</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbyEigen.scale">
			<summary>Gets the scalings applied to each variable. If covariance matrix is used instead
 of the (preferred) correlation matrix, no scaling is performed.</summary>
			<returns>the scalings applied to each variable in the original data</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbyEigen.V">
			<summary>Gets the correlation (or covariance) matrix used by the PCA.</summary>
			<returns>the correlation (or covariance) matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbyEigen.eigen">
			<summary>Gets the eigenvalue decomposition of the correlation (or covariance) matrix.</summary>
			<returns>the eigenvalue decomposition of the correlation (or covariance) matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbyEigen.sdPrincipalComponents">
			<summary>Gets the standard deviations of the principal components (i.e., the square roots of the
 eigenvalues of the correlation (or covariance) matrix).</summary>
			<returns>the standard deviations of the principal components</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbyEigen.loadings">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbyEigen.loading(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCAbyEigen.proportionVar">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.pca.PCA">
			<summary>Principal Component Analysis (PCA) is a mathematical procedure that uses an orthogonal
 transformation to convert a set of observations of possibly correlated variables into a set of
 values of uncorrelated variables called principal components. The number of principal components
 is less than or equal to the number of original variables. This transformation is defined in such
 a way that the first principal component has as high a variance as possible (that is, accounts
 for as much of the variability in the data as possible), and each succeeding component in turn
 has the highest variance possible under the constraint that it be orthogonal to (uncorrelated
 with) the preceding components. Principal components are guaranteed to be independent only if the
 data set is jointly normally distributed.<para> See also: </para><list type="bullet">
 <item>K. V. Mardia, J. T. Kent and J. M. Bibby, &quot;Multivariate Analysis,&quot; London, Academic Press,
 1979.</item>
 <item>W. N. Venables and B. D. Ripley, &quot;Modern Applied Statistics with S,&quot; New York,
 Springer-Verlag, 2002.</item>
 <item><a href="http://en.wikipedia.org/wiki/principal_component_analysis">Wikipedia: Principal
 component analysis</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.nObs">
			<summary>Gets the number of observations in the original data; sample size.</summary>
			<returns><i>nObs</i>, the number of observations in the original data</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.nFactors">
			<summary>Gets the number of variables in the original data.</summary>
			<returns><i>nFactors</i>, the number of variables in the original data</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.mean">
			<summary>Gets the sample means that were subtracted.</summary>
			<returns>the sample means of each variable in the original data</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.scale">
			<summary>Gets the scalings applied to each variable.</summary>
			<returns>the scalings applied to each variable in the original data</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.X">
			<summary>Gets the (possibly centered and/or scaled) data matrix <i>X</i> used for the PCA.</summary>
			<returns>the (possibly centered and/or scaled) data matrix <i>X</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.sdPrincipalComponents">
			<summary>Gets the standard deviations of the principal components
 (i.e., the square roots of the eigenvalues of the correlation (or covariance) matrix).</summary>
			<returns>the standard deviations of the principal components</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.sdPrincipalComponent(System.Int32)">
			<summary>Gets the standard deviation of the <i>i</i>-th principal component.</summary>
			<param name="i">an index, counting from 1</param>
			<returns>the standard deviation of the <i>i</i>-th principal component.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.loadings">
			<summary>Gets the matrix of variable loadings.
 The signs of the columns of the loading are arbitrary.</summary>
			<returns>the matrix of variable loadings</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.loading(System.Int32)">
			<summary>Gets the loading vector of the <i>i</i>-th principal component.</summary>
			<param name="i">an index, counting from 1</param>
			<returns>the loading vector of the <i>i</i>-th principal component</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.proportionVar">
			<summary>Gets the proportion of overall variance explained by each of the principal components.</summary>
			<returns>the proportion of overall variance explained by each of the principal components</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.proportionVar(System.Int32)">
			<summary>Gets the proportion of overall variance explained by the <i>i</i>-th principal component.</summary>
			<param name="i">an index, counting from 1</param>
			<returns>the proportion of overall variance explained by the <i>i</i>-th principal component</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.cumulativeProportionVar">
			<summary>Gets the cumulative proportion of overall variance explained by the principal components</summary>
			<returns>the cumulative proportion of overall variance explained by the principal components</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.pca.PCA.scores">
			<summary>Gets the scores of supplied data on the principal components.
 The signs of the columns of the scores are arbitrary.</summary>
			<returns>the scores of supplied data on the principal components</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMPoisson">
			<summary>This is the Poisson distribution of the error distribution in GLM model.
 <para/>
 The R equivalent function is <c>poisson</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMPoisson.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMPoisson.variance(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMPoisson.theta(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMPoisson.cumulant(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMPoisson.deviance(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMPoisson.overdispersion(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMPoisson.dispersion(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMPoisson.AIC(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMInverseGaussian">
			<summary>This is the Inverse Gaussian distribution of the error distribution in GLM model.
 <para/>
 The R equivalent function is <c>inverse.gaussian</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMInverseGaussian.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMInverseGaussian.variance(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMInverseGaussian.theta(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMInverseGaussian.cumulant(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMInverseGaussian.deviance(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMInverseGaussian.overdispersion(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMInverseGaussian.dispersion(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMInverseGaussian.AIC(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGaussian">
			<summary>This is the Gaussian distribution of the error distribution in GLM model.
 <para/>
 The R equivalent function is <c>gaussian</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGaussian.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGaussian.variance(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGaussian.theta(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGaussian.cumulant(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGaussian.deviance(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGaussian.overdispersion(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGaussian.dispersion(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGaussian.AIC(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGamma">
			<summary>This is the Gamma distribution of the error distribution in GLM model.
 <para/>
 The R equivalent function is <c>Gamma</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGamma.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGamma.variance(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGamma.theta(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGamma.cumulant(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGamma.deviance(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGamma.overdispersion(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGamma.dispersion(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGamma.AIC(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMFamily">
			<summary><c>Family</c> provides a convenient way to specify the error distribution and link function used in GLM model.
 <para/>
 The R equivalent function is <c>family</c>.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;pp.32, Section 2.2.4, Measuring the goodness-of-fit,&quot; Generalized Linear Models. 2nd ed.&quot;</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMFamily.dist">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMExponentialDistribution,com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkFunction)">
			<summary>Construct an instance of <c>Family</c>.</summary>
			<param name="dist">the error distribution</param>
			<param name="link">the link function of this distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMBinomial)">
			<summary>Construct a Binomial family. The default link is <para></para>LinkLogit.</summary>
			<param name="binomial">a Binomial distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGamma)">
			<summary>Construct a Gamma family. The default link is <para></para>LinkInverse.</summary>
			<param name="gamma">a Gamma distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGaussian)">
			<summary>Construct a Gaussian family. The default link is <para></para>LinkIdentity.</summary>
			<param name="gaussian">a Gaussian distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMInverseGaussian)">
			<summary>Construct an Inverse Gaussian family. The default link is <para></para>LinkInverseSquared.</summary>
			<param name="inverseGaussian">an Inverse Gaussian distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMPoisson)">
			<summary>Construct a Poisson family. The default link is <para></para>LinkLog.</summary>
			<param name="poisson">a Poisson distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMFamily.link">
			<summary>Get the link function of this distribution.</summary>
			<returns>the link function of this distribution</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMFamily.distribution">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMExponentialDistribution">
			<summary>This interface represents a probability distribution from the exponential family.
 \[
 f_{Y}(y;\theta,\phi)=\exp[\frac{y * \theta - b(\theta)}{a(\phi)}+c(y,\phi)]
 \]
 where the parameter <i>&#952;</i> is called the canonical parameter,
 <i>b(&#952;)</i> the cumulant function, and <i>&#934;</i> the dispersion parameter.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;Chapter 2. Eq. 2.4. pp.28,&quot; <i>Generalized Linear Models,</i> 2nd ed.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMExponentialDistribution.variance(System.Double)">
			<summary>The variance function of the distribution in terms of the mean <i>&#956;</i>.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;Chapter 2, Table 2.1, pp.30,&quot; <i>Generalized Linear Models,</i> 2nd ed.&quot;</summary>
			<param name="mu">the distribution mean, <i>&#956;</i></param>
			<returns>the value of variance function at <i>&#956;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMExponentialDistribution.theta(System.Double)">
			<summary>The canonical parameter of the distribution in terms of the mean <i>&#956;</i>.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;Chapter 2, Table 2.1, pp.30,&quot; <i>Generalized Linear Models,</i> 2nd ed.&quot;</summary>
			<param name="mu">the distribution mean, <i>&#956;</i></param>
			<returns>the value of canonical parameter <i>&#952;</i> at <i>&#956;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMExponentialDistribution.cumulant(System.Double)">
			<summary>The cumulant function of the exponential distribution.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;Chapter 2, Table 2.1, pp.30,&quot; <i>Generalized Linear Models,</i> 2nd ed.&quot;</summary>
			<param name="theta"><i>&#952;</i></param>
			<returns>the value of the cumulant function at <i>&#952;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMExponentialDistribution.dispersion(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary>Different distribution models have different ways to compute dispersion, <i>&#934;</i>.
 <para/>
 Note that in R&apos;s output, this is called &quot;over-dispersion&quot;.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;Section 2.2.2, Table 2.1,&quot; <i>Generalized Linear Models,</i> 2nd ed.&quot;</summary>
			<param name="y">an observation</param>
			<param name="mu">the distribution mean, <i>&#956;</i></param>
			<param name="nFactors">the number of factors</param>
			<returns>the dispersion</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMExponentialDistribution.overdispersion(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary>Over-dispersion is the presence of greater variability (statistical dispersion)
 in a data set than would be expected based on the nominal variance of a given simple statistical model.
 <blockquote><code><i>
 &#963;^2 = X^2/(n-p), eq. 4.23
 X^2 = sum{(y-&#956;)^2}/V(&#956;), p.34
 = sum{(y-&#956;)^2}/b&apos;&apos;(&#952;), p.29
 </i></code></blockquote>
 <i>X^2</i> estimates <i>a(&#934;) = &#934;</i>, the dispersion parameter (assuming <i>w = 1</i>).
 <para/>
 For,
 <para></para>com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGamma,
 <para></para>com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMGaussian,
 <para></para>com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMInverseGaussian,
 over-dispersion is the same as dispersion.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;Section 4.5, Equation 4.23,&quot; <i>Generalized Linear Models,</i> 2nd ed.&quot;</summary>
			<param name="y">an observation</param>
			<param name="mu">the distribution mean, <i>&#956;</i></param>
			<param name="nFactors">the number of factors</param>
			<returns>the dispersion</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMExponentialDistribution.deviance(System.Double,System.Double)">
			<summary>Deviance <i>D(y;&#956;^)</i> measures the goodness-of-fit of a model, which is defined as
 the difference between the maximum log likelihood achievable and that achieved by the model.
 <blockquote><i>
 D(y;&#956;^) = 2 * [l(y;y) - l(&#956;^;y)]
 </i></blockquote>
 where <i>l</i> is the log-likelihood.
 <para/>
 For an exponential family distribution, this is equivalent to
 <blockquote><i>
 2 * [(y * &#952;(y) - b(&#952;(y))) - (y * &#952;(&#956;^) - b(&#952;(&#956;^)]
 </i></blockquote>
 where <i>b</i> is the cumulant function of the distribution.<para> See also: </para><list type="bullet">
 <item>P. J. MacCullagh and J. A. Nelder, &quot;Section 2.3, pp.34, Measuring the goodness-of-fit,&quot; <i>Generalized Linear Models,</i> 2nd ed.</item>
 <item><a href="http://en.wikipedia.org/wiki/deviance_%28statistics%29">Wikipedia: Deviance</a></item>
 </list></summary>
			<param name="y">an observation</param>
			<param name="mu">the <em>estimated</em> mean, &#956;^</param>
			<returns>the deviance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMExponentialDistribution.AIC(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Int32)">
			<summary><i>AIC = 2 * #param - 2 * log-likelihood</i></summary>
			<param name="y">an observation</param>
			<param name="mu">the distribution mean, <i>&#956;</i></param>
			<param name="weight">the weights assigned to the observations</param>
			<param name="preLogLike">sum of <i>(y<sub>i</sub> * &#952;<sub>i</sub> - b(&#952;<sub>i</sub>))</i></param>
			<param name="deviance">the deviance</param>
			<param name="nFactors">the number of factors</param>
			<returns>the AIC the Akaike information criterion</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMBinomial">
			<summary>This is the Binomial distribution of the error distribution in GLM model.
 <para/>
 The R equivalent function is <c>binomial</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMBinomial.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMBinomial.variance(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMBinomial.theta(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMBinomial.cumulant(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMBinomial.deviance(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMBinomial.overdispersion(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMBinomial.dispersion(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMBinomial.AIC(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Double,System.Double,System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkSqrt">
			<summary>This class represents the square-root link function:
 <blockquote><i>
 g(x) = sqrt(x)
 </i></blockquote><para> See also: </para>GeneralizedLinearModel</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkSqrt.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkSqrt.inverse(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkSqrt.derivative(System.Double)">
			<summary>

 \[
 g&apos;(x) = \frac{1}{2\sqrt{x}}
 \]</summary>
			<param name="x"><i>x</i></param>
			<returns><i>g&apos;(x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkProbit">
			<summary>This class represents the Probit link function,
 which is the inverse of cumulative distribution function of the standard Normal distribution <i>N(0, 1)</i>.<para> See also: </para>GeneralizedLinearModel</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkProbit.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkProbit.inverse(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkProbit.derivative(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkLogit">
			<summary>This class represents the logit link function:
 \[
 g(x) = \log(\frac{\mu}{1-\mu})
 \]<para> See also: </para>GeneralizedLinearModel</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkLogit.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkLogit.inverse(System.Double)">
			<summary>

 \[
 g^{-1}(x) = \frac{\exp(x)}{1+\exp(x)}
 \]</summary>
			<param name="x"><i>x</i></param>
			<returns>g<sup>-1</sup>(x)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkLogit.derivative(System.Double)">
			<summary>

 \[
 g&apos;(x) = \frac{1}{x(1-x)}
 \]</summary>
			<param name="x"><i>x</i></param>
			<returns><i>g&apos;(x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkLog">
			<summary>This class represents the log link function:
 <blockquote><i>
 g(x) = log(x)
 </i></blockquote><para> See also: </para>GeneralizedLinearModel</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkLog.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkLog.inverse(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkLog.derivative(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkInverseSquared">
			<summary>This class represents the inverse-squared link function:
 <blockquote><i>
 g(x) = 1/x<sup>2</sup>
 </i></blockquote><para> See also: </para>GeneralizedLinearModel</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkInverseSquared.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkInverseSquared.inverse(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkInverseSquared.derivative(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkInverse">
			<summary>This class represents the inverse link function:
 <blockquote><i>
 g(x) = 1/x
 </i></blockquote><para> See also: </para>GeneralizedLinearModel</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkInverse.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkInverse.inverse(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkInverse.derivative(System.Double)">
			<summary>

 \[
 g&apos;(x) = -\frac{1}{x^2}
 \]</summary>
			<param name="x"><i>x</i></param>
			<returns><i>g&apos;(x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkIdentity">
			<summary>This class represents the identity link function:
 <blockquote><i>
 g(x) = x
 </i></blockquote><para> See also: </para>GeneralizedLinearModel</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkIdentity.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkIdentity.inverse(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkIdentity.derivative(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkFunction">
			<summary>This interface represents a link function <i>g(x)</i> in Generalized Linear Model (GLM).
 <para/>
 The R equivalent function is <c>make.link</c>.<para> See also: </para>GeneralizedLinearModel</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkFunction.inverse(System.Double)">
			<summary>Inverse of the link function, i.e., <i>g<sup>-1</sup>(x)</i>.</summary>
			<param name="x"><i>x</i></param>
			<returns><i>g<sup>-1</sup>(x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkFunction.derivative(System.Double)">
			<summary>Derivative of the link function, i.e., <i>g&apos;(x)</i>.</summary>
			<param name="x"><i>x</i></param>
			<returns><i>g&apos;(x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkCloglog">
			<summary>This class represents the complementary log-log link function:
 <blockquote><i>
 g(x) = log(-log(1 - x))
 </i></blockquote><para> See also: </para>GeneralizedLinearModel</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkCloglog.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkCloglog.inverse(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkCloglog.derivative(System.Double)">
			<summary>

 \[
 g&apos;(x) = \frac{1}{\log(1-x)\log(x-1)}
 \]</summary>
			<param name="x"><i>x</i></param>
			<returns><i>g&apos;(x)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.IWLS">
			<summary>This implementation estimates parameters <i>&#946;</i> in a GLM model using the Iteratively Re-weighted Least Squares algorithm.
 The idea is that, at each iteration, we regress the adjusted, weighted, dependent variables on the same design matrix.
 <para/>
 The R equivalent function is <c>glm.fit</c>.<para> See also: </para><list type="bullet">
 <item>&quot;P. J. MacCullagh and J. A. Nelder, &quot;An algorithm for fitting generalized linear models,&quot; Generalized Linear Models. 2nd ed. pp.40. Section 2.5.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/generalized_linear_model#maximum_likelihood">Wikipedia: Maximum likelihood</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.IWLS.#ctor(System.Double,System.Int32)">
			<summary>Construct an instance to run the Iteratively Re-weighted Least Squares algorithm.</summary>
			<param name="threshold">the convergence threshold</param>
			<param name="maxIterations">maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.IWLS.fit(com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.IWLS.mu">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.IWLS.betaHat">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.IWLS.weights">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.IWLS.logLikelihood">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMResiduals">
			<summary>Residual analysis of the results of a Generalized Linear Model regression.
 <para/>
 Over-dispersion occurs when the observed variance of the data is larger than the predicted
 variance.
 <para/>
 Deviance measures the goodness-of-fit of a model</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMResiduals.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Performs residual analysis for a GLM regression.</summary>
			<param name="problem">the GLM problem to be solved</param>
			<param name="fitted">the fitted values</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMResiduals.overdispersion">
			<summary>Gets the over-dispersion.</summary>
			<returns>the over-dispersion</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMResiduals.deviances">
			<summary>Gets the deviances of the observations.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;An algorithm for fitting generalized linear
 models,&quot; in <i>Generalized Linear Models,</i> 2nd ed. pp.34.&quot;</summary>
			<returns>the deviances</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMResiduals.deviance">
			<summary>Gets the (total) deviance.</summary>
			<returns>the (total) deviance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMResiduals.devianceResiduals">
			<summary>Gets the deviances residuals.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;An algorithm for fitting generalized linear
 models,&quot; in <i>Generalized Linear Models,</i> 2nd ed. pp.39.&quot;</summary>
			<returns>the deviances residuals</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem">
			<summary>This is a Generalized Linear regression problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMFamily)">
			<summary>Construct a GLM problem.</summary>
			<param name="y">the dependent variables</param>
			<param name="X">the factors</param>
			<param name="intercept"><c>true</c> if to add an additional intercept term to the linear regression</param>
			<param name="family">the exponential family distribution of the mean</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem.#ctor(com.numericalmethod.suanshu.stats.regression.linear.LMProblem,com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.GLMFamily)">
			<summary>Construct a GLM problem from a linear regression problem.</summary>
			<param name="problem">a linear regression problem</param>
			<param name="family">the exponential family distribution of the mean</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem.getFamily">
			<summary>Get the exponential family distribution of the mean.</summary>
			<returns>the exponential family distribution of the mean</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMFitting">
			<summary>This interface represents a fitting method for estimating <i>&#946;</i> in a Generalized Linear
 Model (GLM).
 <para/>
 John Nelder and Robert Wedderburn proposed an iteratively re-weighted least squares method for
 maximum likelihood estimation of the model parameters, <i>&#946;</i>. Maximum-likelihood
 estimation remains popular and is the default method on many statistical computing packages.
 Other approaches, including Bayesian approaches and least squares fits to variance stabilized
 responses, have been developed.<para> See also: </para><a href="http://en.wikipedia.org/wiki/generalized_linear_model">Wikipedia: Generalized
 linear model</a><para> See also: </para>IWLS</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMFitting.fit(com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Fits a Generalized Linear Model.
 <para/>
 This method must be called before the three get methods.</summary>
			<param name="problem">the generalized linear regression problem to be solved</param>
			<param name="beta0Initial">initial guess for <i>&#946;^</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMFitting.mu">
			<summary>Gets <i>&#956;</i> as in
 <blockquote><i>
 E(Y) = &#956; = g<sup>-1</sup>(X&#946;)
 </i></blockquote></summary>
			<returns><i>&#956;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMFitting.betaHat">
			<summary>Gets the estimates of <i>&#946;</i>, &#946;^, as in
 <blockquote><i>
 E(Y) = &#956; = g<sup>-1</sup>(X&#946;)
 </i></blockquote></summary>
			<returns><i>&#946;^</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMFitting.weights">
			<summary>Gets the weights assigned to the observations.</summary>
			<returns>the weights</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMFitting.logLikelihood">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMBeta">
			<summary>This is the estimate of beta, <i>&#946;^</i>, in a Generalized Linear Model.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMBeta.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.GLMFitting,com.numericalmethod.suanshu.stats.regression.linear.glm.GLMResiduals)">
			<summary>Construct an instance of <c>Beta</c>.</summary>
			<param name="fitting">the fitting results of a GLM</param>
			<param name="residuals">the residual analysis of a GLM</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GLMBeta.covariance">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.GeneralizedLinearModel">
			<summary>The Generalized Linear Model (GLM) is a flexible generalization of the Ordinary Least Squares
 regression. GLM generalizes linear regression by allowing the linear model to be related to the
 response variable via a link function and by allowing the magnitude of the variance of each
 measurement to be a function of its predicted value. In GLM, each outcome of the dependent
 variables, <i>Y</i>, is assumed to be generated from a particular distribution in the exponential
 family, a large range of probability distributions that includes the normal, binomial and Poisson
 distributions, among others. The mean, <i>&#956;</i>, of the distribution depends on the
 independent variables, <i>X</i>, through
 <blockquote><i>
 E(Y) = &#956; = g<sup>-1</sup>(X&#946;)
 </i></blockquote>
 where <i>E(Y)</i> is the expected value of <i>Y</i>;
 <i>X&#946;</i> is the linear predictor, a linear combination of unknown parameters,
 <i>&#946;</i>;
 <i>g</i> is the link function.
 <para/>
 The R equivalent function is <c>glm</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/generalized_linear_model">Wikipedia: Generalized linear
 model</a></item>
 <item>&quot;P. J. MacCullagh and J. A. Nelder. An algorithm for fitting generalized linear models,&quot; in
 <i>Generalized Linear Models</i>, 2nd ed. pp.40. Section 2.5.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GeneralizedLinearModel.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem,com.numericalmethod.suanshu.stats.regression.linear.glm.GLMFitting)">
			<summary>Constructs a <c>GeneralizedLinearModel</c> instance.</summary>
			<param name="problem">the generalized linear regression problem to be solved</param>
			<param name="fitting">the fitting method, c.f., <para></para>GLMFitting</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GeneralizedLinearModel.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem)">
			<summary>Solves a generalized linear problem using the Iterative Re-weighted Least Squares algorithm.<para> See also: </para>IWLS</summary>
			<param name="problem">the generalized linear regression problem to be solved</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GeneralizedLinearModel.Ey(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GeneralizedLinearModel.beta">
			<summary>Gets the GLM coefficients estimator, <i>&#946;^</i>.</summary>
			<returns>the GLM coefficients estimator, <i>&#946;^</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GeneralizedLinearModel.residuals">
			<summary>Gets the residual analysis of this GLM regression.</summary>
			<returns>the residual analysis of this GLM regression</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.GeneralizedLinearModel.AIC">
			<summary>Gets the Akaike information criterion (AIC).</summary>
			<returns>the Akaike information criterion (AIC)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection">
			<summary>Given a set of observations {y, X}, we would like to construct a GLM to explain the data. One way
 to do it is to examine each factor (a column in X) one by one, and include in the model the
 significant ones, i.e., those with z-value bigger than some critical value.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection.problem">
			<summary>the GLM problem to be solved</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection.criticalValue">
			<summary>A factor is considered significant if its z-value is bigger than some
 critical value.</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection.flags">
			<summary>indicate whether a factor/variable/regressor is selected in the model</summary>
		</member>
		<member name="F:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection.subset">
			<summary>the subset of factors/variables/regressors selected</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem,System.Double)">
			<summary>Construct automatically a GLM model to explain the observations.</summary>
			<param name="problem">a GLM problem</param>
			<param name="significance">a significance value to determine whether a factor is significant enough
                     (to be included in the model)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection.getModel">
			<summary>Get the constructed model.</summary>
			<returns>a GLM model</returns>
			<exception cref="T:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection.ModelNotFound">if no factor is selected</exception>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection.getFlags">
			<summary>Get the factor flags. A positive value indicates that the factor is selected; 0 otherwise.</summary>
			<returns>factor flags</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection.isSelected(System.Int32)">
			<summary>Check whether a particular index is selected in the model.
 <para/>
 The indices count from 1.</summary>
			<param name="factorIndex">the index to a factor</param>
			<returns><c>true</c> if the particular index is selected in the model</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection.subA">
			<summary>Construct a covariates subset.</summary>
			<returns>the columns corresponding to the selected variables</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection.ModelNotFound">
			<summary>Throw a <c>ModelNotFound</c> exception when fail to construct a model to
 explain the data.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.SingleFactorSelection.ModelNotFound.#ctor(System.String)">
			<summary>Construct a <c>ModelNotFound</c> exception with an error message.</summary>
			<param name="msg">the error message</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.ForwardSelection">
			<summary>To construct a GLM for a set of observations using the forward selection method,
 we iteratively add a significant factor to the model, one at a time.
 This repeats until all remaining factors are insignificant.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.ForwardSelection.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem,System.Double)">
			<summary>Construct a GLM model using the forward selection method.</summary>
			<param name="problem">a GLM problem</param>
			<param name="significance">a significance value to determine whether a factor is significant enough
                     (to be included in the model)</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.BackwardElimination">
			<summary>To construct a GLM for a set of observations using the backward elimination method,
 we first assume that all factors are included in the model.
 Iteratively, we drop/eliminate the least significant factor until all remaining factors are
 significant.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.modelselection.BackwardElimination.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem,System.Double)">
			<summary>Construct a GLM model using the backward elimination method.</summary>
			<param name="problem">a GLM problem</param>
			<param name="significance">a significance value to determine whether a factor is significant enough
                     (to be included in the model)</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiPoisson">
			<summary>This is the quasi Poisson distribution in GLM.
 <para/>
 The R equivalent function is <c>quasipoisson</c>.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;pp.32, Section 2.2.4, Measuring the goodness-of-fit,&quot; Generalized Linear Models. 2nd ed.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiPoisson.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiPoisson.quasiLikelihood(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiPoisson.quasiDeviance(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiInverseGaussian">
			<summary>This is the quasi Inverse-Gaussian distribution in GLM.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;pp.32, Section 2.2.4, Measuring the goodness-of-fit,&quot; Generalized Linear Models. 2nd ed.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiInverseGaussian.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiInverseGaussian.quasiLikelihood(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiInverseGaussian.quasiDeviance(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiGaussian">
			<summary>This is the quasi Gaussian distribution in GLM.
 <para/>
 The R equivalent function is <c>quasi</c>.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;pp.32, Section 2.2.4, Measuring the goodness-of-fit,&quot; Generalized Linear Models. 2nd ed.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiGaussian.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiGaussian.quasiLikelihood(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiGaussian.quasiDeviance(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiGamma">
			<summary>This is the quasi Gamma distribution in GLM.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;pp.32, Section 2.2.4, Measuring the goodness-of-fit,&quot; Generalized Linear Models. 2nd ed.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiGamma.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiGamma.quasiLikelihood(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiGamma.quasiDeviance(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiFamily">
			<summary>This interface represents the quasi-family used in GLM.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiDistribution,com.numericalmethod.suanshu.stats.regression.linear.glm.distribution.link.LinkFunction)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiBinomial)">
			<summary>Construct a Binomial quasi-family.</summary>
			<param name="binomial">a Binomial distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiGamma)">
			<summary>Construct a Gamma quasi-family.</summary>
			<param name="gamma">a Gamma distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiGaussian)">
			<summary>Construct a Gaussian quasi-family.</summary>
			<param name="gaussian">a Gaussian distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiInverseGaussian)">
			<summary>Construct an Inverse Gaussian quasi-family.</summary>
			<param name="inverseGaussian">an Inverse Gaussian distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiPoisson)">
			<summary>Construct a Poisson quasi-family.</summary>
			<param name="poisson">a Poisson distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiFamily.distribution">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiDistribution">
			<summary>This interface represents the quasi-distribution used in GLM.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiDistribution.quasiLikelihood(System.Double,System.Double)">
			<summary>the quasi-likelihood function corresponding to a single observation <i>Q(&#956;; y)</i><para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, <i>Generalized Linear Models,</i> 2nd ed. Chapter 9. Table 9.1. p.326.&quot;</summary>
			<param name="mu"><i>&#956;</i></param>
			<param name="y"><i>y</i></param>
			<returns><i>Q(&#956;; y)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiDistribution.quasiDeviance(System.Double,System.Double)">
			<summary>the quasi-deviance function corresponding to a single observation<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, <i>Generalized Linear Models,</i> 2nd ed. Chapter 9. Eq. 9.4., the integral form, p.327.&quot;</summary>
			<param name="y"><i>y</i></param>
			<param name="mu"><i>&#956;</i></param>
			<returns><i>D(y; &#956;;)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiBinomial">
			<summary>This is the quasi Binomial distribution in GLM.
 <para/>
 The R equivalent function is <c>quasibinomial</c>.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;pp.32, Section 2.2.4, Measuring the goodness-of-fit,&quot; Generalized Linear Models. 2nd ed.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiBinomial.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiBinomial.quasiLikelihood(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiBinomial.quasiDeviance(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMResiduals">
			<summary>Residual analysis of the results of a quasi Generalized Linear Model regression.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMResiduals.overdispersion">
			<summary>Computes the over-dispersion.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;Section 4.5, Equation 4.23,&quot; <i>Generalized Linear
 Models</i>, 2nd ed.&quot;</summary>
			<returns>the over-dispersion</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMResiduals.deviances">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMProblem">
			<summary>This class represents a quasi generalized linear regression problem.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiFamily)">
			<summary>Constructs a quasi GLM problem.</summary>
			<param name="y">the dependent variables</param>
			<param name="X">the factors</param>
			<param name="intercept"><c>true</c> if to add an additional intercept term to the regression</param>
			<param name="quasiFamily">the exponential family distribution for the mean with a quasi-likelihood
                    function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMProblem.#ctor(com.numericalmethod.suanshu.stats.regression.linear.LMProblem,com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.family.QuasiFamily)">
			<summary>Constructs a quasi GLM problem from a linear regression problem.</summary>
			<param name="problem">a linear regression problem</param>
			<param name="quasiFamily">the exponential family distribution for the mean with a quasi-likelihood
                    function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMProblem.family">
			<summary>Gets the quasi-family specification.</summary>
			<returns>the quasi-family specification</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMNewtonRaphson">
			<summary>The Newton-Raphson method is an iterative algorithm to estimate the <i>&#946;</i> of the quasi
 GLM regression. It is a maximum likelihood method.<para> See also: </para><list type="bullet">
 <item>&quot;P. J. MacCullagh and J. A. Nelder, &quot;pp.327, An algorithm for fitting generalized linear
 models,&quot; in <i>Generalized Linear Models</i>, 2nd ed.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/generalized_linear_model#fitting">Wikipedia:
 Fitting</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMNewtonRaphson.#ctor(System.Double,System.Int32)">
			<summary>Constructs an instance to run the Newton-Raphson method.</summary>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMNewtonRaphson.fit(com.numericalmethod.suanshu.stats.regression.linear.glm.GLMProblem,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMNewtonRaphson.mu">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMNewtonRaphson.betaHat">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMNewtonRaphson.logLikelihood">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMNewtonRaphson.weights">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMNewtonRaphson.D">
			<summary>Computes <i>D</i>.

 <blockquote><i>
 D = d(&#956;)/d(&#946;) = (d&#956;/d&#951;) * (d&#951;/d&#946;)
 </i></blockquote></summary>
			<returns><i>D</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMNewtonRaphson.DVInv">
			<summary>Computes <i>D / V(&#956;)</i>.</summary>
			<returns><i>D / V(&#956;)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMBeta">
			<summary>This is the estimate of beta, <i>&#946;^</i>, in a quasi Generalized Linear Model,
 i.e., a GLM with a quasi-family of distributions.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMBeta.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMNewtonRaphson,com.numericalmethod.suanshu.stats.regression.linear.glm.GLMResiduals)">
			<summary>Construct an instance of <c>Beta</c>.</summary>
			<param name="fitting">the fitting results of a quasi-GLM</param>
			<param name="residuals">the residual analysis of a quasi-GLM</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMBeta.covariance">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.GeneralizedLinearModelQuasiFamily">
			<summary>GLM for the quasi-families. In order to construct a likelihood function it is usually necessary
 to posit a probabilistic mechanism specifying, for a range of parameter values, the probabilities
 of all relevant samples that might possibly have been observed. Such a specification implies the
 knowledge of the mechanism by which the data were generated or substantial experience of similar
 data from previous experiments. Often, this knowledge is not available. We may, however, be able
 to specify the range of possible response values and past experience with similar data is usually
 sufficient to specify, in a qualitative fashion, a few additional characteristic features of the
 data. From these characteristics, we may construct a quasi-likelihood function.
 <para/>
 Note that AIC is not computed for the quasi-GLM because there is no &apos;real&apos; likelihood function.<para> See also: </para>&quot;P. J. MacCullagh and J. A. Nelder, &quot;Chapter 9, An algorithm for fitting generalized linear
 models,&quot; in <i>Generalized Linear Models</i>, 2nd ed.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.GeneralizedLinearModelQuasiFamily.#ctor(com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.QuasiGLMProblem)">
			<summary>Constructs a <c>GeneralizedLinearModelQuasiFamily</c> instance.</summary>
			<param name="problem">the quasi generalized linear regression problem to be solved</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.GeneralizedLinearModelQuasiFamily.Ey(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.GeneralizedLinearModelQuasiFamily.beta">
			<summary>Gets the GLM coefficient estimator, <i>&#946;^</i>.</summary>
			<returns>the GLM coefficient estimator, <i>&#946;^</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.glm.quasi.GeneralizedLinearModelQuasiFamily.residuals">
			<summary>Gets the residual analysis.</summary>
			<returns>the residual analysis</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.lasso.UnconstrainedLASSOProblem">
			<summary>A LASSO (least absolute shrinkage and selection operator) problem focuses on solving an RSS
 (residual sum of squared errors) problem with L1 regularization. The unconstrained form
 (Lagrangian form) solves
 \[
 \min_w \left \{ 0.5 * \left \| Xw - y \right \|_2^2 + \lambda * \left \| w \right \|_1 \right \}
 \]<para> See also: </para><list type="bullet">
 <item>R. Tibshirani, &quot;Regression shrinkage and selection via the LASSO,&quot; Journal of the Royal
 Statistical Society, Series B, Volume: 58, Issue: 1, 267 - 288, 1996.</item>
 <item><a href="http://en.wikipedia.org/wiki/lasso_(statistics)#lasso_method"> Wikipedia: LASSO
 method</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.UnconstrainedLASSOProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Constructs a LASSO problem.</summary>
			<param name="y">the vector of response variable <i>(n * 1)</i>, properly demeaned and scaled</param>
			<param name="X">the design matrix of factors <i>(n * m)</i>, properly demeaned and scaled</param>
			<param name="lambda">the penalization parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.UnconstrainedLASSOProblem.#ctor(com.numericalmethod.suanshu.stats.regression.linear.lasso.UnconstrainedLASSOProblem)">
			<summary>Copy constructor.</summary>
			<param name="that">another <c>LASSOProblem</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.UnconstrainedLASSOProblem.lambda">
			<summary>Gets the penalization parameter for the unconstrained form of LASSO.</summary>
			<returns>lambda, the penalization parameter for the unconstrained form of LASSO</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.lasso.UnconstrainedLASSObyQP">
			<summary>This class solves the unconstrained form of LASSO
 (i.e. \( \min_w \left \{ \left \| Xw - y \right \|_2^2 + \lambda * \left \| w \right \|_1 \right
 \} \))
 by transforming it into a single quadratic programming problem with <i>(2 * m)</i> constraints,
 where m is the number of columns of the design matrix.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.UnconstrainedLASSObyQP.#ctor(com.numericalmethod.suanshu.stats.regression.linear.lasso.UnconstrainedLASSOProblem)">
			<summary>Solves an unconstrained LASSO problem by transforming it into a single quadratic programming
 problem.</summary>
			<param name="problem">an unconstrained LASSO problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.UnconstrainedLASSObyQP.Ey(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.UnconstrainedLASSObyQP.beta">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.UnconstrainedLASSObyQP.residuals">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSOProblem">
			<summary>A LASSO (least absolute shrinkage and selection operator) problem focuses on solving an RSS
 (residual sum of squared errors) problem with L1 regularization. The constrained form solves
 \[
 \min_w (\left \| Xw - y \right \|_2^2), \left \| w \right \|_1 \leq t
 \]<para> See also: </para><list type="bullet">
 <item>R. Tibshirani, &quot;Regression shrinkage and selection via the LASSO,&quot; Journal of the Royal
 Statistical Society, Series B, Volume: 58, Issue: 1, 267 - 288, 1996.</item>
 <item><a href="http://en.wikipedia.org/wiki/lasso_(statistics)#lasso_method"> Wikipedia: LASSO
 method</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSOProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Double)">
			<summary>Constructs a LASSO problem in the constrained form.</summary>
			<param name="y">the vector of response variable <i>(n * 1)</i>, properly demeaned and scaled</param>
			<param name="X">the design matrix of factors <i>(n * m)</i>, properly demeaned and scaled</param>
			<param name="t">the penalization parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSOProblem.#ctor(com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSOProblem)">
			<summary>Copy constructor.</summary>
			<param name="that">another <c>LASSOProblem</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSOProblem.t">
			<summary>Get the penalization parameter for the constrained form of LASSO.</summary>
			<returns>t, the penalization parameter for the constrained form of LASSO</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSObyQP">
			<summary>This class solves the constrained form of LASSO (i.e.\(\min_w \left \{ \left \| Xw - y \right
 \|_2^2 \right \}\)
 subject to \( \left \| w \right \|_1 \leq t \)) by transforming it into a single quadratic
 programming problem with <i>(2 * m + 1)</i> constraints, where <i>m</i> is the number of
 columns of the design matrix.
 \[
 $$\min_w ||Xw - y||_2^2, \mbox{ s.t. } \sum{|w|} \leq t\\

 \equiv \min_w \frac{1}{2} ||Xw - y||_2^2, \mbox{ s.t. } \sum{|w|} \leq t\\

 \equiv \min_{\beta} \frac{1}{2} ||X(\beta^{+} - \beta^{-}) - y||_2^2, \mbox{ s.t. } \sum{\beta}
 \leq t, \mbox{ where } \beta = \begin{bmatrix} {\beta^{+}}\\ {\beta^{-}} \end{bmatrix}, w =
 \beta^{+} - \beta^{-}\\

 \equiv \min_{\beta} \left \{ \frac{1}{2} \beta^T \begin{bmatrix} X^T X &amp; -X^T X \\ -X^T X &amp; X^T X
 \end{bmatrix} \beta - \begin{bmatrix} X^T y \\ -X^T y \end{bmatrix} \beta \right \}, \mbox{ s.t.
 } \beta_i \geq 0 \mbox{ and } \sum{-\beta} \geq -t\\

 \equiv \min_{\beta} \left \{ \frac{1}{2} \beta^T M \beta + c^T \beta \right \}, \mbox{ s.t. }
 \beta_i \geq 0 \mbox{ and } \sum{-\beta} \geq -t,
 \mbox{where } M = \begin{bmatrix}X \\-X \end{bmatrix} \begin{bmatrix}X &amp; -X \end{bmatrix} \mbox{
 and } c = - \begin{bmatrix}X^T y \\-X^T y \end{bmatrix}\\$$
 \]<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/lasso_(statistics)#lasso_method"> Wikipedia: LASSO
 method</a></item>
 <item>Kukreja, S. L., Löfberg, J, Brenner, M. J., A LEAST ABSOLUTE SHRINKAGE AND SELECTION OPERATOR
 (LASSO) FOR NONLINEAR SYSTEM IDENTIFICATION, 2006.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSObyQP.#ctor(com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSOProblem)">
			<summary>Solves a constrained LASSO problem by transforming it into a single quadratic programming
 problem.</summary>
			<param name="problem">a constrained LASSO problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSObyQP.Ey(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSObyQP.beta">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSObyQP.residuals">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSObyLARS">
			<summary>This class solves the constrained form of LASSO by modified least angle regression (LARS) and
 linear interpolation:
 \[
 \min_w \left \{ \left \| Xw - y \right \|_2^2 \right \}\) subject to \( \left \| w \right \|_1
 \leq t
 \]<para> See also: </para><list type="bullet">
 <item>B. Efron et. al, &quot;Least Angle Regression,&quot; The Annals of Statistics, Volume: 32(2),
 407 - 499, 2004.</item>
 <item>T. Hastie, R. Tibshirani and J. Friedman, &quot;The Elements of Statistical Learning: Data Mining,
 Inference, and Prediction (Second Edition),&quot; New York, Springer-Verlag, 2009.</item>
 <item><a href="http://en.wikipedia.org/wiki/lasso_(statistics)#lasso_method"> Wikipedia: LASSO
 method</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSObyLARS.#ctor(com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSOProblem,System.Boolean,System.Boolean,System.Double,System.Int32)">
			<summary>Solves a constrained LASSO problem by modified least angle regression (LARS) and linear
 interpolation.</summary>
			<param name="problem">a constrained LASSO problem</param>
			<param name="demeaned">an indicator of whether an intercept is included in the model</param>
			<param name="normalized">an indicator of whether the predictors are first normalized to have unit
                      L2 norm</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSObyLARS.#ctor(com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSOProblem)">
			<summary>Solves a constrained LASSO problem by modified least angle regression (LARS) and linear
 interpolation.</summary>
			<param name="problem">a constrained LASSO problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSObyLARS.Ey(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSObyLARS.beta">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.ConstrainedLASSObyLARS.residuals">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem">
			<summary>Least Angle Regression (LARS) is a regression algorithm for high-dimensional data. Suppose we
 expect a response variable to be determined by a linear combination of a subset of potential
 covariates. Then the LARS algorithm provides a means of producing an estimate of which variables
 to include, as well as their coefficients. The algorithm is similar to forward stepwise
 regression, but instead of including variables at each step, the estimated parameters are
 increased in a direction equiangular to each one&apos;s correlations with the residual.<para> See also: </para><list type="bullet">
 <item>B. Efron et. al, &quot;Least Angle Regression,&quot; The Annals of Statistics, Volume: 32(2), 407 -
 499, 2004.</item>
 <item>T. Hastie, R. Tibshirani and J. Friedman, &quot;The Elements of Statistical Learning: Data Mining,
 Inference, and Prediction (Second Edition),&quot; New York, Springer-Verlag, 2009.</item>
 <item><a href="http://en.wikipedia.org/wiki/least-angle_regression">Wikipedia: Least angle
 regression</a></item> </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,System.Boolean,System.Boolean)">
			<summary>Constructs a Least Angel Regression (LARS) problem.</summary>
			<param name="y">the vector of response variable <i>(n * 1)</i></param>
			<param name="X">the matrix of predictors <i>(n * m)</i></param>
			<param name="demeaned">an indicator of whether an intercept is included in the model</param>
			<param name="normalized">an indicator of whether the predictors are first normalized to have unit L2
                   norm</param>
			<param name="lasso">an indicator of whether LASSO variation is used</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,System.Boolean)">
			<summary>Constructs a least angel regression (LARS) problem, where an intercept is included in the
 model.</summary>
			<param name="y">the vector of response variable <i>(n * 1)</i></param>
			<param name="X">the matrix of predictors <i>(n * m)</i></param>
			<param name="normalized">an indicator of whether the predictors are first normalized to have unit L2
                   norm</param>
			<param name="lasso">an indicator of whether LASSO variation is used</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean)">
			<summary>Constructs a least angel regression (LARS) problem, where an intercept is included in the
 model and the predictors are normalized first.</summary>
			<param name="y">the vector of response variable <i>(n * 1)</i></param>
			<param name="X">the matrix of predictors <i>(n * m)</i></param>
			<param name="lasso">an indicator of whether LASSO variation is used</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs a LASSO variation of the least angel regression (LARS) problem, where an intercept
 is included in the model and the predictors are normalized first.</summary>
			<param name="y">the vector of response variable <i>(n * 1)</i></param>
			<param name="X">the matrix of predictors <i>(n * m)</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem.#ctor(com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem)">
			<summary>Copy constructor.</summary>
			<param name="that">another <c>LeastAngelRegressionProblem</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem.m">
			<summary>Gets the number of predictors (number of columns of <i>X</i>), excluding the intercept.</summary>
			<returns>the number of predictors</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem.isLASSO">
			<summary>Checks if the LASSO variation of LARS is used.</summary>
			<returns><c>true</c> if the LASSO variation of LARS is used</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem.yMean">
			<summary>Gets the mean to be subtracted from the response variable (0 if no intercept is included).</summary>
			<returns>the mean to be subtracted from the response variable</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem.XMean">
			<summary>Gets the mean vector to be subtracted from the predictors (a vector of zeros if no intercept
 is included).</summary>
			<returns>the mean vector to be subtracted from the predictors</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem.XL2Norm">
			<summary>Gets the L2 norms of the predictors (a vector of ones if no standardization is required).</summary>
			<returns>the L2 norm of the predictors</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem.yLARS">
			<summary>Gets the vector of response variable (possibly demeaned) to be used in LARS.</summary>
			<returns>the the vector of response variable (possibly demeaned) to be used in LARS</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem.XLARS">
			<summary>Gets the matrix of predictors (possibly demeaned and/or scaled) to be used in LARS.</summary>
			<returns>the matrix of predictors (possibly demeaned and/or scaled) to be used in LARS</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSFitting">
			<summary>This class computes the entire LARS sequence of coefficients and fits, starting from zero to the
 OLS fit.<para> See also: </para><list type="bullet">
 <item>B. Efron et. al, &quot;Least Angle Regression,&quot; The Annals of Statistics, Volume: 32(2), 407 -
 499, 2004.</item>
 <item>T. Hastie, R. Tibshirani and J. Friedman, &quot;The Elements of Statistical Learning: Data Mining,
 Inference, and Prediction (Second Edition),&quot; New York, Springer-Verlag, 2009.</item>
 <item><a href="http://en.wikipedia.org/wiki/least-angle_regression">Wikipedia: Least angle
 regression</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSFitting.#ctor(com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem,System.Double,System.Int32)">
			<summary>Estimates the entire LARS sequence of coefficients and fits, starting from zero to the OLS
 fit.</summary>
			<param name="problem">the LARS problem to be solved</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is
                      considered 0</param>
			<param name="maxIterations">the maximum number of iterations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSFitting.#ctor(com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem,System.Int32)">
			<summary>Estimates the entire LARS sequence of coefficients with the default epsilon.</summary>
			<param name="problem">the LARS problem</param>
			<param name="maxIterations">the maximum number of steps taken</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSFitting.#ctor(com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSProblem)">
			<summary>Estimates the entire LARS sequence of coefficients with the default epsilon and maximum
 number of steps.</summary>
			<param name="problem">the LARS problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSFitting.getEstimators">
			<summary>Calculate the LARS fitting estimators.</summary>
			<returns>the LARS fitting estimators</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSFitting.Estimators">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSFitting.Estimators.betaMatrix">
			<summary>Gets the entire sequence of estimated (LARS) regression coefficients.</summary>
			<returns>the entire sequence of estimated (LARS) regression coefficients</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSFitting.Estimators.betas">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSFitting.Estimators.max_abs_cor">
			<summary>Gets the estimated sequence of maximal absolute correlations.</summary>
			<returns>the estimated sequence of maximal absolute correlations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSFitting.Estimators.gamma">
			<summary>Gets the estimated sequence of gamma (arc length).</summary>
			<returns>the estimated sequence of gamma (arc length)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSFitting.Estimators.A">
			<summary>Gets the estimated sequence of A.</summary>
			<returns>the estimated sequence of A</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.lasso.lars.LARSFitting.Estimators.actions">
			<summary>Gets the the sequence of actions taken. They are the variables added or dropped in each
 iteration.</summary>
			<returns>the the sequence of actions taken</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.LMProblem">
			<summary>This is a linear regression or a linear model (LM) problem. Linear regression models the
 relationship between a scalar variable <i>y</i> and one or more variables denoted as <i>X</i>. In
 linear regression, models of the unknown parameters are estimated from the data using linear
 functions. Most commonly, linear regression refers to a model in which the conditional mean of
 <i>y</i> given the value of <i>y</i> is an affine function of <i>y</i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/linear_regression">Wikipedia: Linear regression</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Constructs a linear regression problem.</summary>
			<param name="y">the dependent variables</param>
			<param name="X">the factors</param>
			<param name="intercept"><c>true</c> if to additionally add an intercept term to the linear
                  regression</param>
			<param name="weights">the weights assigned to each observation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Constructs a linear regression problem, assuming a constant term (the intercept).</summary>
			<param name="y">the dependent variables</param>
			<param name="X">the factors</param>
			<param name="weights">the weights assigned to each observation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean)">
			<summary>Constructs a linear regression problem, assuming equal weights to all observations.</summary>
			<param name="y">the dependent variables</param>
			<param name="X">the factors</param>
			<param name="intercept"><c>true</c> if to additionally add an intercept term to the linear
                  regression</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Constructs a linear regression problem, assuming
 <list type="bullet">
 <item>a constant term (the intercept)</item>
 <item>equal weights assigned to all observations</item>
 </list></summary>
			<param name="y">the dependent variables</param>
			<param name="X">the factors</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.#ctor(com.numericalmethod.suanshu.stats.regression.linear.LMProblem)">
			<summary>Copy constructor.</summary>
			<param name="that">another <c>LMProblem</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.nObs">
			<summary>Gets the number of observations.</summary>
			<returns>the number of observations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.nFactors">
			<summary>Gets the number of factors, including the intercept if any.</summary>
			<returns>the number of factors, including the intercept if any</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.y">
			<summary>Gets the response vector, the regressands, the dependent variables.</summary>
			<returns>the response vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.wy">
			<summary>Gets the weighted response vector.</summary>
			<returns>the weighted response vector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.A">
			<summary>Gets the regressor matrix.</summary>
			<returns>the regressor matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.wA">
			<summary>Gets the weighted regressor matrix.</summary>
			<returns>the weighted regressor matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.intercept">
			<summary>Checks if an intercept term is added to the linear regression.</summary>
			<returns><c>true</c> if an intercept term is added</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.weights">
			<summary>Gets the weights assigned to each observation.</summary>
			<returns>the weights assigned to each observation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.nExogenousFactors">
			<summary>Gets the number of factors, excluding the intercept.</summary>
			<returns>the number of factors, excluding the intercept</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.X">
			<summary>Gets the factor matrix.
 <para/>
 Note: the automatically appended intercept is not included.</summary>
			<returns>the factor matrix.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.invOfwAtwA">
			<summary>(wA&apos; * wA)<sup>-1</sup></summary>
			<returns>(wA&apos; * wA)<sup>-1</sup></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMProblem.checkInputs">
			<summary>Checks whether this <c>LMProblem</c> instance is valid.</summary>
			<exception cref="T:java.lang.IllegalArgumentException">if this problem is invalid</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.LMBeta">
			<summary>Beta coefficients are the outcomes of fitting a linear regression model. <i>&#946;</i> are the
 coefficients of a linear model. Its estimation is <i>&#946;^</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMBeta.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Constructs an instance of <c>Beta</c>.</summary>
			<param name="betaHat">the coefficient estimates, <i>&#946;^</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMBeta.betaHat">
			<summary>Gets the coefficient estimates, <i>&#946;^</i>.</summary>
			<returns>the coefficient estimates, <i>&#946;^</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMBeta.covariance">
			<summary>Gets the covariance matrix of the coefficient estimates, <i>&#946;^</i>.</summary>
			<returns>the covariance matrix of the coefficient estimates, <i>&#946;^</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMBeta.stderr">
			<summary>Gets the standard errors of the coefficients <i>&#946;^</i>.</summary>
			<returns>the standard errors of the coefficients <i>&#946;^</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LMBeta.t">
			<summary>Gets the t- or z- value of the regression coefficients <i>&#946;^</i>.</summary>
			<returns>the t- or z- value of the regression coefficients <i>&#946;^</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.LinearModel">
			<summary>A linear model provides fitting and the residual analysis (goodness of fit).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LinearModel.Ey(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Computes the expectation \(E(y(x))\) given an input.</summary>
			<param name="x">an input</param>
			<returns>\(E(y(x))\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LinearModel.beta">
			<summary>Gets \(\hat{\beta}\) and statistics.</summary>
			<returns>\(\hat{\beta}\) and statistics</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.LinearModel.residuals">
			<summary>Gets the residual analysis of an OLS regression.</summary>
			<returns>the residual analysis</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticResiduals">
			<summary>Residual analysis of the results of a logistic regression.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticResiduals.deviance">
			<summary>Gets the residual deviance.</summary>
			<returns>the residual deviance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticResiduals.nullDeviance">
			<summary>Gets the null deviance.</summary>
			<returns>the null deviance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticResiduals.devianceResiduals">
			<summary>Gets the residuals, <i>&#949;</i>.</summary>
			<returns>the residuals, <i>&#949;</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticRegression">
			<summary>A logistic regression (sometimes called the logistic model or logit model) is used for prediction
 of the probability of occurrence of an event by fitting data to a logit function logistic curve.
 It is a generalized linear model used for binomial regression.
 <para/>
 This particular implementation works with binary data (<i>y</i>).<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/logistic_regression">Wikipedia: Logistic
 regression</a></item>
 <item>P. J. MacCullagh and J. A. Nelder, &quot;pp.114, Section 4.4, Likelihood functions for binary
 data,&quot; in <i>Generalized Linear Models</i>, 2nd ed.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticRegression.#ctor(com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticProblem)">
			<summary>Constructs a <tt>Logistic</tt> instance.</summary>
			<param name="problem">the logistic regression problem to be solved</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticRegression.#ctor(com.numericalmethod.suanshu.stats.regression.linear.LMProblem)">
			<summary>Constructs a <tt>Logistic</tt> instance.</summary>
			<param name="problem">the logistic regression problem to be solved</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticRegression.logLikelihood(com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticProblem)">
			<summary>Constructs the log-likelihood function for a logistic regression problem.</summary>
			<returns>the log-likelihood function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticRegression.Ey(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Calculates the probability of occurrence (y = 1).</summary>
			<param name="x">the independent variables</param>
			<returns>the probability of occurrence</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticRegression.beta">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticRegression.residuals">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticRegression.ML">
			<summary>Gets the maximum log-likelihood.</summary>
			<returns>the maximum log-likelihood</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticRegression.AIC">
			<summary>Gets the AIC.</summary>
			<returns>the AIC</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticProblem">
			<summary>A logistic regression problem is a variation of the OLS regression problem. It is used when the
 dependent (response) variable is a binary variable. The independent (input) variables can be
 continuous, categorical, or both.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticProblem.#ctor(com.numericalmethod.suanshu.stats.regression.linear.LMProblem)">
			<summary>Constructs a logistic regression problem from a linear regression problem.</summary>
			<param name="problem">a logistic regression problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticProblem.checkInputs">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticBeta">
			<summary>Beta coefficient estimator, <i>&#946;^</i>, of a logistic regression model.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticBeta.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticResiduals)">
			<summary>Construct an instance of <c>Beta</c>.</summary>
			<param name="betaHat"><i>&#946;^</i> of a logistic regression</param>
			<param name="residuals">the residuals of a logistic regression</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.logistic.LogisticBeta.covariance">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSResiduals">
			<summary>This is the residual analysis of the results of an ordinary linear regression model.<para> See also: </para><a href="http://en.wikipedia.org/wiki/ordinary_least_squares#estimation">Wikipedia:
 Estimation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSResiduals.#ctor(com.numericalmethod.suanshu.stats.regression.linear.LMProblem,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Performs the residual analysis for an ordinary linear regression problem.</summary>
			<param name="problem">the linear regression problem to be solved</param>
			<param name="betaHat">&#946;^</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSRegression">
			<summary>(Weighted) Ordinary Least Squares (OLS) is a method for fitting a linear regression model. This
 method minimizes the (weighted) sum of squared distances between the observed responses in the
 dataset, and the responses predicted by the linear approximation.
 <para/>
 The OLS estimator is consistent when the regressors are exogenous and there is no
 multicollinearity, and optimal in the class of linear unbiased estimators when the errors are
 homoscedastic and serially uncorrelated. OLS can be derived as a maximum likelihood estimator
 under the assumption that the errors are normally distributed, however the method has good
 statistical properties for a much broader class of distributions (except for efficiency).<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/linear_regression">Wikipedia: Linear
 regression</a></item>
 <item><a href="http://en.wikipedia.org/wiki/least_squares">Wikipedia: Least squares</a></item>
 <item><a href="http://en.wikipedia.org/wiki/linear_least_squares">Wikipedia: Ordinary least
 squares</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSRegression.#ctor(com.numericalmethod.suanshu.stats.regression.linear.LMProblem,System.Double)">
			<summary>Constructs an <tt>OLSRegression</tt> instance.</summary>
			<param name="problem">the linear regression problem to be solved</param>
			<param name="epsilon">a precision parameter: when a number |x| &#8804; &#949;, it is considered 0</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSRegression.#ctor(com.numericalmethod.suanshu.stats.regression.linear.LMProblem)">
			<summary>Constructs an <tt>OLSRegression</tt> instance.</summary>
			<param name="problem">the linear regression problem to be solved</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSRegression.Ey(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSRegression.Ey(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,System.Boolean)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSRegression.beta">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSRegression.residuals">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSRegression.diagnostics">
			<summary>Gets the diagnostic measures of an OLS regression.</summary>
			<returns>the diagnostic measures of an OLS regression</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSRegression.informationCriteria">
			<summary>Gets the model selection criteria.</summary>
			<returns>the model selection criteria</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSBeta">
			<summary>Beta coefficient estimator, <i>&#946;^</i>, of an Ordinary Least Square linear regression model.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSBeta.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.stats.regression.linear.ols.OLSResiduals)">
			<summary>Constructs an instance of <c>Beta</c>.</summary>
			<param name="betaHat"><i>&#946;^</i> of an OLS regression</param>
			<param name="residuals">the residuals of an OLS regression</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.ols.OLSBeta.covariance">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelRegression">
			<summary>Panel (data) analysis is a statistical method, widely used in social science, epidemiology, and
 econometrics, which deals with two-dimensional (cross sectional/times series) panel data. The
 data are usually collected over time and over the same individuals and then a regression is run
 over these two dimensions.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/panel_data">Wikipedia: Panel data</a></item>
 <item><a href="http://en.wikipedia.org/wiki/panel_analysis">Wikipedia: Panel analysis</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelRegression.getLinearModel(System.String)">
			<summary>Gets the linear model for a particular subject/individual.</summary>
			<param name="subject">the subject</param>
			<returns>the linear model for the subject</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData">
			<summary>A panel data refers to multi-dimensional data frequently involving measurements over time. Panel
 data contain observations of multiple phenomena obtained over multiple time periods for the same
 firms or individuals. In biostatistics, the term longitudinal data is often used instead,
 wherein a subject or cluster constitutes a panel member or individual in a longitudinal study.<para> See also: </para><a href="http://en.wikipedia.org/wiki/panel_data">Wikipedia: Panel data</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.#ctor(System.String,System.String,System.String[])">
			<summary>Constructs a panel of two-dimensional data.</summary>
			<param name="subjectHeader">the name of the subjects</param>
			<param name="timeHeader">the name of the times</param>
			<param name="headers">the data/column names</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.addRow(System.String,System.String,System.Double[])">
			<summary>Inserts a row of data into the panel.</summary>
			<param name="subject">the subject</param>
			<param name="time">the time</param>
			<param name="values">the row data</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.addRow(com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Row)">
			<summary>Inserts a row of data into the panel.</summary>
			<param name="row">a row</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.size">
			<summary>Get the number of rows in the panel.</summary>
			<returns>the number of rows</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.isBalanced">
			<summary>Checks if the panel is balanced.</summary>
			<returns><c>true</c> if the panel is balanced</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.getExtHeaders">
			<summary>Gets the extended headers, including the subject and time headers.</summary>
			<returns>the array of extended headers</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.getExtHeadersString">
			<summary>Gets the extended headers, including the subject and time headers.</summary>
			<returns>the string of extended headers</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.getHeaders">
			<summary>Gets the headers, excluding the subject and time headers.</summary>
			<returns>the array of extended headers</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.getHeadersString">
			<summary>Gets the extended headers, including the subject and time headers.</summary>
			<returns>the string of extended headers</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.getRows">
			<summary>Gets all of the panel data.</summary>
			<returns>all rows in the panel</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.getRowsForSubject(System.String)">
			<summary>Get all the rows pertaining to a particular subject.</summary>
			<param name="subject">the subject</param>
			<returns>all the rows pertaining to a particular subject</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.getRow(System.String,System.String)">
			<summary>Gets one particular row indexed by a pair of subject and time.</summary>
			<param name="subject">the subject</param>
			<param name="time">the time</param>
			<returns>the indexed row</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.getSubjects">
			<summary>Gets the name of all subjects.</summary>
			<returns>all subject names</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.toString">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.getFactorValues(java.util.List,System.String[],com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Transformation[])">
			<summary>Gets the factor values from a panel data.
 Note: each row corresponds to a factor/header value (a transpose of the panel data)</summary>
			<param name="rows">the panel data.</param>
			<param name="headers">the factors to be extracted</param>
			<param name="transformations">the transformation to be applied to the factor values</param>
			<returns>the factor values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.getFactorValues(java.util.List,System.String[])">
			<summary>Gets the factor values from a panel data.
 Note: each row corresponds to a factor/header value (a transpose of the panel data)</summary>
			<param name="rows">the panel data.</param>
			<param name="headers">the factors to be extracted</param>
			<returns>the factor values</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Row">
			<summary>This is one row of the data in a panel. The key or index is a pair of (subject/individual,
 time). This data structure is read-only.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Row.#ctor(System.String,System.String,System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Row.subject">
			<summary>Gets the subject of the row.</summary>
			<returns>the subject</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Row.time">
			<summary>Gets the time of the row.</summary>
			<returns>the time</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Row.values">
			<summary>Gets the values of the row.</summary>
			<returns>the values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Row.get(System.String)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Row.compareTo(com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Row)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Row.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Transformation">
			<summary>Transforms the data, e.g., taking log.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Transformation.header">
			<summary>Gets the name of the factor to apply the transformation to.</summary>
			<returns>the factor name</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Transformation.f">
			<summary>Gets the transformation.</summary>
			<returns>the transformation</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.panel.FixedEffectsModel">
			<summary>Fits the panel data to this linear model:
 \[
 y_{it} = \alpha_{i}+X_{it}\mathbf{\beta}+u_{it}
 \]
 where \(y_{it}\) is the dependent variable observed for individual \(i\) at time \(t\),
 \(X_{it}\) is the time-variant \(1\times K\) regressor matrix, \(\alpha_{i}\) is the unobservable
 time-invariant individual effect and \(u_{it}\) is the error term.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/fixed_effects_model">Wikipedia: Fixed effects
 model</a></item>
 <item>Frees, E. W., Longitudinal and Panel Data: Analysis and Applications in the Social Sciences,
 2004</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.FixedEffectsModel.#ctor(com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData,System.String,System.String[],com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData.Transformation[])">
			<summary>Constructs a &quot;within&quot; fixed effects model from a panel of data.</summary>
			<param name="panel">a panel of data</param>
			<param name="yHeader">the header name of the dependent variables, the regressands</param>
			<param name="XHeaders">the header names of the factors</param>
			<param name="transformations">any transformation that may be applied to the data</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.FixedEffectsModel.#ctor(com.numericalmethod.suanshu.stats.regression.linear.panel.PanelData,System.String,System.String[])">
			<summary>Constructs a &quot;within&quot; fixed effects model from a panel of data.</summary>
			<param name="panel">a panel of data</param>
			<param name="yHeader">the header name of the dependent variables, the regressands</param>
			<param name="XHeaders">the header names of the factors</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.FixedEffectsModel.getLinearModel(System.String)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.panel.FixedEffectsModel.alpha">
			<summary>Gets the individual/subject specific terms.<para> See also: </para>&quot;Frees, E. W., &quot;Eq. 2.7,&quot; Longitudinal and Panel Data: Analysis and Applications in the
 Social Sciences, 2004.&quot;</summary>
			<returns>\(\alpha_i\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals">
			<summary>This is the residual analysis of the results of a linear regression model. Once a regression
 model has been constructed, it may be important to confirm the goodness of fit of the model and
 the statistical significance of the estimated parameters. Commonly used checks of goodness of fit
 include the R-squared, analysis of the pattern of residuals and hypothesis testing. Statistical
 significance can be checked by an F-test of the overall fit, followed by t-tests of individual
 parameters.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/errors_and_residuals_in_statistics">Wikipedia: Errors
 and residuals in statistics</a></item>
 <item><a href="http://en.wikipedia.org/wiki/regression_analysis#regression_diagnostics">Wikipedia:
 Regression diagnostics</a></item>
 <item><a href="http://en.wikipedia.org/wiki/r_square">Wikipedia: Coefficient of
 determination</a></item>
 <item><a href="http://en.wikipedia.org/wiki/residual_sum_of_squares">Wikipedia: Residual sum of
 squares</a></item>
 <item><a href="http://en.wikipedia.org/wiki/explained_sum_of_squares">Wikipedia: Explained sum of
 squares</a></item>
 <item><a href="http://en.wikipedia.org/wiki/total_sum_of_squares">Wikipedia: Total sum of
 squares</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.#ctor(com.numericalmethod.suanshu.stats.regression.linear.LMProblem,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Performs residual analysis for a linear regression problem.</summary>
			<param name="problem">the linear regression problem to be solved</param>
			<param name="fitted">the fitted values, <i>y^</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.getProblem">
			<summary>Gets the linear regression problem.</summary>
			<returns>the linear regression problem</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.fitted">
			<summary>Gets the fitted values, <i>y^</i>.</summary>
			<returns>the fitted values, <i>y^</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.residuals">
			<summary>Gets the residuals, <i>&#949;</i>, the differences between sample and fitted values.</summary>
			<returns>the residuals, <i>&#949;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.weightedFittedValues">
			<summary>Gets the weighted, fitted values.</summary>
			<returns>the weighted, fitted values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.weightedResiduals">
			<summary>Gets the weighted residuals.</summary>
			<returns>the weighted residuals</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.RSS">
			<summary>Gets the diagnostic measure: sum of squared residuals, \(\sum \epsilon^2\).</summary>
			<returns>sum of squared residuals, \(\sum \epsilon^2\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.TSS">
			<summary>Gets the diagnostic measure: total sum of squares, \(\sum (y-y_mean)^2 \).</summary>
			<returns>total sum of squares, \(\sum (y-y_mean)^2 \)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.R2">
			<summary>Gets the diagnostic measure: R-squared.</summary>
			<returns>R-squared</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.AR2">
			<summary>Gets the diagnostic measure: adjusted R-squared</summary>
			<returns>adjusted R-squared</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.stderr">
			<summary>Gets the standard error of the residuals.</summary>
			<returns>the standard error of the residuals</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.Fstat">
			<summary>Gets the diagnostic measure: F statistics
 <blockquote><code><i>
 mean of regression / mean squared error =
 sum((y_i_hat-y_mean)^2) / mean squared error =
 [(TSS-RSS)/n] / [RSS/(m-n)]
 </i></code></blockquote>
 <i>y_i_hat</i> are the fitted values of the regression.<para> See also: </para>&quot;Kutner, Nachtsheim and Neter, &quot;p.69, equation (2.60),&quot; Applied linear regression
 models. 4th edition.&quot;</summary>
			<returns>F statistics</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.hHat">
			<summary>Gets the projection matrix, H-hat.<para> See also: </para>&quot;Sanford Weisberg, &quot;p.168, Section 8.1, Chapter 8,&quot; Applied Linear Regression, 3rd
 edition, 2005. Wiley-Interscience.&quot;</summary>
			<returns>the projection matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.leverage">
			<summary>Gets the leverage.
 The bigger the leverage for an observation, the bigger influence on the prediction.</summary>
			<returns>the leverage</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.standardized">
			<summary><i>standard residual = residual / v1 / sqrt(RSS / (n-m))</i></summary>
			<returns>standardized residuals</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.studentized">
			<summary><i>studentized residual = standardized * sqrt((n-m-1) / (n-m-standardized^2))</i><para> See also: </para><list type="bullet">
 <item>&quot;Chatterjee, Hadi and Price, &quot;p.90 (4.15), Section 4.3,&quot; Regression Analysis by Example,
 3rd edition, 2000. Wiley Series in Probability and Statistics.&quot;</item>
 <item>@see <a href="http://en.wikipedia.org/wiki/studentized_residual">Wikipedia: Studentized
 residual</a></item>
 </list></summary>
			<returns>studentized residuals</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals.df">
			<summary>Gets the degree of freedom.
 <para/>
 TODO: User should be able to modify this method for a different regression.</summary>
			<returns>the degree of freedom</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMInformationCriteria">
			<summary>The information criteria measure the goodness of fit of an estimated statistical model. The
 information criteria (IC) are tests between models - a tool for model selection. Given a data
 set, several competing models may be ranked according to their IC, with the one having the lowest
 IC being the best. From the IC value one may infer that e.g., the top three models are in a tie
 and the rest are far worse, but it would be arbitrary to assign a value above which a given model
 is &apos;rejected&apos;.
 <para/>
 Akaike&apos;s information criterion is a measure of the goodness of fit of an estimated statistical
 model. It is grounded in the concept of entropy, in effect offering a relative measure of the
 information lost when a given model is used to describe reality and can be said to describe the
 tradeoff between bias and variance in model construction, or loosely speaking that of accuracy
 and complexity of the model.
 <para/>
 The BIC is very closely related to the Akaike information criterion (AIC). In BIC, the penalty
 for additional parameters is stronger than that of the AIC.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/akaike_information_criterion">Wikipedia: Akaike
 information criterion</a></item>
 <item><a href="http://en.wikipedia.org/wiki/bayesian_information_criterion">Wikipedia: Bayesian
 information criterion</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMInformationCriteria.#ctor(com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals)">
			<summary>Computes the information criteria from residual analysis.</summary>
			<param name="residuals">the residual analysis of a linear regression problem</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMInformationCriteria.AIC">
			<summary>Gets the Akaike information criterion.<para> See also: </para><a href="http://en.wikipedia.org/wiki/akaike_information_criterion">Wikipedia: Akaike
 information criterion</a></summary>
			<returns>the Akaike information criterion</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMInformationCriteria.BIC">
			<summary>Gets the Bayesian information criterion.<para> See also: </para><a href="http://en.wikipedia.org/wiki/bayesian_information_criterion">Wikipedia:
 Bayesian information criterion</a></summary>
			<returns>the Bayesian information criterion</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMDiagnostics">
			<summary>This class collects some diagnostics measures for the goodness of fit based on the residulas for
 a linear regression model.
 <para/>
 DFFITS is a diagnostic meant to show how influential a point is in a statistical regression.
 It is defined as the change, in the predicted value for a point, obtained when that point is left
 out of the regression, &quot;studentized&quot; by dividing by the estimated standard deviation of the fit
 at that point.
 <para/>
 Cook&apos;s distance is a commonly used estimate of the influence of a data point. Cook&apos;s distance can
 be used in several ways:
 to indicate data points that are particularly worth checking for validity;
 to indicate regions of the design space where it would be good to be able obtain more data
 points.
 <para/>
 Hadi proposed a measure of influence of the i-th observation based on the fact that
 influential observations are outliers in either the response variable or in the predictors, or
 both.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/cook%27s_distance">Wikipedia: Cook&apos;s distance</a></item>
 <item><a href="http://en.wikipedia.org/wiki/dffits">Wikipedia: DFFITS</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMDiagnostics.#ctor(com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals)">
			<summary>Constructs an instance of the <c>Diagnostics</c> from the results of residual analysis.</summary>
			<param name="residuals">the residual analysis of a linear regression</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMDiagnostics.DFFITS">
			<summary>DFFITS, Welsch and Kuh Measure.<para> See also: </para><list type="bullet">
 <item>&quot;Chatterjee, Hadi and Price, &quot;p.105 (4.23), Section 4.9.2, Regression Analysis by
 Example,&quot; 3rd edition, 2000. Wiley Series in Probability and Statistics.&quot;</item>
 <item>&quot;David A. Belsley, Edwin Kuh, Roy E. Welsch, Regression diagnostics: identifying
 influential data and sources of collinearity. Wiley series in probability and mathematical
 statistics. New York: John Wiley &amp; Sons. ISBN 0471058564. 1980.&quot;</item>
 </list></summary>
			<returns>DFFITS</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMDiagnostics.cookDistances">
			<summary>Cook distances.<para> See also: </para>&quot;Sanford Weisberg, &quot;p.200,&quot; Applied Linear Regression, 3rd edition, 2005.
 Wiley-Interscience.&quot;</summary>
			<returns>Cook distances</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMDiagnostics.Hadi">
			<summary>Hadi&apos;s influence measure.<para> See also: </para>&quot;Chatterjee, Hadi and Price, &quot;p.105 (4.24), Section 4.9.2,&quot; Regression Analysis by
 Example, 3rd edition, 2000. Wiley Series in Probability and Statistics.&quot;</summary>
			<returns>Hadi&apos;s influence measure</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.regression.WeightedRSS">
			<summary>Weighted sum of squared residuals (RSS) for a given function \(f(.)\) and observations
 \((x_i,y_i)\).
 \[
 RSS = \sum_{i=1}^n w_i [y_i - f(x_i)]^2
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/least_squares">Wikipedia: Least Squares</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.WeightedRSS.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Constructs a calculator to compute the weighted RSS for a given function.</summary>
			<param name="f">a function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.regression.WeightedRSS.value(System.Double[],System.Double[],System.Double[])">
			<summary>Computes the weighted RSS for a set of observations.</summary>
			<param name="x">the independent variables</param>
			<param name="y">the dependent variables</param>
			<param name="weights">the weights</param>
			<returns>weighted RSS</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009">
			<summary>This class implements the stationary and circular block bootstrapping method with optimized block
 length.<para> See also: </para><list type="bullet">
 <item>Politis, N. Dimitris, White Halbert, &quot;Automatic Block-Length Selection for the Dependent
 Bootstrap&quot;, Econometric Reviews , 2004</item>
 <item>Politis, D., White, H., Patton Andrew,&quot;CORRECTION TO &apos;Automatic Block-Length Selection for
 the Dependent Bootstrap&apos;&quot;, Econometric Reviews, 28(4):372–375, 2009</item>
 <item><a href="http://www.math.ucsd.edu/~politis/soft/ppw/ppw.r">R-code</a></item>
 </list></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.DEFAULT_CACHE_SIZE">
			<summary>The default cache size = the number of available processors &#215; 1000.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.#ctor(System.Double[],System.Int64,com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.Type,com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRLG,com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRNG)">
			<summary>Constructs a block bootstrap sample generator. The block length is automatically selected.</summary>
			<param name="sample">the original sample</param>
			<param name="blockLength">the block length</param>
			<param name="type">the type of block bootstrap, either
                    <para></para>Type#STATIONARY or
                    <para></para>Type#CIRCULAR</param>
			<param name="rlg">a concurrent random long generator</param>
			<param name="rng">a concurrent random exponential generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.#ctor(System.Double[],System.Int64,com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.Type,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Constructs a block bootstrap sample generator. The block length is automatically selected.</summary>
			<param name="sample">the original sample</param>
			<param name="blockLength">the block length</param>
			<param name="type">the type of block bootstrap, either
                    <para></para>Type#STATIONARY or
                    <para></para>Type#CIRCULAR</param>
			<param name="rlg">a random long generator</param>
			<param name="rng">a random exponential generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.#ctor(System.Double[],com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.Type,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Constructs a block bootstrap sample generator. The block length is automatically selected.</summary>
			<param name="sample">the original sample</param>
			<param name="type">the type of block bootstrap, either
               <para></para>Type#STATIONARY or
               <para></para>Type#CIRCULAR</param>
			<param name="rlg">a concurrent random long generator</param>
			<param name="rng">a concurrent random exponential generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.#ctor(System.Double[],com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.Type)">
			<summary>Constructs a block bootstrap sample generator. The block length is automatically selected.</summary>
			<param name="sample">the original sample</param>
			<param name="type">the type of block bootstrap, either
               <para></para>Type#STATIONARY or
               <para></para>Type#CIRCULAR</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.#ctor(System.Double[])">
			<summary>Constructs a block bootstrap sample generator. The default method is
 <para></para>Type#STATIONARY block bootstrapping. The block length is
 automatically selected.</summary>
			<param name="sample">the original sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.getOptimalBlockLength(System.Double[],com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.Type)">
			<summary>Computes the optimal of block length. For stationary block bootstrap, the length of each
 block follows the geometric distribution with mean equal to the computed optimal length; for
 circular block bootstrap, the length of each block is fixed to the computed optimal length.</summary>
			<param name="x">the data</param>
			<param name="type">the type of block bootstrap method</param>
			<returns>the optimal block length \(b_{opt} = \sqrt[3]{\frac{2\hat{G}^2N}{\hat{D}}}\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.getOptimalLag(System.Double[])">
			<summary>Finds the smallest lag \(\hat{m}\) such that the autocorrelation for lags \((\hat{m} +
 k),~k=1,\dots,K_N\) are all insignificant regarding to the critical value.<para> See also: </para>&quot;footnote c, p. 59, Politis and etc. 2004&quot;</summary>
			<param name="x">the data</param>
			<returns>\(M = 2\hat{m}\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.getResample">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.Type">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.Type.STATIONARY">
			<summary></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.Type.CIRCULAR">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.Type.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.block.PattonPolitisWhite2009.Type.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.CaseResamplingReplacement">
			<summary>This is the classical bootstrap method described in the reference. It draws from the original
 sample with replacement.
 <para/>
 This implementation is thread-safe that allows concurrent access to <para></para>#getResample() by
 multiple threads.<para> See also: </para><list type="bullet">
 <item>&quot;B. Efron and R. Tibshirani. An Introduction to the Bootstrap. 1993. Chapman and Hall, New
 York, London.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/bootstrapping_(statistics)#case_resampling">Wikipedia:
 http://en.wikipedia.org/wiki/Bootstrapping_(statistics)#Case_resampling</a></item>
 </list></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.CaseResamplingReplacement.DEFAULT_CACHE_SIZE">
			<summary>The default cache size = the number of available processors &#215; 1000.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.CaseResamplingReplacement.#ctor(System.Double[])">
			<summary>Constructs a bootstrap sample generator. This is the classical bootstrap with replacement.</summary>
			<param name="sample">the original sample.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.CaseResamplingReplacement.#ctor(System.Double[],com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Constructs a bootstrap sample generator. This is the classical bootstrap with replacement.</summary>
			<param name="sample">the original sample.</param>
			<param name="rlg">a uniform random long generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.CaseResamplingReplacement.#ctor(System.Double[],com.numericalmethod.suanshu.stats.random.concurrent.ConcurrentCachedRLG)">
			<summary>Constructs a bootstrap sample generator. This is the classical bootstrap with replacement.</summary>
			<param name="sample">the original sample.</param>
			<param name="rlg">a concurrent uniform random long generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.CaseResamplingReplacement.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.bootstrap.CaseResamplingReplacement.getResample">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.sampler.resampler.Resampler">
			<summary>This is the interface of a re-sampler method.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.Resampler.getResample">
			<summary>Gets a resample from the original sample.
 <para/>
 <em>It is very important this method is thread-safe so resampling can be run in
 parallel.</em></summary>
			<returns>a resample, e.g., a bootstrap sample</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.sampler.resampler.BootstrapEstimator">
			<summary>This class estimates the statistic of a sample using a bootstrap method.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.BootstrapEstimator.#ctor(com.numericalmethod.suanshu.stats.sampler.resampler.Resampler,com.numericalmethod.suanshu.stats.descriptive.StatisticFactory,System.Int32)">
			<summary>Constructs a bootstrap estimator.</summary>
			<param name="bootstrap">the bootstrap method and the sample</param>
			<param name="factory">the statistic</param>
			<param name="B">the number of bootstrap replicas</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.BootstrapEstimator.#ctor(com.numericalmethod.suanshu.stats.sampler.resampler.Resampler,com.numericalmethod.suanshu.stats.descriptive.StatisticFactory,System.Int32,System.Boolean)">
			<summary>Constructs a bootstrap estimator.</summary>
			<param name="bootstrap">the bootstrap method and the sample</param>
			<param name="factory">the statistic; <em>It is very important this class is thread-safe so
                   resampling can be run in parallel.</em></param>
			<param name="B">the number of bootstrap replicas</param>
			<param name="isParallel"><c>true</c> if to run in parallel cores</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.BootstrapEstimator.value">
			<summary>Gets the estimator value (the mean).</summary>
			<returns>the estimator value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.sampler.resampler.BootstrapEstimator.variance">
			<summary>Gets the estimator variance, of which the convergence limit is decided by
 sample size, not <c>B</c>.</summary>
			<returns>the estimator variance</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomWalk">
			<summary>This is the Random Walk construction of a multivariate stochastic process per SDE specification.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomWalk.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateDiscreteSDE,com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.TimeGrid,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a multivariate stochastic process from an SDE.</summary>
			<param name="sde">a discrete SDE</param>
			<param name="timeGrid">specifying the time points in a grid</param>
			<param name="x0">the initial value of the process</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomWalk.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomWalk.nextVector">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomRealizationOfRandomProcess">
			<summary>This class generates random realizations from a multivariate random/stochastic process.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomRealizationOfRandomProcess.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomProcess,System.Int32)">
			<summary>Construct a random realization generator from a multivariate random/stochastic process.</summary>
			<param name="process">a random process</param>
			<param name="size">the size of the realizations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomRealizationOfRandomProcess.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateDiscreteSDE,com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.TimeGrid,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a random realization generator from a multivariate discrete SDE.</summary>
			<param name="sde">a discrete approximation of an SDE</param>
			<param name="timeGrid">specifying the time points in a grid</param>
			<param name="x0">the initial value of the process</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomRealizationOfRandomProcess.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateSDE,com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.TimeGrid,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a random realization generator from a multivariate SDE.</summary>
			<param name="sde">a continuous time SDE</param>
			<param name="timeGrid">specifying the time points in a grid</param>
			<param name="x0">the initial value of the process</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomRealizationOfRandomProcess.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateSDE,System.Int32)">
			<summary>Construct a random realization generator from a multivariate SDE.</summary>
			<param name="sde">a continuous time SDE</param>
			<param name="size">the size of the realizations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomRealizationOfRandomProcess.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomRealizationOfRandomProcess.nextRealization">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomRealizationGenerator">
			<summary>This interface defines a generator to construct random realizations from a multivariate stochastic process.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomRealizationGenerator.nextRealization">
			<summary>Construct a realization of a multivariate stochastic process.</summary>
			<returns>a realization</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomProcess">
			<summary>This interface represents a multivariate random process a.k.a. stochastic process.
 <para/>
 Given a probability space <i>(&#937;, F, P)</i>, a random process (or stochastic process) with state space <i>X</i> is
 a collection of <i>X</i>-valued random variables indexed by a set <i>T</i> (&quot;time&quot;).
 That is, a stochastic process <i>F</i> is a collection <i>{F<sub>t</sub>: t &#8712; T}</i>
 where each <i>F<sub>t</sub></i> is an <i>X</i>-valued random variable.
 <para/>
 According to the Lévy-Khintchine representation, for a stochastic process, we have the Lévy triplet:
 <list type="bullet">
 <item>the absolutely continuous part such that the increment <i>dB</i> is proportional to the square root of time increment <i>dt</i>;</item>
 </list><para> See also: </para><a href="http://en.wikipedia.org/wiki/l%c3%a9vy_process#l.c3.a9vy.e2.80.93it.c5.8d_decomposition">Lévy-Itō decomposition</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomProcess.#ctor(System.Int32,com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.TimeGrid)">
			<summary>Construct a multivariate random process.</summary>
			<param name="nB">the dimension of the Brownian motion (or the number of driving 1D Brownian motions)</param>
			<param name="timeGrid">the time points</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomProcess.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomProcess.nB">
			<summary>Get the dimension of the Brownian motion (or the number of driving 1D Brownian motions).</summary>
			<returns>the dimension of the Brownian motion</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomProcess.time">
			<summary>Get the current time.</summary>
			<returns>the current time; <c>NaN</c> if <para></para>#nextTime() is not already called</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomProcess.nextTime">
			<summary>Get the next time point in the time grid.
 This advances the internal clock.</summary>
			<returns>the next time point in the time grid</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomProcess.Zt">
			<summary>Get a <i>d</i>-dimensional Gaussian innovation.</summary>
			<returns>a <i>d</i>-dimensional Gaussian innovation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateRandomProcess.dB(System.Double)">
			<summary>Get a Brownian motion increment.</summary>
			<param name="dt">the time increment</param>
			<returns>a Brownian motion increment</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateBrownianRRG">
			<summary>This is the Random Walk construction of a multivariate Brownian motion.
 <para/>
 For constant <i>&#956;</i> and <i>&#963;</i>, this method is exact in the sense that
 the joint distribution of the simulated values coincides with the joint distribution of the corresponding Brownian motion a the time grid points.
 Please note that this says nothing about what happens between two successive grid points.
 <para/>
 For time-dependent <i>&#956;</i> and <i>&#963;</i>, this method in general introduce discretization error even at the time grid points,
 because the increments will no longer have exactly the correct mean and variance.<para> See also: </para>&quot;P. Glasserman, &quot;Section 3.1, pp. 81,&quot; Monte Carlo Methods in Financial Engineering, Springer, 2004.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateBrownianRRG.#ctor(System.Int32,com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.TimeGrid,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a random realization generator to produce multi-dimensional Brownian paths at time points specified.</summary>
			<param name="d">the dimension of the Brownian motion</param>
			<param name="timePoints">specifying the time points in a grid</param>
			<param name="initial">the initial value of the process</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateBrownianRRG.#ctor(System.Int32,com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.TimeGrid)">
			<summary>Construct a random realization generator to produce multi-dimensional Brownian paths at time points specified.</summary>
			<param name="d">the dimension of the Brownian motion</param>
			<param name="timePoints">specifying the time points in a grid</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateBrownianRRG.#ctor(System.Int32,System.Int32)">
			<summary>Construct a random realization generator to produce multi-dimensional Brownian paths at evenly spaced time points <i>[0, 1, ...]</i>.</summary>
			<param name="d">the dimension of the Brownian motion</param>
			<param name="T">the number of time points</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateBrownianRRG.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.random.MultivariateBrownianRRG.nextRealization">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ZeroDriftVector">
			<summary>This class represents a 0 drift function.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ZeroDriftVector.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ZeroDriftVector.evaluate(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.DriftVector">
			<summary>The drift term, <i>&#956;</i>, of an SDE takes this form: <i>&#956;(dt, Xt, Zt, ...)</i>.<para> See also: </para>&quot;Fima C. Klebaner, &quot;Section 4.7,&quot; Introduction to Stochastic Calculus with Applications, 2nd ed, Imperial College Press, 2006.&quot;</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.DiffusionSigma">
			<summary>This class implements the diffusion term in the form of a diffusion matrix.
 Each matrix entry is an <i>F<sub>t</sub></i> adapted function.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.DiffusionSigma.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.DiffusionSigma.evaluate(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.DiffusionSigma.sigma_ij(System.Int32,System.Int32)">
			<summary>Get the <i>F<sub>t</sub></i> adapted function the <i>D[i,j]</i> entry in the diffusion matrix.</summary>
			<param name="i">the row index</param>
			<param name="j">the column index</param>
			<returns><i>D[i,j]</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.DiffusionMatrix">
			<summary>The diffusion term, <i>&#963;</i>, of an SDE takes this form: <i>&#963;(dt, Xt, Zt, ...)</i>.<para> See also: </para>&quot;Fima C. Klebaner, &quot;Section 4.7,&quot; Introduction to Stochastic Calculus with Applications, 2nd ed, Imperial College Press, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.DiffusionMatrix.evaluate(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt)">
			<summary>Evaluate the diffusion matrix, <i>&#963;(dt, Xt, Zt, ...)</i>, with respect to a filtration.</summary>
			<param name="ft">a filtration</param>
			<returns>the diffusion matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.DiffusionMatrix.dimension">
			<summary>Get the dimension of the process.
 This is the same as the the number of rows in the diffusion matrix.</summary>
			<returns>the dimension of the process</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.DiffusionMatrix.nB">
			<summary>Get the number of independent Brownian motions.
 This is the same as the number of columns in the diffusion matrix.</summary>
			<returns>the number of independent Brownian motions</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantSigma2">
			<summary><para><c>DEPRECATED:</c> This implementation is slow. Use <para></para>ConstantSigma1 instead.</para>
The class represents a constant diffusion coefficient function.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantSigma2.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a constant diffusion coefficient function.</summary>
			<param name="sigma">the constant diffusion matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantSigma2.sigma_ij(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantSigma2.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantSigma2.nB">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantSigma1">
			<summary>The class represents a constant diffusion coefficient function.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantSigma1.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a constant diffusion coefficient function.</summary>
			<param name="sigma">the constant diffusion matrix</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantSigma1.evaluate(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantSigma1.dimension">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantSigma1.nB">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantDriftVector">
			<summary>The class represents a constant drift function.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantDriftVector.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Construct a constant drift function.</summary>
			<param name="mu">the drift</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.ConstantDriftVector.evaluate(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateEulerSDE">
			<summary>The Euler scheme is the first order approximation of an SDE.
 \[
 dX_t = \mu * dt + \sigma * \sqrt{dt} * Z_t
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/euler%e2%80%93maruyama_method">Wikipedia: Euler-Maruyama method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateEulerSDE.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateSDE)">
			<summary>Discretize a multivariate, continuous-time SDE using the Euler scheme.</summary>
			<param name="sde">a continuous-time SDE</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateEulerSDE.dXt(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt)">
			<summary>

 <para/>
 \(dX_t = \mu * dt + \sigma * \sqrt{dt} * Z_t\)</summary>
			<param name="ft">a filtration</param>
			<returns>the increment of the process in <c>dt</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateEulerSDE.nB">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateEulerSDE.getNewFt">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateDiscreteSDE">
			<summary>This interface represents the discrete approximation of a multivariate SDE.
 We specify an SDE in the differential form, i.e., by its increments.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateDiscreteSDE.nB">
			<summary>Get the number of independent driving Brownian motions.</summary>
			<returns>the number of independent driving Brownian motions</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateDiscreteSDE.getNewFt">
			<summary>Get an empty filtration of the process.</summary>
			<returns>an empty filtration</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateDiscreteSDE.dXt(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt)">
			<summary>This is the SDE specification of a stochastic process.</summary>
			<param name="ft">filtration</param>
			<returns>the increment of the process in <i>dt</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateBrownianSDE">
			<summary>A multivariate Brownian motion is a stochastic process with the following properties.
 <list type="bullet">
 <item>B(0) = 0;</item>
 <item>B(t), t &gt;= 0, are continuous functions of t;</item>
 <item>the increments, B(t) - B(s), t &gt; s, are independent of the past;</item>
 <item>the increments, B(t) - B(s), are (correlated) multi- normally distributed with mean 0.</item>
 </list><para> See also: </para>&quot;Fima C. Klebaner, &quot;Section 3.1,&quot; Introduction to Stochastic Calculus with Applications, 2nd ed, Imperial College Press, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateBrownianSDE.#ctor(System.Int32)">
			<summary>Construct a standard multi-dimensional Brownian motion.</summary>
			<param name="d">the dimension</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateBrownianSDE.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Construct a multi-dimensional Brownian motion.</summary>
			<param name="mu"><i>&#956;</i></param>
			<param name="sigma"><i>&#963;</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateBrownianSDE.dXt(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateBrownianSDE.nB">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.discrete.MultivariateBrownianSDE.getNewFt">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateSDE">
			<summary>This class represents a multi-dimensional, continuous-time Stochastic Differential Equation (SDE) of this form:
 \[
 dX_t = \mu(t,X_t,Z_t,...)*dt + \sigma(t, X_t, Z_t, ...)*dB_t
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateSDE.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.DriftVector,com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.coefficients.DiffusionMatrix,System.Int32)">
			<summary>Construct a multi-dimensional diffusion type stochastic differential equation.</summary>
			<param name="mu">the drift</param>
			<param name="sigma">the diffusion matrix</param>
			<param name="nB">the number of independent driving Brownian motions</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateSDE.getFt">
			<summary>Get an empty filtration of the process.</summary>
			<returns>an empty filtration</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateSDE.dimension">
			<summary>Get the dimension of the process.</summary>
			<returns>the dimension of the process</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateSDE.nB">
			<summary>Get the number of driving Brownian motions.</summary>
			<returns>the number of driving Brownian motions</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateSDE.mu">
			<summary>Get the drift: \(\mu(t,X_t,Z_t,...)\).</summary>
			<returns>the drift</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateSDE.sigma">
			<summary>Get the diffusion matrix: \(\sigma(t, X_t, Z_t, ...)\).</summary>
			<returns>the diffusion matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFtWt">
			<summary>This is a filtration implementation that includes the path-dependent information,
 <i>W<sub>t</sub></i>.<para> See also: </para>MultivariateFt</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFtWt.#ctor">
			<summary>Construct an empty filtration (no information).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFtWt.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFtWt)">
			<summary>Copy constructor.</summary>
			<param name="that">another <tt>Ft</tt></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFtWt.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFtWt.t">
			<summary>Get the current time.</summary>
			<returns>the current time</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFtWt.Wt">
			<summary>Get the current value(s) of the driving Brownian motion(s).</summary>
			<returns>the current value(s) of the driving Brownian motion(s)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFtWt.setDt(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFtWt.setZt(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt">
			<summary>This represents the concept &apos;Filtration&apos;, the information available at time <i>t</i>.
 <para/>
 The information may include (subject to implementation), for example,
 <list type="bullet">
 <item>time</item>
 <item>value of the stochastic process</item>
 <item>values of the driving Brownian motion(s)</item>
 </list><para> See also: </para>&quot;Fima C. Klebaner, &quot;pp.23,&quot; Introduction to Stochastic Calculus with Applications, 2nd ed, Imperial College Press, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt.#ctor">
			<summary>Construct an empty filtration (no information).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt)">
			<summary>Copy constructor.</summary>
			<param name="that">another <c>Ft</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt.dim">
			<summary>Get the dimension of the process.</summary>
			<returns>the dimension of the process</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt.nB">
			<summary>Get the number of independent driving Brownian motions.</summary>
			<returns>the number of independent driving Brownian motions</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt.setDt(System.Double)">
			<summary>Set the current time differential.</summary>
			<param name="dt">the time differential</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt.dt">
			<summary>Get the current time differential.</summary>
			<returns>the time differential</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt.setXt(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Set the current value of the stochastic process.</summary>
			<param name="Xt">the current value of the stochastic process</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt.Xt">
			<summary>Get the current value of the stochastic process.</summary>
			<returns>the current value of the stochastic process</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt.setZt(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Set the current value of the Gaussian innovation.</summary>
			<param name="Zt">the current Gaussian innovation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt.Zt">
			<summary>Get the current value of the Gaussian innovation.</summary>
			<returns>the current Gaussian innovation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt.dWt">
			<summary>Get the increment of the driving Brownian motion during the time differential.
 This is the product of the Gaussian innovation and the square root of the time differential.</summary>
			<returns>the increment of the driving Brownian motion during the time differential</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.FtAdaptedVectorFunction">
			<summary>This represents a vector-valued <i>F<sub>t</sub>-adapted</i> function that depends on <i>X(t), B(t)</i>, or even on the whole past path of <i>B(s), s &#8804; t</i>.<para> See also: </para>&quot;Fima C. Klebaner, &quot;Section 4.7,&quot; Introduction to Stochastic Calculus with Applications, 2nd ed, Imperial College Press, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.FtAdaptedVectorFunction.evaluate(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt)">
			<summary>Evaluate this function, <i>f</i>, at time <i>t</i>.</summary>
			<param name="ft">the filtration at time <i>t</i></param>
			<returns><i>f(t) = f(F<sub>t</sub>)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.FtAdaptedRealFunction">
			<summary>This represents an <i>F<sub>t</sub>-adapted</i> function that depends on <i>X(t), B(t)</i>, or even on the whole past path of <i>B(s), s &#8804; t</i>.<para> See also: </para>&quot;Fima C. Klebaner, &quot;Section 4.7,&quot; Introduction to Stochastic Calculus with Applications, 2nd ed, Imperial College Press, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.FtAdaptedRealFunction.evaluate(com.numericalmethod.suanshu.stats.stochasticprocess.multivariate.sde.MultivariateFt)">
			<summary>Evaluate this function, <i>f</i>, at time <i>t</i>.</summary>
			<param name="ft">the filtration at time <i>t</i></param>
			<returns><i>f(t) = f(F<sub>t</sub>)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.UnitGrid">
			<summary>This is the sequence of time points <i>[0, 1, ..., T]</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.UnitGrid.#ctor(System.Int32)">
			<summary>Construct a sequence of time points <i>[0, 1, ..., T]</i>.</summary>
			<param name="T">the grid size</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.UnitGrid.#ctor">
			<summary>Construct a sequence of time points <i>[0, 1, ..., &#8734;]</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.UnitGrid.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.UnitGrid.iterator">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.TimeGrid">
			<summary>Specify the time points in a grid or axis.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.TimeGrid.size">
			<summary>Get the number of time points.</summary>
			<returns>the number of time points</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.EvenlySpacedGrid">
			<summary>This is an evenly spaced time grid.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.EvenlySpacedGrid.#ctor(System.Double,System.Double,System.Int32)">
			<summary>Construct an evenly spaced time grid.</summary>
			<param name="T0">the begin of the time interval</param>
			<param name="T">the end of the time interval</param>
			<param name="N">the number of time points, including the initial</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.EvenlySpacedGrid.size">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.EvenlySpacedGrid.T">
			<summary>Get the end time.</summary>
			<returns>the end time</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.EvenlySpacedGrid.iterator">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.F_Sum_tBtDt">
			<summary>This represents a function of this integral
 \[
 \int_{0}^{1} (t - 0.5) * B(t) dt
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.F_Sum_tBtDt.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.F_Sum_tBtDt.setFt(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.F_Sum_tBtDt.sum_BtDt">
			<summary>Get <i>&#931;(Bt)*(dt)</i>.</summary>
			<returns><i>&#931;(Bt)*(dt)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.F_Sum_tBtDt.sum_tBtDt">
			<summary>Get <i>&#931;(t-0.5)*(Bt)*(dt)</i>.</summary>
			<returns><i>&#931;(t-0.5)*(Bt)*(dt)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.F_Sum_BtDt">
			<summary>This represents a function of this integral
 \[
 I = \int_{0}^{1} B(t)dt
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.F_Sum_BtDt.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.F_Sum_BtDt.setFt(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.F_Sum_BtDt.sum_BtDt">
			<summary>Get <i>&#931;(Bt)*(dt)</i>.</summary>
			<returns><i>&#931;(Bt)*(dt)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.FiltrationFunction">
			<summary>A filtration function, parameterized by a fixed filtration, is a function of time, \(f(\mathfrak{F_{t_i}})\).
 The function is not necessarily adapted.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.FiltrationFunction.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.FiltrationFunction.evaluate(System.Int32)">
			<summary>Compute the function value at the <i>i</i>-th time point, \(f(\mathfrak{F_{t_i}})\).</summary>
			<param name="i">the index to time</param>
			<returns>\(f(\mathfrak{F_{t_i}})\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.FiltrationFunction.setFt(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration)">
			<summary>Set the filtration for this function.
 <para/>
 This function is called for each call to
 <para></para>Integrator#integrate(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction, double, double) integrate
 before doing the integration.</summary>
			<param name="Ft">a filtration</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.FiltrationFunction.getFt">
			<summary>Get the filtration.</summary>
			<returns>the filtration</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.FiltrationFunction.Ft">
			<summary>Compute all function values at all time points.</summary>
			<returns>\(f(\mathfrak{F_{t_i}})\), at all time points</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.FiltrationFunction.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration">
			<summary>This class represents the filtration information known at the end of time.
 It contains all histories about a simulation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration.#ctor(com.numericalmethod.suanshu.stats.timeseries.datastructure.univariate.UnivariateTimeSeries)">
			<summary>Construct a <c>Filtration</c> from a Brownian path.</summary>
			<param name="Bt">a Brownian path</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration.size">
			<summary>Get the length of the history.</summary>
			<returns>the length of the Brownian path</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration.B(System.Int32)">
			<summary>Get the Brownian motion value at the <i>i</i>-th time point.</summary>
			<param name="i">a time index, counting from 0</param>
			<returns>\(B_{t_i}\) the Brownian motion value at the <i>i</i>-th time point</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration.Bt">
			<summary>Get the entire Brownian path.</summary>
			<returns>the entire Brownian path</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration.dB(System.Int32)">
			<summary>Get the Brownian increment at the <i>i</i>-th time point.

 <blockquote><c>
 dB[i] = B[i+1] - B[i]
 </c></blockquote></summary>
			<param name="i">a time index, counting from 0</param>
			<returns>\(dB_{t_i}\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration.dBt">
			<summary>Get all the Brownian increments.</summary>
			<returns>the Brownian increments</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration.time(System.Int32)">
			<summary>Get the <i>i</i>-th time point.</summary>
			<param name="i">a time index</param>
			<returns>the <i>i</i>-th time point</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration.times">
			<summary>Get the entire time grid.</summary>
			<returns>the times</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration.dt(System.Int32)">
			<summary>Get the <i>i</i>-th time increment.

 <blockquote><c>
 dt[i] = t[i+1] - t[i]
 </c></blockquote></summary>
			<param name="i">a time index, counting from 0</param>
			<returns>dt the <i>i</i>-th time increment</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration.dt">
			<summary>Get all the time increments.</summary>
			<returns>the time increments</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Bt">
			<summary>This is a <c>FiltrationFunction</c> that returns \(B(t_i)\),
 the Brownian motion value at the <i>i</i>-th time point.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Bt.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Bt.evaluate(System.Int32)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.IntegralDt">
			<summary>This class evaluates the following class of integrals.
 \[
 \int f(t)dt
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.IntegralDt.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.FiltrationFunction)">
			<summary>Construct an integral for <i>f</i> with respect to <i>dt</i>.</summary>
			<param name="f">an integrand</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.IntegralDt.ft">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.IntegralDt.du">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.IntegralDB">
			<summary>This class evaluates the following class of integrals.
 \[
 \int f(t)dB_t
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.IntegralDB.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.FiltrationFunction)">
			<summary>Construct an integral for <i>f</i> with respect to <i>dB</i>.</summary>
			<param name="f">an integrand</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.IntegralDB.ft">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.IntegralDB.du">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Integral">
			<summary>The class represents an integral of a function, in the Lebesgue sense.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Integral.f">
			<summary>the integrand</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Integral.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.FiltrationFunction)">
			<summary>Construct an integral from an integrand.</summary>
			<param name="f">an integrand</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Integral.ft">
			<summary>Get an array of the function values.</summary>
			<returns>an array of the function values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Integral.du">
			<summary>Get an array of the measure values.</summary>
			<returns>an array of the measure values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Integral.value(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.filtration.Filtration)">
			<summary>Integrate the function with respect to a given filtration.</summary>
			<param name="Ft">a filtration</param>
			<returns>the integral value</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Expectation">
			<summary>This class computes the expectation of the following class of integrals.
 \[
 E(\int f(B_{t_i})dt)
 \]
 <para/>
 <i>f</i> is not necessarily an adapted function.
 <para/>
 The Brownian paths are generated by Monte Carlo simulations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Expectation.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Integral,System.Double,System.Double,System.Int32,System.Int32,System.Int64)">
			<summary>Compute the expectation for the integral of a stochastic process.</summary>
			<param name="I">the integral of a stochastic process</param>
			<param name="t0">the beginning time of the integral time interval</param>
			<param name="t1">the ending time of the integral time interval</param>
			<param name="n">the number of discretization in the integral time interval</param>
			<param name="nSim">the number of simulations</param>
			<param name="seed">a seed</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Expectation.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Integral,System.Double,System.Double,System.Int32,System.Int32)">
			<summary>Compute the expectation for the integral of a stochastic process.</summary>
			<param name="I">the integral of a stochastic process</param>
			<param name="t0">the beginning time of the integral time interval</param>
			<param name="t1">the ending time of the integral time interval</param>
			<param name="n">the number of discretization in the integral time interval</param>
			<param name="nSim">the number of simulations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Expectation.mean">
			<summary>Compute the mean of the integral.</summary>
			<returns>the mean of the integral</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.integration.Expectation.variance">
			<summary>Compute the variance of the integral.</summary>
			<returns>the variance of the integral</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomWalk">
			<summary>This is the Random Walk construction of a stochastic process per SDE specification.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomWalk.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.DiscreteSDE,com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.TimeGrid,System.Double)">
			<summary>Construct a univariate stochastic process from an SDE.</summary>
			<param name="sde">a discrete SDE</param>
			<param name="timeGrid">specifying the time points in a grid</param>
			<param name="x0">the initial value of the process</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomWalk.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomWalk.nextDouble">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomRealizationOfRandomProcess">
			<summary>This class generates random realizations from a random/stochastic process.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomRealizationOfRandomProcess.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomProcess,System.Int32)">
			<summary>Construct a random realization generator from a random/stochastic process.</summary>
			<param name="process">a random process</param>
			<param name="size">the size of the realizations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomRealizationOfRandomProcess.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.DiscreteSDE,com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.TimeGrid,System.Double)">
			<summary>Construct a random realization generator from a discrete SDE.</summary>
			<param name="sde">a discrete approximation of an SDE</param>
			<param name="timeGrid">specifying the time points in a grid</param>
			<param name="x0">the initial value of the process</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomRealizationOfRandomProcess.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.SDE,com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.TimeGrid,System.Double)">
			<summary>Construct a random realization generator from an SDE.</summary>
			<param name="sde">a continuous time SDE</param>
			<param name="timeGrid">specifying the time points in a grid</param>
			<param name="x0">the initial value of the process</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomRealizationOfRandomProcess.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.SDE,System.Int32)">
			<summary>Construct a random realization generator from an SDE.</summary>
			<param name="sde">a continuous time SDE</param>
			<param name="size">the size of the realizations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomRealizationOfRandomProcess.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomRealizationOfRandomProcess.nextRealization">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomRealizationGenerator">
			<summary>This interface defines a generator to construct random realizations from a univariate stochastic process.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomRealizationGenerator.nextRealization">
			<summary>Construct a realization of a univariate stochastic process.</summary>
			<returns>a realization</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomProcess">
			<summary>This interface represents a univariate random process a.k.a. stochastic process.
 <para/>
 Given a probability space <i>(&#937;, F, P)</i>, a random process (or stochastic process) with state space <i>X</i> is
 a collection of <i>X</i>-valued random variables indexed by a set <i>T</i> (&quot;time&quot;).
 That is, a stochastic process <i>F</i> is a collection <i>{F<sub>t</sub>: t &#8712; T}</i>
 where each <i>F<sub>t</sub></i> is an <i>X</i>-valued random variable.
 <para/>
 According to the Lévy-Khintchine representation, for a stochastic process, we have the Lévy triplet:
 <list type="bullet">
 <item>the absolutely continuous part such that the increment <i>dB</i> is proportional to the square root of time increment <i>dt</i>;</item>
 </list><para> See also: </para><a href="http://en.wikipedia.org/wiki/l%c3%a9vy_process#l.c3.a9vy.e2.80.93it.c5.8d_decomposition">Lévy-Itō decomposition</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomProcess.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.timegrid.TimeGrid)">
			<summary>Construct a univariate random process.</summary>
			<param name="timeGrid">the time points</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomProcess.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomProcess.time">
			<summary>Get the current time.</summary>
			<returns>the current time; <c>NaN</c> if <para></para>#nextTime() is not already called</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomProcess.nextTime">
			<summary>Get the next time point in the time grid.
 This advances the internal clock.</summary>
			<returns>the next time point in the time grid</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomProcess.Zt">
			<summary>Get a Gaussian innovation.</summary>
			<returns>a Gaussian innovation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomProcess.dB(System.Double)">
			<summary>Get a Brownian motion increment.</summary>
			<param name="dt">the time increment</param>
			<returns>a Brownian motion increment</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.ExpectationAtEndTime">
			<summary>This class computes the expectation (mean) and the variance of a stochastic process,
 by Monte Carlo simulation, at the end of an interval: \(E(X_T)\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.ExpectationAtEndTime.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomRealizationGenerator,System.Int32)">
			<summary>Compute the expectation of a random process at the end time.</summary>
			<param name="rrg">a generator of realizations of the random process</param>
			<param name="nSims">the number of simulations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.ExpectationAtEndTime.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.RandomProcess,System.Int32,System.Int32)">
			<summary>Compute the expectation of a random process at the end time.</summary>
			<param name="process">a random process</param>
			<param name="size">the size of the realizations</param>
			<param name="nSims">the number of simulations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.ExpectationAtEndTime.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.SDE,System.Double,System.Double,System.Int32,System.Double,System.Int32)">
			<summary>Compute the expectation of a stochastic SDE at the end time.</summary>
			<param name="sde">the integrand SDE</param>
			<param name="T0">the begin of the time interval</param>
			<param name="T">the end of the time interval</param>
			<param name="nT">the number of sub-intervals in <i>[T0, T]</i></param>
			<param name="x0">the initial value</param>
			<param name="nSims">the number of simulations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.ExpectationAtEndTime.value">
			<summary>Get the expectation (the mean).</summary>
			<returns>the expectation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.random.ExpectationAtEndTime.variance">
			<summary>Get the variance.</summary>
			<returns>the variance</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.coefficients.Drift">
			<summary>This class represents the drift term, <i>&#956;</i>, of a univariate SDE.
 It has this form: \(\mu(t,X_t,Z_t,...)\).
 The drift is an <i>F<sub>t</sub></i> adapted function.<para> See also: </para>&quot;Fima C. Klebaner, &quot;pp. 126,&quot; Introduction to Stochastic Calculus with Applications, 2nd ed, Imperial College Press, 2006.&quot;</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.coefficients.Diffusion">
			<summary>This class represents the diffusion term, <i>&#963;</i>, of a univariate SDE.
 It has this form: \(\sigma(t, X_t, Z_t, ...)\).
 The diffusion is an <i>F<sub>t</sub></i> adapted function.<para> See also: </para>&quot;Fima C. Klebaner, &quot;pp. 126,&quot; Introduction to Stochastic Calculus with Applications, 2nd ed, Imperial College Press, 2006.&quot;</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.MilsteinSDE">
			<summary>Milstein scheme is a first-order approximation to a continuous-time SDE.
 It adds a term to the Euler scheme by expanding both the drift and diffusion terms to <i>O(dt)</i>.
 \[
 dX_t = \mu * dt + \sigma * \sqrt{dt} * Z_t + \frac{1}{2} \frac{d\sigma}{dt} * \sigma * dt * (Z_t^2 - 1)
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/milstein_method">Wikipedia: Milstein method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.MilsteinSDE.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.SDE)">
			<summary>Discretize a continuous-time SDE using the Milstein scheme.</summary>
			<param name="sde">a continuous-time SDE</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.MilsteinSDE.dXt(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft)">
			<summary>

 <para/>
 This is an implementation of the Milstein scheme.
 \[
 dX_t = \mu * dt + \sigma * \sqrt{dt} * Z_t + \frac{1}{2} \frac{d\sigma}{dt} * \sigma * dt * (Z_t^2 - 1)
 \]</summary>
			<param name="ft">a filtration</param>
			<returns>the increment of the process in <c>dt</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.MilsteinSDE.getNewFt">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.MilsteinSDE.db(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft)">
			<summary>\[
 \frac{d\sigma}{dt}
 \]</summary>
			<param name="ft">a filtration</param>
			<returns>\(\frac{d\sigma}{dt}\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.EulerSDE">
			<summary>The Euler scheme is the first order approximation of an SDE.
 \[
 dX_t = \mu * dt + \sigma * \sqrt{dt} * Z_t
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/euler%e2%80%93maruyama_method">Wikipedia: Euler-Maruyama method</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.EulerSDE.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.SDE)">
			<summary>Discretize a continuous-time SDE using the Euler scheme.</summary>
			<param name="sde">a continuous-time SDE</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.EulerSDE.dXt(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft)">
			<summary>

 <para/>
 \(dX_t = \mu * dt + \sigma * \sqrt{dt} * Z_t\)</summary>
			<param name="ft">a filtration</param>
			<returns>the increment of the process in <c>dt</c></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.EulerSDE.getNewFt">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.DiscreteSDE">
			<summary>This interface represents the discrete approximation of a univariate SDE.
 We specify an SDE in the differential form, i.e., by its increments.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.DiscreteSDE.getNewFt">
			<summary>Get an empty filtration of the process.</summary>
			<returns>an empty filtration</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.DiscreteSDE.dXt(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft)">
			<summary>This is the SDE specification of a stochastic process.</summary>
			<param name="ft">filtration</param>
			<returns>the increment of the process in <i>dt</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.BrownianSDE">
			<summary>A Brownian motion is a stochastic process with the following properties.
 <list type="bullet">
 <item>B(0) = 0;</item>
 <item>B(t), t &#8805; 0, are continuous functions of t;</item>
 <item>the increments, B(t) - B(s), t &gt; s, are independent of the past;</item>
 <item>the increments, B(t) - B(s), are normally distributed with mean 0 and variance (t - s).</item>
 </list><para> See also: </para>&quot;Fima C. Klebaner, &quot;Section 3.1,&quot; Introduction to Stochastic Calculus with Applications, 2nd ed, Imperial College Press, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.BrownianSDE.#ctor(System.Double,System.Double)">
			<summary>Construct a univariate Brownian motion.</summary>
			<param name="mu"><i>&#956;</i>, the drift</param>
			<param name="sigma"><i>&#963;</i>, the diffusion constant</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.BrownianSDE.#ctor">
			<summary>Construct a univariate standard Brownian motion.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.BrownianSDE.dXt(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.discrete.BrownianSDE.getNewFt">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.XtAdaptedFunction">
			<summary>This represents an <i>F<sub>t</sub>-adapted</i> function that depends only on <i>X(t)</i>.<para> See also: </para>&quot;Fima C. Klebaner, &quot;Section 4.7,&quot; Introduction to Stochastic Calculus with Applications, 2nd ed, Imperial College Press, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.XtAdaptedFunction.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.XtAdaptedFunction.evaluate(System.Double)">
			<summary>Evaluate this function, <i>f</i>, based on only the current value of the stochastic process.</summary>
			<param name="Xt">the current value of the stochastic process</param>
			<returns><i>f(X<sub>t</sub>)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.XtAdaptedFunction.evaluate(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.SDE">
			<summary>This class represents a univariate, continuous-time Stochastic Differential Equation (SDE) of
 the following form.
 \[
 dX_t = \mu(t,X_t,Z_t,...)*dt + \sigma(t, X_t, Z_t, ...)*dB_t
 \]<para> See also: </para><a href="http://en.wikipedia.org/wiki/stochastic_differential_equation">
 Wikipedia: Stochastic differential equation</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.SDE.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.coefficients.Drift,com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.coefficients.Diffusion)">
			<summary>Construct a univariate diffusion type stochastic differential equation.</summary>
			<param name="drift">the drift, &#956;</param>
			<param name="diffusion">the diffusion coefficient; &#963;</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.SDE.getFt">
			<summary>Get an empty filtration of the process.</summary>
			<returns>an empty filtration</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.SDE.drift">
			<summary>Get the drift: \(\mu(t,X_t,Z_t,...)\).</summary>
			<returns>the drift</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.SDE.diffusion">
			<summary>Get the diffusion coefficient: \(\sigma(t, X_t, Z_t, ...)\).</summary>
			<returns>the diffusion coefficient</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.FtWt">
			<summary>This is a filtration implementation that includes the path-dependent information,
 <i>W<sub>t</sub></i>.<para> See also: </para>Ft</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.FtWt.#ctor">
			<summary>Construct an empty filtration (no information).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.FtWt.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.FtWt)">
			<summary>Copy constructor.</summary>
			<param name="that">another <tt>Ft</tt></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.FtWt.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.FtWt.t">
			<summary>Get the current time.</summary>
			<returns>the current time</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.FtWt.Wt">
			<summary>Get the current value of the driving Brownian motion.</summary>
			<returns>the current value of the driving Brownian motion</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.FtWt.setDt(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.FtWt.setZt(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.FtAdaptedFunction">
			<summary>This represents an <i>F<sub>t</sub>-adapted</i> function that depends on <i>X(t), B(t)</i>, or even on the whole past path of <i>B(s), s &#8804; t</i>.<para> See also: </para>&quot;Fima C. Klebaner, &quot;Section 4.7,&quot; Introduction to Stochastic Calculus with Applications, 2nd ed, Imperial College Press, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.FtAdaptedFunction.evaluate(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft)">
			<summary>Evaluate this function, <i>f</i>, at time <i>t</i>.</summary>
			<param name="ft">the filtration at time <i>t</i></param>
			<returns><i>f(t) = f(F<sub>t</sub>)</i></returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft">
			<summary>This represents the concept &apos;Filtration&apos;, the information available at time <i>t</i>.
 <para/>
 The information may include (subject to implementation), for example,
 <list type="bullet">
 <item>time</item>
 <item>value of the stochastic process</item>
 <item>values of the driving Brownian motion(s)</item>
 </list><para> See also: </para>&quot;Fima C. Klebaner, &quot;pp.23,&quot; Introduction to Stochastic Calculus with Applications, 2nd ed, Imperial College Press, 2006.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft.#ctor">
			<summary>Construct an empty filtration (no information).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft)">
			<summary>Copy constructor.</summary>
			<param name="that">another <c>Ft</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft.deepCopy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft.setDt(System.Double)">
			<summary>Set the current time differential.</summary>
			<param name="dt">the time differential</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft.dt">
			<summary>Get the current time differential.</summary>
			<returns>the time differential</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft.setXt(System.Double)">
			<summary>Set the current value of the stochastic process.</summary>
			<param name="Xt">the current value of the stochastic process</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft.Xt">
			<summary>Get the current value of the stochastic process.</summary>
			<returns>the current value of the stochastic process</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft.setZt(System.Double)">
			<summary>Set the current value of the Gaussian innovation.</summary>
			<param name="Zt">the current Gaussian innovation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft.Zt">
			<summary>Get the current value of the Gaussian innovation.</summary>
			<returns>the current Gaussian innovation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.Ft.dWt">
			<summary>Get the increment of the driving Brownian motion during the time differential.
 This is the product of the Gaussian innovation and the square root of the time differential.</summary>
			<returns>the increment of the driving Brownian motion during the time differential</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.GeometricBrownian">
			<summary>A Geometric Brownian motion (GBM) (occasionally, exponential Brownian motion) is
 a continuous-time stochastic process in which the logarithm of the randomly varying quantity follows a Brownian motion.<para> See also: </para><a href="http://en.wikipedia.org/wiki/geometric_brownian_motion">Wikipedia: Geometric Brownian motion</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.GeometricBrownian.#ctor(System.Double,System.Double)">
			<summary>Construct a Geometric Brownian motion.

 <blockquote><i>
 dS = rSdt + &#963;SdW
 </i></blockquote></summary>
			<param name="r">the log drift</param>
			<param name="sigma">the log diffusion coefficient</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUSim">
			<summary>This class simulates a discrete path of a univariate Ornstein-Uhlenbeck (OU) process.<para> See also: </para><a href="http://en.wikipedia.org/wiki/ornstein-uhlenbeck_process">
 Wikipedia: Ornstein-Uhlenbeck process</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUSim.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OrnsteinUhlenbeckProcess,System.Double,System.Double,com.numericalmethod.suanshu.stats.random.univariate.normal.RandomStandardNormalNumberGenerator)">
			<summary>Create an OU process simulator.</summary>
			<param name="ou">the underlying OU process</param>
			<param name="dt">the time interval \(\delta_t\)</param>
			<param name="x0">the starting value</param>
			<param name="rng">the standard Gaussian innovation generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUSim.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OrnsteinUhlenbeckProcess,System.Double,System.Double)">
			<summary>Create an OU process simulator. <para></para>StandardNormalRNG is used for generating i.i.d
 innovations.</summary>
			<param name="ou">the underlying OU process</param>
			<param name="dt">the time interval \(\delta_t\)</param>
			<param name="x0">the starting value</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUSim.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OrnsteinUhlenbeckProcess,System.Double)">
			<summary>Create an OU process simulator using the overall mean as the starting value.
 <para></para>StandardNormalRNG is used for generating i.i.d innovations.</summary>
			<param name="ou">the underlying OU process</param>
			<param name="dt">the time interval \(\delta_t\)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUSim.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OrnsteinUhlenbeckProcess)">
			<summary>Create an OU process simulator with a time interval of 1, using the overall mean as the
 starting value. <para></para>StandardNormalRNG is used for generating i.i.d innovations.</summary>
			<param name="ou">the underlying OU process</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUSim.nextDouble">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUSim.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUSim.getProcess">
			<summary>Get the underlying OU process of this generator.</summary>
			<returns>the underlying OU process</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUSim.dt">
			<summary>Get the time interval \(\delta_t\) of this generator.</summary>
			<returns>the time interval \(\delta_t\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUFittingOLS">
			<summary>This class fits a univariate Ornstein-Uhlenbeck process by using least squares regression.<para> See also: </para>&quot;Sun, Kevin, univariate_OU_fitting.pdf&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUFittingOLS.#ctor(System.Boolean)">
			<summary>Create an instance with the option whether to estimate the volatility parameter. If the
 volatility parameter is <em>NOT</em> estimated, the fitted process will assume
 <i>&#963;=1</i>.</summary>
			<param name="estimateVolatility"><c>true</c> if volatility parameter is to be estimated</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUFittingOLS.#ctor">
			<summary>Create an instance that estimates the volatility parameter &#963;.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUFittingOLS.getFittedOU(System.Double[])">
			<summary>Fit an OU process by using least squares regression. By default, the time interval is assumed
 to be 1.</summary>
			<param name="ts">the time series</param>
			<returns>the fitted OU process</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUFittingOLS.getFittedOU(System.Double[],System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUFittingMLE">
			<summary>This class fits a univariate Ornstein-Uhlenbeck process by using MLE.<para> See also: </para>&quot;Sun, Kevin, univariate_OU_fitting.pdf&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUFittingMLE.#ctor(System.Boolean)">
			<summary>Create an instance with the option whether to estimate the volatility parameter. If the
 volatility parameter is <em>NOT</em> estimated, the fitted process will assume
 <i>&#963;=1</i>.</summary>
			<param name="estimateVolatility"><c>true</c> if volatility parameter is to be estimated</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUFittingMLE.#ctor">
			<summary>Create an instance that estimates the volatility parameter &#963;.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUFittingMLE.getFittedOU(System.Double[])">
			<summary>Fit an OU process by using MLE. By default, the time interval is assumed to be 1.</summary>
			<param name="ts">the time series</param>
			<returns>the fitted OU process</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUFittingMLE.getFittedOU(System.Double[],System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUFitting">
			<summary>This interface defines an estimation procedure to fit a univariate Ornstein-Uhlenbeck process.<para> See also: </para><a href="http://en.wikipedia.org/wiki/ornstein-uhlenbeck_process">
 Wikipedia: Ornstein-Uhlenbeck process</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OUFitting.getFittedOU(System.Double[],System.Double)">
			<summary>Get the fitted OU process.</summary>
			<param name="ts">the time series</param>
			<param name="dt">the time interval between two successive points in the time series</param>
			<returns>the fitted OU process</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OrnsteinUhlenbeckProcess">
			<summary>This class represents a univariate Ornstein-Uhlenbeck (OU) process.
 An Ornstein-Uhlenbeck process, \(x_t\), satisfies the following SDE:
 \[
 dx_t = \theta (\mu - x_t)dt + \sigma dW_t,
 \]
 where \(W_t\) represents a Wiener process.<para> See also: </para><a href="http://en.wikipedia.org/wiki/ornstein-uhlenbeck_process">
 Wikipedia: Ornstein-Uhlenbeck process</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OrnsteinUhlenbeckProcess.#ctor(System.Double,System.Double)">
			<summary>Construct a univariate OU process with unit volatility.</summary>
			<param name="mu">the overall mean</param>
			<param name="theta">the mean reversion rate</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OrnsteinUhlenbeckProcess.#ctor(System.Double,System.Double,System.Double)">
			<summary>Construct a univariate OU process.</summary>
			<param name="mu">the overall mean</param>
			<param name="theta">the mean reversion rate</param>
			<param name="sigma">the volatility</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OrnsteinUhlenbeckProcess.#ctor(com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OrnsteinUhlenbeckProcess)">
			<summary>Copy constructor.</summary>
			<param name="that">a univariate OU process</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OrnsteinUhlenbeckProcess.mu">
			<summary>Get the overall mean.</summary>
			<returns>the overall mean</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OrnsteinUhlenbeckProcess.theta">
			<summary>Get the mean reversion rate.</summary>
			<returns>the mean reversion rate</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.stochasticprocess.univariate.sde.process.ou.OrnsteinUhlenbeckProcess.sigma">
			<summary>Get the volatility.</summary>
			<returns>the volatility</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.CramerVonMises2Samples">
			<summary>This algorithm calculates the two sample Cramer-Von Mises test statistic and p-value. The p-value
 is approximated by linear interpolation.<para> See also: </para><list type="bullet">
 <item>&quot;Anderson, T. W., &quot;On the distribution of the two Sample Cramer-von Mises Criterion&quot;, The
 Annals of Mathematical Statistics, Vol. 33, No. 3, Sep. 1962, pp. 1148-1159.&quot;</item>
 <item>&quot;Anderson, T. W., Darling, D. A. &quot;Asymptotic Theory of Certain &quot;Goodness of Fit&quot; Criteria
 based on Stochastic Processes&quot;, The Annals of Mathematical Statistics, Col.23, No.2, Jun., 1952,
 pp 193-212.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.CramerVonMises2Samples.#ctor(System.Double[],System.Double[])">
			<summary>Calculate the statistics and p-value of two sample Cramer-Von Mises test.</summary>
			<param name="x1">the first sample</param>
			<param name="x2">the second sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.CramerVonMises2Samples.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.CramerVonMises2Samples.pValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.CramerVonMises2Samples.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.CramerVonMises2Samples.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.AndersonDarlingPValue">
			<summary>This algorithm calculates the p-value when the Anderson-Darling statistic and the number of
 samples are given. The p-value is calculated by the interpolation formula (section 4, p.920):
 \[
 t_m\left ( \alpha \right ) = b_0 + \frac{b_1}{\sqrt m} + \frac{b_2}{m}
 \]
 where the coefficients for each &#945; are calculated by OLS regression using data in Table 1.
 <i>m</i> is the total number of samples minus 1.
 <para/>
 We use a two-step procedure to interpolate the data in Table 1.
 In the first step, the dependent
 variables are <i>1/\sqrt(m)</i> and <i>1/m</i>, where <i>m = 1, ... 10, 1000000</i>. The
 independent variable is statistics corresponding to upper percentiles
 <i>0.25, 0.1, 0.05, 0.025, 0.01</i>. The prediction values corresponding to actual number of samples
 minus 1 are stored. Therefore there are 5 OLS regressions in this step and 5 prediction values.
 <para/>
 In the second step, the dependent variables are 5 predictions and their squares, and the
 independent variables are the p-values <i>{0.25,0.1,0.05,0.025,0.01}</i>. The p-value corresponding
 to the actual statistics <i>t<sub>m</sub></i> is predicted by the linear regression model <i>t<sub>m</sub>(\alpha)
 = b<sub>0</sub>+b<sub>1</sub>/\sqrt(m)+b<sub>2</sub>/m</i>.
 <para/>
 The details of this step is not mentioned in the paper. The process of calculating p-value
 when the statistics is not in the table is documented by only one sentence in right column
 paragraph 3, p. 920: &quot;Similarly, one could interpolate and even extrapolate p-value for the
 observed Anderson-Darling statistic; see Section 7 for an example.&quot; The author suggests using
 linear extrapolation. We use the second order extrapolation for two reasons:
 1)	By regressing the p-values against the statistics in Table 1. We found that the
 coefficient of the second order term is significant in most cases and the R square value is
 higher than the regression which only include the first order term. This indicates by
 including the second order term, the extrapolation is more accurate. Take m=1 as an example:
 the p-value of the second order coefficient is 0.03352. The corresponding R square 0.9994.
 On the other hand the R square of regression which only includes the first order term is 0.9939.
 2)	The R program includes also the second order term.<para> See also: </para>&quot;Scholz, F.W., and Stephens, M.A., &quot;K-sample Anderson-Darling Tests&quot;, Journal of the
 American Statistical Association, Vol. 82, No. 399, 1987.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.AndersonDarlingPValue.#ctor(System.Int32)">
			<summary>Construct the Anderson-Darling distribution for a particular number of samples.</summary>
			<param name="m">the number of samples minus 1</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.AndersonDarlingPValue.alpha(System.Double)">
			<summary>Gets the p-value for a test statistic.</summary>
			<param name="tm">the test statistics</param>
			<returns>the p-value corresponding to the test statistics</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.AndersonDarling">
			<summary>This algorithm calculates the Anderson-Darling k-sample test statistics and p-values.
 <para/>
 The Anderson-Darling k-sample test tests whether the k samples are from the same
 distribution, which does not needs to be specified. The results produce two statistics and two
 p-values. <i>T<sub>kN</sub></i> and <i>p<sub>kN</sub></i> are the statistic and p-value when
 there are no tied observations. <i>T<sub>akN</sub></i> and <i>p<sub>akN</sub></i> are the
 statistic and p-value when the distribution is discrete, or when the continuous data are
 grouped. Under these two circumstances there may be tied observations.<para> See also: </para>&quot;Scholz, F. W., and Stephens, M. A., &quot;K-sample Anderson-Darling Tests&quot;, Journal of the
 American Statistical Association, Vol. 82, No. 399, 1987.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.AndersonDarling.#ctor(System.Double[][])">
			<summary>Runs the Anderson-Darling test.</summary>
			<param name="x">the k samples, each sample in form of a <c>double</c> array.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.AndersonDarling.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.AndersonDarling.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.AndersonDarling.pValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.AndersonDarling.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.AndersonDarling.pValueAlternative">
			<summary>Gets the alternative p-value (adjusted for ties).</summary>
			<returns>the alternative p-value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.AndersonDarling.statisticsAlternative">
			<summary>Gets the alternative Anderson-Darling statistic (adjusted for ties).</summary>
			<returns>the alternative Anderson-Darling statistic</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution">
			<summary>Compute the p-values for the generalized (conditionally distribution-free) Smirnov homogeneity test.
 That is,
 \[
 P(D_{m,n} \geq c | H_0) = 1 - P(D_{m,n} c | H_0) = 1 - \textup{cdf}(c)
 \]
 where
 \[
 D_{m,n} = \max \left | S_m(x) - S_n(x) \right |
 \]<para> See also: </para><list type="bullet">
 <item>&quot;Andrei M. Nikiforov, &quot;Algorithm AS 288: Exact Smirnov Two-Sample Tests for Arbitrary Distributions,&quot; Royal Statistical Society, 1994.&quot;</item>
 <item>&quot;Jean Dickinson Gibbons, Subhabrata Chakraborti, &quot;Section 6.3,&quot; Nonparametric Statistical Inference, 4th edition, CRC.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.#ctor(System.Int32,System.Int32,System.Double[],com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.Side,System.Int32)">
			<summary>Construct a two-sample Kolmogorov distribution.</summary>
			<param name="n1">the size of sample 1</param>
			<param name="n2">the size of sample 2</param>
			<param name="samples">the concatenation of the two samples in <em>ascending</em> order</param>
			<param name="side">one-sided or two-sided test</param>
			<param name="bigN">the threshold to use the asymptotic distribution when <i>n &gt; bigN</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.#ctor(System.Int32,System.Int32,com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.Side,System.Int32)">
			<summary>Construct a two-sample Kolmogorov distribution,
 assuming that there is no tie in the samples.</summary>
			<param name="n1">the size of sample 1</param>
			<param name="n2">the size of sample 2</param>
			<param name="side">one-sided or two-sided test</param>
			<param name="bigN">the threshold to use the asymptotic distribution when <i>n &gt; bigN</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.#ctor(System.Int32,System.Int32,com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.Side,System.Double[])">
			<summary>Construct a two-sample Kolmogorov distribution.</summary>
			<param name="n1">the size of sample 1</param>
			<param name="n2">the size of sample 2</param>
			<param name="side">one-sided or two-sided test</param>
			<param name="samples">the concatenation of the two samples in <em>ascending</em> order</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.#ctor(System.Double[],System.Double[],com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.Side)">
			<summary>Construct a two-sample Kolmogorov distribution.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
			<param name="side">one-sided or two-sided test</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.Side">
			<summary>the available types of Kolmogorov-Smirnov two-sample test</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.Side.EQUAL">
			<summary>two-sample; two-sided</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.Side.GREATER">
			<summary>two-sample; one-sided</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.Side.LESS">
			<summary>two-sample; one-sided</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.Side.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovTwoSamplesDistribution.Side.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov2Samples">
			<summary>The two-sample Kolmogorov-Smirnov test (two-sample KS test) tests for the equality of the
 distributions of two samples.<para> See also: </para>&quot;Jean Dickinson Gibbons, Subhabrata Chakraborti, &quot;Section 6.3,&quot; Nonparametric Statistical
 Inference, 4th edition.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov2Samples.#ctor(System.Double[],System.Double[],com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Side)">
			<summary>Construct a two-sample Kolmogorov-Smirnov test.</summary>
			<param name="sample1">a sample</param>
			<param name="sample2">another sample</param>
			<param name="side">one-sided or two-sided test</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov2Samples.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov2Samples.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov1Sample">
			<summary>The one-sample Kolmogorov-Smirnov test (one-sample KS test) compares a sample with a reference probability distribution.
 This class computes the one-sample Kolmogorov-Smirnov statistic.<para> See also: </para>&quot;Jean Dickinson Gibbons, Subhabrata Chakraborti, &quot;Section 4.3,&quot; Nonparametric Statistical Inference, 4th edition.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov1Sample.#ctor(System.Double[],com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution,com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Side)">
			<summary>Construct a one-sample Kolmogorov-Smirnov test.</summary>
			<param name="sample">a sample</param>
			<param name="F">the reference probability distribution to test against</param>
			<param name="side">one-sided or two-sided test</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov1Sample.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov1Sample.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov">
			<summary>The Kolmogorov-Smirnov test (KS test) compares a sample with a reference probability distribution (one-sample KS test),
 or to compare two samples (two-sample KS test).
 The Kolmogorov-Smirnov statistic quantifies the distance between the empirical distribution function of the sample
 and the cumulative distribution function of the reference distribution (one-sample KS test),
 or between the empirical distribution functions of two samples (two-sample KS test).
 The null distribution of this statistic is calculated under the null hypothesis
 that the sample is drawn from the reference distribution (in the one-sample case), or
 that the samples are drawn from the same distribution (in the two-sample case).
 In each case, the distributions considered under the null hypothesis are continuous distributions but are otherwise unrestricted.
 The test-statistics is either <i>D<sub>n</sub></i>, <i>D<sub>n</sub><sup>+</sup></i>, or <i>D<sub>n</sub><sup>-</sup></i>,
 depending on the side to compute.
 <para/>
 By R convention, when the exact p-value is not available, we use the limiting distribution.
 The exact p-value is not available in the case of ties for the one-sample case.
 <para/>
 The R equivalent function is <c>ks.test</c>.<para> See also: </para><list type="bullet">
 <item>Jean Dickinson Gibbons, Subhabrata Chakraborti, Nonparametric Statistical Inference. 4th edition. CRC.</item>
 <item><a href="http://en.wikipedia.org/wiki/kolmogorov%e2%80%93smirnov_test">Wikipedia: Kolmogorov-Smirnov test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Type">
			<summary>the available types of the Kolmogorov-Smirnov tests</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Type.ONE_SAMPLE">
			<summary>the one-sample Kolmogorov-Smirnov test</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Type.TWO_SAMPLE">
			<summary>the two-sample Kolmogorov-Smirnov test</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Type.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Type.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Side">
			<summary>the available types of the Kolmogorov-Smirnov statistic</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Side.TWO_SIDED">
			<summary>compute <i>D<sub>n</sub></i></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Side.GREATER">
			<summary>compute <i>D<sub>n</sub><sup>+</sup></i>;
 check whether the cdf of a sample lies above the null hypothesis</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Side.LESS">
			<summary>compute <i>D<sub>n</sub><sup>-</sup></i>;
 check whether the cdf of a sample lies below the null hypothesis</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Side.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovSmirnov.Side.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution">
			<summary>Compute the probability that <i>F(x)</i> is dominated by the upper confidence contour, for all <i>x</i>:
 <blockquote><i>
 Pn(&#949;) = Pr{F(x) &lt; min{Fn(x) + &#949;, 1}}
 </i></blockquote><para> See also: </para><list type="bullet">
 <item>&quot;Z. W. Birnbaum and Fred H. Tingey, &quot;One-sided confidence contours for probability distribution functions,&quot; The Annals of Mathematical Statistics, Vol. 22, No. 4 (Dec., 1951), p. 592-596.&quot;</item>
 <item>&quot;N. Smirnov, &quot;Sur les 6carts de la courbe de distribution empirique,&quot; Rec. Math. (Mat.Sbornik), N. S. Vol. 6 (48) (1939), p. 3-26.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.#ctor(System.Int32,System.Int32)">
			<summary>Construct a one-sided Kolmogorov distribution.</summary>
			<param name="n">the number of observations</param>
			<param name="bigN">the threshold to use the asymptotic distribution when <i>n &gt; bigN</i></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.#ctor(System.Int32)">
			<summary>Construct a one-sided Kolmogorov distribution.
 We use the asymptotic distribution for <i>n &gt; 50</i>.</summary>
			<param name="n">the number of observations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.asymptoticCDF(System.Double,System.Double)">
			<summary>This is the asymptotic distribution of the one-sided Kolmogorov distribution.<para> See also: </para>&quot;N. Smirnov, &quot;Sur les 6carts de la courbe de distribution empirique,&quot; Rec. Math. (Mat.Sbornik), N. S. Vol. 6 (48) (1939), p. 3-26.&quot;</summary>
			<param name="m">a scaling factor; usually a function of the size of the sample(s)</param>
			<param name="x"><i>x</i></param>
			<returns><i>Pr(x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovOneSidedDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution">
			<summary>The Kolmogorov distribution is the distribution of the Kolmogorov-Smirnov statistic.
 The statistic is defined as the supremum of the absolute difference between the empirical and reference distributions.<para> See also: </para><list type="bullet">
 <item>&quot;George Marsaglia, Wai Wan Tsang, Jingbo Wang, &quot;Evaluating Kolmogorov&apos;s distribution,&quot; Journal of Statistical Software, 8/18.&quot;</item>
 <item>&quot;J. H. Drew, A. G. Glen, and L. M. Leemis, &quot;Computing the cumulative distribution function of the Kolmogorov-Smirnov statistic,&quot; Computational Statistics and Data Analysis 34 (2000) 1-15.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/kolmogorov_distribution#kolmogorov_distribution">Wikipedia: Kolmogorov distribution</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.#ctor(System.Int32,System.Int32,System.Boolean)">
			<summary>Construct a Kolmogorov distribution for a sample size <i>n</i>.</summary>
			<param name="n">the number of observations</param>
			<param name="bigN">the threshold to use the asymptotic distribution when <i>n &gt; bigN</i></param>
			<param name="rightTailApproximation"><c>true</c> if we use the right tail approximation; the accuracy is up to 7 digits</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.#ctor(System.Int32)">
			<summary>Construct a Kolmogorov distribution for a sample size <i>n</i>.
 We use the asymptotic distribution when <i>n &gt; 16000</i>.
 We use an approximation for the right tail.</summary>
			<param name="n">the number of observations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.asymptoticCDF(System.Double)">
			<summary>This is the asymptotic distribution of the Kolmogorov distribution.<para> See also: </para><a href="http://en.wikipedia.org/wiki/kolmogorovdistribution%e2%80%93smirnov_test#kolmogorov_distribution">Wikipedia: Kolmogorov distribution</a></summary>
			<param name="x">a critical value</param>
			<returns><i>F(x)</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.kolmogorov.KolmogorovDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilkDistribution">
			<summary>Shapiro-Wilk distribution is the distribution of the Shapiro-Wilk statistics,
 which tests the null hypothesis that a sample comes from a normally distributed population.
 <para/>
 This is an implementation of ALGORITHM AS R94.
 Although our implementation allows for sample size &gt; 5000, its validity is not rigorously established.<para> See also: </para><list type="bullet">
 <item>Patrick Royston, &quot;A Remark on Algorithm AS 181: The W Test for Normality,&quot; Applied Statistics, 44, 547-551, 1995.</item>
 <item>Patrick Royston, &quot;Approximating the Shapiro-Wilk W-test for non-normality,&quot; Statistics and Computing, Volume 2, Number 3, 117-119.</item>
 <item>Patrick Royston, &quot;Algorithm AS 181: The W Test for Normality,&quot; Applied Statistics, 31, 176-180, 1982.</item>
 <item><a href="http://en.wikipedia.org/wiki/shapiro-wilk">Wikipedia: Shapiro-Wilk test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilkDistribution.#ctor(System.Int32)">
			<summary>Construct a Shapiro-Wilk distribution.</summary>
			<param name="n">the number of observations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilkDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilkDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilkDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilkDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilkDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilkDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilkDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilkDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilkDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilkDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilk">
			<summary>The Shapiro-Wilk test tests the null hypothesis that a sample comes from a normally distributed population.
 The sample size must be between 3 and 5000.
 <para/>
 The R equivalent function is <c>shapiro.test</c>.<para> See also: </para><list type="bullet">
 <item>Patrick Royston, &quot;A Remark on Algorithm AS 181: The W Test for Normality,&quot; Applied Statistics, 44, 547-551, 1995.</item>
 <item>Patrick Royston, &quot;Approximating the Shapiro-Wilk W-test for non-normality,&quot; Statistics and Computing, Volume 2, Number 3, 117-119, 1992.</item>
 <item>Patrick Royston, &quot;An Extension of Shapiro and Wilk&apos;s W Test for Normality to Large Samples,&quot; Applied Statistics, 31, 115-124, 1982d.</item>
 <item>Patrick Royston, &quot;Algorithm AS 181: The W Test for Normality,&quot; Applied Statistics, 31, 176-180. 1982c.</item>
 <item>Patrick Royston, &quot;An extension of Shapiro and Wilk&apos;s Wtest for normality to large samples,&quot; Appl. Statist., 31, 115-124, 1982b.</item>
 <item>Patrick Royston, &quot;Algorithm AS177. Expected normal order statistics (exact and approximate),&quot; Applied Statistics, 31, 161-165, 1982a.</item>
 <item><a href="http://en.wikipedia.org/wiki/shapiro%e2%80%93wilk_test">Wikipedia: Shapiro-Wilk test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilk.#ctor(System.Double[])">
			<summary>Perform the Shapiro-Wilk test to test for the null hypothesis that a sample comes from a normally distributed population.</summary>
			<param name="sample">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilk.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilk.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilk.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.ShapiroWilk.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.normality.Lilliefors">
			<summary>Lilliefors test tests the null hypothesis that data come from a normally distributed population with an estimated sample mean and variance.
 The test statistic is the maximal absolute difference between empirical and the hypothetical Normal distribution function.
 Since the hypothesized cdf has been moved closer to the data by estimation based on the data,
 the &quot;null distribution&quot; of the test statistic, i.e. its probability distribution assuming the null hypothesis is true,
 is stochastically smaller than the Kolmogorov-Smirnov distribution, hence the Lilliefors distribution.
 <para/>
 In this implementation, we first compute the p-value from the Dallal-Wilkinson (1986) formula, which is claimed to be only reliable when the p-value is smaller than 0.1.
 When this p-value is &gt; 0.1, we compute again the p-value from the distribution of the modified statistic (Stephen 1974).
 <para/>
 The R equivalent function is <c>lillie.test</c> in package <c>nortest</c>.<para> See also: </para><list type="bullet">
 <item>G. E. Dallal, L. Wilkinson, &quot;An analytic approximation to the distribution of Lilliefors&apos; test for normality,&quot; The American Statistician, 40, 294-296, 1986.</item>
 <item>M. A. Stephens, &quot;EDF statistics for goodness of fit and some comparisons,&quot; Journal of the American Statistical Association, 69, 730-737, 1974.</item>
 <item><a href="http://en.wikipedia.org/wiki/lilliefors_test">Wikipedia: Lilliefors test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.Lilliefors.#ctor(System.Double[])">
			<summary>Perform the Lilliefors test to test for the null hypothesis that data come from a normally distributed population with an estimated sample mean and variance.</summary>
			<param name="sample">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.Lilliefors.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.Lilliefors.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.Lilliefors.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.Lilliefors.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.normality.JarqueBeraDistribution">
			<summary>Jarque-Bera distribution is the distribution of the Jarque-Bera statistics, which measures the departure from normality.
 The statistics is
 \[
 JB = \frac{n}{6}[S^2 + \frac{K^2}{4}]
 \]
 <i>S</i> is the skewness; <i>K</i> is the kurtosis.<para> See also: </para><a href="http://en.wikipedia.org/wiki/jarque%e2%80%93bera_test">Wikipedia: Jarque-Bera test</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.JarqueBeraDistribution.#ctor(System.Int32,System.Int32,com.numericalmethod.suanshu.stats.random.univariate.normal.StandardNormalRNG)">
			<summary>Construct a Jarque-Bera distribution using Monte Carlo simulation.</summary>
			<param name="N">the number of observations in a sample</param>
			<param name="nSim">the number of simulations</param>
			<param name="rnorm">a Gaussian random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.JarqueBeraDistribution.#ctor(System.Int32,System.Int32)">
			<summary>Construct a Jarque-Bera distribution using Monte Carlo simulation.</summary>
			<param name="N">the number of observations in a sample</param>
			<param name="nSim">the number of simulations</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.normality.JarqueBera">
			<summary>The Jarque-Bera test is a goodness-of-fit measure of departure from normality, based on the sample kurtosis and skewness.
 The JB statistic has an asymptotic chi-square distribution with two degrees of freedom and
 can be used to test the null hypothesis that the data are from a normal distribution.
 The null hypothesis is a joint hypothesis of the skewness being 0 and the excess kurtosis being 0,
 since samples from a normal distribution have an expected skewness of 0 and an expected excess kurtosis of 0 (which is the same as a kurtosis of 3).
 As the definition of JB shows, any deviation from this increases the JB statistic.
 <para/>
 The R equivalent function is <c>rjb.test</c> in package <c>lawstat</c>, or  <c>jarque.bera.test</c> in package <c>tseries</c> for <i>N &gt; 2000</i>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/jarque%e2%80%93bera_test">Wikipedia: Jarque-Bera test</a></summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.normality.JarqueBera.nSim">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.JarqueBera.#ctor(System.Double[],System.Boolean)">
			<summary>Perform the Jarque-Bera test to test for the departure from normality.</summary>
			<param name="sample">a sample</param>
			<param name="isExact"><c>true</c> if the exact Jarque-Bera distribution is to be used</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.JarqueBera.#ctor(System.Double[])">
			<summary>Perform the Jarque-Bera test to test for the departure from normality,
 using the asymptotic chi-square distribution.</summary>
			<param name="sample">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.JarqueBera.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.JarqueBera.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.JarqueBera.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.JarqueBera.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.normality.DAgostino">
			<summary>D&apos;Agostino&apos;s K<sup>2</sup> test is a goodness-of-fit measure of departure from normality.
 It tests whether or not a given sample comes from a normally distributed population.
 The test is based on transformations of the sample kurtosis and skewness,
 and has power only against the alternatives that the distribution is skewed and/or kurtic.
 <para/>
 The R equivalent function is <c>dagoTest</c> in <c>fBasics</c>.<para> See also: </para>&quot;Ralph B. D&apos;Agostino, Albert Belanger, and Ralph B. D&apos;Agostino, Jr. &quot;A Suggestion for Using Powerful and Informative Tests of Normality&quot;, The American Statistician, Vol. 44, No. 4. (Nov., 1990), pp. 316-321.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.DAgostino.#ctor(System.Double[])">
			<summary>Perform D&apos;Agostino&apos;s test to test for the departure from normality.</summary>
			<param name="sample">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.DAgostino.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.DAgostino.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.DAgostino.Z1">
			<summary>Get Z1.
 NB: the paper is inconsistent about which skewness value to use; either the unbiased or the biased one.
 The derivation in Section 3 uses the biased estimator but the numerical example in Section 5 use the unbiased indicator.</summary>
			<returns>Z1</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.DAgostino.Z2">
			<summary>Get Z1.
 NB: the paper is inconsistent about which skewness value to use; either the unbiased or the biased one.
 The derivation in Section 3 uses the biased estimator but the numerical example in Section 5 use the unbiased indicator.</summary>
			<returns>Z1</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.DAgostino.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.DAgostino.pValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.DAgostino.pvalueZ1">
			<summary>Get the p-value for Z1.</summary>
			<returns>the p-value for Z1</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.normality.DAgostino.pvalueZ2">
			<summary>Get the p-value for Z2.</summary>
			<returns>the p-value for Z2</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.pearson.FisherExactDistribution">
			<summary>Fisher&apos;s exact test distribution is, as its name states, exact, and can therefore be used regardless of the sample characteristics.
 It converges asymptotically to Chi-square distribution for a large and well balanced sample.
 For a set of small, sparse, or unbalanced data,
 the exact and asymptotic p-values can be quite different and may lead to opposite conclusions concerning the hypothesis of interest.
 The exact distribution becomes difficult to calculate with large samples or well-balanced tables,
 but fortunately these are precisely the conditions where the chi-square distribution is appropriate.<para> See also: </para><a href="http://en.wikipedia.org/wiki/fisher%27s_exact_test">Wikipedia: Fisher&apos;s exact test</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.FisherExactDistribution.#ctor(System.Int32[],System.Int32[],System.Int32,System.Int64)">
			<summary>Construct the distribution for Fisher&apos;s exact test.</summary>
			<param name="rowSums">the row totals</param>
			<param name="colSums">the column totals</param>
			<param name="nSims">the number of simulations</param>
			<param name="seed">a seed to repeat the exact simulation</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.FisherExactDistribution.#ctor(System.Int32[],System.Int32[],System.Int32)">
			<summary>Construct the distribution for Fisher&apos;s exact test.</summary>
			<param name="rowSums">the row totals</param>
			<param name="colSums">the column totals</param>
			<param name="nSims">the number of simulations</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest">
			<summary>Pearson&apos;s chi-square test of independence assesses whether paired observations on two variables,
 expressed in a contingency table, are independent of each other.<para> See also: </para><a href="http://en.wikipedia.org/wiki/pearson%27s_chi-square_test">
 Wikipedia: Pearson&apos;s chi-square test</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Int32,com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.Type)">
			<summary>Assess whether the two random variables in the contingency table are independent.</summary>
			<param name="sample">a contingency table</param>
			<param name="nSims">the number of simulations when EXACT distribution is used</param>
			<param name="type">the type of distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.#ctor(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Assess whether the two random variables in the contingency table are independent.</summary>
			<param name="sample">a contingency table</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.pValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.getExpectedContingencyTable(System.Int32[],System.Int32[])">
			<summary>Assume the null hypothesis of independence, we compute the expected frequency of each
 category.</summary>
			<param name="rowSums">the row totals</param>
			<param name="colSums">the column totals</param>
			<returns>a table of expected frequencies under the null hypothesis</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.pearsonStat(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix,System.Boolean)">
			<summary>Compute the Pearson&apos;s cumulative test statistic, which asymptotically approaches a
 <i>&#967;2</i> distribution.</summary>
			<param name="O">the observation matrix</param>
			<param name="E">the expectation matrix</param>
			<param name="YatesContinuityCorrection"><c>true</c> if to minus <i>0.5</i> for each observation in
                                  the test statistics</param>
			<returns>the Pearson&apos;s cumulative test statistic</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.Type">
			<summary>the available distributions used for the test</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.Type.ASYMPTOTIC">
			<summary>The default is the asymptotic distribution of Fisher&apos;s exact test.
 It is appropriate for a large and well balanced sample.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.Type.EXACT">
			<summary>This is the exact distribution for Fisher&apos;s exact test.
 It is appropriate when the sample size is small and the contingency table unbalanced.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.Type.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.ChiSquareIndependenceTest.Type.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.pearson.AS159">
			<summary>Algorithm AS 159 accepts a table shape (the number of rows and columns), and two vectors, the
 lists of row and column sums. There may be 0, 1, or many tables with nonnegative, integral
 entries that have the given shape and sums. If there is at least one candidate, then the routine
 will choose one, uniformly over the number of distinct candidates. The routine will report the
 case if there are no candidates.
 <para/>
 Other implementations includes <c>rcont2</c>. For example,
 <list type="bullet">
 <item>https://svn.r-project.org/R/trunk/src/library/stats/src/rcont.c</item>
 <item>http://people.sc.fsu.edu/~jburkardt/c_src/asa159/asa159.c</item>
 <item>http://lib.stat.cmu.edu/apstat/159</item>
 </list><para> See also: </para>&quot;W. M. Patefield, &quot;Algorithm AS 159: An Efficient Method of Generating RXC Tables with Given
 Row and Column Totals,&quot; Applied Statistics, Volume 30, Number 1, 1981, pages 91-97.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.AS159.#ctor(System.Int32[],System.Int32[])">
			<summary>Constructs a random table generator according to the row and column totals.</summary>
			<param name="rowSums">the row totals</param>
			<param name="colSums">the column totals</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.AS159.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.AS159.isValidated(com.numericalmethod.suanshu.algebra.linear.matrix.doubles.Matrix)">
			<summary>Checks whether a matrix satisfies the row and column sums.</summary>
			<param name="A">a matrix</param>
			<returns><c>true</c> if <c>A</c> satisfies the constraints</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.AS159.nextMatrix">
			<summary>Constructs a random matrix based on the row and column sums.</summary>
			<returns>a random matrix</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.distribution.pearson.AS159.RandomMatrix">
			<summary>a random matrix generated by AS159 and its probability</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.pearson.AS159.RandomMatrix.A">
			<summary>a random matrix constructed by AS159</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.distribution.pearson.AS159.RandomMatrix.prob">
			<summary>the probability of observing this matrix</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.distribution.pearson.AS159.RandomMatrix.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.HypothesisTest">
			<summary>A statistical hypothesis test is a method of making decisions using experimental data.
 A result is called statistically significant if it is unlikely to have occurred by chance.
 Specifically, given a null hypothesis, we compute the p-value of a test statistics.
 The p-value tells the probability of observing the observations under the null.
 We often accept the alternative hypothesis, (i.e. rejects a null hypothesis) if
 the p-value is less than 0.05 or 0.01, corresponding respectively to a 5% or 1% chance of rejecting the null hypothesis when it is true.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/statistical_hypothesis_testing">Wikipedia: Statistical hypothesis testing</a></item>
 <item><a href="http://en.wikipedia.org/wiki/test_statistic">Wikipedia: Test statistic</a></item>
 <item><a href="http://en.wikipedia.org/wiki/p-value">Wikipedia: P-value</a></item>
 <item><a href="http://en.wikipedia.org/wiki/null_hypothesis">Wikipedia: Null hypothesis</a></item>
 <item><a href="http://en.wikipedia.org/wiki/alternative_hypothesis">Wikipedia: Alternative hypothesis</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.HypothesisTest.#ctor(System.Double[][])">
			<summary>Construct an instance of <c>HypothesisTest</c> from the samples.</summary>
			<param name="samples">an array of samples</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.HypothesisTest.statistics">
			<summary>Get the test statistics.<para> See also: </para><a href="http://en.wikipedia.org/wiki/test_statistic">Wikipedia: Test statistic</a></summary>
			<returns>the test statistics</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.HypothesisTest.pValue">
			<summary>Get the p-value for the test statistics.<para> See also: </para><a href="http://en.wikipedia.org/wiki/p-value">Wikipedia: P-value</a></summary>
			<returns>the p-value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.HypothesisTest.nGroups">
			<summary>Get the number of groups of observations.</summary>
			<returns>the number of groups of observations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.HypothesisTest.nObs">
			<summary>Get the total number of observations.</summary>
			<returns>the total number of observations</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.HypothesisTest.isNullRejected(System.Double)">
			<summary>Use the p-value to check whether the null hypothesis can be rejected for a given significance level.
 That is, the probability of making the observations under the null is small.</summary>
			<param name="alpha">a significance level of test</param>
			<returns><c>true</c> if the hypothesis is rejected due to <i>p-value &lt; &#945;</i></returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.HypothesisTest.getNullHypothesis">
			<summary>Get a description of the null hypothesis.<para> See also: </para><a href="http://en.wikipedia.org/wiki/null_hypothesis">Wikipedia: Null hypothesis</a></summary>
			<returns>the null hypothesis description</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.HypothesisTest.getAlternativeHypothesis">
			<summary>Get the description of the alternative hypothesis.<para> See also: </para><a href="http://en.wikipedia.org/wiki/alternative_hypothesis">Wikipedia: Alternative hypothesis</a></summary>
			<returns>the alternative hypothesis description</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.HypothesisTest.oneSidedPvalue(com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution,System.Double)">
			<summary>The one-sided p-value is the probability of observing a test statistic <em>at least</em> as extreme as the one observed.
 For a continuous distribution, it is given by the complementary cumulative distribution function (survival function).
 For a discrete distribution, we need to add also the probability of observing the critical value.</summary>
			<param name="F">a univariate distribution</param>
			<param name="x">the critical value</param>
			<returns>the p-value for the critical value</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.mean.T">
			<summary>Student&apos;s t-test tests for the equality of means,
 for the one-sample case, against a hypothetical mean,
 and for two-sample case, of two populations.
 <para/>
 Welch&apos;s t-test is an adaptation of Student&apos;s t-test intended for use with two samples having possibly <em>unequal</em> variances.
 <para/>
 The R equivalent function is <c>t.test</c>.<para> See also: </para><list type="bullet">
 <item>Richard D. De Veaux, Paul F. Velleman, David E. Bock. &quot;Chapter 24,&quot; Stats: Data and Models.</item>
 <item><a href="http://en.wikipedia.org/wiki/student's_t-test">Student&apos;s t-test</a></item>
 <item><a href="http://en.wikipedia.org/wiki/welch%27s_t_test">Welch&apos;s t-test</a></item>
 <item><a href="http://en.wikipedia.org/wiki/welch-satterthwaite_equation">Welch-Satterthwaite equation</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.#ctor(System.Double[],System.Double)">
			<summary>Construct a one-sample location test of whether the mean of a normally distributed population has a value specified in a null hypothesis.</summary>
			<param name="sample">a sample</param>
			<param name="mu">the hypothetical mean in the null hypothesis</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.#ctor(System.Double[],System.Double[])">
			<summary>Construct Welch&apos;s t-test, an adaptation of Student&apos;s t-test, for the use with two samples having possibly <em>unequal</em> variances.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.#ctor(System.Double[],System.Double[],System.Double)">
			<summary>Construct Welch&apos;s t-test, an adaptation of Student&apos;s t-test, for the use with two samples having possibly <em>unequal</em> variances.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
			<param name="mu">the hypothetical mean-difference in the null hypothesis</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.#ctor(System.Double[],System.Double[],System.Boolean,System.Double)">
			<summary>Construct a two sample location test of the null hypothesis that the means of two normally distributed populations are equal.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
			<param name="isEqualVar"><c>true</c> if we assume the variances of the two samples are equal; <c>false</c> otherwise</param>
			<param name="mu">the hypothetical mean-difference in the null hypothesis. The default value is 0.</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.pValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.rightOneSidedPvalue">
			<summary>Get the right, one-sided p-value.</summary>
			<returns>the right, one-sided p-value.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.leftOneSidedPvalue">
			<summary>Get the left, one-sided p-value.</summary>
			<returns>the left, one-sided p-value.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.confidenceInterval(System.Double)">
			<summary>Get the confidence interval.</summary>
			<param name="confidence">the confidence level, e.g., for a 2-sided 95% confidence interval, we use 0.975 because 1 - 0.95 = 2 * (1 - 0.025)</param>
			<returns>the left and right interval values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.rightConfidenceInterval(System.Double)">
			<summary>Get the one sided right confidence interval, <i>[a, &#8734;)</i></summary>
			<param name="confidence">the confidence level, e.g., 0.95 for 95% confidence interval</param>
			<returns>the left interval value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.leftConfidenceInterval(System.Double)">
			<summary>Get the one sided left confidence interval, <i>[0, a]</i></summary>
			<param name="confidence">the confidence level, e.g., 0.95 for 95% confidence interval</param>
			<returns>the right interval value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.df">
			<summary>Get the degree of freedom.</summary>
			<returns>the degree of freedom</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.mean1">
			<summary>Get the mean of the first sample.</summary>
			<returns>the mean of the first sample</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.T.mean2">
			<summary>Get the mean of the second sample.</summary>
			<returns>the mean of the second sample</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.mean.OneWayANOVA">
			<summary>The One-Way ANOVA test tests for the equality of the means of several groups.
 ANOVAs are helpful because they possess an advantage over a two-sample t-test.
 Doing multiple two-sample t-tests would result in an increased chance of committing a type I error.
 For this reason, ANOVAs are useful in comparing three or more means.

 <para/>
 The R equivalent function is <c>aov</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/analysis_of_variance">Wikipedia: ANOVA</a></item>
 <item><a href="http://en.wikipedia.org/wiki/analysis_of_variance#the_f-test">Wikipedia: The FDistribution-test</a></item>
 <item><a href="http://en.wikipedia.org/wiki/fdistribution-test">Wikipedia: FDistribution-test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.OneWayANOVA.#ctor(System.Double[][])">
			<summary>Perform the one-way ANOVA test to test for the equality of the means of several groups.</summary>
			<param name="samples">the samples</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.OneWayANOVA.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.OneWayANOVA.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.OneWayANOVA.df1">
			<summary>Get the first degree of freedom.</summary>
			<returns>the first degree of freedom</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.OneWayANOVA.df2">
			<summary>Get the second degree of freedom.</summary>
			<returns>the second degree of freedom</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.OneWayANOVA.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.mean.OneWayANOVA.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.rank.VanDerWaerden">
			<summary>The Van der Waerden test tests for the equality of all population distribution functions.
 It converts the ranks from a standard Kruskal-Wallis one-way analysis of variance to quantiles of the standard normal distribution.
 These are called normal scores and the test is computed from these normal scores.<para> See also: </para><a href="http://en.wikipedia.org/wiki/van_der_waerden_test">Wikipedia: Van der Waerden test</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.VanDerWaerden.#ctor(System.Double[][])">
			<summary>Perform the Van Der Waerden test to test for the equality of all population distribution functions.</summary>
			<param name="samples">samples</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.VanDerWaerden.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.VanDerWaerden.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.VanDerWaerden.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.VanDerWaerden.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.rank.SiegelTukey">
			<summary>The Siegel-Tukey test tests for differences in scale (variability) between two groups.
 The test is used to determine if one of two groups of data tends to have more widely dispersed
 values than the other.
 In other words, the test determines whether one of the two groups tends to move, sometimes to the
 right, sometimes to the left, but away from the center (of the ordinal scale).<para> See also: </para><a href="http://en.wikipedia.org/wiki/siegel%e2%80%93tukey_test">Wikipedia: iegel-Tukey
 test</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.SiegelTukey.#ctor(System.Double[],System.Double[],System.Double,System.Boolean)">
			<summary>Perform the Siegel-Tukey test to test for differences in scale (variability) between two
 groups.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
			<param name="mu">the hypothetical mean difference</param>
			<param name="isExact">indicate whether the exact Wilcoxon Rank Sum distribution is used</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.SiegelTukey.#ctor(System.Double[],System.Double[],System.Double)">
			<summary>Perform the Siegel-Tukey test to test for differences in scale (variability) between two
 groups.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
			<param name="mu">the hypothetical mean difference</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.SiegelTukey.#ctor(System.Double[],System.Double[])">
			<summary>Perform the Siegel-Tukey test to test for differences in scale (variability) between two
 groups.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.SiegelTukey.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.SiegelTukey.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.SiegelTukey.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.SiegelTukey.pValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.SiegelTukey.rightOneSidedPvalue">
			<summary>Get the right, one-sided p-value.</summary>
			<returns>the right, one-sided p-value.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.SiegelTukey.leftOneSidedPvalue">
			<summary>Get the left, one-sided p-value.</summary>
			<returns>the left, one-sided p-value.</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.rank.KruskalWallis">
			<summary>The Kruskal-Wallis test is a non-parametric method for testing the equality of population medians among groups.
 It is identical to a one-way analysis of variance with the data replaced by their ranks.
 Since it is a non-parametric method, the Kruskal-Wallis test does not assume a normal population,
 unlike the analogous one-way analysis of variance.
 However, the test does assume an identically-shaped and scaled distribution for each group, except for any difference in medians.
 <para/>
 TODO: correction for ties
 <para/>
 The R equivalent function is <c>kruskal.test</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/kruskal-wallis">Wikipedia: Kruskal-Wallis one-way analysis of variance</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.KruskalWallis.#ctor(System.Double[][])">
			<summary>Construct a Kruskal-Wallis test for the equality of medians of groups.</summary>
			<param name="samples">samples</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.KruskalWallis.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.KruskalWallis.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.KruskalWallis.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.KruskalWallis.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution">
			<summary>Compute the exact distribution of the Wilcoxon signed rank test statistic.
 <para/>
 Let <i>x</i> be a sample of size <i>N</i> from a continuous distribution symmetric about the origin.
 The Wilcoxon signed rank statistic is the sum of the ranks of the absolute values <i>x[i]</i> for which <i>x[i]</i> are positive.
 This statistic takes values between 0 and <i>N(N+1)/2</i>.
 <para/>
 The R equivalent functions are <c>dsignrank, pdsignrank, qdsignrank, rdsignrank</c>.<para> See also: </para>&quot;Zbynek Sidak, Pranab K. Sen, Jaroslav Hajek. &quot;Theorems 2, Section 5.3, p.173,&quot; Theory of Rank Tests.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.#ctor(System.Int32)">
			<summary>Construct a Wilcoxon Signed Rank distribution for a sample size <c>N</c>.</summary>
			<param name="N">the number of observations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.rightOneSidedPvalue(System.Double)">
			<summary>Compute the one-sided p-value for the statistic greater than a critical value.</summary>
			<param name="x">a critical value</param>
			<returns>the one-sided p-value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRankDistribution.pValue(System.Double)">
			<summary>Compute the two-sided p-value for a critical value.</summary>
			<param name="x">a critical value</param>
			<returns>the p-value</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRank">
			<summary>The Wilcoxon signed rank test tests,
 for the one-sample case, the median of the distribution against a hypothetical median, and
 for the two-sample case, the equality of medians of groups.
 Unlike the Student&apos;s t-test, the Wilcoxon signed rank test does not assume any distribution of the population.
 <para/>
 The R equivalent function is <c>wilcox.test</c>.<para> See also: </para><list type="bullet">
 <item>&quot;Gibbons and Chakraborti, Nonparameric statistical inference (2003), Chapter 5.7, p.197.&quot;</item>
 <item><a href="http://en.wikipedia.org/wiki/wilcoxon_signed-rank_test">Wikipedia: Wilcoxon signed-rank test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRank.#ctor(System.Double[],System.Double[],System.Double,System.Boolean)">
			<summary>Perform the Wilcoxon Signed Rank test to test for the equality of medians.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
			<param name="mu">the hypothetical median that the distribution is symmetric about</param>
			<param name="isExact"><c>true</c> if to use the exact distribution; otherwise, normal approximation is used</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRank.#ctor(System.Double[],System.Double[])">
			<summary>Perform the Wilcoxon Signed Rank test to test for the equality of medians.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRank.#ctor(System.Double[],System.Int32)">
			<summary>Perform the Wilcoxon Signed Rank test to test for the equality of medians.</summary>
			<param name="sample">a sample</param>
			<param name="mu">the hypothetical median that the distribution is symmetric about</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRank.#ctor(System.Double[])">
			<summary>Perform the Wilcoxon Signed Rank test to test for the equality of medians.</summary>
			<param name="sample">a sample</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRank.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRank.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRank.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRank.pValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRank.rightOneSidedPvalue">
			<summary>Get the right, one-sided p-value.</summary>
			<returns>the right, one-sided p-value.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonSignedRank.leftOneSidedPvalue">
			<summary>Get the left, one-sided p-value.</summary>
			<returns>the left, one-sided p-value.</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution">
			<summary>Compute the exact distribution of the Wilcoxon rank sum test statistic.
 Let <i>x</i> and <i>y</i> be two random, independent samples of sizes <i>M</i> and <i>N</i>.
 The Wilcoxon rank sum statistic is the number of all pairs <i>(x[i], y[j])</i> for which <i>y[j]</i> is not greater than <i>x[i]</i>.
 This statistic takes values between 0 and <i>M * N</i>.
 <para/>
 The R equivalent functions are <c>dwilcox, pwilcox, qwilcox, rwilcox</c>.<para> See also: </para>&quot;Zbynek Sidak, Pranab K. Sen, Jaroslav Hajek. &quot;Theorems 1, Section 5.3, p.173,&quot; Theory of Rank Tests.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.#ctor(System.Int32,System.Int32)">
			<summary>Construct a Wilcoxon Rank Sum distribution for sample sizes <c>M</c> and <c>N</c>.</summary>
			<param name="M">the number of observations in group 1</param>
			<param name="N">the number of observations in group 2</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.entropy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.rightOneSidedPvalue(System.Double)">
			<summary>Compute the one-sided p-value for the statistic greater than a critical value.</summary>
			<param name="x">a critical value</param>
			<returns>the right, one-sided p-value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSumDistribution.pValue(System.Double)">
			<summary>Compute the two-sided p-value for a critical value.</summary>
			<param name="x">a critical value</param>
			<returns>the p-value</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSum">
			<summary>The Wilcoxon rank sum test tests for the equality of means of two populations, or whether the means differ by an offset.
 That is, it tests the null hypothesis that the distribution <i>x - y</i> is symmetric about <c>mu</c>.
 This test is also called the Mann-Whitney-Wilcoxon, Mann-Whitney-U, or Wilcoxon-Mann-Whitney test.
 <para/>
 The R equivalent function is <c>wilcox.test</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/mann%e2%80%93whitney_u">Wikipedia: Mann-Whitney U</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSum.#ctor(System.Double[],System.Double[],System.Double,System.Boolean,System.Boolean)">
			<summary>Perform the Wilcoxon Rank Sum test to test for the equality of means of two populations, or whether the means differ by an offset.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
			<param name="mu">the hypothetical location that the <i>(sample1 - sample2)</i> is symmetric about</param>
			<param name="isExact"><c>true</c> if to use the exact distribution; otherwise, normal approximation is used</param>
			<param name="isCorrected"><c>true</c> if to use the continuity correction for the normal distribution; otherwise, standard normal approximation is used</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSum.#ctor(System.Double[],System.Double[],System.Double,System.Boolean)">
			<summary>Perform the Wilcoxon Rank Sum test to test for the equality of means of two populations, or whether the means differ by an offset.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
			<param name="mu">the hypothetical location that the <i>(sample1 - sample2)</i> is symmetric about</param>
			<param name="isExact"><c>true</c> if to use the exact distribution; otherwise, normal approximation is used</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSum.#ctor(System.Double[],System.Double[],System.Double)">
			<summary>Perform the Wilcoxon Rank Sum test to test for the equality of means of two populations, or whether the means differ by an offset.
 The exact distribution is used for sample size &lt; 50.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
			<param name="mu">the hypothetical location that the <i>(sample1 - sample2)</i> is symmetric about</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSum.#ctor(System.Double[],System.Double[])">
			<summary>Perform the Wilcoxon Rank Sum test to test for the equality of means of two populations.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSum.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSum.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSum.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSum.pValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSum.rightOneSidedPvalue">
			<summary>Get the right, one-sided p-value.</summary>
			<returns>the right, one-sided p-value.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.rank.wilcoxon.WilcoxonRankSum.leftOneSidedPvalue">
			<summary>Get the left, one-sided p-value.</summary>
			<returns>the left, one-sided p-value.</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.White">
			<summary>The White test tests for conditional heteroskedasticity.
 It is a chi-squared test: the test statistic is n&#967;<sup>2</sup> with <i>k</i> degrees of freedom.
 If the White test shows that there is conditional heteroskedasticity, we can consider a GARCH model.<para> See also: </para><list type="bullet">
 <item>H. White, &quot;A Heteroskedasticity-Consistent Covariance Matrix Estimator and a Direct Test for Heteroskedasticity,&quot; Econometrica 48 (4): 817-838, MR575027 JSTOR 1912934, 1980.</item>
 <item>R. Koenker, &quot;A Note on Studentizing a Test for Heteroskedasticity,&quot; Journal of Econometrics 17, 107-112, 1981.</item>
 <item><a href="http://en.wikipedia.org/wiki/white_test">Wikipedia: White test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.White.#ctor(com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals)">
			<summary>Perform the White test to test for heteroskedasticity in a linear regression model.</summary>
			<param name="residuals">the <c>Residuals</c> object from an OLS regression</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.White.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.White.getX2">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.White.getAuxiliaryRegression">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.White.getAuxiliaryOLSRegression(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Heteroskedasticity">
			<summary>A heteroskedasticity test tests, for a linear regression model,
 whether the estimated variance of the residuals from a regression is dependent on the values of the independent variables (regressors).
 The test statistic is computed by regressing the transformed residuals from the original regression against the original regressors (plus intercept).
 Different implementations of heteroskedasticity tests have different ways to do the transformation.
 The test distribution is a Chi-squared distribution.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Heteroskedasticity.N">
			<summary>the number of observations</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Heteroskedasticity.residuals">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Heteroskedasticity.#ctor(com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals)">
			<summary>Construct a heteroskedasticity test.</summary>
			<param name="residuals">the residuals from a linear regression result</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Heteroskedasticity.getAuxiliaryRegression">
			<summary>Define the transformation of residuals.</summary>
			<returns>an auxiliary regression</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Heteroskedasticity.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Heteroskedasticity.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Heteroskedasticity.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Heteroskedasticity.pValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Heteroskedasticity.getX2">
			<summary>Get the Chi-squared distribution.</summary>
			<returns>the Chi-squared distribution</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Heteroskedasticity.getAuxiliaryOLSRegression(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals)">
			<summary>Get the auxiliary regression.</summary>
			<param name="y">the observations</param>
			<param name="residuals">the residuals from a linear regression result</param>
			<returns>the auxiliary regression</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.HarveyGodfrey">
			<summary>The Harvey-Godfrey test tests for conditional heteroskedasticity.
 The test statistics is computed by regressing <em>log of squared</em> residuals from the original regression against the original regressors (plus intercept).
 The test is a chi-squared test: the test statistic distribution is n&#967;<sup>2</sup> with <i>k</i> degrees of freedom.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.HarveyGodfrey.#ctor(com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals)">
			<summary>Perform the Harvey-Godfrey test to test for heteroskedasticity in a linear regression model.</summary>
			<param name="residuals">the <c>Residuals</c> object from an OLS regression</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.HarveyGodfrey.getAuxiliaryRegression">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Glejser">
			<summary>The Glejser test tests for conditional heteroskedasticity.
 The test statistics is computed by regressing <em>absolute</em> residuals from the original regression against the original regressors (plus intercept).
 The test is a chi-squared test: the test statistic distribution is n&#967;<sup>2</sup> with <i>k</i> degrees of freedom.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Glejser.#ctor(com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals)">
			<summary>Perform the Glejser test to test for heteroskedasticity in a linear regression model.</summary>
			<param name="residuals">the <c>Residuals</c> object from an OLS regression</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.Glejser.getAuxiliaryRegression">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.BreuschPagan">
			<summary>The Breusch-Pagan test tests for conditional heteroskedasticity.
 The test statistics is computed by regressing <em>squared</em> residuals from the original regression against the original regressors (plus intercept).
 The test is a chi-squared test: the test statistic distribution is n&#967;<sup>2</sup> with <i>k</i> degrees of freedom.
 If the Breush-Pagan test shows that there is conditional heteroscedasticity,
 it can be corrected by using the Hansen method, using robust standard errors, or re-thinking the regression equation.
 <para/>
 The R equivalent function is <c>bptest</c>.<para> See also: </para><list type="bullet">
 <item>T. S. Breusch and A. R. Pagan, &quot;A simple test for heteroscedasticity and random coefficient variation,&quot; Econometrica 47 (5): 1287-1294, 1979.</item>
 <item>R. Koenker, &quot;A Note on Studentizing a Test for Heteroscedasticity,&quot; Journal of Econometrics 17, 107-112, 1981.</item>
 <item><a href="http://en.wikipedia.org/wiki/breusch-pagan_test">Wikipedia: Breusch-Pagan test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.BreuschPagan.#ctor(com.numericalmethod.suanshu.stats.regression.linear.residualanalysis.LMResiduals,System.Boolean)">
			<summary>Perform the Breusch-Pagan test to test for heteroskedasticity in a linear regression model.</summary>
			<param name="residuals">the <c>Residuals</c> object from an OLS regression</param>
			<param name="studentized"><c>true</c> if to use Koenker&apos;s studentized version of the test statistic</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.BreuschPagan.getAuxiliaryRegression">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.regression.linear.heteroskedasticity.BreuschPagan.statistics">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType">
			<summary>These are the three versions of the Augmented Dickey-Fuller (ADF) test.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType.NO_CONSTANT">
			<summary>test for a unit root without drift or time trend</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType.CONSTANT">
			<summary>test for a unit root with drift</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType.CONSTANT_TIME">
			<summary>test for a unit root with
 drift and deterministic time trend</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType.getDistribution(System.Int32)">
			<summary>Get an ADF distribution per sample size.
 TODO: lag order is now ignored.</summary>
			<param name="sampleSize">the sample size</param>
			<returns>an ADF distribution</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.adf.AugmentedDickeyFuller">
			<summary>The Augmented Dickey Fuller test tests whether a one-time differencing (d = 1) will make the time
 series stationary.
 That is, whether the series has a unit root.
 Cheung and Lai (1995) pointed out that the lag order does have some effect on the critical
 values, esp. when the sample size is small.
 <para/>
 The R equivalent function is <c>adf.test</c> in package <c>tseries</c>.<para> See also: </para><list type="bullet">
 <item>&quot;S. E. Said and D. A. Dickey, &quot;Testing for Unit Roots in Autoregressive-Moving Average Models
 of Unknown Order,&quot; Biometrika, vol. 71, no. 3, pp.599-607, 1984.&quot;</item>
 <item>&quot;Yin-Wong Cheung, Kon S. Lai, &quot;ESTIMATING FINITE SAMPLE CRITICAL VALUES FOR UNIT ROOT TESTS
 USING PURE RANDOM WALK PROCESSES,&quot; Journal of Time Series Analysis, vol. 16, issue 5, pp.493-498,
 1995.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.AugmentedDickeyFuller.#ctor(System.Double[],com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType,System.Int32,com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFDistribution)">
			<summary>Perform the Augmented Dickey-Fuller test to test for the existence of uniroot.</summary>
			<param name="x">a time series</param>
			<param name="type">the trend type</param>
			<param name="lagOrder">the lag order; when <c>lagOrder</c> = 0, we perform the original
                 Dickey-Fuller test.</param>
			<param name="dist">the ADF distribution to use; in general, the correct ADF distribution depends
                 on the trend type and lag order;
                 to improve accuracy, the user may generate and use a customized ADF distribution;
                 <c>null</c> for the default</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.AugmentedDickeyFuller.#ctor(System.Double[])">
			<summary>Perform the Augmented Dickey-Fuller test to test for the existence of uniroot.
 Lag order is automatically selected as in R.
 <blockquote><c>
 nLag = (int) Math.pow((series.length - 1, 1.0 / 3.0));
 </c></blockquote>
 This corresponds to the suggested upper bound on the rate.</summary>
			<param name="x">a time series</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.AugmentedDickeyFuller.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.AugmentedDickeyFuller.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.AugmentedDickeyFuller.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.AugmentedDickeyFuller.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFFiniteSampleDistribution">
			<summary>This class computes the finite sample distribution of the Augmented Dickey-Fuller (ADF) test
 statistics.
 There are three main versions of the test and thus three possible asymptotic distributions:
 <list type="number">
 <item>test for a unit root without drift or time trend (NO_CONSTANT);</item>
 <item>test for a unit root with drift (CONSTANT);</item>
 <item>test for a unit root with drift and deterministic time trend (CONSTANT_TIME).</item>
 </list>
 Note that our results are different from those in R.
 The p-values in R are interpolated using the values from Table 4.2, p. 103 of Banerjee et al.
 (1993).
 SuanShu computes the exact p-values (and hence the whole cdf).
 See <a
 href='http://numericalmethod.com/forum/index.php/topic,122.0.html'>http://numericalmethod.com/forum/index.php/topic,122.0.html</a><para> See also: </para><list type="bullet">
 <item>D. A. Dickey and W. A. Fuller, &quot;Distribution of the Estimators for Autoregressive Time Series
 with a Unit Root,&quot; J. Amer. Stat. Assoc., vol. 74, pp. 427-431, 1979.</item>
 <item>E. Said and D. A. Dickey, &quot;Testing for Unit Roots in Autoregressive Moving Average Models of
 Unknown Order,&quot; Biometrika, vol. 71, 599-607, 1984.</item>
 <item>A. Banerjee et al., &quot;ch. 4, pp. 99-135,&quot; Cointegration, Error Correction, and the Econometric
 Analysis of Non-Stationary Data, Oxford, Oxford University Press, 1993.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFFiniteSampleDistribution.#ctor(System.Int32,com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int64)">
			<summary>Construct a finite sample distribution for the Augmented Dickey-Fuller test statistic.</summary>
			<param name="sampleSize">the (finite) sample size</param>
			<param name="trend">the type of Augmented Dickey-Fuller test</param>
			<param name="lagAdjust"><c>true</c> if the distribution is adjusted for lags</param>
			<param name="lagOrder">the lag order; <c>lagOrder = 0</c> yields the original Dickey-Fuller
                   distribution</param>
			<param name="truncation">the number of truncated values</param>
			<param name="nSims">the number of simulations</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFFiniteSampleDistribution.#ctor(System.Int32,com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType,System.Boolean,System.Int32)">
			<summary>Construct a finite sample distribution for the Augmented Dickey-Fuller test statistic.
 The number of truncated values is 50.</summary>
			<param name="sampleSize">the (finite) sample size</param>
			<param name="trend">the type of Augmented Dickey-Fuller test</param>
			<param name="lagAdjust"><c>true</c> if the distribution is adjusted for lags</param>
			<param name="lagOrder">the lag order; <c>lagOrder = 0</c> yields the original Dickey-Fuller
                   distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFFiniteSampleDistribution.#ctor(System.Int32,com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType)">
			<summary>Construct a finite sample distribution for the <em>original</em> Dickey-Fuller test
 statistic.
 We do not adjust for the lag.</summary>
			<param name="sampleSize">the (finite) sample size</param>
			<param name="trend">the type of Augmented Dickey-Fuller test</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFFiniteSampleDistribution.#ctor(System.Int32)">
			<summary>Construct a finite sample distribution for the Augmented Dickey-Fuller test statistic.
 We test for a unit root with a drift and a deterministic time trend.</summary>
			<param name="sampleSize">the (finite) sample size</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFDistribution">
			<summary>This represents an Augmented Dickey Fuller distribution.</summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution1">
			<summary><para><c>DEPRECATED:</c> use instead <para></para>ADFAsymptoticDistribution</para>
This is the asymptotic distribution of the Augmented Dickey-Fuller test statistic, for the <para></para>TrendType#CONSTANT_TIME case.
 <para/>
 Note that our results are different from those in R.
 The p-values in R are interpolated using the values from Table 4.2, p. 103 of Banerjee et al. (1993).
 SuanShu computes the exact p-values (and hence the whole cdf).
 See <a href='http://numericalmethod.com/forum/index.php/topic,122.0.html'>http://numericalmethod.com/forum/index.php/topic,122.0.html</a><para> See also: </para><list type="bullet">
 <item>&quot;Wayne A. Fuller, &quot;Chapter 10, pp.553, 554, 561, 568,&quot; Introduction to Statistical Time Series.&quot;</item>
 <item>&quot;A. Banerjee, J. J. Dolado, J. W. Galbraith, and D. F. Hendry, Cointegration, Error Correction, and the Econometric Analysis of Non-Stationary Data, Oxford University Press, Oxford, 1993.&quot;</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution1.#ctor(com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution1.Type)">
			<summary>Construct an asymptotic distribution for the augmented Dickey-Fuller test statistic.</summary>
			<param name="type">the type of Dickey-Fuller test</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution1.#ctor(System.Int32,System.Int32,com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution1.Type,System.Int64)">
			<summary>Construct an asymptotic distribution for the augmented Dickey-Fuller test statistic.</summary>
			<param name="nT">the number of grid point in interval <i>[0, 1]</i></param>
			<param name="nSims">the number of simulations</param>
			<param name="type">the type of Dickey-Fuller test</param>
			<param name="seed">the seed</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution1.Type">
			<summary>the available types of Dickey-Fuller tests</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution1.Type.DICKEY_FULLER">
			<summary>the original version of the Dickey-Fuller test, developed in 1979</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution1.Type.AUGMENTED_DICKEY_FULLER">
			<summary>the augmented version of the Dickey-Fuller test</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution1.Type.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution1.Type.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution">
			<summary>This class computes the asymptotic distribution of the Augmented Dickey-Fuller (ADF) test statistic.
 There are three main versions of the test and thus three possible asymptotic distributions:
 <list type="number">
 <item>test for a unit root without drift or time trend (NO_CONSTANT);</item>
 <item>test for a unit root with drift (CONSTANT);</item>
 <item>test for a unit root with drift and deterministic time trend (CONSTANT_TIME).</item>
 </list>
 Note that our results are different from those in R.
 The p-values in R are interpolated using the values from Table 4.2, p. 103 of Banerjee et al. (1993).
 SuanShu computes the exact p-values (and hence the whole cdf).
 See <a href='http://numericalmethod.com/forum/index.php/topic,122.0.html'>http://numericalmethod.com/forum/index.php/topic,122.0.html</a><para> See also: </para><list type="bullet">
 <item>D. A. Dickey and W. A. Fuller, &quot;Distribution of the Estimators for Autoregressive Time Series with a Unit Root,&quot; J. Amer. Stat. Assoc., vol. 74, pp. 427-431, 1979.</item>
 <item>E. Said and D. A. Dickey, &quot;Testing for Unit Roots in Autoregressive Moving Average Models of Unknown Order,&quot; Biometrika, vol. 71, 599-607, 1984.</item>
 <item>A. Banerjee et al., &quot;ch. 4, pp. 99-135,&quot; Cointegration, Error Correction, and the Econometric Analysis of Non-Stationary Data, Oxford, Oxford University Press, 1993.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution.#ctor(com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType,System.Int32,System.Int32,System.Int64)">
			<summary>Construct an asymptotic distribution for the augmented Dickey-Fuller test statistic.</summary>
			<param name="trend">the type of Augmented Dickey-Fuller test</param>
			<param name="nSims">the number of simulations</param>
			<param name="nT">the number of grid points in interval <i>[0, 1]</i></param>
			<param name="seed">the seed</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.ADFAsymptoticDistribution.#ctor(com.numericalmethod.suanshu.stats.test.timeseries.adf.TrendType)">
			<summary>Construct an asymptotic distribution for the augmented Dickey-Fuller test statistic.</summary>
			<param name="trend">the type of Augmented Dickey-Fuller test</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.adf.table.ADFDistributionTable_NO_CONSTANT_lag0">
			<summary>This table contains the quantile values of both finite (for various sample sizes) and infinite
 (asymptotic) distributions of the Augmented Dicky Fuller test statistics for the
 <para></para>TrendType#NO_CONSTANT case.
 It is generated by
 <code>
 <c>ADFFiniteSampleDistribution dist =
     new ADFFiniteSampleDistribution(sampleSize, TrendType.NO_CONSTANT,
     false, 0, 0,//0 lag
     100000);//number of simulations
 </c>
 </code>
 <code>
 <c>ADFAsymptoticDistribution dist = new ADFAsymptoticDistribution(
     type,
     100000,
     100000);
 </c>
 </code></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.table.ADFDistributionTable_NO_CONSTANT_lag0.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.adf.table.ADFDistributionTable_CONSTANT_TIME_lag0">
			<summary>This table contains the quantile values of both finite (for various sample sizes) and infinite
 (asymptotic) distributions of the Augmented Dicky Fuller test statistics for the
 <para></para>TrendType#CONSTANT_TIME case.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.table.ADFDistributionTable_CONSTANT_TIME_lag0.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.adf.table.ADFDistributionTable_CONSTANT_lag0">
			<summary>This table contains the quantile values of both finite (for various sample sizes) and infinite
 (asymptotic) distributions of the Augmented Dicky Fuller test statistics for the
 <para></para>TrendType#CONSTANT case.
 It is generated by
 <code>
 <c>ADFFiniteSampleDistribution dist =
     new ADFFiniteSampleDistribution(sampleSize, TrendType.CONSTANT,
     false, 0, 0),//0 lag
     100000);//number of simulations
 </c>
 </code></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.table.ADFDistributionTable_CONSTANT_lag0.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.adf.table.ADFDistributionTable">
			<summary>A table contains the simulated observations/values of an empirical ADF distribution for a given set of parameters.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.table.ADFDistributionTable.#ctor(com.numericalmethod.suanshu.misc.datastructure.MathTable)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.adf.table.ADFDistributionTable.getObservations(System.Int32)">
			<summary>Get the observations to compute an empirical distribution.</summary>
			<param name="sampleSize">the sample size of observations</param>
			<returns>the observations</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.portmanteau.LjungBox">
			<summary>The Ljung-Box test (named for Greta M. Ljung and George E. P. Box) is a portmanteau test for autocorrelated errors.
 A portmanteau test tests whether any of a group of autocorrelations of a time series are different from zero.
 The Ljung-Box statistic is better for all sample sizes including small ones.
 The <para></para>BoxPierce Box-Pierce test statistic is a simplified version of the Ljung-Box statistic
 for which subsequent simulation studies have shown poor performance.
 <para/>
 The R equivalent function is <c>Box.test</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/box%e2%80%93pierce_test">Wikipedia: Box-Pierce test</a></item>
 <item><a href="http://en.wikipedia.org/wiki/portmanteau_test">Wikipedia: Portmanteau test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.portmanteau.LjungBox.#ctor(System.Double[],System.Int32,System.Int32)">
			<summary>Perform the Ljung-Box test to check auto-correlation in a time series.</summary>
			<param name="x">a univariate time series</param>
			<param name="lag">the number of lags to check</param>
			<param name="fitdf">the degrees of freedom to be subtracted if <c>x</c> is a series of residuals</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.timeseries.portmanteau.BoxPierce">
			<summary><para><c>DEPRECATED:</c> use <para></para>LjungBox</para>
The Box-Pierce test (named for George E. P. Box and David A. Pierce) is a portmanteau test for autocorrelated errors.
 A portmanteau test tests whether any of a group of autocorrelations of a time series are different from zero.
 The Box-Pierce statistic is computed as the weighted sum of squares of a sequence of autocorrelations.
 <para/>
 The R equivalent function is <c>Box.test</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/box%e2%80%93pierce_test">Wikipedia: Box-Pierce test</a></item>
 <item><a href="http://en.wikipedia.org/wiki/portmanteau_test">Wikipedia: Portmanteau test</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.portmanteau.BoxPierce.#ctor(System.Double[],System.Int32,System.Int32)">
			<summary>Perform the Box-Pierce test to check auto-correlation in a time series.</summary>
			<param name="x">a univariate time series</param>
			<param name="lag">the number of lags to check</param>
			<param name="fitdf">the degrees of freedom to be subtracted if <c>x</c> is a series of residuals</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.portmanteau.BoxPierce.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.portmanteau.BoxPierce.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.portmanteau.BoxPierce.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.timeseries.portmanteau.BoxPierce.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.variance.Levene">
			<summary>The Levene test tests for the equality of variance of groups. Levene&apos;s test does not require
 normality of the underlying data.
 Some statistical tests, for example ANOVA, assume that variances are equal across groups or
 samples.
 A homoscedasticity test, such as the Levene test, can be used to verify that assumption.
 <para/>
 The R equivalent function is <c>levene.test</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/levene's_test">Wikipedia: Levene&apos;s test</a></item>
 <item><a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35a.htm">Levene Test for
 Equality of Variances</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Levene.#ctor(System.Double[])">
			<summary>Perform the Levene test to test for equal variances across the groups.
 The absolute deviations are computed from the medians.</summary>
			<param name="samples">samples</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Levene.#ctor(com.numericalmethod.suanshu.stats.test.variance.Levene.Type,System.Double[][])">
			<summary>Perform the Levene test to test for equal variances across the groups.</summary>
			<param name="type">the implementation chosen</param>
			<param name="samples">samples</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Levene.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Levene.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Levene.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Levene.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.variance.Levene.Type">
			<summary>the available implementations when computing the absolute deviations</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.variance.Levene.Type.MEDIAN">
			<summary>compute the absolute deviations from the group medians</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.variance.Levene.Type.MEANS">
			<summary>compute the absolute
 deviations from the group means</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.test.variance.Levene.Type.TRIMMED_MEANS">
			<summary>compute the absolute
 deviations from the group trimmed means</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Levene.Type.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Levene.Type.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.variance.F">
			<summary>The F-test tests whether two <em>normal</em> populations have the same variance.
 This test is sensitive to the assumption that the variables are normally distributed.
 <para/>
 The R equivalent function is <c>var.test</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/fdistribution-test_of_equality_of_variances">Wikipedia: FDistribution-test of equality of variances</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.F.#ctor(System.Double[],System.Double[])">
			<summary>Perform the F-test to test for equal variance of two normal populations.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.F.#ctor(System.Double[],System.Double[],System.Double)">
			<summary>Perform the F-test to test for equal variance of two normal populations.</summary>
			<param name="sample1">sample 1</param>
			<param name="sample2">sample 2</param>
			<param name="ratio">the hypothesized ratio of the population variances of samples 1 and 2</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.F.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.F.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.F.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.F.pValue">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.F.rightOneSidedPvalue">
			<summary>Get the right, one-sided p-value.</summary>
			<returns>the right, one-sided p-value.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.F.leftOneSidedPvalue">
			<summary>Get the left, one-sided p-value.</summary>
			<returns>the left, one-sided p-value.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.F.confidenceInterval(System.Double)">
			<summary>Compute the confidence interval.</summary>
			<param name="confidence">the confidence level, e.g., for a 2-sided 95% confidence interval, we use 0.975 because 1 - 0.95 = 2 * (1 - 0.025)</param>
			<returns>the left and right interval bounds</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.F.rightConfidenceInterval(System.Double)">
			<summary>Compute the one sided right confidence interval, [a, &#8734;)</summary>
			<param name="confidence">the confidence level, e.g., 0.95 for 95% confidence interval</param>
			<returns>the left interval bound</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.F.leftConfidenceInterval(System.Double)">
			<summary>Compute the one sided left confidence interval, [0, a]</summary>
			<param name="confidence">the confidence level, e.g., 0.95 for 95% confidence interval</param>
			<returns>the right interval bound</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.variance.BrownForsythe">
			<summary>The Brown-Forsythe test is a statistical test for the equality of group variances based on performing an ANOVA on a transformation of the response variable.
 In statistics, when a usual one-way ANOVA is performed, it is assumed that the group variances are statistically equal.
 If this assumption is not valid, then the resulting F-test is invalid.
 A homoscedasticity test, such as the Brown-Forsythe test, can be used to verify that assumption.<para> See also: </para><a href="http://en.wikipedia.org/wiki/brown%e2%80%93forsythe_test">Wikipedia: Brown-Forsythe Test</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.BrownForsythe.#ctor(System.Double[][])">
			<summary>Perform the Brown-Forsythe test to test for equal variances across the groups.</summary>
			<param name="samples">samples</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.BrownForsythe.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.BrownForsythe.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.BrownForsythe.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.BrownForsythe.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.test.variance.Bartlett">
			<summary>Bartlett&apos;s test is used to test if <c>k</c> samples are from populations with equal variances, hence homoscedasticity.
 Some statistical tests, for example ANOVA, assume that variances are equal across groups or samples.
 A homoscedasticity test, such as the Bartlett test, can be used to verify that assumption.
 Bartlett&apos;s test is sensitive to departures from normality.
 That is, if the samples come from non-normal distributions, then Bartlett&apos;s test may simply be testing for non-normality.
 The <para></para>Levene and <para></para>BrownForsythe tests are alternatives to the Bartlett test that are less sensitive to departures from normality.
 <para/>
 The R equivalent function is <c>bartlett.test</c>.<para> See also: </para><list type="bullet">
 <item><a href="http://en.wikipedia.org/wiki/bartlett%27s_test">Wikipedia: Bartlett&apos;s test</a></item>
 <item><a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda357.htm">Engineer Statistics handbook</a></item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Bartlett.#ctor(System.Double[][])">
			<summary>Perform the Bartlett test to test for equal variances across the groups.</summary>
			<param name="samples">samples</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Bartlett.getNullHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Bartlett.getAlternativeHypothesis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Bartlett.statistics">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.test.variance.Bartlett.pValue">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.cluster.Clusters">
			<summary>Store cluster information obtained by cluster analysis.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.Clusters.#ctor(System.Double[],java.util.List,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.Clusters.getExceedenceCount">
			<summary>Get the number of observations that is greater than a given threshold.</summary>
			<returns>the number of exceedences</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.Clusters.getClusterCount">
			<summary>Get the number of clusters.</summary>
			<returns>the number of clusters</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.Clusters.getAverageClusterSize">
			<summary>Get the average cluster size.</summary>
			<returns>the average cluster size.</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.Clusters.getClusters">
			<summary>Get the list of clusters.</summary>
			<returns>the cluster list</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.Clusters.getClusterMaxima">
			<summary>Get an array of cluster maxima.</summary>
			<returns>maxima of the clusters</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.cluster.Clusters.Cluster">
			<summary>Define the beginning and ending indices (inclusively) of a cluster.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.Clusters.Cluster.#ctor(System.Int32,System.Int32)">
			<summary>Create a cluster with the beginning and ending indices of the cluster.</summary>
			<param name="beginIndex">the beginning index (inclusive)</param>
			<param name="endIndex">the ending index (inclusive)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.Clusters.Cluster.getBeginIndex">
			<summary>Get the index of the first element of this cluster.</summary>
			<returns>the beginning index of the cluster</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.Clusters.Cluster.getEndIndex">
			<summary>Get the index of the last element of this cluster.</summary>
			<returns>the ending index of the cluster</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.Clusters.Cluster.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.cluster.ClusterAnalyzer">
			<summary>This class counts clusters of exceedances based on observations above a given threshold, and the
 discontinuity of exceedances can be tolerated by an interval length <c>r</c>.
 <para/>
 The clusters of exceedances are identified as follows:
 <list type="number">
 <item>The first exceedance of the threshold initiates the first cluster.</item>
 <item>The first cluster then remains active until either <c>r</c> consecutive values fall below
 (or are equal to) the threshold,</item>
 <item>The next exceedance of the threshold (if it exists) then initiates the second cluster, and so
 on.</item>
 </list>
 <para/>
 Average cluster size is the total number of exceedances divided by the total number of clusters
 (i.e., the cluster size of a cluster is defined as the number of exceedances within a cluster).
 <para/>
 The R equivalent function is <c>evd::clusters</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.ClusterAnalyzer.#ctor(System.Double)">
			<summary>Create an instance with the given threshold value and default interval length value of 1.</summary>
			<param name="threshold">the threshold value</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.ClusterAnalyzer.#ctor(System.Double,System.Int32)">
			<summary>Create an instance with the given threshold and clustering interval length.</summary>
			<param name="threshold">the threshold value</param>
			<param name="intervalLength">the clustering interval length <c>r</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.ClusterAnalyzer.getThreshold">
			<summary>Get the threshold for exceedance.</summary>
			<returns>the threshold</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.ClusterAnalyzer.getIntervalLength">
			<summary>Get the clustering interval length.</summary>
			<returns>the interval length</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.cluster.ClusterAnalyzer.getClusters(System.Double[])">
			<summary>Count clusters from the given observations.</summary>
			<param name="observations">the observation to be analyzed</param>
			<returns>the clusters</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeLogistic">
			<summary>The bivariate negative logistic model. Define
 \[
 y_i = y_i(z_i) = \left[1+\frac{\xi_i(z_i-\mu_i)}{\sigma_i}\right]^{-1/\xi_i}
 \]
 for \(1+\xi_i(z_i-\mu_i)/\sigma_i &gt; 0\) and \(i=1,2\) where the marginal univariate GEV
 parameters are given by \((\mu_i,\sigma_i,\xi_i)\), and \(G_i(z_i) = \exp(-y_i)\).
 The distribution function of the bivariate negative logistic model is
 \[
 G(z_1,z_2) = \exp\left\{-y_1-y_2+\left[y_1^{-r}+y_2^{-r}\right]^{-1/r}\right\}
 \]
 where \(r &gt; 0\) is the dependence parameter. This is a special case of the bivariate
 asymmetric negative logistic model. Independence is obtained in the limit as \(r\) approaches
 zero. Complete dependence is obtained as \(r\) tends to infinity.
 <para/>
 The R equivalent functions are
 <c>evd::dbvneglog</c>, <c>evd::pbvneglog</c>, <c>evd::rbvneglog</c>, <c>evd::hbvneglog</c>,
 <c>evd::abvneglog</c>, <c>evd::ccbvevd</c>.<para> See also: </para>&quot;J. Galambos, &quot;Order statistics of samples from multivariate distributions,&quot; in Journal of
 the American Statistical Association, vol. 70, no. 351, 1975, pp. 674-680.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeLogistic.#ctor(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeLogistic.#ctor(System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeLogistic.#ctor(System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeLogistic.density(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeLogistic.cdf(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeLogistic.spectralDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeLogistic.dependence(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeLogistic.conditionalCopula(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeLogistic.nextVector">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeLogistic.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeBilogistic">
			<summary>The negative bilogistic model. Define
 \[
 y_i = y_i(z_i) = \left[1+\frac{\xi_i(z_i-\mu_i)}{\sigma_i}\right]^{-1/\xi_i}
 \]
 for \(1+\xi_i(z_i-\mu_i)/\sigma_i &gt; 0\) and \(i=1,2\) where the marginal univariate GEV
 parameters are given by \((\mu_i,\sigma_i,\xi_i)\), and \(G_i(z_i) = \exp(-y_i)\).
 The distribution function of the negative bilogistic model is
 \[
 G(z_1,z_2) = \exp\left\{-y_1 - y_2 + y_1 q^{(1+\alpha)} + y_2 (1-q)^{(1+\beta)}\right\}
 \]
 where \(q = q(y_1,y_2;\alpha,\beta)\) is the root of the equation
 \[
 (1+\alpha) y_1 q^\alpha - (1+\beta) y_2 (1-q)^\beta = 0,
 \]
 and \(\alpha,\beta &gt; 0\) are the dependence parameters. When \(\alpha=\beta\) the negative
 bilogistic model is equivalent to the negative logistic model with dependence parameter
 \(r=1/\alpha=1/\beta\). Complete dependence is obtained in the limit as \(\alpha=\beta\)
 approaches zero. Independence is obtained as \(\alpha=\beta\) tends to infinity, and when one of
 \(\alpha\), \(\beta\) is fixed and the other tends to infinity. Different limits occur when one
 of \(\alpha\), \(\beta\) is fixed and the other approaches zero.
 <para/>
 The R equivalent functions are
 <c>evd:dbvnegbilog</c>, <c>evd:pbvnegbilog</c>, <c>evd:rbvnegbilog</c>,
 <c>evd:hbvnegbilog</c>, <c>evd:abvnegbilog</c>, <c>evd:ccbvevd</c>.<para> See also: </para>&quot;S. G. Coles and J. A. Tawn, &quot;Statistical methods for multivariate extremes: an application
 to structural design (with discussion),&quot; in Appl. Statist., vol. 43, 1994, pp. 1-48.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeBilogistic.#ctor(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeBilogistic.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeBilogistic.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeBilogistic.density(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeBilogistic.cdf(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeBilogistic.spectralDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeBilogistic.dependence(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeBilogistic.conditionalCopula(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeBilogistic.nextVector">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDNegativeBilogistic.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic">
			<summary>The bivariate logistic model. Define
 \[
 y_i = y_i(z_i) = \left[1+\frac{\xi_i(z_i-\mu_i)}{\sigma_i}\right]^{-1/\xi_i}
 \]
 for \(1+\xi_i(z_i-\mu_i)/\sigma_i &gt; 0\) and \(i=1,2\) where the marginal univariate GEV
 parameters are given by \((\mu_i,\sigma_i,\xi_i)\), and \(G_i(z_i) = \exp(-y_i)\).
 The distribution function of the bivariate logistic model is
 \[
 G(z_1,z_2) = \exp\left\{-[y_1^{1/r}+y_2^{1/r}]^r\right\}
 \]
 where \(0 &lt; r \le 1\) is the dependence parameter. Complete dependence is obtained in the
 limit as \(r\) approaches zero. Independence is obtained when \(r = 1\). This is a special case
 of the bivariate asymmetric logistic model.
 <para/>
 The R equivalent functions are
 <c>evd::dbvlog</c>, <c>evd::pbvlog</c>, <c>evd::rbvlog</c>, <c>evd::hbvlog</c>,
 <c>evd::abvlog</c>, <c>evd::ccbvevd</c>.<para> See also: </para>&quot;E. J. Gumbel, &quot;Distributions des valeurs extremes en plusieurs dimensions,&quot; Publ. Inst.
 Statist. Univ. Paris, 9, 1960, pp. 171-173.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic.#ctor(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic.#ctor(System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic.#ctor(System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic.getMarginal1">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic.getMarginal2">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic.density(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic.cdf(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic.spectralDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic.dependence(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic.conditionalCopula(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic.nextVector">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDLogistic.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDHuslerReiss">
			<summary>The Husler-Reiss model. Define
 \[
 y_i = y_i(z_i) = \left[1+\frac{\xi_i(z_i-\mu_i)}{\sigma_i}\right]^{-1/\xi_i}
 \]
 for \(1+\xi_i(z_i-\mu_i)/\sigma_i &gt; 0\) and \(i=1,2\) where the marginal univariate GEV
 parameters are given by \((\mu_i,\sigma_i,\xi_i)\), and \(G_i(z_i) = \exp(-y_i)\).
 The distribution function of the Husler-Reiss model is
 \[
 G(z_1,z_2) =
 \exp\left(-y_1\Phi\left\{\frac{1}{r}+\frac{r}{2}\left[\log(\frac{y_1}{y_2})\right]\right\}
 -y_2\Phi\left\{\frac{1}{r}+\frac{r}{2}\left[\log(\frac{y_2}{y_1})\right]\right\}\right)
 \]
 where \(r &gt; 0\) is the dependence parameter, and \(\Phi()\) is the standard normal
 distribution. Independence is obtained in the limit as \(r\) approaches zero. Complete dependence
 is obtained as \(r\) tends to infinity.
 <para/>
 The R equivalent functions are
 <c>evd::dbvhr</c>, <c>evd::pbvhr</c>, <c>evd::rbvhr</c>, <c>evd::hbvhr</c>,
 <c>evd::abvhr</c>, <c>evd::ccbvevd</c>.<para> See also: </para>&quot;J. Husler and R.-D. Reiss, &quot;Maxima of normal random vectors: between independence and
 complete dependence,&quot; in Statistics &amp; Probability Letters, vol. 7, no. 4, 1989, pp. 283-286.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDHuslerReiss.#ctor(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDHuslerReiss.#ctor(System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDHuslerReiss.#ctor(System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDHuslerReiss.density(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDHuslerReiss.cdf(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDHuslerReiss.spectralDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDHuslerReiss.dependence(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDHuslerReiss.conditionalCopula(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDHuslerReiss.nextVector">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDHuslerReiss.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDColesTawn">
			<summary>The Coles-Tawn model. Define
 \[
 y_i = y_i(z_i) = \left[1+\frac{\xi_i(z_i-\mu_i)}{\sigma_i}\right]^{-1/\xi_i}
 \]
 for \(1+\xi_i(z_i-\mu_i)/\sigma_i &gt; 0\) and \(i=1,2\) where the marginal univariate GEV
 parameters are given by \((\mu_i,\sigma_i,\xi_i)\), and \(G_i(z_i) = \exp(-y_i)\).
 The distribution function of the Coles-Tawn model is
 \[
 G(z_1,z_2) = \exp\left\{-y_1 [1 - B(q;\alpha+1,\beta)] - y_2 B(q;\alpha,\beta+1)\right\}
 \]
 where \(\alpha,\beta &gt; 0\) are the dependence parameters,
 \(q=\alpha y_2/(\alpha y_2+\beta y_1)\) and \(B(q;\alpha,\beta)\) is the beta distribution
 function evaluated at \(q\) with shape parameters \(\alpha\) and \(\beta\). Complete dependence
 is obtained in the limit as \(\alpha=\beta\) tends to infinity. Independence is obtained as
 \(\alpha=\beta\) approaches zero, and when one of \(\alpha\), \(\beta\) is fixed and the other
 approaches zero. Different limits occur when one of \(\alpha\), \(\beta\) is fixed and the other
 tends to infinity.
 <para/>
 The R equivalent functions are
 <c>evd::dbvct</c>, <c>evd::pbvct</c>, <c>evd::rbvct</c>, <c>evd::hbvct</c>,
 <c>evd::abvct</c>, <c>evd::ccbvevd</c>.<para> See also: </para>&quot;S. G. Coles and J. A. Tawn, &quot;Modelling extreme multivariate events,&quot; in J. Roy. Statist.
 Soc., B, vol. 53, 1991, pp. 377-392.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDColesTawn.#ctor(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDColesTawn.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDColesTawn.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDColesTawn.density(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDColesTawn.cdf(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDColesTawn.spectralDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDColesTawn.dependence(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDColesTawn.conditionalCopula(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDColesTawn.nextVector">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDColesTawn.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDBilogistic">
			<summary>The bilogistic model. Define
 \[
 y_i = y_i(z_i) = \left[1+\frac{\xi_i(z_i-\mu_i)}{\sigma_i}\right]^{-1/\xi_i}
 \]
 for \(1+\xi_i(z_i-\mu_i)/\sigma_i &gt; 0\) and \(i=1,2\) where the marginal univariate GEV
 parameters are given by \((\mu_i,\sigma_i,\xi_i)\), and \(G_i(z_i) = \exp(-y_i)\).
 The distribution function of the bilogistic model is
 \[
 G(z_1,z_2) = \exp\left\{-y_1 q^{(1-\alpha)} -y_2 (1-q)^{(1-\beta)}\right\}
 \]
 where \(q = q(y_1,y_2;\alpha,\beta)\) is the root of the equation
 \[
 (1-\alpha) y_1 (1-q)^\beta - (1-\beta) y_2 q^\alpha = 0,
 \]
 and \(0 &lt; \alpha,\beta &lt; 1\) are the dependence parameters. When \(\alpha=\beta\), the
 bilogistic model is equivalent to the logistic model with dependence parameter
 \(r=\alpha=\beta\). Complete dependence is obtained in the limit as \(\alpha=\beta\) approaches
 zero. Independence is obtained as \(\alpha=\beta\) approaches one, and when one of \(\alpha\),
 \(\beta\) is fixed and the other approaches one. Different limits occur when one of \(\alpha\),
 \(\beta\) is fixed and the other approaches zero.
 <para/>
 The R equivalent functions are
 <c>evd::dbvbilog</c>, <c>evd::pbvbilog</c>, <c>evd::rbvbilog</c>, <c>evd::hbvbilog</c>,
 <c>evd::abvbilog</c>, <c>evd::ccbvevd</c>.<para> See also: </para>&quot;R. L., Smith, &quot;Extreme value theory&quot;, in Handbook of Applicable Mathematics (ed. W.
 Ledermann), vol. 7, Chichester: John Wiley, 1990, pp. 437-471.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDBilogistic.#ctor(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDBilogistic.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDBilogistic.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDBilogistic.density(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDBilogistic.cdf(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDBilogistic.spectralDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDBilogistic.dependence(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDBilogistic.conditionalCopula(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDBilogistic.nextVector">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDBilogistic.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricNegativeLogistic">
			<summary>The bivariate asymmetric negative logistic model. Define
 \[
 y_i = y_i(z_i) = \left[1+\frac{\xi_i(z_i-\mu_i)}{\sigma_i}\right]^{-1/\xi_i}
 \]
 for \(1+\xi_i(z_i-\mu_i)/\sigma_i &gt; 0\) and \(i=1,2\) where the marginal univariate GEV
 parameters are given by \((\mu_i,\sigma_i,\xi_i)\), and \(G_i(z_i) = \exp(-y_i)\).
 The distribution function of the bivariate asymmetric negative logistic model is
 \[
 G(z_1,z_2) = \exp\left\{-y_1-y_2+\left[(t_1y_1)^{-r}+(t_2y_2)^{-r}\right]^{-1/r}\right\}
 \]
 where \(r &gt; 0\) is the dependence parameter, and \(0 &lt; t_1,t_2 \le 1\) are the
 asymmetry parameters. When \(t_1=t_2=1\), the asymmetric negative logistic model is equivalent to
 the negative logistic model.Independence is obtained in the limit as either \(r\), \(t_1\) or
 \(t_2\) approaches zero. Complete dependence is obtained in the limit when \(t_1=t_2=1\) and
 \(r\) tends to infinity. Different limits occur when \(t_1\) and \(t_2\) are fixed and \(r\)
 tends to infinity.
 <para/>
 The R equivalent functions are
 <c>evd::dbvaneglog</c>, <c>evd::pbvaneglog</c>, <c>evd::rbvaneglog</c>,
 <c>evd::hbvaneglog</c>, <c>evd::abvaneglog</c>, <c>evd::ccbvevd</c>.<para> See also: </para>&quot;H. Joe, &quot;Families of min-stable multivariate exponential and multivariate extreme value
 distributions,&quot; in Statist. Probab. Letters, vol. 9, 1990, pp. 75-81.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricNegativeLogistic.#ctor(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricNegativeLogistic.#ctor(System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricNegativeLogistic.#ctor(System.Double,System.Double,System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricNegativeLogistic.#ctor(System.Double,System.Double,System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricNegativeLogistic.density(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricNegativeLogistic.cdf(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricNegativeLogistic.spectralDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricNegativeLogistic.dependence(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricNegativeLogistic.conditionalCopula(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricNegativeLogistic.nextVector">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricNegativeLogistic.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricMixed">
			<summary>The asymmetric mixed model. Define
 \[
 y_i = y_i(z_i) = \left[1+\frac{\xi_i(z_i-\mu_i)}{\sigma_i}\right]^{-1/\xi_i}
 \]
 for \(1+\xi_i(z_i-\mu_i)/\sigma_i &gt; 0\) and \(i=1,2\) where the marginal univariate GEV
 parameters are given by \((\mu_i,\sigma_i,\xi_i)\), and \(G_i(z_i) = \exp(-y_i)\).
 The distribution function of the asymmetric mixed model is
 \[
 G(z_1,z_2) = \exp\left\{-(y_1+y_2)A\left[y_1/(y_1+y_2)\right]\right\}
 \]
 where \(A()\) is the dependence function with dependence parameters \(\alpha\) and \(\beta\)
 \[
 A(t;\alpha,\beta) = 1 - (\alpha + \beta)t + \alpha t^2 + \beta t^3
 \]
 where \(\alpha, \alpha + 3\beta \ge 0\), and where \(\alpha + \beta, \alpha + 2\beta \le 1\).
 These constraints imply that \(\beta\) lies in the interval [-0.5,0.5] and that \(\alpha\) lies
 in the interval [0,1.5], though \(\alpha\) can only be greater than one if \(\beta\) is negative.
 The strength of dependence increases for increasing \(\alpha\) (for fixed \(\beta\)). Complete
 dependence cannot be obtained. Independence is obtained when both parameters are zero.
 <para/>
 The R equivalent functions are
 <c>evd::dbvamix</c>, <c>evd::pbvamix</c>, <c>evd::rbvamix</c>, <c>evd::hbvamix</c>,
 <c>evd::abvamix</c>, <c>evd::ccbvevd</c>.<para> See also: </para>&quot;J. A. Tawn, &quot;Bivariate extreme value theory: models and estimation,&quot; in Biometrika, vol.
 75, 1988, pp. 397-415.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricMixed.#ctor(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricMixed.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricMixed.#ctor(System.Double,System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricMixed.density(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricMixed.cdf(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricMixed.spectralDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricMixed.dependence(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricMixed.conditionalCopula(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricMixed.nextVector">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricMixed.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricLogistic">
			<summary>The bivariate asymmetric logistic model. Define
 \[
 y_i = y_i(z_i) = \left[1+\frac{\xi_i(z_i-\mu_i)}{\sigma_i}\right]^{-1/\xi_i}
 \]
 for \(1+\xi_i(z_i-\mu_i)/\sigma_i &gt; 0\) and \(i=1,2\) where the marginal univariate GEV
 parameters are given by \((\mu_i,\sigma_i,\xi_i)\), and \(G_i(z_i) = \exp(-y_i)\).
 The distribution function of the bivariate asymmetric logistic model is
 \[
 G(z_1,z_2) = \exp\left\{-(1-t_1)y_1-(1-t_2)y_2-[(t_1y_1)^{1/r}+(t_2y_2)^{1/r}]^r\right\}
 \]
 where \(0 &lt; r \le 1\) is the dependence parameter, and \(0 \le t_1,t_2 \le 1\) are the
 asymmetry parameters. When \(t_1 = t_2 = 1\), the asymmetric logistic model is equivalent to the
 logistic model. Independence is obtained when either \(r = 1\), \(t_1 = 0\) or \(t_2 = 0\).
 Complete dependence is obtained in the limit when \(t_1 = t_2 = 1\) and \(r\) approaches zero.
 Different limits occur when \(t_1\) and \(t_2\) are fixed and \(r\) approaches zero.
 <para/>
 The R equivalent functions are
 <c>evd::dbvalog</c>, <c>evd::pbvalog</c>, <c>evd::rbvalog</c>, <c>evd::hbvalog</c>,
 <c>evd::abvalog</c>, <c>evd::ccbvevd</c>.<para> See also: </para>&quot;J. A. Tawn, &quot;Bivariate extreme value theory: models and estimation,&quot; Biometrika, 75, 1988,
 pp. 397-415.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricLogistic.#ctor(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricLogistic.#ctor(System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricLogistic.#ctor(System.Double,System.Double,System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricLogistic.#ctor(System.Double,System.Double,System.Double,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD,com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricLogistic.density(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricLogistic.cdf(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricLogistic.spectralDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricLogistic.dependence(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricLogistic.conditionalCopula(System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricLogistic.nextVector">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVDAsymmetricLogistic.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVD">
			<summary>Bivariate extreme value (BEV) distribution is the joint distribution of componentwise maxima of
 two-dimensional iid random vectors. Let \((\tilde{X}_i,\tilde{Y}_i)&apos;\) be iid random vectors with
 joint distribution function \(\tilde{F}\). Also, let
 \(X_n=\max(\tilde{X}_1,\ldots,\tilde{X}_n)\) and \(Y_n=\max(\tilde{Y}_1,\ldots,\tilde{Y}_n)\),
 that is, \((X_n,Y_n)&apos;\) is the vector of componentwise maxima. The limiting joint distribution
 function of normalized componentwise maxima,
 \[
 G(x,y) = Pr(X_n \le x, Y_n \le y) \;\text{when}\; n \to \infty
 \]
 can be characterized in terms of the marginal GEV distributions and the BEV copula.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVD.cdf(System.Double,System.Double)">
			<summary>The joint distribution function \(F_{X_1,X_2}(x_1,x_2) = Pr(X_1 \le x_1, X_2 \le x_2)\).</summary>
			<param name="x1">the value drawn from \(X_1\)</param>
			<param name="x2">the value drawn from \(X_2\)</param>
			<returns>the joint distribution of \(X_1\) and \(X_2\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVD.density(System.Double,System.Double)">
			<summary>The joint distribution density \(f_{X_1,X_2}(x_1,x_2)\).</summary>
			<param name="x1">the value drawn from \(X_1\)</param>
			<param name="x2">the value drawn from \(X_2\)</param>
			<returns>the joint density of \(X_1\) and \(X_2\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVD.spectralDensity(System.Double)">
			<summary>The density \(h\) of the spectral measure \(H\) on the interval (0,1).
 Any bivariate extreme value distribution can be written as
 \[
 G(z_1,z_2) = \exp\left\{-\int_0^1 \max(w y_1, (1-w) y_2) H(dw)\right\}
 \]
 where \(y_i=(1+\xi_i(z_i-\mu_i)/\sigma_i)^{(-1/\xi_i)}\), and \(\mu_i\), \(\sigma_i\),
 \(\xi_i\) are the location, scale and shape parameters.
 <para/>
 For some function \(H()\) defined on [0,1], satisfying
 \[
 \int_0^1 w H(dw) = \int_0^1 (1-w) H(dw) = 1.
 \]
 \(H()\) is called the spectral measure, with density \(h\) on the interval (0,1).
 <para/>
 For differentiable models, \(H\) may have up to two point masses: at zero and one. Assuming
 that the model parameters are in the interior of the parameter space, we have the following.
 For the asymmetric logistic and asymmetric negative logistic models the point masses are of
 size \((1-t_1)\) and \((1-t_2)\) respectively. For the asymmetric mixed model they are of
 size \((1-\alpha-\beta)\) and \((1-\alpha-2*\beta)\) respectively. For all other models the
 point masses are zero.
 <para/>
 At independence, \(H\) has point masses of size one at both zero and one. At complete
 dependence [a non-differentiable model] \(H\) has a single point mass of size two at 1/2. In
 either case, \(h\) is zero everywhere.</summary>
			<param name="x">x</param>
			<returns>\(h(x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVD.dependence(System.Double)">
			<summary>The dependence function \(A\) for the parametric bivariate extreme value model.
 Any bivariate extreme value distribution can be written as
 \[
 G(z_1,z_2) = \exp\left\{-(y_1+y_2)A\left[y_1/(y_1+y_2)\right]\right\}
 \]
 for some function \(A()\) defined on [0,1], where
 \(y_i=(1+\xi_i(z_i-\mu_i)/\sigma_i)^{(-1/\xi_i)}\), and \(\mu_i\), \(\sigma_i\), \(\xi_i\)
 are the location, scale and shape parameters.
 <para/>
 It follows that \(A(0)=A(1)=1\), and that \(A()\) is a convex function with
 \(\max(x,1-x) \le A(x) \le 1\) for all \(0 \le x \le 1\).
 <para/>
 The lower and upper limits of \(A\) are obtained under complete dependence and independence
 respectively. \(A()\) does not depend on the marginal parameters.</summary>
			<param name="x">x</param>
			<returns>\(A(x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVD.conditionalCopula(System.Double,System.Double)">
			<summary>The conditional copula function conditioning on either margin. The function calculates
 \(P(U_1 &lt; x_1|U_2 = x_2)\), where \((U_1,U_2)\) is a random vector with Uniform(0,1)
 margins and with a dependence structure given by the specified parametric model.<para> See also: </para>&quot;A. G. Stephenson and J. A. Tawn, &quot;Exploiting Occurence Times in Likelihood Inference
 for Componentwise Maxima,&quot; in Biometrika, vol. 92(1), 2004, pp. 213-217.&quot;</summary>
			<param name="x1">an observation from \(U_1\)</param>
			<param name="x2">an observation from \(U_2\)</param>
			<returns>the conditional copula \(P(U_1 &lt; x_1|U_2 = x_2)\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit">
			<summary>Fit log-ACER function by sequential quadratic programming (SQP) minimization (of weighted RSS),
 using <para></para>LinearFit&apos;s solution as the initial guess. The weights are computed as:
 \[
 w_i = \frac{1}{(\log CI^+(\eta_i) - \log CI^-(\eta_i))^2}
 \]
 These weights measure the reciprocals of variances and are used to put less emphasis on the more
 uncertain values for the ACER function.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit.fit(com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACER,System.Double)">
			<summary>Fit ACER function with empirical ACER estimates. Weights are computed from the confidence
 intervals of the estimates.</summary>
			<param name="estimates">the empirical ACER estimates</param>
			<param name="tailMarker">the tail marker</param>
			<returns>the fitted ACER parameters</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit.fit(System.Double[],System.Double[],System.Double[],System.Double,System.Double)">
			<summary>Fit the ACER function with the input values of barrier levels, epsilons, confidence
 intervals, and the mean of the peaks. Weights are computed from the input confidence
 intervals.</summary>
			<param name="eta">the barrier levels</param>
			<param name="epsilon">the ACER values</param>
			<param name="confWidth">the confidence interval half-widths for the ACER values</param>
			<param name="peakMean">the mean of the events (or peaks)</param>
			<param name="tailMarker">the tail marker</param>
			<returns>the fitted ACER parameters</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit.fitWithWeights(System.Double[],System.Double[],System.Double[],System.Double,System.Double,System.Double)">
			<summary>Fit the ACER function with the input values of barrier levels, epsilons, confidence
 intervals, and the mean of the peaks. Weights</summary>
			<param name="eta">the barrier levels</param>
			<param name="epsilon">the ACER values (assume all positive as ACER represents a probability)</param>
			<param name="weights">the weighting for the ACER values (put more emphasis on more confident
                   values)</param>
			<param name="peakMean">the mean of the events (or peaks)</param>
			<param name="minLevel">the minimum barrier level</param>
			<param name="tailMarker">the tail marker</param>
			<returns>the fitted ACER parameters</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit.fitWithWeightsAndInitial(System.Double[],System.Double[],System.Double[],com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit.computeWeights(System.Double[],System.Double[])">
			<summary>Compute weights from epsilon values and their corresponding confidence interval half-width.</summary>
			<param name="epsilon">the epsilon values</param>
			<param name="confint">the confidence interval half-width</param>
			<returns>the computed weights</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit.computeWeightedRSS(com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter,System.Double[],System.Double[],System.Double[])">
			<summary>Measure how fit the estimated log-ACER function to the empirical epsilons by weighted sum of
 squared residuals (RSS).</summary>
			<param name="param">the estimated parameter for ACER function</param>
			<param name="barrierLevels">the barrier levels</param>
			<param name="epsilons">the (positive) empirical epsilons for the corresponding barrier levels</param>
			<param name="weights">the weights for the corresponding epsilon</param>
			<returns>the computed weighted RSS</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit.Result">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit.Result.getParameter">
			<summary></summary>
			<returns>the parameter</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit.Result.getWeights">
			<summary></summary>
			<returns>the weights</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit.Result.getRSS">
			<summary></summary>
			<returns>the weighted RSS</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.LinearFit">
			<summary>Find the parameters for the ACER function from the given empirical epsilon, using OLS regression
 on the logarithm of the values. That is,
 \[
 \log(\epsilon_k) = \log(q) - a (\eta - b)^c
 \]
 <para/>
 Note that there are four variables in the equation, namely, <i>q</i>, <i>b</i>, <i>a</i>,
 <i>c</i>. This algorithm fixes the value of <i>b</i> and <i>c</i>:
 <list type="bullet">
 <item><i>b</i>: the minimum barrier levels, and at most the mean of the observed peaks</item>
 <item><i>c</i>: 2, or any user-specified value</item>
 </list>
 and then apply ordinary least square (OLS) regression to determine <i>q</i> and <i>a</i>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.LinearFit.#ctor">
			<summary>Create an instance with the assumption of <c>c = 2</c>. Experiments show that this
 assumption is a good choice.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.LinearFit.#ctor(System.Double)">
			<summary>This fitting assumes <c>c</c> is a constant.</summary>
			<param name="c">the assumed value of <c>c</c></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.LinearFit.fit(System.Double[],System.Double[],System.Double)">
			<summary>Fit the ACER function with OLS.
 <para/>
 Note: the input epsilon values must be positive (as they represent probabilities).</summary>
			<param name="eta">the barrier levels</param>
			<param name="epsilon">the empirical epsilon values</param>
			<param name="peakMean">the mean of the observed peaks</param>
			<returns>the fitted ACER parameter</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERReturnLevel">
			<summary>Given an ACER function, compute the return level \(\eta\) for a given return period \(R\).
 \(\epsilon_k(\eta)\) can be computed as the inverse of this equation:
 \[
 R = \frac{1}{Pr(X &gt; \eta)} = \frac{1}{1 - \exp(-\epsilon_k(\eta) N)}
 \]
 and the corresponding return level \(\eta\) can be found by the inverse of the ACER function.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERReturnLevel.#ctor(com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter,System.Double)">
			<summary>Create an instance with the (estimated) ACER function parameter and the total number of
 events.</summary>
			<param name="parameter">the parameter for the ACER function</param>
			<param name="N">the total number of events per time period</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERLogFunction">
			<summary>The ACER function in log scale (base <i>e</i>), i.e., \(log(\epsilon_k(\eta))\).
 <para/>
 The R equivalent function is <c>acer::acer.log_evaluate</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERLogFunction.#ctor(com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter)">
			<summary>Create an instance with the ACER function parameter.</summary>
			<param name="param">the parameter</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERLogFunction.evaluate(System.Double)">
			<summary>Compute the log-scale epsilon value at the given barrier level.</summary>
			<param name="eta">the barrier level \(\eta\)</param>
			<returns>\(log(epsilon_k(\eta))\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERInverseFunction">
			<summary>The inverse of the ACER function.
 \[
 \epsilon_k^{-1}(x) = \exp(\frac{1}{c}( \log(-\log\frac{x}{q}) - \log a)) + b
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERInverseFunction.#ctor(com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERInverseFunction.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction">
			<summary>The ACER (Average Conditional Exceedance Rate) function \(\epsilon_k(\eta)\) approximates the
 probability
 \[
 \epsilon_k(\eta) = Pr(X_k &gt; \eta | X_1 \le \eta, X_2 \le \eta, ..., X_{k-1} \le \eta)
 \]
 for a sequence of stochastic process observations \(X_i\) with a k-step memory.
 <para/>
 The function is of the form (Gumbel-type):
 \[
 \hat{\epsilon_k}(\eta) = q_k exp(-a_k (\eta - b_k)^{c_k}), \eta \ge \eta_1
 \]
 <para/>
 The R equivalent function is <c>acer::acer.evaluate</c>. Note: R defines the conditional of
 epsilon using &quot;less than&quot; but this implementation sticks to the original paper which uses &quot;less
 than or equal to&quot;.<para> See also: </para>&quot;Naess A. and Gaidai O., &quot;Estimation of extreme values from sampled time series,&quot; Structural
 Safety, 31(4):325-334, July 2009.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.#ctor(com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.evaluate(System.Double)">
			<summary>Compute the epsilon value.</summary>
			<param name="eta">the barrier level \(\eta\)</param>
			<returns>the epsilon</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter">
			<summary>Parameters for <para></para>ACERFunction.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter.#ctor(System.Double[])">
			<summary>Create an instance with a <c>double[]</c> which contains
 <c>q</c>, <c>b</c>, <c>a</c>, <c>c</c>.</summary>
			<param name="param">[q, b, a, c]</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter.#ctor(System.Double,System.Double,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter.q">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter.b">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter.a">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter.c">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERConfidenceInterval">
			<summary>Using the given (estimated) ACER function as the mean, find the ACER parameters at the lower and
 upper bounds of the estimated confidence interval of ACER values.
 <para/>
 The R equivalent function is <c>acer::acer.estimate_confidence_intervals</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERConfidenceInterval.#ctor(com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERFunction.ACERParameter,com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACER,System.Double,System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERConfidenceInterval.getLowerLevel(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERConfidenceInterval.getUpperLevel(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERConfidenceInterval.getLowerParameter">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERConfidenceInterval.getUpperParameter">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERConfidenceInterval.toString">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERAnalysis">
			<summary>Average Conditional Exceedance Rate (ACER) method is for estimating the cdf of the maxima \(M\)
 distribution from observations.
 \[
 F_M(\eta) = Pr(\max(X_1,X_2,...,X_n) \le \eta)
 \]
 With the assumption of the k-step markov-like dependency, the cdf \(F_M(\eta)\) becomes:
 \[
 \begin{eqnarray}
 F_M(\eta) \approx P_k(\eta) &amp; = &amp;
 \exp(- \sum_{j=k}^N \alpha_{kj}(\eta) - \alpha_{k-1,k-1}(\eta) - ... - \alpha_{11}(\eta)) \\
 &amp; \approx &amp; \exp(- \sum_{j=k}^N \alpha_{kj}(\eta)) \\
 &amp; \approx &amp; \exp(- \epsilon_k(\eta) N)
 \end{eqnarray}
 \]
 where \(\alpha_{kj}(\eta)\) is the probability of the <i>j</i>-th element exceeding \(\eta\)
 conditional on the previous (k-1) non-exceedances, and \(\epsilon_k(\eta)\) is the mean of these
 conditional probabilities when \(N \to \infty\).
 The result could be used for estimation of an extreme distribution.
 <para/>
 This algorithm works as follows:
 <list type="number">
 <item>By counting the occurrences of threshold exceedances conditional on <i>(k-1)</i> previous
 non-exceedances in the observations, find the empirical values for \(P_k(\eta_i)\) where
 \(\eta_i\) are various equally-spaced barrier levels (or, thresholds) greater than the given tail
 marker.</item>
 <item>Using the empirical \(P_k(\eta_i)\), fit the sub-asymptotic form of Gumbel distribution,
 i.e., the ACER function:
 \[
 \hat{\epsilon_k}(\eta) = q_k exp(-a_k (\eta - b_k)^{c_k}), \eta \ge \eta_1.
 \]
 </item>
 <item>With the fitted parameters of the ACER function, calculate the confidence interval of the
 fitted ACER function.</item>
 </list>
 <para/>
 Another well-known estimation method is Peaks Over Threshold (POT). POT method assumes
 independence among extreme events, and therefore always requires declustering and dropping other
 non-peak data. This is considered to be wasteful. On the other hand, ACER method accounts for
 Markov-like dependence (i.e., k-step memory) in time series (with k=1 as a special case for event
 independence). That is, a threshold exceedance is considered as an occurrence if the previous
 (k-1) points are below the threshold. Experiments show that k=2 (i.e., conditional on one
 previous non-exceedance) is accurate enough for estimation for a wide range of data.
 <para/>
 The R equivalent function is <c>acer::acer.analysis</c>.<para> See also: </para>&quot;Naess, A. and Gaidai, O., &quot;Estimation of extreme values from sampled time series,&quot; in
 Structural Safety 31 (2009), p. 325-334&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERAnalysis.#ctor">
			<summary>Create an instance with the default values. That is,
 <code>
 <c>this(2, 300, 0.95, true, true);
 </c>
 </code></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERAnalysis.#ctor(System.Int32,System.Int32,System.Double,System.Boolean,System.Boolean)">
			<summary>Create an instance with various options listed below.
 <list type="bullet">
 <item>the value of <i>k</i> in the assumed k-step memory model (<i>k = 1</i> means no
 dependency on previous observations; <i>k = 2</i> is good enough for most cases)</item>
 <item>the number of barrier levels \(\eta_i\) for estimating the ACER values at different
 levels</item>
 <item>the confidence level for computing the confidence interval of the estimated ACER
 function</item>
 <item>whether or not to use only peaks in the observations for estimation (peaks are defined as
 data points whose values are preceded and followed by values smaller than itself)</item>
 <item>whether or not to put more emphasis on periods in which more events occur</item>
 </list></summary>
			<param name="kStepMemory">the value of k in the k-step memory model</param>
			<param name="nLevels">the number of barrier levels to be used for estimation</param>
			<param name="confidenceLevel">the confidence level for computing confidence interval</param>
			<param name="usePeaksOnly"><c>true</c> if use only peaks in the observations for estimation</param>
			<param name="weightedByPeakCount"><c>true</c> if weight periods by the peak counts in the periods</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERAnalysis.run(System.Double[],System.Double)">
			<summary>Run the analysis with single-period observations. Tail marker is used to
 determine the start of the distribution tail, i.e., extreme values.</summary>
			<param name="observations">the observations (one row for each period, can has different length)</param>
			<param name="tailMarker">the appropriately chosen tail level \(\eta_1\)</param>
			<returns>the analysis result</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERAnalysis.run(System.Double[][],System.Double)">
			<summary>Run the analysis with multi-period observations. Tail marker is used to
 determine the start of the distribution tail, i.e., extreme values.</summary>
			<param name="observations">the observations (one row for each period, can has different length)</param>
			<param name="tailMarker">the appropriately chosen tail level \(\eta_1\)</param>
			<returns>the analysis result</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERAnalysis.Result">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERAnalysis.Result.#ctor(com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.NonlinearFit.Result,com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERConfidenceInterval,com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERReturnLevel,com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACER)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERAnalysis.Result.getFitResult">
			<summary>Get the fitted parameter.</summary>
			<returns>the fitted parameter</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERAnalysis.Result.getConfidenceInterval">
			<summary>Get the estimated confidence intervals of the fitted ACER function.</summary>
			<returns>the estimated confidence interval</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERAnalysis.Result.getReturnLevel">
			<summary>Get the return level function for the estimated ACER function.</summary>
			<returns>the return level function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.ACERAnalysis.Result.getEstimates">
			<summary>Get the empirical estimates.</summary>
			<returns>the estimates</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EpsilonStatisticsCalculator">
			<summary>Compute statistics: mean, confidence interval of estimated ACER values \(\epsilon_k(\eta_i)\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EpsilonStatisticsCalculator.#ctor(System.Boolean,System.Double)">
			<summary>Create an instance with the weighting option and confidence interval.</summary>
			<param name="isWeightedByPeakCount">whether or not weighted (by peak count) mean to be used</param>
			<param name="confidenceLevel">the confidence level</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EpsilonStatisticsCalculator.compute(System.Double[][],System.Double[][],System.Int32)">
			<summary>Compute the statistics.</summary>
			<param name="kStepMemory">k in the k-step memory assumption</param>
			<param name="observations">the data (each row for one period, row lengths can be different)</param>
			<param name="acers">the estimated ACER&apos;s (each row for different levels in one period)</param>
			<returns>the estimated results</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACERStatistics">
			<summary>This class contains the computed statistics of the estimated ACERs.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACERStatistics.#ctor(System.Double[],System.Double[])">
			<summary>Create an instance for storing the computed statistics for estimated epsilon for various
 barrier levels.</summary>
			<param name="mean">the means of the estimated epsilons</param>
			<param name="confidenceInterval">the confidence interval half-widths</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACERStatistics.getMean">
			<summary>Get the mean of the empirical estimates for each barrier level.</summary>
			<returns>the mean of the estimated ACERs \(\bar{\epsilon_k}(\eta_i)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACERStatistics.getConfidenceInterval">
			<summary>Get the width of half of the confidence interval, that is, the interval is mean +/-
 width.</summary>
			<returns>the half confidence interval width of the estimates</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACEREstimation">
			<summary>This class estimates empirical ACER values from the given observations.
 <para/>
 The R equivalent function is <c>acer::acer.prepare</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACEREstimation.#ctor">
			<summary>Create an instance with default values. That is,
 <code>
 <c>this(300, true, new EpsilonStatisticsCalculator(true, 0.95), 2);
 </c>
 </code></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACEREstimation.#ctor(System.Int32,System.Boolean,com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EpsilonStatisticsCalculator,System.Int32)">
			<summary>Create an instance for counting empirical ACERs.</summary>
			<param name="nLevels">number of barrier levels to be used for estimation (e.g., 300)</param>
			<param name="usePeaksOnly">perform estimation on peaks only</param>
			<param name="statisticsCalculator">the calculator for computing the mean and the confidence interval</param>
			<param name="kStepMemory">k in k-step memory assumption (2 is enough in most cases)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACEREstimation.estimate(System.Double[][])">
			<summary>Estimate epsilon (or ACERs) from the given observations (each row is for one period).</summary>
			<param name="observations">the multi-period observations</param>
			<returns>estimated epsilons</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACER">
			<summary>This class contains empirical ACER \(\hat{\epsilon_k}(\eta_i)\) values and other related
 statistics estimated from observations.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACER.#ctor(System.Double[][],System.Double[],System.Double,System.Double,System.Double[][],System.Double[],System.Double[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACER.getPeaks">
			<summary>Get the peaks found in the observations.</summary>
			<returns>the peaks (one row for one period)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACER.getBarrierLevels">
			<summary>Get the barrier levels used for estimation.</summary>
			<returns>the barrier levels</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACER.getEventCountPerPeriod">
			<summary>Get the mean peak rate, or the average number of peaks per period.</summary>
			<returns>the number of peaks per time unit</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACER.getPeakMean">
			<summary>Get the average value of peaks.</summary>
			<returns>the mean of peaks</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACER.getACERs">
			<summary>Get the estimated epsilon values for different barrier levels per period.</summary>
			<returns>the estimates (one row per period)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACER.getMeans">
			<summary>Get the (weighted) mean of the estimates for the generated barrier levels.</summary>
			<returns>the (weighted) means of estimates</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.EmpiricalACER.getConfidenceWidths">
			<summary>Get the confidence interval half-widths for the estimates of the barrier levels.</summary>
			<returns>the confidence interval half-widths</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.ACERUtils">
			<summary>Utility functions used in ACER empirical analysis.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.ACERUtils.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.ACERUtils.extractPeaks(System.Double[])">
			<summary>Extract peaks (values which are preceded and followed by values smaller than itself).</summary>
			<param name="data">the data</param>
			<returns>the peaks</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.ACERUtils.computeWeightsByPeriodLength(System.Double[][])">
			<summary>Compute the weights for periods, proportional to the lengths of the periods. That is,
 \[
 w_i = \frac{T_i}{\sum_i T_i}
 \]</summary>
			<param name="observations">the observations (one row for one period)</param>
			<returns>the period weights</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.ACERByCounting">
			<summary>Estimate epsilons by counting conditional exceedances from the observations.
 <para/>
 The R equivalent function is <c>acer::acer.estimate_acer</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.ACERByCounting.#ctor(System.Double[],System.Int32)">
			<summary>Create an instance for estimating epsilon for each of the given barrier levels.</summary>
			<param name="barrierLevels">the barrier levels \(\eta_i\)</param>
			<param name="kStepMemory">value of k in the assumption of k-step memory</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.ACERByCounting.estimateForMultiPeriods(System.Double[][])">
			<summary>Estimate for multiple periods. This method is suitable for both stationary and non-stationary
 time series. Estimates for multiple periods can then be used to compute the sample mean,
 standard deviation, and confidence interval.</summary>
			<param name="observations">data for multiple periods (one row for one period)</param>
			<returns>estimated ACER values, each row contains estimates for one period</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.acer.empirical.ACERByCounting.estimateForOnePeriod(System.Double[])">
			<summary>Estimate for a single period.</summary>
			<param name="observations">data for one period</param>
			<returns>estimated ACER values, the i-th element = \(\hat{\epsilon_k}(\eta_i)\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.MaximumLikelihoodFitting">
			<summary>This interface defines model fitting by maximum likelihood algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.MaximumLikelihoodFitting.fit(System.Double[])">
			<summary>Fit the model with the given observations.</summary>
			<param name="observations">the observations for fitting</param>
			<returns>the fitted parameters of the model</returns>
			<exception cref="T:java.lang.Exception">when an error has occurred during fitting process</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.GEVFittingByMaximumLikelihood">
			<summary>Estimate the <para></para>GeneralizedEVD parameter from the observations by
 maximum likelihood approach.
 <para/>
 The R equivalent function is <c>evd::fgev</c>.<para> See also: </para>&quot;E. Castillo, A. S. Hadi, N. Balakrishnan, J. M. Sarabia, &quot;Extreme Value and Related Models
 with Applications in Engineering and Science,&quot; Wiley-Interscience, 2004, ch.9, P.212&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.GEVFittingByMaximumLikelihood.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.GEVFittingByMaximumLikelihood.fit(System.Double[])">
			<summary>Find the best-fit GEV parameters (location, scale, shape) by minimizing the negative
 log-likelihood.</summary>
			<param name="observations">the observations</param>
			<returns>the fitted parameters for GEV distribution</returns>
			<exception cref="T:java.lang.Exception">when the optimizer failed to find the minimizer</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.EstimateByLogLikelihood">
			<summary>Result from maximum likelihood fitting algorithm, which contains:
 <list type="bullet">
 <item>the log-likelihood function,</item>
 <item>the fitted parameters for the target model,</item>
 <item>the variance-covariance matrix,</item>
 <item>the standard errors,</item>
 <item>the confidence intervals.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.EstimateByLogLikelihood.#ctor(com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.analysis.function.rn2r1.RealScalarFunction)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.EstimateByLogLikelihood.getFittedParameters">
			<summary>Get the fitted parameters. That is, the parameters that evaluate to the maximum
 log-likelihood.</summary>
			<returns>the fitted parameters for the model</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.EstimateByLogLikelihood.getLogLikelihoodFunction">
			<summary>Get the log-likelihood function. That is,
 \[
 \ell(\theta | X_1,\ldots,X_n) = \sum_{i=1}^n \log f(X_i| \theta)
 \]
 where \(\theta\) is the parameter, \(X_i\) are the observations, \(f(.)\) is the probability
 density function.</summary>
			<returns>the log-likelihood function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.EstimateByLogLikelihood.logLikelihood">
			<summary>Compute the log-likelihood at the fitted value. That is, the maximum log-likelihood.</summary>
			<returns>the maximum log-likelihood computed at the fitted value</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.EstimateByLogLikelihood.covarianceMatrix">
			<summary>Get the covariance matrix, which is estimated as the inverse of negative Hessian matrix of
 the log-likelihood function valued at the fitted parameter.</summary>
			<returns>the covariance matrix</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.EstimateByLogLikelihood.standardError">
			<summary>Get the standard errors of the fitted parameters.</summary>
			<returns>the standard errors</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.EstimateByLogLikelihood.confidenceInterval(System.Double)">
			<summary>Compute the \((1 - \alpha)100\%\) confidence intervals for each element of the fitted
 parameter, given the required confidence level. That is,
 \[
 CI = (\hat{\theta} \pm z_{\alpha/2} \hat{\sigma}_{\hat{\theta}})
 \]
 where \(\hat{\theta}\) is the fitted parameter, \(\hat{\sigma}_{\hat{\theta}}\) is the
 standard error of the estimate.</summary>
			<param name="confidenceLevel">the required confidence level</param>
			<returns>the confidence interval</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.ConfidenceInterval">
			<summary>This class stores information for a list of confidence intervals, with the same confidence level.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.ConfidenceInterval.#ctor(System.Double,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector,com.numericalmethod.suanshu.algebra.linear.vector.doubles.Vector)">
			<summary>Create an instance with the confidence interval information.</summary>
			<param name="confidenceLevel">the confidence level</param>
			<param name="mean">the mean values</param>
			<param name="lower">the lower bound values of the confidence intervals</param>
			<param name="upper">the upper bound values of the confidence intervals</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.ConfidenceInterval.getConfidenceLevel">
			<summary>Get the confidence level.</summary>
			<returns>the confidence level</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.ConfidenceInterval.getMean">
			<summary>Get the mean values.</summary>
			<returns>the mean values</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.ConfidenceInterval.getLower">
			<summary>Get the lower bounds of the confidence intervals.</summary>
			<returns>the lower bounds</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.ConfidenceInterval.getUpper">
			<summary>Get the upper bounds of the confidence intervals.</summary>
			<returns>the upper bounds</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.pot.PeaksOverThresholdOnClusters">
			<summary>Similar to <para></para>PeaksOverThreshold POT, but only use the peak observations in clusters for the
 parametric estimation. Peaks are defined as the maxima in the clusters found by
 <para></para>ClusterAnalyzer.
 <para/>
 The R equivalent functions are <c>evd::fpot</c> with <c>cmax=TRUE</c>.<para> See also: </para>&quot;Enrique Castillo, Ali S. Hadi, N. Balakrishnan, Jose M. Sarabia, &quot;Extreme Value and Related
 Models with Applications in Engineering and Science,&quot; P.268&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.pot.PeaksOverThresholdOnClusters.#ctor(com.numericalmethod.suanshu.stats.evt.cluster.ClusterAnalyzer)">
			<summary>Create an instance with a <para></para>ClusterAnalyzer which is used to find clusters from
 observations.</summary>
			<param name="clusterAnalyzer">the cluster analyzer</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.pot.PeaksOverThresholdOnClusters.fit(System.Double[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.pot.PeaksOverThreshold">
			<summary>Peaks Over Threshold (POT) method estimates the parameters for generalized Pareto distribution
 (GPD) using maximum likelihood on the observations that are over a given threshold.
 <para/>
 The R equivalent functions are <c>evd::fpot</c>.<para> See also: </para>&quot;E. Castillo, A. S. Hadi, N. Balakrishnan, J. M. Sarabia, &quot;Extreme Value and Related Models
 with Applications in Engineering and Science,&quot; Wiley-Interscience, 2004, ch.10, P.268&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.pot.PeaksOverThreshold.#ctor(System.Double)">
			<summary>Create an instance for POT method with a given threshold.
 <para/>
 The desired threshold is the lowest value for which the threshold excess fits the generalized
 Pareto distribution.</summary>
			<param name="threshold">the threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.fitting.pot.PeaksOverThreshold.fit(System.Double[])">
			<summary>Fits the observations to a generalized Pareto distribution (GPD).</summary>
			<param name="observations">the observations</param>
			<returns>the estimate for the GPD parameters (scale, shape)</returns>
			<exception cref="T:java.lang.Exception">if the optimization module failed to find parameters by MLE</exception>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.UnivariateEVD">
			<summary>Distribution of extreme values (e.g., maxima, minima, or other order statistics).
 <para/>
 The extreme value theorem (also the Fisher-Tippett-Gnedenko theorem or the Fisher-Tippett
 theorem) is a general result in extreme value theory regarding asymptotic distribution of extreme
 order statistics. The maximum of a sample of IID random variables after proper renormalization
 converges in distribution to one of 3 possible distributions, the Gumbel distribution, the
 Fr&#233;chet distribution, or the Weibull distribution.
 <para/>
 The role of the extremal types theorem for maxima is similar to that of central limit theorem for
 averages.<para> See also: </para><a href="http://en.wikipedia.org/wiki/extreme_value_theory">Wikipedia: Extreme value
 theory</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.UnivariateEVD.logDensity(System.Double)">
			<summary>Get the logarithm of the probability density function at \(x\), that is, \(\log(f(x))\).</summary>
			<param name="x">\(x\)</param>
			<returns>\(\log(f(x))\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.ReversedWeibullDistribution">
			<summary>The Reversed Weibull distribution is a special case (Type III) of the generalized extreme value
 distribution, with \(\xi&lt;0\).
 The cumulative distribution function is
 \[
 F(x;\mu,\sigma,\xi)=
 \begin{cases}
 e^{-(-(x-\mu)/\sigma)^{\alpha}} &amp; x&lt;\mu \\
 1 &amp; x\geq \mu
 \end{cases}
 \]
 <para/>
 The R equivalent functions are
 <c>evd::drweibull</c>, <c>evd::prweibull</c>, <c>evd::qrweibull</c>, <c>evd::rrweibull</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/weibull_distribution">Wikipedia: Weibull
 distribution</a><para> See also: </para><a
 href="http://en.wikipedia.org/wiki/generalized_extreme_value_distribution#link_to_fr.c3.a9chet.2c_weibull_and_gumbel_families">
 Wikipedia: Generalized extreme value distribution - Link to Fréchet, Weibull and Gumbel
 families</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.ReversedWeibullDistribution.#ctor">
			<summary>Create an instance with the default parameter values: location \(\mu=0\), scale \(\sigma=1\),
 shape \(\alpha=1\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.ReversedWeibullDistribution.#ctor(System.Double,System.Double,System.Double)">
			<summary>Create an instance with the given parameter values.</summary>
			<param name="location">the location parameter \(\mu\)</param>
			<param name="scale">the scale parameter \(\sigma\)</param>
			<param name="shape">the shape parameter \(\alpha\)</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution">
			<summary>The asymptotic nondegenerate distributions of the <i>r</i>-th smallest (largest) order statistic.
 <para/>
 The R equivalent functions are <c>evd::dorder</c>, <c>evd::porder</c>, <c>evd::rorder</c>.<para> See also: </para>&quot;E. Castillo, A. S. Hadi, N. Balakrishnan, J. M. Sarabia, &quot;Extreme Value and Related Models
 with Applications in Engineering and Science,&quot; Wiley-Interscience, 2004, ch.7, P.158&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution.#ctor(com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution,System.Int32,System.Int32)">
			<summary>Create an instance with the probability distribution of \(X\), the number of iid samples
 to be drawn, and the order statistic.</summary>
			<param name="dist">the probability distribution</param>
			<param name="nIIDs">the number of independent variables</param>
			<param name="order">the order statistic (largest) (1 means smallest, n means largest)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution.density(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution.logDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.OrderStatisticsDistribution.entropy">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution">
			<summary>The distribution of \(M\), where \(M=\min(x_1,x_2,...,x_n)\) and \(x_i\)&apos;s are iid samples drawn
 from of a random variable \(X\) with cdf \(F(x)\). Since \(x_i\)&apos;s are independent, the
 cumulative distribution function of \(M\) is simply
 \[
 \begin{eqnarray}
 F_{min}(x;n) &amp; = &amp; Pr(\min(X_1,X_2,...,X_n) \le x) \\
 &amp; = &amp; 1-Pr(\min(X_1,X_2,...,X_n) &gt; x) \\
 &amp; = &amp; 1-Pr(\text{all} \; X_i &gt; x) \\
 &amp; = &amp; 1-\prod_{i=1}^n(1-F(x)) \\
 &amp; = &amp; 1-[1-F(x)]^n
 \end{eqnarray}
 \]
 <para/>
 The R equivalent functions are
 <c>evd::dextreme</c>, <c>evd::pextreme</c>, <c>evd::qextreme</c>, <c>evd::rextreme</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution.#ctor(com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution.density(System.Double)">
			<summary>The probability density function. That is,
 \[
 f_{min}(x;n) = \frac{d}{dx}F_{min}(x;n) = nf(x)[1-F(x)]^{n-1}.
 \]</summary>
			<param name="x">\(x\)</param>
			<returns>\(f_{min}(x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution.logDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution.cdf(System.Double)">
			<summary>The cumulative distribution function. That is,
 \[
 f_{min}(x;n) = 1-[1-F(x)]^n.
 \]</summary>
			<param name="x">\(x\)</param>
			<returns>\(F_{min}(x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MinimaDistribution.entropy">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution">
			<summary>The distribution of \(M\), where \(M=\max(x_1,x_2,...,x_n)\) and \(x_i\)&apos;s are iid samples drawn
 from of a random variable \(X\) with cdf \(F(x)\). Since \(x_i\)&apos;s are independent, the
 cumulative distribution function of \(M\) is simply
 \[
 \begin{eqnarray}
 F_M(x;n) &amp; = &amp; Pr(\max(X_1,X_2,...,X_n) \le x) \\
 &amp; = &amp; Pr(X_1 \le x, X_2 \le x, ..., X_n \le x) \\
 &amp; = &amp; \prod_{i=1}^nF(x) \\
 &amp; = &amp; [F(x)]^n
 \end{eqnarray}
 \]
 <para/>
 The R equivalent functions are
 <c>evd::dextreme</c>, <c>evd::pextreme</c>, <c>evd::qextreme</c>, <c>evd::rextreme</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution.#ctor(com.numericalmethod.suanshu.stats.distribution.univariate.ProbabilityDistribution,System.Int32)">
			<summary>Create an instance with the probability distribution of \(X\), and the number of iid samples
 to be drawn.</summary>
			<param name="dist">the distribution of \(X\)</param>
			<param name="nIIDs">the number of independent samples</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution.density(System.Double)">
			<summary>The probability density function. That is,
 \[
 f_max(x;n) = \frac{d}{dx}F_max(x;n) = nf(x)[F(x)]^{n-1}.
 \]</summary>
			<param name="x">\(x\)</param>
			<returns>\(f_max(x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution.logDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution.cdf(System.Double)">
			<summary>The cumulative distribution function. That is,
 \[
 f_max(x;n) = [F(x)]^n.
 \]</summary>
			<param name="x">\(x\)</param>
			<returns>\(F_{max}(x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.MaximaDistribution.entropy">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.GumbelDistribution">
			<summary>The Gumbel distribution is a special case (Type I) of the generalized extreme value distribution,
 with \(\xi=0\).
 The cumulative distribution function is
 \[
 F(x;\mu,\sigma,0)=e^{-e^{-(x-\mu)/\sigma}} \;\; \text{for} \;\; x\in\mathbb R.
 \]

 The R equivalent functions are
 <c>evd::dgumbel</c>, <c>evd::pgumbel</c>, <c>evd::qgumbel</c>, <c>evd::rgumbel</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/gumbel_distribution">Wikipedia: Gumbel
 distribution</a><para> See also: </para><a
 href="http://en.wikipedia.org/wiki/generalized_extreme_value_distribution#link_to_fr.c3.a9chet.2c_weibull_and_gumbel_families">
 Wikipedia: Generalized extreme value distribution - Link to Fréchet, Weibull and Gumbel
 families</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GumbelDistribution.#ctor">
			<summary>Create an instance with the default parameter values: location \(\mu=0\), scale \(\sigma=1\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GumbelDistribution.#ctor(System.Double,System.Double)">
			<summary>Create an instance with the given parameter values.</summary>
			<param name="location">the location parameter \(\mu\)</param>
			<param name="scale">the scale parameter \(\sigma\)</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution">
			<summary>Generalized Pareto distribution (GPD) is used for modeling exceedances over (or shortfalls below)
 a threshold. The cumulative distribution function is
 \[
 F(x; \mu,\sigma,\xi) =
 \begin{cases}
 1 - \left(1+ \frac{\xi(x-\mu)}{\sigma}\right)^{-1/\xi} &amp; \text{for} \; \xi \neq 0, \\
 1 - \exp \left(-\frac{x-\mu}{\sigma}\right) &amp; \text{for} \; \xi = 0.
 \end{cases}
 \]
 for \(x \ge \mu\) when \(\xi \ge 0\), and \(\mu \le x \le \mu - \sigma /\xi\) when \(\xi &lt;0\),
 where \(\mu\in\mathbb R\) is the location parameter, \(\sigma&gt;0\) the scale parameter and
 \(\xi\in\mathbb R\) the shape parameter. Note that some references give the &quot;shape parameter&quot; as
 \(\kappa=-\xi\).<para> See also: </para><a href="http://en.wikipedia.org/wiki/generalized_pareto_distribution">Wikipedia:
 Generalized Pareto distribution</a><para> See also: </para><a href="http://en.wikipedia.org/wiki/pickands%e2%80%93balkema%e2%80%93de_haan_theorem">
 Wikipedia: Pickands-Balkema-de Haan theorem</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.#ctor">
			<summary>Create an instance with the default parameter values: location \(\mu=0\), scale \(\sigma=1\),
 shape \(\xi=0\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.#ctor(System.Double,System.Double)">
			<summary>Create an instance with zero location, and the given scale and shape parameters. If GPD is
 used to model exceedances over a threshold, location is usually set to zero (i.e., location
 is at the threshold).</summary>
			<param name="scale">the scale parameter \(\sigma\)</param>
			<param name="shape">the shape parameter \(\xi\)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.#ctor(System.Double,System.Double,System.Double)">
			<summary>Create an instance with the given parameter values.</summary>
			<param name="location">the location parameter \(\mu\)</param>
			<param name="scale">the scale parameter \(\sigma\)</param>
			<param name="shape">the shape parameter \(\xi\)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.density(System.Double)">
			<summary>The probability density function
 \[
 f(x; \mu,\sigma,\xi) =
 \begin{cases}
 \frac{1}{\sigma}\left(1+ \frac{\xi (x-\mu)}{\sigma}\right)^{\left(-\frac{1}{\xi} - 1\right)}
 &amp; \text{for} \; \xi \neq 0, \\
 \frac{1}{\sigma}\exp \left(-\frac{x-\mu}{\sigma}\right) &amp; \text{for} \; \xi = 0
 \end{cases}
 \]
 for \(x \ge \mu\) when \(\xi \ge 0\), and \(\mu \le x \le \mu - \sigma /\xi\) when
 \(\xi &lt;0\).</summary>
			<param name="x">\(x\)</param>
			<returns>\(f(x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.logDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.cdf(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.mean">
			<summary>\[
 \mu + \frac{\sigma}{1-\xi}
 \]
 for \(\xi &lt; 1\).</summary>
			<returns>the mean</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.variance">
			<summary>\[
 \frac{\sigma^2}{(1-\xi)^2(1-2\xi)}
 \]
 for \(\xi &lt; 1/2\).</summary>
			<returns>the variance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.median">
			<summary>\[
 \mu + \frac{\sigma( 2^{\xi} -1)}{\xi}
 \]</summary>
			<returns>the median</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedParetoDistribution.entropy">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD">
			<summary>Generalized extreme value (GEV) distribution is a family of continuous probability distributions
 developed within extreme value theory to combine the Gumbel, Fr&#233;chet and Weibull families
 also known as type I, II and III extreme value distributions. By the extreme value theorem the
 GEV distribution is the limit distribution of properly normalized <em>maxima</em> of a sequence
 of independent and identically distributed (IID) random variables.
 <para/>
 The R equivalent functions are
 <c>evd::dgev</c>, <c>evd::pgev</c>, <c>evd::qgev</c>, <c>evd::mtransform</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/generalized_extreme_value_distribution">Wikipedia:
 Generalized extreme value distribution</a><para> See also: </para><a href="http://en.wikipedia.org/wiki/fisher%e2%80%93tippett%e2%80%93gnedenko_theorem">
 Wikipedia: Fisher-Tippett-Gnedenko theorem</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.#ctor">
			<summary>Create an instance of generalized extreme value distribution with the default parameter
 values: location \(\mu=0\), scale \(\sigma=1\), shape \(\xi=0\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.#ctor(System.Double,System.Double,System.Double)">
			<summary>Create an instance of generalized extreme value distribution with the given parameters.</summary>
			<param name="location">the location parameter \(\mu\)</param>
			<param name="scale">the scale parameter \(\sigma &gt; 0\)</param>
			<param name="shape">the shape parameter \(\xi\)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.getLocation">
			<summary>Get the location parameter.</summary>
			<returns>\(\mu\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.getScale">
			<summary>Get the scale parameter.</summary>
			<returns>\(\sigma\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.getShape">
			<summary>Get the shape parameter.</summary>
			<returns>\(\xi\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.marginalTransform(System.Double)">
			<summary>Transform to exponential margins under the GEV model. That is,
 /[
 t(x) =
 \begin{cases}
 \big(1+(\tfrac{x-\mu}{\sigma})\xi\big)^{-1/\xi} \textrm{if}\ \xi\neq0 \\
 e^{-(x-\mu)/\sigma} \textrm{if}\ \xi=0
 \end{cases}
 /]</summary>
			<param name="x">\(x\)</param>
			<returns>\(t(x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.marginalInverseTransform(System.Double)">
			<summary>Inverse of marginal transform.</summary>
			<param name="x">\(x\)</param>
			<returns>\(t^{-1}(x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.cdf(System.Double)">
			<summary>
 The cumulative distribution function of GEV distribution is
 \[
 F(x;\mu,\sigma,\xi)
 = \exp\left\{-\left[1+\xi\left(\frac{x-\mu}{\sigma}\right)\right]^{-1/\xi}\right\}
 \]
 for \(1+\xi(x-\mu)/\sigma&gt;0\).</summary>
			<param name="x">\(x\)</param>
			<returns>\(F(x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.density(System.Double)">
			<summary>
 The probability density function of GEV distribution is
 \[
 f(x;\mu,\sigma,\xi)
 = \frac{1}{\sigma}\left[1+\xi\left(\frac{x-\mu}{\sigma}\right)\right]^{(-1/\xi)-1}
 \exp\left\{-\left[1+\xi\left(\frac{x-\mu}{\sigma}\right)\right]^{-1/\xi}\right\}
 \]
 for \(1+\xi(x-\mu)/\sigma&gt;0\).</summary>
			<param name="x">\(x\)</param>
			<returns>\(f(x)\)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.logDensity(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.quantile(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.mean">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.moment(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.skew">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.variance">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.median">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.kurtosis">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.GeneralizedEVD.entropy">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.FrechetDistribution">
			<summary>The Fr&#233;chet distribution is a special case (Type II) of the generalized extreme value
 distribution, with \(\xi&gt;0\).
 The cumulative distribution function is
 \[
 F(x;\mu,\sigma,\xi)=
 \begin{cases}
 0 &amp; x\leq \mu \\
 e^{-((x-\mu)/\sigma)^{-\alpha}} &amp; x&gt;\mu.
 \end{cases}
 \]
 <para/>
 The R equivalent functions are
 <c>evd::dfrechet</c>, <c>evd::pfrechet</c>, <c>evd::qfrechet</c>, <c>evd::rfrechet</c>.<para> See also: </para><a href="http://en.wikipedia.org/wiki/fr%c3%a9chet_distribution">Wikipedia: Fréchet
 distribution</a><para> See also: </para><a
 href="http://en.wikipedia.org/wiki/generalized_extreme_value_distribution#link_to_fr.c3.a9chet.2c_weibull_and_gumbel_families">
 Wikipedia: Generalized extreme value distribution - Link to Fréchet, Weibull and Gumbel
 families</a></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.FrechetDistribution.#ctor">
			<summary>Create an instance with the default parameter values: location \(\mu=0\), scale \(\sigma=1\),
 shape \(\alpha=1\).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.FrechetDistribution.#ctor(System.Double,System.Double,System.Double)">
			<summary>Create an instance with the given parameter values.</summary>
			<param name="location">the location parameter \(\mu\)</param>
			<param name="scale">the scale parameter \(\sigma\)</param>
			<param name="shape">the shape parameter \(\alpha\)</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.evd.univariate.random.InverseTransformSamplingEVDRng">
			<summary>Generate random numbers according to a given univariate extreme value distribution, by
 <em>inverse transform sampling</em>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.random.InverseTransformSamplingEVDRng.#ctor(com.numericalmethod.suanshu.stats.evt.evd.univariate.UnivariateEVD)">
			<summary>Create an instance with the given extreme value distribution.</summary>
			<param name="dist">the extreme value distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.random.InverseTransformSamplingEVDRng.#ctor(com.numericalmethod.suanshu.stats.evt.evd.univariate.UnivariateEVD,System.Int64[])">
			<summary>Create an instance with the given extreme value distribution and seeds for this random number
 generator.</summary>
			<param name="dist">the extreme value distribution</param>
			<param name="seeds">the seeds</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.random.InverseTransformSamplingEVDRng.nextDouble">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.evd.univariate.random.InverseTransformSamplingEVDRng.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.exi.ExtremalIndexEstimation">
			<summary>The extremal index \(\theta \in [0,1]\) characterizes the degree of local dependence in the
 extremes of a stationary time series. The index of 1 means that exceedances occur singly in the
 limit, while the index of value less than 1 implies that exceedances tend to occur in clusters.
 <para/>
 The extremal index can be interpreted as:
 <list type="bullet">
 <item>the reciprocal of the limiting mean number of exceedances in blocks (i.e., cluster size) with
 at least one exceedance; or</item>
 <item>the limiting probability that an exceedance is followed by a run of observations below the
 threshold; or</item>
 <item>the times between exceedances over a high threshold.</item>
 </list></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.exi.ExtremalIndexEstimation.value(System.Double[])">
			<summary>Estimate the extremal index with the given observations from a distribution.</summary>
			<param name="observations">the observations</param>
			<returns>the estimated extremal index \(\theta\)</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.exi.ExtremalIndexByFerroSeegers">
			<summary>This class estimates the extremal index from observations by the algorithm proposed by Ferro and
 Seegers.
 <para/>
 The R equivalent function is <c>evd::exi</c>.<para> See also: </para>&quot;Ferro, C. A. T. and Segers, J., &quot;Inference for clusters of extreme values,&quot; J. R.
 Statist. Soc. B (2003), 65, Part 2, pp. 545-556.&quot;</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.exi.ExtremalIndexByFerroSeegers.#ctor(System.Double)">
			<summary>Create an instance with the given threshold.</summary>
			<param name="threshold">the threshold</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.exi.ExtremalIndexByFerroSeegers.value(System.Double[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.exi.ExtremalIndexByClusterSizeReciprocal">
			<summary>This class estimates the extremal index by the reciprocal of the average cluster size.<para> See also: </para>ClusterAnalyzer</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.exi.ExtremalIndexByClusterSizeReciprocal.#ctor(System.Double)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.exi.ExtremalIndexByClusterSizeReciprocal.#ctor(System.Double,System.Int32)">
			<summary>Create an instance with the given threshold and clustering interval length.</summary>
			<param name="threshold">the threshold value</param>
			<param name="intervalLength">the clustering interval length</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.exi.ExtremalIndexByClusterSizeReciprocal.value(System.Double[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.function.ReturnPeriod">
			<summary>The return period \(R\) of a level \(\eta\) for a random variable \(X\) is the mean number of
 trials that must be done for \(X\) to exceed \(\eta\). It is defined as
 \[
 R = \frac{1}{P(X &gt; \eta)} = \frac{1}{1 - F_X(\eta)}.
 \]</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.function.ReturnPeriod.#ctor(com.numericalmethod.suanshu.stats.evt.evd.univariate.UnivariateEVD)">
			<summary>Construct the return period function for a given univariate extreme value distribution.</summary>
			<param name="evd">the univariate extreme value distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.function.ReturnPeriod.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Construct the return period function with the cumulative distribution function of a
 univariate extreme value distribution. This is suitable when only the cdf is known.</summary>
			<param name="cdfFunction">the cdf of the univariate extreme value distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.function.ReturnPeriod.evaluate(System.Double)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.function.ReturnLevel">
			<summary>Given a GEV distribution of a random variable \(X\), the return level \(\eta\) is the value that
 is expected to be exceeded on average once every interval of time \(T\), with a probability of
 \(1 / T\). Therefore,
 \[
 \begin{eqnarray}
 P(X &gt; \eta) &amp; = &amp; \frac{1}{T} \\
 1 - F_X(\eta) &amp; = &amp; \frac{1}{T} \\
 F_X(\eta) &amp; = &amp; 1 - \frac{1}{T} \\
 \eta &amp; = &amp; F^{-1}(1 - \frac{1}{T})
 \end{eqnarray}
 \]
 where \(F^{-1}\) is the inverse of the CDF, or quantile function of the distribution.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.function.ReturnLevel.#ctor(com.numericalmethod.suanshu.stats.evt.evd.univariate.UnivariateEVD)">
			<summary>Construct the return level function for a given univariate extreme value distribution.</summary>
			<param name="evd">the univariate extreme value distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.function.ReturnLevel.#ctor(com.numericalmethod.suanshu.analysis.function.rn2r1.univariate.UnivariateRealFunction)">
			<summary>Construct the return level function with the inverse function of a univariate extreme value
 distribution. This is suitable when only the cdf is known.</summary>
			<param name="cdfInverse">the inverse of the cdf</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.function.ReturnLevel.evaluate(System.Double)">
			<summary>Compute the return level from the given return period.</summary>
			<param name="returnPeriod">the length of the return period</param>
			<returns>the return level</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC">
			<summary>Simulation of first order extreme value Markov chains such that each pair of consecutive values
 has the dependence structure of given bivariate extreme value distributions.
 <para/>
 The R equivalent function is <c>evd::evmc</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.#ctor(com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVD,com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.MarginalDistributionType)">
			<summary>Create an instance with a given bivariate distribution that defines the dependence structure
 between two consecutive simulated values, and uses <para></para>UniformRNG for random number
 generation.</summary>
			<param name="bevd">the dependence between two consecutive values</param>
			<param name="marginalType">the type of the marginal distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.#ctor(com.numericalmethod.suanshu.stats.evt.evd.bivariate.BivariateEVD,com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.MarginalDistributionType,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Create an instance with a given bivariate distribution that defines the dependence structure
 between two consecutive simulated values, and a uniform random number generator.</summary>
			<param name="bivariate">the dependence between two consecutive values</param>
			<param name="marginalType">the type of the marginal distribution</param>
			<param name="uniformRng">the uniform random number generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.nextDouble">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.MarginalDistributionType">
			<summary>Types of marginal distribution of each simulated value.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.MarginalDistributionType.UNIFORM">
			<summary>Uniform distribution.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.MarginalDistributionType.GUMBEL">
			<summary>Gumbel distribution.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.MarginalDistributionType.FRECHET">
			<summary>Frechet distribution.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.MarginalDistributionType.RWEIBULL">
			<summary>Reversed Weibull distribution.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.MarginalDistributionType.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.markovchain.ExtremeValueMC.MarginalDistributionType.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.timeseries.MMAModel">
			<summary>This is equivalent to MARMA(0, q).
 <para/>
 The R equivalent function is <c>evd::mma</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MMAModel.#ctor(System.Double[])">
			<summary>Create an instance with the MA coefficients, using <para></para>FrechetDistribution as the GEV
 distribution.</summary>
			<param name="MA">the MA coefficients \(\theta_i\)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MMAModel.#ctor(System.Double[],com.numericalmethod.suanshu.stats.evt.evd.univariate.UnivariateEVD)">
			<summary>Create an instance with the MA coefficients, and a GEV distribution for generating
 innovations.</summary>
			<param name="MA">the MA coefficients \(\theta_i\)</param>
			<param name="dist">the GEV distribution</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.timeseries.MARModel">
			<summary>This is equivalent to MARMA(p, 0).
 <para/>
 The R equivalent function is <c>evd::mar</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARModel.#ctor(System.Double[])">
			<summary>Create an instance with the AR coefficients, using <para></para>FrechetDistribution as the GEV
 distribution.</summary>
			<param name="AR">the AR coefficients \(\phi_i\)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARModel.#ctor(System.Double[],com.numericalmethod.suanshu.stats.evt.evd.univariate.UnivariateEVD)">
			<summary>Create an instance with the AR coefficients, and a GEV distribution for generating
 innovations.</summary>
			<param name="AR">the AR coefficients \(\phi_i\)</param>
			<param name="dist">the GEV distribution</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.timeseries.MARMASim">
			<summary>Generate random numbers based on a given MARMA model.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMASim.#ctor(com.numericalmethod.suanshu.stats.evt.timeseries.MARMAModel)">
			<summary>Create an instance with the given <para></para>MARMAModel.</summary>
			<param name="model">the MARMA model</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMASim.#ctor(com.numericalmethod.suanshu.stats.evt.timeseries.MARMAModel,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator)">
			<summary>Create an instance with the given <para></para>MARMAModel, but override the innovation generation
 by the the given generator.</summary>
			<param name="model">the MARMA model</param>
			<param name="generator">the innovation generator</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMASim.#ctor(com.numericalmethod.suanshu.stats.evt.timeseries.MARMAModel,com.numericalmethod.suanshu.stats.random.univariate.RandomNumberGenerator,System.Double[])">
			<summary>Create an instance with the given <para></para>MARMAModel and initial values, but override the
 innovation generation by the the given generator.</summary>
			<param name="model">the MARMA model</param>
			<param name="generator">the innovation generator</param>
			<param name="initials">the initial values of the process (\(X_{-k}, X_{-k+1}, ..., X_{-1}\))</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMASim.getModel">
			<summary>Get the MARMA model.</summary>
			<returns>the MARMA model</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMASim.nextDouble">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMASim.seed(System.Int64[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.stats.evt.timeseries.MARMAModel">
			<summary>Simulation of max autoregressive moving average processes, i.e., MARMA(p, q) processes. That is,
 \[
 X_k = \max(\phi_1 X_{k-1}, \phi_2 X_{k-2}, ..., \phi_p X_{k-p},
 \epsilon_k, \theta_1 \epsilon_{k-1}, \theta_2 \epsilon_{k-2}, ..., \theta_q \epsilon_{k-q})
 \]
 where \(\phi_i\)&apos;s are AR coefficients, \(\theta_i\)&apos;s are MA coefficients, \(\epsilon_i\)&apos;s are
 innovations generated by a GEV distribution.
 <para/>
 The R equivalent function is <c>evd::marma</c>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMAModel.#ctor(com.numericalmethod.suanshu.stats.evt.evd.univariate.UnivariateEVD)">
			<summary>Create an instance with a given GEV distribution for generating innovations.</summary>
			<param name="dist">the GEV distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMAModel.#ctor(System.Double[],System.Double[])">
			<summary>Create an instance with the AR and MA coefficients, using <para></para>FrechetDistribution as the
 GEV distribution.</summary>
			<param name="AR">the AR coefficients \(\phi_i\)</param>
			<param name="MA">the MA coefficients \(\theta_i\)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMAModel.#ctor(System.Double[],System.Double[],com.numericalmethod.suanshu.stats.evt.evd.univariate.UnivariateEVD)">
			<summary>Create an instance with the AR and MA coefficients, and a GEV distribution for generating
 innovations.</summary>
			<param name="AR">the AR coefficients \(\phi_i\)</param>
			<param name="MA">the MA coefficients \(\theta_i\)</param>
			<param name="dist">the GEV distribution</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMAModel.getDistribution">
			<summary>Get the univariate extreme value distribution for generating innovations.</summary>
			<returns>the innovation distribution</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMAModel.p">
			<summary>Get the number of AR terms.</summary>
			<returns>the number of AR terms</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMAModel.q">
			<summary>Get the number of MA terms.</summary>
			<returns>the number of MA terms</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMAModel.AR">
			<summary>Get the AR coefficients.</summary>
			<returns>the AR coefficients</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.stats.evt.timeseries.MARMAModel.MA">
			<summary>Get the MA coefficients.</summary>
			<returns>the MA coefficients</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.config.dc.DynamicCreatorConfiguration">
			<summary>Configuration for the Mersenne Twister Dynamic Creator (MT-DC), that is used to generate
 independent random number generators.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.dc.DynamicCreatorConfiguration.dcSeeds">
			<summary>Gets the seeds to be used by the dynamic creator algorithm to compute MT parameters.</summary>
			<returns>the seeds for MT-DC algorithm</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.dc.DynamicCreatorConfiguration.mtSeeds">
			<summary>Gets the seeds used to seed the individual MT RNGs, after the parameters have been found.</summary>
			<returns>the seeds for each created MT RNG</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.config.dc.DefaultDynamicCreatorConfiguration">
			<summary>Default settings for <para></para>DynamicCreatorConfiguration.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.dc.DefaultDynamicCreatorConfiguration.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.dc.DefaultDynamicCreatorConfiguration.dcSeeds">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.dc.DefaultDynamicCreatorConfiguration.mtSeeds">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.config.local.LocalConfiguration">
			<summary>Defines the configuration for a local execution.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.local.LocalConfiguration.concurrency">
			<summary></summary>
			<returns>the number of threads to be used</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.local.LocalConfiguration.dynamicCreatorConfig">
			<summary></summary>
			<returns>the configuration to use for the dynamic creator algorithm</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration">
			<summary>Configuration that can be used to configure grid executors that distribute work to remote
 machines.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration.hostname">
			<summary>Gets the hostname of the local master machine.</summary>
			<returns>the hostname of the local master machine</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration.slaves">
			<summary>Gets the list of remote host (slave) information.</summary>
			<returns>the remote hosts</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration.remoteQueueSize">
			<summary>Gets the size of the queue at each remote machine, that the system will attempt to keep
 constant.</summary>
			<returns>the ideal queue size</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration.failureDetectionConfiguration">
			<summary>Gets the configuration for the failure detection or <c>null</c> if there should be no
 failure detection.</summary>
			<returns>the failure detection configuration</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration.dynamicCreatorConfig">
			<summary>Gets the configuration for the dynamic creation algorithm.</summary>
			<returns>the configuration to use for the dynamic creator algorithm</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration.repeatable">
			<summary>For repeatability of random number generation, task distribution has to be deterministic.
 Activating this will decrease performance and disable failure detection.</summary>
			<returns>whether the computation must be repeatable</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration.FailureDetectionConfiguration">
			<summary>Configuration that affects failure detection only.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration.FailureDetectionConfiguration.timeoutMillis">
			<summary>The number of milliseconds after which a job times out.
 <para/>
 Note that this should be in relation to the above queue size, since for a longer queue,
 it will get longer for the job to reach the front of the queue and get serviced.
 <para/>
 This is NOT the same timeout that is used for hosts that are unreachable!</summary>
			<returns>the number of milliseconds after which to re-send the job</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration.FailureDetectionConfiguration.timeoutScanIntervalMillis">
			<summary>The interval at which expired jobs are scanned.
 <para/>
 A large value means it will take longer to detect failures, but it will slightly reduce
 the load on the master machine (that needs to send out the jobs and handle the
 responses).</summary>
			<returns>the interval at which to scan for expired jobs in milliseconds</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration.FailureDetectionConfiguration.maximumRetries">
			<summary>The maximum amount of retries per work before it is discarded.</summary>
			<returns>the amount of retries after which the work is discarded and null is inserted</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.config.remote.Host">
			<summary>Defines a host on a remote (or local) port.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.remote.Host.#ctor(System.String,System.Int32)">
			<summary>Creates a host.</summary>
			<param name="hostname">the hostname of the host</param>
			<param name="port">the port of the host</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.remote.Host.hostname">
			<summary></summary>
			<returns>the address of the host</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.remote.Host.port">
			<summary></summary>
			<returns>the port on which the client is running</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.config.xml.GridExecutorFactoryFromConfig">
			<summary>Generates <para></para>GridExecutor according to the settings in the configuration file.
 <para/>
 By default, the configuration file is read from <c>grid.xml</c> on the classpath.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.config.xml.GridExecutorFactoryFromConfig.SCHEMA_FILE">
			<summary>The location of the XML schema file that defines <tt>grid.xml</tt>.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.config.xml.GridExecutorFactoryFromConfig.XML_NAMESPACE">
			<summary>The namespace of the XML schema of <tt>grid.xml</tt>.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.xml.GridExecutorFactoryFromConfig.#ctor(System.String)">
			<summary>Creates a factory that generates <para></para>GridExecutor according to the settings in the
 configuration file.</summary>
			<param name="configPath">the path to the configuration file</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.xml.GridExecutorFactoryFromConfig.#ctor(java.io.InputStream)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.config.xml.GridExecutorFactoryFromConfig.newExecutor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.GridExecutorFactory">
			<summary>Factory that creates <para></para>GridExecutor.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.GridExecutorFactory.newExecutor">
			<summary>Creates a new instance of <para></para>GridExecutor.</summary>
			<returns>the new instance</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.GridExecutor">
			<summary>Instances of this class can run code that can be distributed across multiple machines (or CPU
 cores).
 <para/>
 Note that if a function invocation fails, for example by throwing an exception, <c>null</c> will
 be inserted in the result!</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.GridExecutor.shutdown">
			<summary>Shuts down the executor gracefully. Calling this method will cause the JVM to reclaim
 resources from this executor.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.GridExecutor.map(java.util.List,com.numericalmethod.suanshu.grid.function.Function)">
			<summary>Performs the &apos;map&apos; operation from functional programming, applying the given function
 <i>f</i> to each element in the input collection.
 <para/>
 The output collection will contain, for each input element, an output element at the same
 index, which is the result to applying <i>f</i> to it.</summary>
			<param name="xs">the input collection</param>
			<param name="f">the function to be applied to each element in the input collection</param>
			<returns>the result of the map operation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.GridExecutor.forLoop(System.Int32,System.Int32,com.numericalmethod.suanshu.grid.function.Function)">
			<summary>Runs a for-loop over the given range of integers, using an increment of 1.</summary>
			<param name="start">the start of the range of the for-loop, inclusive</param>
			<param name="end">the end of the range of the for-loop, exclusive</param>
			<param name="f">the function to be run at each step of the for loop</param>
			<returns>the result of applying the given function to each index</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.GridExecutor.forLoop(System.Int32,System.Int32,System.Int32,com.numericalmethod.suanshu.grid.function.Function)">
			<summary>Runs a for-loop over the given range of integers, using the given increment.</summary>
			<param name="start">the start of the range of the for-loop, inclusive</param>
			<param name="end">the end of the range of the for-loop, exclusive</param>
			<param name="increment">the increment between successive steps of the for loop</param>
			<param name="f">the function to be run at each step of the for loop</param>
			<returns>the result of applying the given function to each index</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.DefaultGridExecutorFactory">
			<summary>The default factory that creates instances of <para></para>GridExecutor.
 <para/>
 <para></para>#getInstance() returns a factory that configures <para></para>GridExecutors with
 settings specified in a configuration file. By default, it is read from <tt>grid.xml</tt> on the
 classpath.
 <para/>
 Here is a sample <tt>grid.xml</tt>:
 <code>
 &lt;?xml version=&quot;1.0&quot;?&gt;
 &lt;grid
     xmlns=&quot;http://www.numericalmethod.com/grid&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xsi:schemaLocation=&quot;http://www.numericalmethod.com/grid http://www.numericalmethod.com/xsd/grid.xsd&quot;&gt;
     &lt;!-- Uncomment / Comment out the configuration to switch between local and remote operation --&gt;
     &lt;!-- CHOICE 1: LOCAL EXECUTION --&gt;
     &lt;!--
     &lt;local&gt;
         &lt;concurrency&gt;4&lt;/concurrency&gt;
     &lt;/local&gt;
     --&gt;
     &lt;!-- CHOICE 2: REMOTE EXECUTION --&gt;
     &lt;remote&gt;
         &lt;hostname&gt;192.168.1.101&lt;/hostname&gt;
         &lt;slaves&gt;
             &lt;!-- one or more slaves --&gt;
             &lt;slave&gt;
                 &lt;hostname&gt;192.168.1.102&lt;/hostname&gt;
                 &lt;port&gt;2552&lt;/port&gt;
             &lt;/slave&gt;
             &lt;slave&gt;
                 &lt;hostname&gt;192.168.1.103&lt;/hostname&gt;
                 &lt;port&gt;2552&lt;/port&gt;
             &lt;/slave&gt;
         &lt;/slaves&gt;
         &lt;!-- Optional: remote execution parameters --&gt;
         &lt;queueSize&gt;2&lt;/queueSize&gt;
         &lt;failureDetection&gt;
             &lt;timeout&gt;5000&lt;/timeout&gt;
             &lt;scanInterval&gt;1000&lt;/scanInterval&gt;
             &lt;maximumRetries&gt;3&lt;/maximumRetries&gt;
         &lt;/failureDetection&gt;
     &lt;/remote&gt;

     &lt;!-- Optional: Random Number Generator Configuration --&gt;
     &lt;rng&gt;
         &lt;repeatable&gt;false&lt;/repeatable&gt;
         &lt;dynamicCreator&gt;
             &lt;dcSeeds&gt;1234 5687&lt;/dcSeeds&gt;
             &lt;mtSeeds&gt;9876 5432&lt;/mtSeeds&gt;
         &lt;/dynamicCreator&gt;
     &lt;/rng&gt;
 &lt;/grid&gt;
 </code>

 <h3>Local Execution</h3>
 To use local CPUs for computation, use <tt>&lt;local&gt;</tt> configuration in which
 <tt>&lt;concurrency&gt;</tt> specifies the number of threads to use, where 0 is a default value
 for using default concurrency, i.e., the number of available processors (see
 <para></para>#getDefaultConcurrency()).

 <h3>Remote Execution</h3>
 In order to use remote computers for parallel computation, you need to specify
 <tt>&lt;remote&gt;</tt> section in the configuration file.
 <para/>
 You need to enter the hostname of the master machine that the code is run on. It is the address
 that the remote machines refer to the master machine. Please ensure that the address is
 appropriate for the application, e.g., only use a local network address, if the distributed
 computation is only run on the local network.
 <para/>
 Then you can configure one or more remote slave machines, to which to connect via the given
 address and port respectively.
 <para/>
 Optionally, you can set the size of the queues on slave machines. The queue size sets, how many
 jobs are kept in flight per slave machine. By default, all jobs will be sent out immediately,
 which may be undesirable when sharing the remote clients among applications.
 <para/>
 This will also impact failure detection (below): A large size will increase the cost of failure,
 whilst a small size can decrease the performance due to slave machines being idle, whilst
 waiting for more work. Two would be a good size for tasks that take longer than a network
 round-trip (e.g. a second or longer).
 <para/>
 You can turn failure detection on by providing a <tt>&lt;failureDetection&gt;</tt> element with
 the following options:
 <list type="bullet">
 <item>
 <em>Time-out</em> and <em>scan-interval</em> affect when and how failures are detected.
 Periodically (set by the scan-interval), the master checks for timed-out jobs. A job is timed-out
 if it has been sent a longer time ago than the specified timeout value.
 </item>
 <item>
 The <em>maximum retries</em> is the number of times a particular job will be retried until it is
 considered broken and <c>null</c> is put in the result list. A good value for this will depend
 on what your requirements are for liveness, the chances of a job always throwing an exception
 and the impact of having a <c>null</c> value in the response set.
 </item>
 </list>
 Note that if the job has to queue, this will cause it to take longer. Hence, you must make sure
 that the time-out value takes into account the time you expect the job to take, the target queue
 size and whether the slave machines are busy. Setting this to too low a value will cause
 thrashing, by spamming the kernels with duplicate work messages!

 <h3>Random Number Generation</h3>
 In the next optional section you may specify the seed(s) used for the <para></para>DynamicCreator
 algorithm that generates unique <para></para>MersenneTwister random number generators and the seeds
 for the random number generators that are created. If this section is not provided, the seeds
 will be chosen randomly on each execution.
 <para/>
 The framework can be switched to a mode, where it produces strictly repeatable results, even when
 using <para></para>RandomizedFunctions. This approach will, however, defeat failure detection because
 tasks cannot be re-sent. Please also remember to provide seeds in the section above. For best
 performance, this option should remain switched off!</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.executor.DefaultGridExecutorFactory.DEFAULT_CONFIG_PATH">
			<summary>The path (relative to the classpath), where the framework looks for the configuration by
 default.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.executor.DefaultGridExecutorFactory.FALLBACK_CONFIG_PATH">
			<summary>When the default configuration file cannot be found, this fallback configuration file will be
 used.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.DefaultGridExecutorFactory.getInstance">
			<summary>Gets an instance using the configuration found in <tt>grid.xml</tt> on the classpath.
 To set a different configuration file location, use <para></para>#setConfigurationPath(String).
 <para/>
 If no configuration file is found, the <para></para>#FALLBACK_CONFIG_PATH default one is used.</summary>
			<returns>the <para></para>GridExecutorFactory that will create instances according to the
         configuration file</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.DefaultGridExecutorFactory.setConfigurationPath(System.String)">
			<summary>Sets the configuration path to the given path relative to the classpath.
 <para/>
 For most purposes, you should just place your configuration in the default location
 (&apos;<tt>grid.xml</tt>&apos; on the classpath). If you need to use different configurations for
 different parts of your program, consider using <para></para>GridExecutorFactoryFromConfig
 directly.</summary>
			<param name="path">the location of the configuration file</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.DefaultGridExecutorFactory.getDefaultConcurrency">
			<summary>Gets the default concurrency (number of threads) for the local machine, that is, the number
 of available processors returned by <c>Runtime.getRuntime().availableProcessors()</c>.</summary>
			<returns>the default concurrency</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.AbstractGridExecutor">
			<summary>Provides basic default implementations of <para></para>GridExecutor functions on top of the map
 operation. These may be overridden later for efficiency.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.AbstractGridExecutor.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.AbstractGridExecutor.map(java.util.List,com.numericalmethod.suanshu.grid.function.Function)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.AbstractGridExecutor.forLoop(System.Int32,System.Int32,com.numericalmethod.suanshu.grid.function.Function)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.AbstractGridExecutor.forLoop(System.Int32,System.Int32,System.Int32,com.numericalmethod.suanshu.grid.function.Function)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.local.ThreadLocalRngGridExecutor">
			<summary>A simple adaptor, which allows for execution of <para></para>RandomizedFunctions, using a random
 number generator for each thread (with the same thread name).
 <para/>
 This only works for local <para></para>GridExecutors and is not suitable for producing
 repeatable results.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.local.ThreadLocalRngGridExecutor.#ctor(java.lang.Iterable,com.numericalmethod.suanshu.grid.executor.local.LocalGridExecutor)">
			<summary>Creates a new instance, which wraps the given grid executor.</summary>
			<param name="rngIterable">the random number generators that will be used</param>
			<param name="gridExecutor">the grid executor that is to be wrapped</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.local.ThreadLocalRngGridExecutor.shutdown">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.local.ThreadLocalRngGridExecutor.map(java.util.List,com.numericalmethod.suanshu.grid.function.Function)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.local.ThreadLocalRngGridExecutor.configuration">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.local.LocalParallelGridExecutor">
			<summary>Grid executor that executes everything locally.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.local.LocalParallelGridExecutor.#ctor(com.numericalmethod.suanshu.grid.config.local.LocalConfiguration)">
			<summary>Creates a new instance which uses the given number of threads.</summary>
			<param name="config">the configuration of the executor</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.local.LocalParallelGridExecutor.#ctor">
			<summary>Creates a new instance which uses the default number of threads.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.local.LocalParallelGridExecutor.shutdown">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.local.LocalParallelGridExecutor.map(java.util.List,com.numericalmethod.suanshu.grid.function.Function)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.local.LocalParallelGridExecutor.configuration">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.local.LocalGridExecutorFactory">
			<summary>Creates local instances of <para></para>GridExecutors from a configuration object.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.local.LocalGridExecutorFactory.#ctor(com.numericalmethod.suanshu.grid.config.local.LocalConfiguration)">
			<summary>Creates a new instance that configures <para></para>GridExecutor instances using the given
 configuration.</summary>
			<param name="config">the configuration</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.local.LocalGridExecutorFactory.newExecutor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.local.LocalGridExecutor">
			<summary>Interface for classes that execute all their tasks locally (in the same JVM).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.local.LocalGridExecutor.configuration">
			<summary>Gets the configuration that is used by this instance.</summary>
			<returns>the current configuration</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.WorkerCountCollector">
			<summary>Collects the number of workers managed by each of the given slaves.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.WorkerCountCollector.props(java.util.List,Timeout)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.WorkerCountCollector.onReceive(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Worker">
			<summary>The actor who does the real work.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Worker.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Worker.onReceive(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.WorkAssignment">
			<summary>Utility class that contains the method that performs assignment of a task with a given index to a
 slave/worker with a given index (given the numbers of slaves and workers).
 <para/>
 The goal is to provide a uniform allocation of tasks, regardless of any previous filtering
 according to another allocation algorithm.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.WorkAssignment.assign(System.Int64,System.Int32)">
			<summary></summary>
			<param name="taskIndex">the index of the task which is to be assigned</param>
			<param name="nAssignees">the number of actors to which to assign</param>
			<returns>the worker to which the task is to be assigned</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Slave">
			<summary>Slave that is meant to run on a remote machine and that creates the <para></para>Worker instances.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Slave.#ctor">
			<summary>Creates a new slave with the number of workers corresponding to the default concurrency,
 i.e., the number of cores detected in the machine.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Slave.#ctor(System.Int32)">
			<summary>Creates a new slave which has a fixed number of workers and sends results to the given
 master.</summary>
			<param name="nWorkers">the number of workers</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Slave.onReceive(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.OrderedAccumulator">
			<summary>Collects all results in a list, ensuring that the order according to the indices is preserved in
 the returned list.
 <para/>
 Results for indices may arrive multiple times and may be <c>null</c> due to a failure. A
 non-<c>null</c> result is preferred over a <c>null</c> result.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.OrderedAccumulator.#ctor(System.Int32)">
			<summary>Creates a new instance which shuts down the system after receiving n results.</summary>
			<param name="nResults">the number of results after which to shut down the system</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.OrderedAccumulator.onReceive(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.NoOpActor">
			<summary>Does nothing.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.NoOpActor.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.NoOpActor.onReceive(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Master">
			<summary>Delegates <para></para>Work to one or more slaves and forwards <para></para>Results to a predefined
 accumulator.
 <para/>
 Also forwards work and results to the failure detector, which will keep track of their relative
 timings and if it expires, send back the work to the master to be re-sent to a delegate.
 <para/>
 Clients can first send their work and then send (&apos;ask&apos;) the <para></para>GetResults message, which
 will cause the <para></para>Result to be returned when it is computed.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Master.#ctor(System.Int32,java.util.List,System.Boolean,Props,com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Master.MasterAwareProps)">
			<summary>Creates a new instance with the given supervisor, the given slaves and a failure detector of
 the given type.</summary>
			<param name="queueSize">the target size of the work queue per remote client</param>
			<param name="slaves">the actors to which to delegate the work</param>
			<param name="repeatable">whether the simulation has to be repeatable</param>
			<param name="accumulatorProps">the properties of the accumulator that is to be created</param>
			<param name="failureDetectorProps">the properties of the failure detector</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Master.onReceive(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Master.MasterAwareProps">
			<summary>Defines objects that create <para></para>Props, whilst being aware of the <para></para>Master.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.Master.MasterAwareProps.props(ActorRef)">
			<summary>Creates a <para></para>Props with a reference to the master.</summary>
			<param name="master">the location of the master</param>
			<returns>the <para></para>Props that may be aware of the master</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.GridRouterConfig">
			<summary>Assigns work to slaves (that is, routing) in an efficient manner.
 <para/>
 Although Akka provides routing classes, we can do a better job at this as we know the semantics
 of <para></para>Work and <para></para>Result.
 <para/>
 This class only uses minimal synchronization, since any concurrency issues will not affect the
 correctness of the program.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.GridRouterConfig.#ctor(ActorRef,java.util.List,System.Boolean)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.GridRouterConfig.routerDispatcher">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.GridRouterConfig.supervisorStrategy">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.GridRouterConfig.createCustomRoute(RouteeProvider)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.FailureDetector">
			<summary>Acts on behalf of the master and keeps track of all the work that was <em>delegated</em>, as well
 as the responses that were <em>received</em>.
 <para/>
 If a given item of work takes too long, from the moment it was issued, it will send the work back
 to the master again.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.FailureDetector.#ctor(ActorRef,System.Int64,System.Int64,System.Int32)">
			<summary>Creates a new instance which scans all outstanding jobs at the given interval and resends the
 <para></para>Work if it has exceeded the timeout.</summary>
			<param name="worker">the actor to which to resend the work</param>
			<param name="scanInterval">the interval (in milliseconds) at which to scan the list of outstanding
                      job</param>
			<param name="timeoutMillis">the amount of time (in milliseconds) after which work is considered
                      &apos;expired&apos;</param>
			<param name="maxRetries">the maximum number of times work can be sent</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.FailureDetector.preStart">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.actor.FailureDetector.onReceive(System.Object)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.Kernel">
			<summary>A kernel that can be used for standalone operation of a <para></para>Slave, i.e., to add a node to the
 computation cluster.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.executor.remote.akka.Kernel.SYSTEM">
			<summary>The name of the system created by the kernel.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.executor.remote.akka.Kernel.ACTOR">
			<summary>The name of the slave actor in the system on this kernel.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.executor.remote.akka.Kernel.N_WORKERS">
			<summary>The number of workers to be created.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.Kernel.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.Kernel.startup">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.Kernel.shutdown">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.Kernel.getPort">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.Kernel.getAkkaRemoteAddress(System.String,System.Int32)">
			<summary>Gets the address of the slave actor that can be understood by Akka, for the given hostname
 and port.</summary>
			<param name="hostname">the hostname for which to get the address</param>
			<param name="port">the port at which the Akka system is running</param>
			<returns>the address of the remote actor</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.Kernel.main(System.String[])">
			<summary>Wraps the Akka&apos;s kernel, ensuring that it is used correctly and only leaving the port as an
 option.</summary>
			<param name="args">{hostname, port}</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaUtils">
			<summary>Utility methods for Akka.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaUtils.AUTO_SELECT_PORT">
			<summary>Setting this port causes Akka to automatically select a free port.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaUtils.DEFAULT_SYSTEM_NAME">
			<summary>The default name for a system.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaUtils.createActorSystem(System.String)">
			<summary>A way to create an actor system that explicitly specifies the classloader.</summary>
			<param name="name">the name of the actor system that is to be created</param>
			<returns>the newly created actor system</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaUtils.setAkkaPort(System.Int32)">
			<summary>Sets the port that is used by subsequent systems created by Akka.</summary>
			<param name="port">the port that should be used</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaUtils.getSystemPort(ActorSystem)">
			<summary>Gets the current port number used by a given actor system.</summary>
			<param name="system">the actor system</param>
			<returns>the currently used port number</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaUtils.setAkkaHostname(System.String)">
			<summary>Sets the address to bind the remoting to, to the given address.
 <para/>
 This is also sent as the &apos;sender&apos; along with messages, so it is required for clients to reply
 to them.</summary>
			<param name="url">the address that is to be set</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaUtils.getKernelPathsFromHosts(java.util.Collection)">
			<summary>Gets the actor paths for Kernels running on the given remote hosts.</summary>
			<param name="hosts">the remote hosts</param>
			<returns>the Akka paths of <para></para>Kernels running at the given hosts</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaUtils.runKernel(Bootable,System.Int32)">
			<summary>Runs a given kernel on a given port. Convenience method that sets the port to the given
 integer, runs the Kernel and restores the port to automatic (the default setting).</summary>
			<param name="kernel">the kernel</param>
			<param name="port">the port number</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaUtils.runKernel(Bootable)">
			<summary>Runs a given kernel on an automatically selected port.</summary>
			<param name="kernel">the kernel</param>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaGridExecutorFactory">
			<summary>Creates instances of <para></para>GridExecutorFactory that use Akka&apos;s remoting to distribute
 computation, from a configuration object.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaGridExecutorFactory.#ctor(com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration)">
			<summary>Creates a new instance which uses the hosts in the given document to configure instances.</summary>
			<param name="config">the configuration from which to configure the executors</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaGridExecutorFactory.newExecutor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaGridExecutor">
			<summary>Uses Akka to distribute the computational load between multiple machines.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaGridExecutor.DEFAULT_MT_PERIOD">
			<summary>The period of the <para></para>MersenneTwister instance that are used by slaves.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaGridExecutor.#ctor(com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration)">
			<summary>Creates a new instance from the given configuration, using the provided router.</summary>
			<param name="config">the configuration of this executor</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaGridExecutor.#ctor(com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration,System.Boolean)">
			<summary>Creates a new instance from the given configuration, using the provided router.
 <para/>
 Note that when calling this constructor it is the callee&apos;s responsibility to provide a
 repeatable router if so desired, as the default router from the configuration will not be
 used.</summary>
			<param name="config">the configuration of this executor</param>
			<param name="repeatable">whether the work assignment needs to be repeatable</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaGridExecutor.map(java.util.List,com.numericalmethod.suanshu.grid.function.Function)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaGridExecutor.finalize">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaGridExecutor.shutdown">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.AkkaGridExecutor.configuration">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.ActorProps">
			<summary>Static factory class that contains all of the common <para></para>Props, to make the code that uses
 them more readable.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.ActorProps.orderedAccumulatorProps(System.Int32)">
			<summary><para></para>Props for an ordered accumulator, which returns its result after it has seen the
 given number of results.</summary>
			<param name="nResults">the number of results after which the ordered accumulator will return the
                 aggregated result</param>
			<returns>the <para></para>Props for such an actor</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.ActorProps.failureDetectorProps(com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration)">
			<summary><para></para>MasterAwareProps (needs to have a reference to the master actor), for the failure
 detector.

 The failure detector will configure itself from the configuration</summary>
			<param name="config">the configuration used to configure the failure detector</param>
			<returns>the configuration for the failure detector</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.ActorProps.defaultFailureDetectorProps">
			<summary></summary>
			<returns><para></para>MasterAwareProps that do nothing (for disabling an operation)</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.ActorProps.slaveProps(System.Int32)">
			<summary>Creates a new slave which delegates work locally to the given number of workers.</summary>
			<param name="nWorkers">the number of workers to delegate the work to</param>
			<returns>the <para></para>Props for such an actor</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.message.WorkerCountRequest">
			<summary>Request for the number of workers managed by a slave.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.WorkerCountRequest.#ctor(System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.WorkerCountRequest.slaveId">
			<summary></summary>
			<returns>the slave id</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.message.WorkerCountReply">
			<summary>Reply for <para></para>WorkerCountRequest.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.WorkerCountReply.#ctor(System.Int32,System.Int32)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.WorkerCountReply.slaveId">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.WorkerCountReply.nWorkers">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Work">
			<summary>Represents a unit of work as done by an actor (worker). The work is defined as applying a generic
 <para></para>Function to an argument.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Work.#ctor(System.Int32,com.numericalmethod.suanshu.grid.function.Function,System.Object)">
			<summary>Creates an indexed work with the function and the input. By default, work is assigned to
 workers randomly (i.e., NOT using deterministic assignment).</summary>
			<param name="index">the index of the operation, to be returned with the result</param>
			<param name="f">the function to be applied to the data</param>
			<param name="data">the data on which to apply the function</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Work.#ctor(System.Int32,com.numericalmethod.suanshu.grid.function.Function,System.Object,System.Boolean)">
			<summary>Creates an indexed work with the function, the input, and .</summary>
			<param name="index">the index of the operation, to be returned with the result</param>
			<param name="f">the function to be applied to the data</param>
			<param name="data">the data on which to apply the function</param>
			<param name="useDeterministicAssignment">whether the work should be assigned to workers
                                   deterministically, based on its index</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Work.f">
			<summary></summary>
			<returns>the function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Work.data">
			<summary></summary>
			<returns>the data</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Work.index">
			<summary></summary>
			<returns>the index of the operation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Work.useDeterministicAssignment">
			<summary></summary>
			<returns>whether the work should be assigned to workers deterministically</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result">
			<summary>Simple immutable message class to communicate results.
 <para/>
 Note that this class handles both successes and failures to make propagation thereof easier.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result.temporaryFailure(System.Int32)">
			<summary>Returns a new result that indicates a failure at the given index.</summary>
			<param name="index">the index which failed</param>
			<returns>the result indicating a failure at the given index</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result.finalFailure(System.Int32)">
			<summary>Returns a new result that indicates that the failure at the given index is seen as final.</summary>
			<param name="index">the index which failed</param>
			<returns>the result</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result.success(System.Int32,System.Object)">
			<summary>Returns a new result that contains the result at the given index.</summary>
			<param name="index">the index which failed</param>
			<param name="value">the actual result</param>
			<returns>the result</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result.index">
			<summary>Gets the index of the work.</summary>
			<returns>the index of the operation</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result.value">
			<summary>Gets the value held inside this result.</summary>
			<returns>the result</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result.type">
			<summary>Gets the type of this result.</summary>
			<returns>the type of this result</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result.Type">
			<summary>Classified the result by how it was created.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result.Type.SUCCESS">
			<summary>The result was created by orderly termination of a function.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result.Type.TEMPORARY_FAILURE">
			<summary>The result is an exception.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result.Type.FINAL_FAILURE">
			<summary>The result is null, since we ran out of retries (likely a permanent bug in the function).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result.Type.values">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.Result.Type.valueOf(System.String)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator">
			<summary>A message sent to <para></para>Slaves to indicate that it should run the <para></para>DynamicCreator
 algorithm for all workers according or to <para></para>Workers to indicate that they should run it to
 generate their own Mersenne Twister random number generator.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.#ctor(com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.IdRange,com.numericalmethod.suanshu.stats.random.univariate.uniform.mersennetwister.dynamiccreation.MersenneExponent,System.Int64[],System.Int64[])">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.idRange">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.period">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.mtSeeds">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.dcSeeds">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.IdRange">
			<summary>Defines a range of id&apos;s that can be assigned to the individual workers in a core.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.IdRange.#ctor(System.Int32,System.Int32)">
			<summary>Creates a new id range. If <c>start</c> equals to <c>end</c>, the range is empty.</summary>
			<param name="start">the start of the range (inclusive)</param>
			<param name="end">the end of the range (exclusive)</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.IdRange.singleId(System.Int32)">
			<summary>Creates an instance with a single id.</summary>
			<param name="id">the id</param>
			<returns>the instance with a single id</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.IdRange.emptyRange">
			<summary>Creates an empty range.</summary>
			<returns>the empty instance</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.IdRange.start">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.IdRange.end">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.InitDynamicCreator.IdRange.length">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.message.GetResults">
			<summary>Basic message that is used to ask the for the final result.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.GetResults.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.message.CollectWorkerCounts">
			<summary>Request to collect the number of workers managed by the slaves.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.CollectWorkerCounts.#ctor">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.message.BroadcastMessage">
			<summary>A message that is sent to each slave by the master. Note that the length and order of the
 messages array, must match the order in which the slaves were provided to the <para></para>Master upon
 creation.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.BroadcastMessage.#ctor(System.Object[])">
			<summary>Creates a new instance which should cause the</summary>
			<param name="messages"></param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.message.BroadcastMessage.messages">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.akka.serialization.KryoSerializer">
			<summary>Implementation of object serialization using Kryo API.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.serialization.KryoSerializer.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.serialization.KryoSerializer.identifier">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.serialization.KryoSerializer.includeManifest">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.serialization.KryoSerializer.toBinary(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.akka.serialization.KryoSerializer.fromBinaryJava(System.Byte[],java.lang.Class)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.executor.remote.RemoteGridExecutor">
			<summary>Interface for classes that execute their tasks remotely.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.executor.remote.RemoteGridExecutor.configuration">
			<summary>Gets the configuration that is used by this instance.</summary>
			<returns>the current configuration</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.function.RandomizedFunction">
			<summary>A variant of <para></para>Function, which permits subclasses to offer randomized functions.
 <para/>
 The safe and repeatable allocation of random number generators is handled by the framework. This
 can be specified in the configuration file.
 <para/>
 The <para></para>#eval(Object) of this object may not be called directly and is for use by the
 framework only.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.function.RandomizedFunction.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.function.RandomizedFunction.withRngSource(com.numericalmethod.suanshu.grid.function.RandomizedFunction,com.numericalmethod.suanshu.grid.function.RandomizedFunction.RandomLongGeneratorSource)">
			<summary>Creates a <para></para>RandomizedFunction which allows direct calls to <para></para>#eval(Object) in
 the returned <para></para>RandomizedFunction.</summary>
			<param name="f">the function which to wrap</param>
			<param name="rngSource">the random number generator that shall be used by calls to
                  <para></para>#eval(Object)</param>
			<returns>the wrapped function</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.function.RandomizedFunction.eval(System.Object)">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.function.RandomizedFunction.eval(System.Object,com.numericalmethod.suanshu.stats.random.univariate.RandomLongGenerator)">
			<summary>Applies the function to the given input. The function must use the given random number
 generator to obtain random numbers for use in the computation.</summary>
			<param name="in">the input of the function</param>
			<param name="rng">the random number generator that is to be used</param>
			<returns>the result of the function applied to the input</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.function.RandomizedFunction.RandomLongGeneratorSource">
			<summary>Factory type that gets <para></para>RandomLongGenerators.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.function.RandomizedFunction.RandomLongGeneratorSource.rng">
			<summary></summary>
			<returns>a random number generator</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.function.Function">
			<summary>A function in the classical sense, that it maps from an input to an output.
 <para/>
 Implementations must provide a default constructor for the deserialization to work.
 <para/>
 The same is true for the input and output type (or implementations thereof).</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.function.Function.eval(System.Object)">
			<summary>Applies the function to the given input.</summary>
			<param name="in">the input of the function</param>
			<returns>the result of applying the function to the given input</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.test.config.SimpleTestRemoteConfiguration">
			<summary>Doesn&apos;t perform failure detection.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.SimpleTestRemoteConfiguration.#ctor(com.numericalmethod.suanshu.grid.config.remote.Host[])">
			<summary></summary>
			<param name="hosts">the hosts to delegate the work to</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.SimpleTestRemoteConfiguration.failureDetectionConfiguration">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.SimpleTestRemoteConfiguration.repeatable">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.SimpleTestRemoteConfiguration.withRepeatable(System.Boolean)">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.test.config.FailureDetectingTestRemoteConfiguration">
			<summary>Similar to <para></para>DefaultTestRemoteConfiguration but adds failure detection.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.FailureDetectingTestRemoteConfiguration.#ctor(com.numericalmethod.suanshu.grid.config.remote.Host[])">
			<summary>Uses a default failure detection configuration, which is optimized for tests with simple
 failures.</summary>
			<param name="hosts">the hosts to which to delegate the work</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.FailureDetectingTestRemoteConfiguration.#ctor(com.numericalmethod.suanshu.grid.config.remote.RemoteConfiguration.FailureDetectionConfiguration,com.numericalmethod.suanshu.grid.config.remote.Host[])">
			<summary>Creates a test configuration with a given failure detection configuration and a list of
 host information.</summary>
			<param name="failureDetectionConfiguration">the failure detection configuration</param>
			<param name="hosts">the hosts to which to delegate the work</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.FailureDetectingTestRemoteConfiguration.failureDetectionConfiguration">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.FailureDetectingTestRemoteConfiguration.remoteQueueSize">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.FailureDetectingTestRemoteConfiguration.repeatable">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.test.config.DefaultTestRemoteConfiguration">
			<summary>Simple remote configuration that replaces everything but the hosts with the default remote
 configuration - similar to leaving out the relevant elements in an XML configuration files.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.DefaultTestRemoteConfiguration.#ctor(com.numericalmethod.suanshu.grid.config.remote.Host[])">
			<summary>Creates a test configuration with a list of host information.</summary>
			<param name="hosts">the hosts to which to delegate the work</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.DefaultTestRemoteConfiguration.hostname">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.DefaultTestRemoteConfiguration.slaves">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.DefaultTestRemoteConfiguration.remoteQueueSize">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.config.DefaultTestRemoteConfiguration.dynamicCreatorConfig">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.test.TestRemoteConfigurationFactory">
			<summary>Used to allow the test to customize its configuration, after the slaves have been configured by
 a <para></para>RemoteGridExecutorTestHelper.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.TestRemoteConfigurationFactory.configWithSlaves(com.numericalmethod.suanshu.grid.config.remote.Host[])">
			<summary>Gets the configuration that uses the given slaves.</summary>
			<param name="slaves">the slaves that are to be used</param>
			<returns>the configuration</returns>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.test.TestRemoteConfigurationFactory.DefaultConfig">
			<summary>The default configuration that should be applicable to most tests.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.TestRemoteConfigurationFactory.DefaultConfig.#ctor(System.Boolean)">
			<summary></summary>
			<param name="repeatableRng">whether repeatable random number generation is required</param>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.TestRemoteConfigurationFactory.DefaultConfig.configWithSlaves(com.numericalmethod.suanshu.grid.config.remote.Host[])">
			<summary></summary>
		</member>
		<member name="T:com.numericalmethod.suanshu.grid.test.RemoteGridExecutorTestHelper">
			<summary>When using this class directly, you should remember to call <para></para>#shutdown() after you&apos;re done
 with the test.
 <para/>
 This class is designed to help build unit tests for distributed computations using the grid
 framework, by setting up a <para></para>RemoteGridExecutor that connects to a few local nodes.
 <para/>
 The need for such a test arises because some errors will only occur when attempting to actually
 send the code over the network and will be masked when using a local (default) instance of
 <para></para>GridExecutor.
 <para/>
 In particular, the Akka framework needs to be able to serialize all the objects that are sent
 over the network, using Java&apos;s serialization mechanism.
 <para/>
 Please note that test using this class will not detect problems with your firewall configuration.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.test.RemoteGridExecutorTestHelper.N_SLAVES">
			<summary>The default number of slaves that are created.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.test.RemoteGridExecutorTestHelper.N_WORKERS_PER_SLAVE">
			<summary>The default number of workers per slave.</summary>
		</member>
		<member name="P:com.numericalmethod.suanshu.grid.test.RemoteGridExecutorTestHelper.QUEUE_SIZE">
			<summary>The default maximum queue size per worker.</summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.RemoteGridExecutorTestHelper.#ctor">
			<summary></summary>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.RemoteGridExecutorTestHelper.newExecutor(System.Boolean)">
			<summary>Sets up a new <para></para>RemoteGridExecutor, with a few <para></para>Kernels, that uses a
 default configuration at <para></para>TestRemoteConfigurationFactory.DefaultConfig.
 <para/>
 Between any two calls to this method, you must call <para></para>#shutdown(). A good practice
 would be to call this method in the <c>@Before</c> method and to call <c>shutdown()</c> in
 the <c>@After</c> method of your test.</summary>
			<param name="repeatableRng"><c>true</c> if a repeatable random number generation is needed</param>
			<returns>the new executor</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.RemoteGridExecutorTestHelper.newExecutor(com.numericalmethod.suanshu.grid.test.TestRemoteConfigurationFactory)">
			<summary>Sets up a new <para></para>RemoteGridExecutor, with a few <para></para>Kernels, that uses the
 given configuration and a default number of slaves and workers per slave.
 <para/>
 Between any two calls to this method, you must call <para></para>#shutdown(). A good practice
 would be to call this method in the <c>@Before</c> method and to call <c>shutdown()</c> in
 the <c>@After</c> method of your test.</summary>
			<param name="config">creates the configuration to use for the given kernels</param>
			<returns>the new executor</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.RemoteGridExecutorTestHelper.newExecutor(com.numericalmethod.suanshu.grid.test.TestRemoteConfigurationFactory,System.Int32,System.Int32)">
			<summary>Sets up a new <para></para>RemoteGridExecutor, with a few <para></para>Kernels, that uses the
 given configuration.
 <para/>
 Between any two calls to this method, you must call <para></para>#shutdown(). A good practice
 would be to call this method in the <c>@Before</c> method and to call <c>shutdown()</c> in
 the <c>@After</c> method of your test.</summary>
			<param name="config">creates the configuration to use for the given kernels</param>
			<param name="nSlaves">the number of slaves to create</param>
			<param name="nWorkersPerSlave">the number of workers per slave, i.e., the maximum concurrency per
                         slave</param>
			<returns>the new executor</returns>
		</member>
		<member name="M:com.numericalmethod.suanshu.grid.test.RemoteGridExecutorTestHelper.shutdown">
			<summary>Shuts down the system.</summary>
		</member>
	</members>
</doc>
